(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.MapboxDraw = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var runSetup = require('./src/setup');
var setupOptions = require('./src/options');
var setupAPI = require('./src/api');
var Constants = require('./src/constants');

var setupDraw = function setupDraw(options, api) {
  options = setupOptions(options);

  var ctx = {
    options: options
  };

  api = setupAPI(ctx, api);
  ctx.api = api;

  var setup = runSetup(ctx);

  api.onAdd = setup.onAdd;
  api.onRemove = setup.onRemove;
  api.types = Constants.types;
  api.options = options;

  return api;
};

module.exports = function (options) {
  setupDraw(options, this);
};

},{"./src/api":194,"./src/constants":195,"./src/options":231,"./src/setup":233}],2:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,
    area = 0,
    coordsLength = coords.length;

    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {// i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength -1;
                upperIndex = 0;
            } else if (i === coordsLength - 1) {// i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            } else { // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i+1;
                upperIndex = i+2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}
},{"wgs84":192}],3:[function(require,module,exports){
module.exports = normalize;

var types = {
    Point: 'geometry',
    MultiPoint: 'geometry',
    LineString: 'geometry',
    MultiLineString: 'geometry',
    Polygon: 'geometry',
    MultiPolygon: 'geometry',
    GeometryCollection: 'geometry',
    Feature: 'feature',
    FeatureCollection: 'featurecollection'
};

/**
 * Normalize a GeoJSON feature into a FeatureCollection.
 *
 * @param {object} gj geojson data
 * @returns {object} normalized geojson data
 */
function normalize(gj) {
    if (!gj || !gj.type) return null;
    var type = types[gj.type];
    if (!type) return null;

    if (type === 'geometry') {
        return {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: {},
                geometry: gj
            }]
        };
    } else if (type === 'feature') {
        return {
            type: 'FeatureCollection',
            features: [gj]
        };
    } else if (type === 'featurecollection') {
        return gj;
    }
}

},{}],4:[function(require,module,exports){
var jsonlint = require('jsonlint-lines'),
  geojsonHintObject = require('./object');

/**
 * @alias geojsonhint
 * @param {(string|object)} GeoJSON given as a string or as an object
 * @param {Object} options
 * @param {boolean} [options.noDuplicateMembers=true] forbid repeated
 * properties. This is only available for string input, becaused parsed
 * Objects cannot have duplicate properties.
 * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains
 * unnecessary coordinate precision.
 * @returns {Array<Object>} an array of errors
 */
function hint(str, options) {

    var gj, errors = [];

    if (typeof str === 'object') {
        gj = str;
    } else if (typeof str === 'string') {
        try {
            gj = jsonlint.parse(str);
        } catch(e) {
            var match = e.message.match(/line (\d+)/);
            var lineNumber = parseInt(match[1], 10);
            return [{
                line: lineNumber - 1,
                message: e.message,
                error: e
            }];
        }
    } else {
        return [{
            message: 'Expected string or object as input',
            line: 0
        }];
    }

    errors = errors.concat(geojsonHintObject.hint(gj, options));

    return errors;
}

module.exports.hint = hint;

},{"./object":5,"jsonlint-lines":164}],5:[function(require,module,exports){
var rightHandRule = require('./rhr');

/**
 * @alias geojsonhint
 * @param {(string|object)} GeoJSON given as a string or as an object
 * @param {Object} options
 * @param {boolean} [options.noDuplicateMembers=true] forbid repeated
 * properties. This is only available for string input, becaused parsed
 * Objects cannot have duplicate properties.
 * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains
 * unnecessary coordinate precision.
 * @returns {Array<Object>} an array of errors
 */
function hint(gj, options) {

    var errors = [];
    var precisionWarningCount = 0;
    var maxPrecisionWarnings = 10;
    var maxPrecision = 6;

    function root(_) {

        if ((!options || options.noDuplicateMembers !== false) &&
           _.__duplicateProperties__) {
            errors.push({
                message: 'An object contained duplicate members, making parsing ambigous: ' + _.__duplicateProperties__.join(', '),
                line: _.__line__
            });
        }

        if (requiredProperty(_, 'type', 'string')) {
            return;
        }

        if (!types[_.type]) {
            var expectedType = typesLower[_.type.toLowerCase()];
            if (expectedType !== undefined) {
                errors.push({
                    message: 'Expected ' + expectedType + ' but got ' + _.type + ' (case sensitive)',
                    line: _.__line__
                });
            } else {
                errors.push({
                    message: 'The type ' + _.type + ' is unknown',
                    line: _.__line__
                });
            }
        } else if (_) {
            types[_.type](_);
        }
    }

    function everyIs(_, type) {
        // make a single exception because typeof null === 'object'
        return _.every(function(x) {
            return x !== null && typeof x === type;
        });
    }

    function requiredProperty(_, name, type) {
        if (typeof _[name] === 'undefined') {
            return errors.push({
                message: '"' + name + '" member required',
                line: _.__line__
            });
        } else if (type === 'array') {
            if (!Array.isArray(_[name])) {
                return errors.push({
                    message: '"' + name +
                        '" member should be an array, but is an ' +
                        (typeof _[name]) + ' instead',
                    line: _.__line__
                });
            }
        } else if (type === 'object' && _[name] && _[name].constructor.name !== 'Object') {
            return errors.push({
                message: '"' + name +
                    '" member should be ' + (type) +
                    ', but is an ' + (_[name].constructor.name) + ' instead',
                line: _.__line__
            });
        } else if (type && typeof _[name] !== type) {
            return errors.push({
                message: '"' + name +
                    '" member should be ' + (type) +
                    ', but is an ' + (typeof _[name]) + ' instead',
                line: _.__line__
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.3
    function FeatureCollection(featureCollection) {
        crs(featureCollection);
        bbox(featureCollection);
        if (featureCollection.properties !== undefined) {
            errors.push({
                message: 'FeatureCollection object cannot contain a "properties" member',
                line: featureCollection.__line__
            });
        }
        if (featureCollection.coordinates !== undefined) {
            errors.push({
                message: 'FeatureCollection object cannot contain a "coordinates" member',
                line: featureCollection.__line__
            });
        }
        if (!requiredProperty(featureCollection, 'features', 'array')) {
            if (!everyIs(featureCollection.features, 'object')) {
                return errors.push({
                    message: 'Every feature must be an object',
                    line: featureCollection.__line__
                });
            }
            featureCollection.features.forEach(Feature);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.1
    function position(_, line) {
        if (!Array.isArray(_)) {
            return errors.push({
                message: 'position should be an array, is a ' + (typeof _) +
                    ' instead',
                line: _.__line__ || line
            });
        }
        if (_.length < 2) {
            return errors.push({
                message: 'position must have 2 or more elements',
                line: _.__line__ || line
            });
        }
        if (_.length > 3) {
            return errors.push({
                message: 'position should not have more than 3 elements',
                level: 'message',
                line: _.__line__ || line
            });
        }
        if (!everyIs(_, 'number')) {
            return errors.push({
                message: 'each element in a position must be a number',
                line: _.__line__ || line
            });
        }

        if (options && options.precisionWarning) {
            if (precisionWarningCount === maxPrecisionWarnings) {
                precisionWarningCount += 1;
                return errors.push({
                    message: 'truncated warnings: we\'ve encountered coordinate precision warning ' + maxPrecisionWarnings + ' times, no more warnings will be reported',
                    level: 'message',
                    line: _.__line__ || line
                });
            } else if (precisionWarningCount < maxPrecisionWarnings) {
                _.forEach(function(num) {
                    var precision = 0;
                    var decimalStr = String(num).split('.')[1];
                    if (decimalStr !== undefined)
                        precision = decimalStr.length;
                    if (precision > maxPrecision) {
                        precisionWarningCount += 1;
                        return errors.push({
                            message: 'precision of coordinates should be reduced',
                            level: 'message',
                            line: _.__line__ || line
                        });
                    }
                });
            }
        }
    }

    function positionArray(coords, type, depth, line) {
        if (line === undefined && coords.__line__ !== undefined) {
            line = coords.__line__;
        }
        if (depth === 0) {
            return position(coords, line);
        }
        if (depth === 1 && type) {
            if (type === 'LinearRing') {
                if (!Array.isArray(coords[coords.length - 1])) {
                    errors.push({
                        message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',
                        line: line
                    });
                    return true;
                }
                if (coords.length < 4) {
                    errors.push({
                        message: 'a LinearRing of coordinates needs to have four or more positions',
                        line: line
                    });
                }
                if (coords.length &&
                    (coords[coords.length - 1].length !== coords[0].length ||
                    !coords[coords.length - 1].every(function(pos, index) {
                        return coords[0][index] === pos;
                }))) {
                    errors.push({
                        message: 'the first and last positions in a LinearRing of coordinates must be the same',
                        line: line
                    });
                    return true;
                }
            } else if (type === 'Line' && coords.length < 2) {
                return errors.push({
                    message: 'a line needs to have two or more coordinates to be valid',
                    line: line
                });
            }
        }
        if (!Array.isArray(coords)) {
            errors.push({
                message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',
                line: line
            });
        } else {
            var results = coords.map(function(c) {
                return positionArray(c, type, depth - 1, c.__line__ || line);
            });
            return results.some(function(r) {
                return r;
            });
        }
    }

    function crs(_) {
        if (!_.crs) return;
        var defaultCRSName = 'urn:ogc:def:crs:OGC:1.3:CRS84';
        if (typeof _.crs === 'object' && _.crs.properties && _.crs.properties.name === defaultCRSName) {
            errors.push({
                message: 'old-style crs member is not recommended, this object is equivalent to the default and should be removed',
                line: _.__line__
            });
        } else {
            errors.push({
                message: 'old-style crs member is not recommended',
                line: _.__line__
            });
        }
    }

    function bbox(_) {
        if (!_.bbox) {
            return;
        }
        if (Array.isArray(_.bbox)) {
            if (!everyIs(_.bbox, 'number')) {
                errors.push({
                    message: 'each element in a bbox member must be a number',
                    line: _.bbox.__line__
                });
            }
            if (!(_.bbox.length === 4 || _.bbox.length === 6)) {
                errors.push({
                    message: 'bbox must contain 4 elements (for 2D) or 6 elements (for 3D)',
                    line: _.bbox.__line__
                });
            }
            return errors.length;
        }
        errors.push({
            message: 'bbox member must be an array of numbers, but is a ' + (typeof _.bbox),
            line: _.__line__
        });
    }

    function geometrySemantics(geom) {
        if (geom.properties !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "properties" member',
                line: geom.__line__
            });
        }
        if (geom.geometry !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "geometry" member',
                line: geom.__line__
            });
        }
        if (geom.features !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "features" member',
                line: geom.__line__
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.2
    function Point(point) {
        crs(point);
        bbox(point);
        geometrySemantics(point);
        if (!requiredProperty(point, 'coordinates', 'array')) {
            position(point.coordinates);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.6
    function Polygon(polygon) {
        crs(polygon);
        bbox(polygon);
        if (!requiredProperty(polygon, 'coordinates', 'array')) {
            if (!positionArray(polygon.coordinates, 'LinearRing', 2)) {
                rightHandRule(polygon, errors);
            }
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.7
    function MultiPolygon(multiPolygon) {
        crs(multiPolygon);
        bbox(multiPolygon);
        if (!requiredProperty(multiPolygon, 'coordinates', 'array')) {
            if (!positionArray(multiPolygon.coordinates, 'LinearRing', 3)) {
                rightHandRule(multiPolygon, errors);
            }
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.4
    function LineString(lineString) {
        crs(lineString);
        bbox(lineString);
        if (!requiredProperty(lineString, 'coordinates', 'array')) {
            positionArray(lineString.coordinates, 'Line', 1);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.5
    function MultiLineString(multiLineString) {
        crs(multiLineString);
        bbox(multiLineString);
        if (!requiredProperty(multiLineString, 'coordinates', 'array')) {
            positionArray(multiLineString.coordinates, 'Line', 2);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.3
    function MultiPoint(multiPoint) {
        crs(multiPoint);
        bbox(multiPoint);
        if (!requiredProperty(multiPoint, 'coordinates', 'array')) {
            positionArray(multiPoint.coordinates, '', 1);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.8
    function GeometryCollection(geometryCollection) {
        crs(geometryCollection);
        bbox(geometryCollection);
        if (!requiredProperty(geometryCollection, 'geometries', 'array')) {
            if (!everyIs(geometryCollection.geometries, 'object')) {
                errors.push({
                    message: 'The geometries array in a GeometryCollection must contain only geometry objects',
                    line: geometryCollection.__line__
                });
            }
            if (geometryCollection.geometries.length === 1) {
                errors.push({
                    message: 'GeometryCollection with a single geometry should be avoided in favor of single part or a single object of multi-part type',
                    line: geometryCollection.geometries.__line__
                });
            }
            geometryCollection.geometries.forEach(function(geometry) {
                if (geometry) {
                    if (geometry.type === 'GeometryCollection') {
                        errors.push({
                            message: 'GeometryCollection should avoid nested geometry collections',
                            line: geometryCollection.geometries.__line__
                        });
                    }
                    root(geometry);
                }
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.2
    function Feature(feature) {
        crs(feature);
        bbox(feature);
        // https://github.com/geojson/draft-geojson/blob/master/middle.mkd#feature-object
        if (feature.id !== undefined &&
            typeof feature.id !== 'string' &&
            typeof feature.id !== 'number') {
            errors.push({
                message: 'Feature "id" member must have a string or number value',
                line: feature.__line__
            });
        }
        if (feature.features !== undefined) {
            errors.push({
                message: 'Feature object cannot contain a "features" member',
                line: feature.__line__
            });
        }
        if (feature.coordinates !== undefined) {
            errors.push({
                message: 'Feature object cannot contain a "coordinates" member',
                line: feature.__line__
            });
        }
        if (feature.type !== 'Feature') {
            errors.push({
                message: 'GeoJSON features must have a type=feature member',
                line: feature.__line__
            });
        }
        requiredProperty(feature, 'properties', 'object');
        if (!requiredProperty(feature, 'geometry', 'object')) {
            // https://tools.ietf.org/html/rfc7946#section-3.2
            // tolerate null geometry
            if (feature.geometry) root(feature.geometry);
        }
    }

    var types = {
        Point: Point,
        Feature: Feature,
        MultiPoint: MultiPoint,
        LineString: LineString,
        MultiLineString: MultiLineString,
        FeatureCollection: FeatureCollection,
        GeometryCollection: GeometryCollection,
        Polygon: Polygon,
        MultiPolygon: MultiPolygon
    };

    var typesLower = Object.keys(types).reduce(function(prev, curr) {
        prev[curr.toLowerCase()] = curr;
        return prev;
    }, {});

    if (typeof gj !== 'object' ||
        gj === null ||
        gj === undefined) {
        errors.push({
            message: 'The root of a GeoJSON object must be an object.',
            line: 0
        });
        return errors;
    }

    root(gj);

    errors.forEach(function(err) {
        if ({}.hasOwnProperty.call(err, 'line') && err.line === undefined) {
            delete err.line;
        }
    });

    return errors;
}

module.exports.hint = hint;

},{"./rhr":6}],6:[function(require,module,exports){
function rad(x) {
    return x * Math.PI / 180;
}

function isRingClockwise (coords) {
    var area = 0;
    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }
    }

    return area >= 0;
}

function isPolyRHR (coords) {
    if (coords && coords.length > 0) {
        if (isRingClockwise(coords[0]))
            return false;
        var interiorCoords = coords.slice(1, coords.length);
        if (!interiorCoords.every(isRingClockwise))
            return false;
    }
    return true;
}

function rightHandRule (geometry) {
    if (geometry.type === 'Polygon') {
        return isPolyRHR(geometry.coordinates);
    } else if (geometry.type === 'MultiPolygon') {
        return geometry.coordinates.every(isPolyRHR);
    }
}

module.exports = function validateRightHandRule(geometry, errors) {
    if (!rightHandRule(geometry)) {
        errors.push({
            message: 'Polygons and MultiPolygons should follow the right-hand rule',
            level: 'message',
            line: geometry.__line__
        });
    }
};

},{}],7:[function(require,module,exports){
var measureDistance = require('@turf/distance');
var point = require('@turf/helpers').point;
var bearing = require('@turf/bearing');
var destination = require('@turf/destination');

/**
 * Takes a {@link LineString|line} and returns a {@link Point|point} at a specified distance along the line.
 *
 * @name along
 * @param {Feature<LineString>} line input line
 * @param {number} distance distance along the line
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} Point `distance` `units` along the line
 * @addToMap along, line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var along = turf.along(line, 1, 'miles');
 * //=along
 */
module.exports = function (line, distance, units) {
    var coords;
    if (line.type === 'Feature') coords = line.geometry.coordinates;
    else if (line.type === 'LineString') coords = line.coordinates;
    else throw new Error('input must be a LineString Feature or Geometry');

    var travelled = 0;
    for (var i = 0; i < coords.length; i++) {
        if (distance >= travelled && i === coords.length - 1) break;
        else if (travelled >= distance) {
            var overshot = distance - travelled;
            if (!overshot) return point(coords[i]);
            else {
                var direction = bearing(coords[i], coords[i - 1]) - 180;
                var interpolated = destination(coords[i], overshot, direction, units);
                return interpolated;
            }
        } else {
            travelled += measureDistance(coords[i], coords[i + 1], units);
        }
    }
    return point(coords[coords.length - 1]);
};

},{"@turf/bearing":15,"@turf/destination":33,"@turf/distance":38,"@turf/helpers":8}],8:[function(require,module,exports){
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} properties properties
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var geometry = {
 *      "type": "Point",
 *      "coordinates": [
 *        67.5,
 *        32.84267363195431
 *      ]
 *    }
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties) {
    if (!geometry) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object=} properties an Object that is used as the {@link Feature}'s
 * properties
 * @returns {Feature<Point>} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
function point(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (typeof coordinates[0] !== 'number' || typeof coordinates[1] !== 'number') throw new Error('Coordinates must numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties);
}

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object=} properties a properties object
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
function polygon(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties);
}

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
function lineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties);
}

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var fc = turf.featureCollection(features);
 *
 * //=fc
 */
function featureCollection(features) {
    if (!features) throw new Error('No features passed');

    return {
        type: 'FeatureCollection',
        features: features
    };
}

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 *
 */
function multiLineString(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties);
}

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 *
 */
function multiPoint(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties);
}


/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties);
}

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
function geometryCollection(geometries, properties) {
    if (!geometries) throw new Error('No geometries passed');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties);
}

var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

/**
 * Convert a distance measurement from radians to a more friendly unit.
 *
 * @name radiansToDistance
 * @param {number} radians in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToDistance(radians, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) throw new Error('Invalid unit');

    return radians * factor;
}

/**
 * Convert a distance measurement from a real-world unit into radians
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
function distanceToRadians(distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) throw new Error('Invalid unit');

    return distance / factor;
}

/**
 * Convert a distance measurement from a real-world unit into degrees
 *
 * @name distanceToDegrees
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function distanceToDegrees(distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) throw new Error('Invalid unit');

    return (distance / factor) * 57.2958;
}

module.exports = {
    feature: feature,
    featureCollection: featureCollection,
    geometryCollection: geometryCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    radiansToDistance: radiansToDistance,
    distanceToRadians: distanceToRadians,
    distanceToDegrees: distanceToDegrees
};

},{}],9:[function(require,module,exports){
var area = require('@mapbox/geojson-area').geometry;
var geomReduce = require('@turf/meta').geomReduce;

/**
 * Takes one or more features and returns their area in square meters.
 *
 * @name area
 * @param {FeatureCollection|Feature<any>} geojson input GeoJSON feature(s)
 * @returns {number} area in square meters
 * @addToMap polygon
 * @example
 * var polygon = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [
 *       [
 *         [125, -15],
 *         [113, -22],
 *         [117, -37],
 *         [130, -33],
 *         [148, -39],
 *         [154, -27],
 *         [144, -15],
 *         [125, -15]
 *       ]
 *     ]
 *   }
 * }
 * var area = turf.area(polygon);
 * //=area => square meters
 * //=polygon
 */
module.exports = function (geojson) {
    return geomReduce(geojson, function (value, geometry) {
        return value + area(geometry);
    }, 0);
};

},{"@mapbox/geojson-area":2,"@turf/meta":10}],10:[function(require,module,exports){
/**
 * Callback for coordEach
 *
 * @private
 * @callback coordEachCallback
 * @param {[number, number]} currentCoords The current coordinates being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentCoords, currentIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.coordEach(features, function (currentCoords, currentIndex) {
 *   //=currentCoords
 *   //=currentIndex
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
    var i, j, k, g, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        currentIndex = 0,
        isGeometryCollection,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            coords = geometry.coordinates;

            wrapShrink = (excludeWrapCoord &&
                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                1 : 0;

            if (geometry.type === 'Point') {
                callback(coords, currentIndex);
                currentIndex++;
            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], currentIndex);
                    currentIndex++;
                }
            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], currentIndex);
                        currentIndex++;
                    }
            } else if (geometry.type === 'MultiPolygon') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], currentIndex);
                            currentIndex++;
                        }
            } else if (geometry.type === 'GeometryCollection') {
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {[number, number]} currentCoords The current coordinate being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {
 *   //=previousValue
 *   //=currentCoords
 *   //=currentIndex
 *   return currentCoords;
 * });
 */
function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(layer, function (currentCoords, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentCoords;
        } else {
            previousValue = callback(previousValue, currentCoords, currentIndex);
        }
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @private
 * @callback propEachCallback
 * @param {*} currentProperties The current properties being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, currentIndex)
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.propEach(features, function (currentProperties, currentIndex) {
 *   //=currentProperties
 *   //=currentIndex
 * });
 */
function propEach(layer, callback) {
    var i;
    switch (layer.type) {
    case 'FeatureCollection':
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(layer.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=currentIndex
 *   return currentProperties
 * });
 */
function propReduce(layer, callback, initialValue) {
    var previousValue = initialValue;
    propEach(layer, function (currentProperties, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentProperties;
        } else {
            previousValue = callback(previousValue, currentProperties, currentIndex);
        }
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @private
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, currentIndex)
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.featureEach(features, function (currentFeature, currentIndex) {
 *   //=currentFeature
 *   //=currentIndex
 * });
 */
function featureEach(layer, callback) {
    if (layer.type === 'Feature') {
        callback(layer, 0);
    } else if (layer.type === 'FeatureCollection') {
        for (var i = 0; i < layer.features.length; i++) {
            callback(layer.features[i], i);
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=currentIndex
 *   return currentFeature
 * });
 */
function featureReduce(layer, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(layer, function (currentFeature, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentFeature;
        } else {
            previousValue = callback(previousValue, currentFeature, currentIndex);
        }
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {Object} layer any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * var coords = turf.coordAll(features);
 * //=coords
 */
function coordAll(layer) {
    var coords = [];
    coordEach(layer, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, currentIndex)
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.geomEach(features, function (currentGeometry, currentIndex) {
 *   //=currentGeometry
 *   //=currentIndex
 * });
 */
function geomEach(layer, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        currentIndex = 0,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            if (geometry.type === 'Point' ||
                geometry.type === 'LineString' ||
                geometry.type === 'MultiPoint' ||
                geometry.type === 'Polygon' ||
                geometry.type === 'MultiLineString' ||
                geometry.type === 'MultiPolygon') {
                callback(geometry, currentIndex);
                currentIndex++;
            } else if (geometry.type === 'GeometryCollection') {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], currentIndex);
                    currentIndex++;
                }
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=currentIndex
 *   return currentGeometry
 * });
 */
function geomReduce(layer, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(layer, function (currentGeometry, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentGeometry;
        } else {
            previousValue = callback(previousValue, currentGeometry, currentIndex);
        }
    });
    return previousValue;
}

module.exports = {
    coordEach: coordEach,
    coordReduce: coordReduce,
    propEach: propEach,
    propReduce: propReduce,
    featureEach: featureEach,
    featureReduce: featureReduce,
    coordAll: coordAll,
    geomEach: geomEach,
    geomReduce: geomReduce
};

},{}],11:[function(require,module,exports){
var helpers = require('@turf/helpers');
var lineclip = require('lineclip');
var getCoords = require('@turf/invariant').getCoords;
var lineString = helpers.lineString;
var multiLineString = helpers.multiLineString;
var polygon = helpers.polygon;
var multiPolygon = helpers.multiPolygon;

/**
 * Takes a {@link Feature} and a bbox and clips the feature to the bbox using [lineclip](https://github.com/mapbox/lineclip).
 * May result in degenerate edges when clipping Polygons.
 *
 * @name bbox-clip
 * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature feature to clip to the bbox
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @returns {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} clipped Feature
 * @example
 * var bbox = [0, 0, 10, 10];
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[[2, 2], [8, 4], [12, 8], [3, 7], [2, 2]]]
 *   }
 * }
 *
 * var clipped = turf.bboxClip(poly, bbox);
 *
 * //=clipped
 */
module.exports = function (feature, bbox) {
    var geom = getGeom(feature);
    var coords = getCoords(feature);
    var properties = feature.properties;

    switch (geom) {
    case 'LineString':
    case 'MultiLineString':
        var lines = [];
        if (geom === 'LineString') coords = [coords];
        coords.forEach(function (line) {
            lineclip(line, bbox, lines);
        });
        if (lines.length === 1) return lineString(lines[0], properties);
        return multiLineString(lines, properties);
    case 'Polygon':
        return polygon(clipPolygon(coords, bbox), properties);
    case 'MultiPolygon':
        return multiPolygon(coords.map(function (polygon) {
            return clipPolygon(polygon, bbox);
        }), properties);
    default:
        throw new Error('geometry ' + geom + ' not supported');
    }
};

function clipPolygon(rings, bbox) {
    var outRings = [];
    for (var i = 0; i < rings.length; i++) {
        var clipped = lineclip.polygon(rings[i], bbox);
        if (clipped.length > 0) {
            if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
                clipped.push(clipped[0]);
            }
            outRings.push(clipped);
        }
    }
    return outRings;
}

function getGeom(feature) {
    return (feature.geometry) ? feature.geometry.type : feature.type;
}

},{"@turf/helpers":12,"@turf/invariant":62,"lineclip":166}],12:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],13:[function(require,module,exports){
var each = require('@turf/meta').coordEach;

/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {(Feature|FeatureCollection)} geojson input features
 * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @addToMap features, bboxPolygon
 * @example
 * var pt1 = turf.point([114.175329, 22.2524])
 * var pt2 = turf.point([114.170007, 22.267969])
 * var pt3 = turf.point([114.200649, 22.274641])
 * var pt4 = turf.point([114.200649, 22.274641])
 * var pt5 = turf.point([114.186744, 22.265745])
 * var features = turf.featureCollection([pt1, pt2, pt3, pt4, pt5])
 *
 * var bbox = turf.bbox(features);
 *
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //=bbox
 *
 * //=bboxPolygon
 */
module.exports = function (geojson) {
    var bbox = [Infinity, Infinity, -Infinity, -Infinity];
    each(geojson, function (coord) {
        if (bbox[0] > coord[0]) bbox[0] = coord[0];
        if (bbox[1] > coord[1]) bbox[1] = coord[1];
        if (bbox[2] < coord[0]) bbox[2] = coord[0];
        if (bbox[3] < coord[1]) bbox[3] = coord[1];
    });
    return bbox;
};

},{"@turf/meta":14}],14:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],15:[function(require,module,exports){
var getCoord = require('@turf/invariant').getCoord;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point|points} and finds the geographic bearing between them.
 *
 * @name bearing
 * @param {Feature<Point>} start starting Point
 * @param {Feature<Point>} end ending Point
 * @param {boolean} [final=false] calculates the final bearing if true
 * @returns {number} bearing in decimal degrees
 * @addToMap point1, point2
 * @example
 * var point1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#f00'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var point2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#0f0'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 *
 * var bearing = turf.bearing(point1, point2);
 * point1.properties.bearing = bearing
 * //=bearing
 */
function bearing(start, end, final) {
    if (final === true) return calculateFinalBearing(start, end);

    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(start);
    var coordinates2 = getCoord(end);

    var lon1 = degrees2radians * coordinates1[0];
    var lon2 = degrees2radians * coordinates2[0];
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

    var bear = radians2degrees * Math.atan2(a, b);

    return bear;
}

/**
 * Calculates Final Bearing
 * @private
 * @param {Feature<Point>} start starting Point
 * @param {Feature<Point>} end ending Point
 * @returns {number} bearing
 */
function calculateFinalBearing(start, end) {
    // Swap start & end
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}

module.exports = bearing;

},{"@turf/invariant":62}],16:[function(require,module,exports){
var linestring = require('@turf/helpers').lineString;
var Spline = require('./spline.js');

/**
 * Takes a {@link LineString|line} and returns a curved version
 * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)
 * algorithm.
 *
 * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).
 *
 * @name bezier
 * @param {Feature<LineString>} line input LineString
 * @param {number} [resolution=10000] time in milliseconds between points
 * @param {number} [sharpness=0.85] a measure of how curvy the path should be between splines
 * @returns {Feature<LineString>} curved line
 * @addToMap line, curved
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {
 *     "stroke": "#f00"
 *   },
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-76.091308, 18.427501],
 *       [-76.695556, 18.729501],
 *       [-76.552734, 19.40443],
 *       [-74.61914, 19.134789],
 *       [-73.652343, 20.07657],
 *       [-73.157958, 20.210656]
 *     ]
 *   }
 * };
 *
 * var curved = turf.bezier(line);
 * curved.properties = { stroke: '#0f0' };
 *
 * //=curved
 */
module.exports = function (line, resolution, sharpness) {
    var lineOut = linestring([]);

    lineOut.properties = line.properties;

    var spline = new Spline({
        points: line.geometry.coordinates.map(function (pt) {
            return {x: pt[0], y: pt[1]};
        }),
        duration: resolution,
        sharpness: sharpness
    });

    for (var i = 0; i < spline.duration; i += 10) {
        var pos = spline.pos(i);
        if (Math.floor(i / 100) % 2 === 0) {
            lineOut.geometry.coordinates.push([pos.x, pos.y]);
        }
    }

    return lineOut;
};

},{"./spline.js":18,"@turf/helpers":17}],17:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],18:[function(require,module,exports){
/* eslint-disable */

 /**
   * BezierSpline
   * https://github.com/leszekr/bezier-spline-js
   *
   * @private
   * @copyright
   * Copyright (c) 2013 Leszek Rybicki
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
var Spline = function (options) {
    this.points = options.points || [];
    this.duration = options.duration || 10000;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    // this is to ensure compatibility with the 2d version
    for (var i = 0; i < this.length; i++) this.points[i].z = this.points[i].z || 0;
    for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2,
            z: (p1.z + p2.z) / 2
        });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (var i = 0; i < this.centers.length - 1; i++) {
        var p1 = this.centers[i];
        var p2 = this.centers[i + 1];
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([{
            x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)},
            {
                x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
                y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
                z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)}]);
    }
    this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
};

  /*
    Caches an array of equidistant (more or less) points on the curve.
  */
Spline.prototype.cacheSteps = function (mindist) {
    var steps = [];
    var laststep = this.pos(0);
    steps.push(0);
    for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
            steps.push(t);
            laststep = step;
        }
    }
    return steps;
};

  /*
    returns angle and speed in the given point in the curve
  */
Spline.prototype.vector = function (t) {
    var p1 = this.pos(t + 10);
    var p2 = this.pos(t - 10);
    return {
        angle:180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed:Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
    };
};

  /*
    Gets the position of the point, given time.

    WARNING: The speed is not constant. The time it takes between control points is constant.

    For constant speed, use Spline.steps[i];
  */
Spline.prototype.pos = function (time) {

    function bezier(t, p1, c1, c2, p2) {
        var B = function (t) {
            var t2 = t * t, t3 = t2 * t;
            return [(t3), (3 * t2 * (1 - t)), (3 * t * (1 - t) * (1 - t)), ((1 - t) * (1 - t) * (1 - t))];
        };
        var b = B(t);
        var pos = {
            x : p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
            y : p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
            z : p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
        };
        return pos;
    }
    var t = time - this.delay;
    if (t < 0) t = 0;
    if (t > this.duration) t = this.duration - 1;
    //t = t-this.delay;
    var t2 = (t) / this.duration;
    if (t2 >= 1) return this.points[this.length - 1];

    var n = Math.floor((this.points.length - 1) * t2);
    var t1 = (this.length - 1) * t2 - n;
    return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
};

module.exports = Spline;

},{}],19:[function(require,module,exports){
var each = require('@turf/meta').coordEach,
    centroid = require('@turf/centroid'),
    convex = require('@turf/convex'),
    explode = require('@turf/explode'),
    point = require('@turf/helpers').point;

/**
 * Takes a [feature](http://geojson.org/geojson-spec.html#feature-objects)
 * or a [featureCollection](http://geojson.org/geojson-spec.html#feature-collection-objects)
 * and returns its [center of mass](https://en.wikipedia.org/wiki/Center_of_mass)
 * using this formula: [Centroid of Polygon](https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon).
 *
 * @param {FeatureCollection|Feature} fc - the feature collection or feature
 * @returns {Feature<Point>} the center of mass
 * @example
 * var feature = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [
 *       [
 *         [
 *           4.854240417480469,
 *           45.77258200374433
 *         ],
 *         [
 *           4.8445844650268555,
 *           45.777431068484894
 *         ],
 *         [
 *           4.845442771911621,
 *           45.778658234059755
 *         ],
 *         [
 *           4.845914840698242,
 *           45.779376562352425
 *         ],
 *         [
 *           4.846644401550292,
 *           45.78021460033108
 *         ],
 *         [
 *           4.847245216369629,
 *           45.78078326178593
 *         ],
 *         [
 *           4.848060607910156,
 *           45.78138184652523
 *         ],
 *         [
 *           4.8487043380737305,
 *           45.78186070968964
 *         ],
 *         [
 *           4.849562644958495,
 *           45.78248921135124
 *         ],
 *         [
 *           4.850893020629883,
 *           45.78302792142197
 *         ],
 *         [
 *           4.852008819580077,
 *           45.78374619341895
 *         ],
 *         [
 *           4.852995872497559,
 *           45.784075398324866
 *         ],
 *         [
 *           4.853854179382324,
 *           45.78443452873236
 *         ],
 *         [
 *           4.8549699783325195,
 *           45.78470387501975
 *         ],
 *         [
 *           4.85569953918457,
 *           45.784793656826345
 *         ],
 *         [
 *           4.857330322265624,
 *           45.784853511283764
 *         ],
 *         [
 *           4.858231544494629,
 *           45.78494329284938
 *         ],
 *         [
 *           4.859304428100585,
 *           45.784883438488365
 *         ],
 *         [
 *           4.858360290527344,
 *           45.77294120818474
 *         ],
 *         [
 *           4.854240417480469,
 *           45.77258200374433
 *         ]
 *       ]
 *     ]
 *   }
 * };
 *
 * var centerOfMass = turf.centerOfMass(feature);
 *
 * //=centerOfMass
 */
function centerOfMass(fc) {
    if (fc.type === 'Feature' && fc.geometry.type === 'Polygon') {
        var coords = [];
        each(fc, function (coord) {
            coords.push(coord);
        });

        // First, we neutralize the feature (set it around coordinates [0,0]) to prevent rounding errors
        // We take any point to translate all the points around 0
        var centre = centroid(fc);
        var translation = centre.geometry.coordinates;
        var sx = 0;
        var sy = 0;
        var sArea = 0;
        var i, pi, pj, xi, xj, yi, yj, a;

        var neutralizedPoints = coords.map(function (point) {
            return [
                point[0] - translation[0],
                point[1] - translation[1]
            ];
        });

        for (i = 0; i < coords.length - 1; i++) {
            // pi is the current point
            pi = neutralizedPoints[i];
            xi = pi[0];
            yi = pi[1];

            // pj is the next point (pi+1)
            pj = neutralizedPoints[i + 1];
            xj = pj[0];
            yj = pj[1];

            // a is the common factor to compute the signed area and the final coordinates
            a = xi * yj - xj * yi;

            // sArea is the sum used to compute the signed area
            sArea += a;

            // sx and sy are the sums used to compute the final coordinates
            sx += (xi + xj) * a;
            sy += (yi + yj) * a;
        }

        // Shape has no area: fallback on turf.centroid
        if (sArea === 0) {
            return centre;
        } else {
            // Compute the signed area, and factorize 1/6A
            var area = sArea * 0.5;
            var areaFactor = 1 / (6 * area);

            // Compute the final coordinates, adding back the values that have been neutralized
            return point([
                translation[0] + areaFactor * sx,
                translation[1] + areaFactor * sy
            ]);
        }
    } else {
        // Not a polygon: Compute the convex hull and work with that
        var hull = convex(explode(fc));

        if (hull) {
            return module.exports(hull);
        } else {
            // Hull is empty: fallback on the centroid
            return centroid(fc);
        }
    }
}

module.exports = centerOfMass;

},{"@turf/centroid":20,"@turf/convex":30,"@turf/explode":43,"@turf/helpers":21,"@turf/meta":22}],20:[function(require,module,exports){
var each = require('@turf/meta').coordEach;
var point = require('@turf/helpers').point;

/**
 * Takes one or more features and calculates the centroid using
 * the mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating
 * the centroid of a set of polygons.
 *
 * @name centroid
 * @param {(Feature|FeatureCollection)} features input features
 * @returns {Feature<Point>} the centroid of the input features
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [105.818939,21.004714],
 *       [105.818939,21.061754],
 *       [105.890007,21.061754],
 *       [105.890007,21.004714],
 *       [105.818939,21.004714]
 *     ]]
 *   }
 * };
 *
 * var centroidPt = turf.centroid(poly);
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [poly, centroidPt]
 * };
 *
 * //=result
 */
module.exports = function (features) {
    var xSum = 0, ySum = 0, len = 0;
    each(features, function (coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return point([xSum / len, ySum / len]);
};

},{"@turf/helpers":21,"@turf/meta":22}],21:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],22:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],23:[function(require,module,exports){
var bbox = require('@turf/bbox'),
    point = require('@turf/helpers').point;

/**
 * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
 *
 * @name center
 * @param {(Feature|FeatureCollection)} layer input features
 * @return {Feature<Point>} a Point feature at the absolute center point of all input features
 * @addToMap features, centerPt
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.522259, 35.4691]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.502754, 35.463455]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508269, 35.463245]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.516809, 35.465779]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.515372, 35.467072]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.509363, 35.463053]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.511123, 35.466601]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.518547, 35.469327]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.519706, 35.469659]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.517839, 35.466998]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508678, 35.464942]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.514914, 35.463453]
 *       }
 *     }
 *   ]
 * };
 *
 * var centerPt = turf.center(features);
 * centerPt.properties['marker-size'] = 'large';
 * centerPt.properties['marker-color'] = '#000';
 *
 * var resultFeatures = features.features.concat(centerPt);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function (layer) {
    var ext = bbox(layer);
    var x = (ext[0] + ext[2]) / 2;
    var y = (ext[1] + ext[3]) / 2;
    return point([x, y]);
};

},{"@turf/bbox":13,"@turf/helpers":24}],24:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],25:[function(require,module,exports){
var destination = require('@turf/destination');
var helpers = require('@turf/helpers');
var polygon = helpers.polygon;

/**
 * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
 *
 * @name circle
 * @param {Feature<Point>} center center point
 * @param {number} radius radius of the circle
 * @param {number} [steps=64] number of steps
 * @param {string} [units=kilometers] miles, kilometers, degrees, or radians
 * @returns {Feature<Polygon>} circle polygon
 * @example
 * var center = turf.point([-75.343, 39.984]);
 * var radius = 5;
 * var steps = 10;
 * var units = 'kilometers';
 *
 * var circle = turf.circle(center, radius, steps, units);
 *
 * //=circle
 */
module.exports = function (center, radius, steps, units) {
    steps = steps || 64;
    var coordinates = [];

    for (var i = 0; i < steps; i++) {
        coordinates.push(destination(center, radius, i * 360 / steps, units).geometry.coordinates);
    }

    coordinates.push(coordinates[0]);

    return polygon([coordinates]);
};

},{"@turf/destination":33,"@turf/helpers":26}],26:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],27:[function(require,module,exports){
var turfbbox = require('@turf/bbox');
var inside = require('@turf/inside');
var rbush = require('rbush');

/**
 * Merges a specified property from a FeatureCollection of points into a
 * FeatureCollection of polygons. Given an `inProperty` on points and an `outProperty`
 * for polygons, this finds every point that lies within each polygon, collects the
 * `inProperty` values from those points, and adds them as an array to `outProperty`
 * on the polygon.
 *
 * @name collect
 * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate
 * @param {FeatureCollection<Point>} points points to be aggregated
 * @param {string} inProperty property to be nested from
 * @param {string} outProperty property to be nested into
 * @returns {FeatureCollection<Polygon>} polygons with properties listed based on `outField`
 * @addToMap collected, pointFC
 * @example
 * var poly1 = turf.polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);
 * var poly2 = turf.polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);
 * var polyFC = turf.featureCollection([poly1, poly2]);
 * var pt1 = turf.point([5,5], {population: 200});
 * var pt2 = turf.point([1,3], {population: 600});
 * var pt3 = turf.point([14,2], {population: 100});
 * var pt4 = turf.point([13,1], {population: 200});
 * var pt5 = turf.point([19,7], {population: 300});
 * var pointFC = turf.featureCollection([pt1, pt2, pt3, pt4, pt5]);
 * var collected = turf.collect(polyFC, pointFC, 'population', 'values');
 * var values = collected.features[0].properties.values
 * //=values => [200, 600]
 * //=pointFC
 * //=collected
 */
module.exports = function (polygons, points, inProperty, outProperty) {
    var rtree = rbush(6);

    var treeItems = points.features.map(function (item) {
        return {
            minX: item.geometry.coordinates[0],
            minY: item.geometry.coordinates[1],
            maxX: item.geometry.coordinates[0],
            maxY: item.geometry.coordinates[1],
            property: item.properties[inProperty]
        };
    });

    rtree.load(treeItems);
    polygons.features.forEach(function (poly) {

        if (!poly.properties) {
            poly.properties = {};
        }
        var bbox = turfbbox(poly);
        var potentialPoints = rtree.search({minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3]});
        var values = [];
        potentialPoints.forEach(function (pt) {
            if (inside({'type': 'Point', 'coordinates': [pt.minX, pt.minY]}, poly)) {
                values.push(pt.property);
            }
        });

        poly.properties[outProperty] = values;
    });

    return polygons;
};

},{"@turf/bbox":13,"@turf/inside":60,"rbush":174}],28:[function(require,module,exports){
// 1. run tin on points
// 2. calculate lenth of all edges and area of all triangles
// 3. remove triangles that fail the max length test
// 4. buffer the results slightly
// 5. merge the results
var tin = require('@turf/tin');
var union = require('@turf/union');
var distance = require('@turf/distance');

/**
 * Takes a set of {@link Point|points} and returns a concave hull polygon.
 *
 * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.
 *
 * @param {FeatureCollection<Point>} points input points
 * @param {number} maxEdge the size of an edge necessary for part of the
 * hull to become concave (in miles)
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Polygon>} a concave hull
 * @throws {Error} if maxEdge parameter is missing or unable to compute hull
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.601226, 44.642643]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.591442, 44.651436]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.580799, 44.648749]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.573589, 44.641788]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.587665, 44.64533]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.595218, 44.64765]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.concave(points, 1, 'miles');
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
function concave(points, maxEdge, units) {
    if (typeof maxEdge !== 'number') throw new Error('maxEdge parameter is required');

    var tinPolys = tin(points);
    var filteredPolys = tinPolys.features.filter(filterTriangles);
    tinPolys.features = filteredPolys;
    if (tinPolys.features.length < 1) {
        throw new Error('too few polygons found to compute concave hull');
    }

    function filterTriangles(triangle) {
        var pt1 = triangle.geometry.coordinates[0][0];
        var pt2 = triangle.geometry.coordinates[0][1];
        var pt3 = triangle.geometry.coordinates[0][2];
        var dist1 = distance(pt1, pt2, units);
        var dist2 = distance(pt2, pt3, units);
        var dist3 = distance(pt1, pt3, units);
        return (dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge);
    }

    return merge(tinPolys);
}

function merge(polygons) {
    var merged = JSON.parse(JSON.stringify(polygons.features[0])),
        features = polygons.features;

    for (var i = 0, len = features.length; i < len; i++) {
        var poly = features[i];
        if (poly.geometry) {
            merged = union(merged, poly);
        }
    }
    return merged;
}

module.exports = concave;

},{"@turf/distance":38,"@turf/tin":118,"@turf/union":29}],29:[function(require,module,exports){
var jsts = require('jsts');

/**
 * Takes two or more {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @name union
 * @param {...Feature<Polygon>} A polygon to combine
 * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.574787, 35.594087],
 *       [-82.574787, 35.615581],
 *       [-82.545261, 35.615581],
 *       [-82.545261, 35.594087],
 *       [-82.574787, 35.594087]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.560024, 35.585153],
 *       [-82.560024, 35.602602],
 *       [-82.52964, 35.602602],
 *       [-82.52964, 35.585153],
 *       [-82.560024, 35.585153]
 *     ]]
 *   }
 * };
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * var union = turf.union(poly1, poly2);
 *
 * //=polygons
 *
 * //=union
 */
module.exports = function () {
    var reader = new jsts.io.GeoJSONReader();
    var result = reader.read(JSON.stringify(arguments[0].geometry));

    for (var i = 1; i < arguments.length; i++) {
        result = result.union(reader.read(JSON.stringify(arguments[i].geometry)));
    }

    var writer = new jsts.io.GeoJSONWriter();
    result = writer.write(result);

    return {
        type: 'Feature',
        geometry: result,
        properties: arguments[0].properties
    };
};

},{"jsts":165}],30:[function(require,module,exports){
var each = require('@turf/meta').coordEach,
    convexHull = require('convex-hull'),
    polygon = require('@turf/helpers').polygon;

/**
 * Takes a {@link Feature} or a {@link FeatureCollection} and returns a convex hull {@link Polygon}.
 *
 * Internally this uses
 * the [convex-hull](https://github.com/mikolalysenko/convex-hull) module that
 * implements a [monotone chain hull](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).
 *
 * @name convex
 * @param {Feature|FeatureCollection} feature input Feature or FeatureCollection
 * @returns {Feature<Polygon>} a convex hull
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.404052, 43.8424511]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.579833, 43.659924]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.360107, 43.516688]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.14038, 43.588348]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.convex(points);
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (feature) {
    var points = [];

    // Remove Z in coordinates because it breaks the convexHull algorithm
    each(feature, function (coord) {
        points.push([coord[0], coord[1]]);
    });

    var hull = convexHull(points);

    // Hull should have at least 3 different vertices in order to create a valid polygon
    if (hull.length >= 3) {
        var ring = [];
        for (var i = 0; i < hull.length; i++) {
            ring.push(points[hull[i][0]]);
        }
        ring.push(points[hull[hull.length - 1][1]]);
        return polygon([ring]);
    }
    return undefined;
};

},{"@turf/helpers":31,"@turf/meta":32,"convex-hull":140}],31:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],32:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],33:[function(require,module,exports){
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
var getCoord = require('@turf/invariant').getCoord;
var helpers = require('@turf/helpers');
var point = helpers.point;
var distanceToRadians = helpers.distanceToRadians;

/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Feature<Point>} from starting point
 * @param {number} distance distance from the starting point
 * @param {number} bearing ranging from -180 to 180
 * @param {string} [units=kilometers] miles, kilometers, degrees, or radians
 * @returns {Feature<Point>} destination point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var distance = 50;
 * var bearing = 90;
 * var units = 'miles';
 *
 * var destination = turf.destination(point, distance, bearing, units);
 * destination.properties['marker-color'] = '#f00';
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [point, destination]
 * };
 *
 * //=result
 */
module.exports = function (from, distance, bearing, units) {
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(from);
    var longitude1 = degrees2radians * coordinates1[0];
    var latitude1 = degrees2radians * coordinates1[1];
    var bearing_rad = degrees2radians * bearing;

    var radians = distanceToRadians(distance, units);

    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) *
        Math.sin(radians) * Math.cos(latitude1),
        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));

    return point([radians2degrees * longitude2, radians2degrees * latitude2]);
};

},{"@turf/helpers":34,"@turf/invariant":62}],34:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],35:[function(require,module,exports){
// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = require('jsts');

/**
 * Finds the difference between two {@link Polygon|polygons} by clipping the second
 * polygon from the first.
 *
 * @name difference
 * @param {Feature<Polygon>} p1 input Polygon feature
 * @param {Feature<Polygon>} p2 Polygon feature to difference from `p1`
 * @return {Feature<(Polygon|MultiPolygon)>} a Polygon or MultiPolygon feature showing the area of `p1` excluding the area of `p2`
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.738586, -23.596711],
 *       [-46.738586, -23.458207],
 *       [-46.560058, -23.458207],
 *       [-46.560058, -23.596711],
 *       [-46.738586, -23.596711]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.650009, -23.631314],
 *       [-46.650009, -23.5237],
 *       [-46.509246, -23.5237],
 *       [-46.509246, -23.631314],
 *       [-46.650009, -23.631314]
 *     ]]
 *   }
 * };
 *
 * var differenced = turf.difference(poly1, poly2);
 * differenced.properties.fill = '#f00';
 *
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * //=polygons
 *
 * //=differenced
 */

module.exports = function (p1, p2) {
    var poly1 = JSON.parse(JSON.stringify(p1));
    var poly2 = JSON.parse(JSON.stringify(p2));
    if (poly1.type !== 'Feature') {
        poly1 = {
            type: 'Feature',
            properties: {},
            geometry: poly1
        };
    }
    if (poly2.type !== 'Feature') {
        poly2 = {
            type: 'Feature',
            properties: {},
            geometry: poly2
        };
    }

    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(poly1.geometry));
    var b = reader.read(JSON.stringify(poly2.geometry));
    var differenced = a.difference(b);

    if (differenced.isEmpty()) return undefined;

    var writer = new jsts.io.GeoJSONWriter();
    var geojsonGeometry = writer.write(differenced);

    poly1.geometry = differenced;

    return {
        type: 'Feature',
        properties: poly1.properties,
        geometry: geojsonGeometry
    };
};

},{"jsts":165}],36:[function(require,module,exports){
var turfUnion = require('@turf/union');
var turfOverlaps = require('turf-overlaps');
var turfbbox = require('@turf/bbox');
var Rbush = require('rbush');
var gju = require('geojson-utils');
var getClosest = require('get-closest');

/**
 * Dissolves a FeatureCollection of polygons based on a property. Note that multipart features within the collection are not supported
 *
 * @name dissolve
 * @param {FeatureCollection<Polygon>} featureCollection input feature collection to be dissolved
 * @param {string} [propertyName] property name on which to dissolve features
 * @returns {FeatureCollection<Polygon>} a FeatureCollection containing the dissolved polygons
 * @example
 * var features = {
 * "type": "FeatureCollection",
 * "features": [
 *   {
 *     "type": "Feature",
 *     "properties": {
 *       "combine": "yes"
 *     },
 *     "geometry": {
 *       "type": "Polygon",
 *       "coordinates": [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]
 *     }
 *   },
 *   {
 *     "type": "Feature",
 *     "properties": {
 *       "combine": "yes"
 *     },
 *     "geometry": {
 *       "type": "Polygon",
 *       "coordinates": [[[0, -1], [0, 0], [1, 0], [1, -1], [0,-1]]]
 *     }
 *   },
 *   {
 *     "type": "Feature",
 *     "properties": {
 *       "combine": "no"
 *     },
 *     "geometry": {
 *       "type": "Polygon",
 *       "coordinates": [[[1,-1],[1, 0], [2, 0], [2, -1], [1, -1]]]
 *     }
 *   }
 *  ]
 * }
 *
 * var dissolved = turf.dissolve(features, 'combine');
 *
 * //=dissolved
 */
module.exports = function (featureCollection, propertyName) {

    var originalIndexOfItemsRemoved = [];
    var treeItems = [];
    var rtree = new Rbush();
    for (var polyIndex = 0; polyIndex < featureCollection.features.length; polyIndex++) {
        var inputFeatureBbox = turfbbox(featureCollection.features[polyIndex]);
        var treeObj = {
            minX: inputFeatureBbox[0],
            minY: inputFeatureBbox[1],
            maxX: inputFeatureBbox[2],
            maxY: inputFeatureBbox[3],
            origIndexPosition: polyIndex
        };
        treeItems.push(treeObj);
    }
    rtree.load(treeItems);

    for (var i = 0; i < featureCollection.features.length; i++) {
        var polygon = featureCollection.features[i];

        var polyBoundingBox = turfbbox(polygon);
        var searchObj = {
            minX: polyBoundingBox[0],
            minY: polyBoundingBox[1],
            maxX: polyBoundingBox[2],
            maxY: polyBoundingBox[3]
        };
        var potentialMatchingFeatures = rtree.search(searchObj);

        var featureChanged = false;

        for (var searchIndex = 0; searchIndex < potentialMatchingFeatures.length; searchIndex++) {
            polygon = featureCollection.features[i];

            var matchFeaturePosition = potentialMatchingFeatures[searchIndex].origIndexPosition;

            if (originalIndexOfItemsRemoved.length > 0 && matchFeaturePosition !== 0) {
                if (matchFeaturePosition > originalIndexOfItemsRemoved[originalIndexOfItemsRemoved.length - 1]) {
                    matchFeaturePosition = matchFeaturePosition - (originalIndexOfItemsRemoved.length);
                } else {
                    var closestNumber = getClosest.greaterNumber(matchFeaturePosition, originalIndexOfItemsRemoved);
                    if (closestNumber !== 0) {
                        matchFeaturePosition = matchFeaturePosition - closestNumber;
                    }
                }
            }

            if (matchFeaturePosition === i) {
                continue;
            }
            var matchFeature = featureCollection.features[matchFeaturePosition];

            if (typeof propertyName !== undefined) {
                if (matchFeature.properties[propertyName] !== polygon.properties[propertyName]) {
                    continue;
                }
            }

            var overlapCheck = turfOverlaps(polygon, matchFeature);

            if (!overlapCheck) {
                var polyClone = JSON.stringify(polygon);
                var polyBeingCheckedClone = JSON.stringify(matchFeature);
                var linestring1 = toLinestring(JSON.parse(polyClone));
                var linestring2 = toLinestring(JSON.parse(polyBeingCheckedClone));
                overlapCheck = gju.lineStringsIntersect(linestring1.geometry, linestring2.geometry);
            }
            if (!overlapCheck) {
                continue;
            }

            featureCollection.features[i] = turfUnion(polygon, matchFeature);
            originalIndexOfItemsRemoved.push(potentialMatchingFeatures[searchIndex].origIndexPosition);
            originalIndexOfItemsRemoved.sort(function (a, b) {
                return a - b;
            });

            rtree.remove(potentialMatchingFeatures[searchIndex]);
            featureCollection.features.splice(matchFeaturePosition, 1);
            searchObj.origIndexPosition = i;
            rtree.remove(searchObj, function (a, b) {
                return a.origIndexPosition === b.origIndexPosition;
            });
            featureChanged = true;
        }
        if (featureChanged) {
            var newBoundingBox = turfbbox(polygon);
            rtree.insert({
                minX: newBoundingBox[0],
                minY: newBoundingBox[1],
                maxX: newBoundingBox[2],
                maxY: newBoundingBox[3],
                origIndexPosition: i
            });
            i--;
        }
    }
    return featureCollection;
};

function toLinestring(polygon) {
    if (polygon === null || polygon === undefined) throw new Error('No polygon was passed');
    polygon.geometry.type = 'LineString';
    var flat_arr = [].concat.apply([], polygon.geometry.coordinates);
    polygon.geometry.coordinates = flat_arr;
    return polygon;
}

},{"@turf/bbox":13,"@turf/union":37,"geojson-utils":160,"get-closest":161,"rbush":174,"turf-overlaps":188}],37:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29,"jsts":165}],38:[function(require,module,exports){
var getCoord = require('@turf/invariant').getCoord;
var radiansToDistance = require('@turf/helpers').radiansToDistance;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Calculates the distance between two {@link Point|points} in degrees, radians,
 * miles, or kilometers. This uses the
 * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
 * to account for global curvature.
 *
 * @name distance
 * @param {Feature<Point>} from origin point
 * @param {Feature<Point>} to destination point
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var to = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 * var units = "miles";
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [from, to]
 * };
 *
 * //=points
 *
 * var distance = turf.distance(from, to, units);
 *
 * //=distance
 */
module.exports = function (from, to, units) {
    var degrees2radians = Math.PI / 180;
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);
    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];

    var a = Math.pow(Math.sin(dLat / 2), 2) +
          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
};

},{"@turf/helpers":39,"@turf/invariant":62}],39:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],40:[function(require,module,exports){
var bbox = require('@turf/bbox');
var bboxPolygon = require('@turf/bbox-polygon');

/**
 * Takes any number of features and returns a rectangular {@link Polygon} that encompasses all vertices.
 *
 * @name envelope
 * @param {(Feature|FeatureCollection)} features input features
 * @return {Feature<Polygon>} a rectangular Polygon feature that encompasses all vertices
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location A"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.343, 39.984]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location B"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.833, 39.284]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location C"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.534, 39.123]
 *       }
 *     }
 *   ]
 * };
 *
 * var enveloped = turf.envelope(fc);
 *
 * var resultFeatures = fc.features.concat(enveloped);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function (features) {
    return bboxPolygon(bbox(features));
};

},{"@turf/bbox":13,"@turf/bbox-polygon":41}],41:[function(require,module,exports){
var polygon = require('@turf/helpers').polygon;

/**
 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
 *
 * @name bboxPolygon
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @return {Feature<Polygon>} a Polygon representation of the bounding box
 * @addToMap poly
 * @example
 * var bbox = [0, 0, 10, 10];
 *
 * var poly = turf.bboxPolygon(bbox);
 *
 * //=poly
 */

module.exports = function (bbox) {
    var lowLeft = [bbox[0], bbox[1]];
    var topLeft = [bbox[0], bbox[3]];
    var topRight = [bbox[2], bbox[3]];
    var lowRight = [bbox[2], bbox[1]];

    return polygon([[
        lowLeft,
        lowRight,
        topRight,
        topLeft,
        lowLeft
    ]]);
};

},{"@turf/helpers":42}],42:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],43:[function(require,module,exports){
var featureCollection = require('@turf/helpers').featureCollection;
var featureEach = require('@turf/meta').featureEach;
var coordEach = require('@turf/meta').coordEach;
var point = require('@turf/helpers').point;

/**
 * Takes a feature or set of features and returns all positions as
 * {@link Point|points}.
 *
 * @name explode
 * @param {(Feature|FeatureCollection)} geojson input features
 * @returns {FeatureCollection<point>} points representing the exploded input features
 * @throws {Error} if it encounters an unknown geometry type
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [177.434692, -17.77517],
 *       [177.402076, -17.779093],
 *       [177.38079, -17.803937],
 *       [177.40242, -17.826164],
 *       [177.438468, -17.824857],
 *       [177.454948, -17.796746],
 *       [177.434692, -17.77517]
 *     ]]
 *   }
 * };
 *
 * var points = turf.explode(poly);
 *
 * //=poly
 *
 * //=points
 */
module.exports = function (geojson) {
    var points = [];
    if (geojson.type === 'FeatureCollection') {
        featureEach(geojson, function (feature) {
            coordEach(feature, function (coord) {
                points.push(point(coord, feature.properties));
            });
        });
    } else {
        coordEach(geojson, function (coord) {
            points.push(point(coord, geojson.properties));
        });
    }
    return featureCollection(points);
};

},{"@turf/helpers":44,"@turf/meta":45}],44:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],45:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],46:[function(require,module,exports){
var featureEach = require('@turf/meta').featureEach;
var geomEach = require('@turf/meta').geomEach;
var getCoords = require('@turf/invariant').getCoords;
var helpers = require('@turf/helpers');
var point = helpers.point;
var lineString = helpers.lineString;
var polygon = helpers.polygon;
var featureCollection = helpers.featureCollection;

/**
 * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).
 *
 * @name flatten
 * @param {Feature} geojson any valid {@link GeoJSON} with multi-geometry {@link Feature}s
 * @returns {FeatureCollection} a flattened {@link FeatureCollection}
 * @example
 * var geometry = {
 *   "type": "MultiPolygon",
 *   "coordinates": [
 *     [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
 *      [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
 *      [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
 *    ]
 *  };
 *
 * var flattened = turf.flatten(geometry);
 *
 * //=flattened
 */
function flatten(geojson) {
    var type = (geojson.geometry) ? geojson.geometry.type : geojson.type;
    switch (type) {
    case 'MultiPoint':
        return flattenMultiPoint(geojson);
    case 'MultiPolygon':
        return flattenMultiPolygon(geojson);
    case 'MultiLineString':
        return flattenMultiLineString(geojson);
    case 'FeatureCollection':
        return flattenFeatureCollection(geojson);
    case 'GeometryCollection':
        return flattenGeometryCollection(geojson);
    case 'Point':
    case 'LineString':
    case 'Polygon':
        return featureCollection([geojson]);
    }
}
module.exports = flatten;

/**
 * Flatten MultiPoint
 *
 * @private
 * @param {Feature<MultiPoint>} geojson GeoJSON Feature
 * @returns {FeatureCollection<Point>} Feature Collection
 */
function flattenMultiPoint(geojson) {
    var points = [];
    getCoords(geojson).forEach(function (coords) {
        points.push(point(coords, geojson.properties));
    });
    return featureCollection(points);
}

/**
 * Flatten MultiLineString
 *
 * @private
 * @param {Feature<MultiLineString>} geojson GeoJSON Feature
 * @returns {FeatureCollection<LineString>} Feature Collection
 */
function flattenMultiLineString(geojson) {
    var lines = [];
    getCoords(geojson).forEach(function (coords) {
        lines.push(lineString(coords, geojson.properties));
    });
    return featureCollection(lines);
}

/**
 * Flatten MultiPolygon
 *
 * @private
 * @param {Feature<MultiPolygon>} geojson GeoJSON Feature
 * @returns {FeatureCollection<Polygon>} Feature Collection
 */
function flattenMultiPolygon(geojson) {
    var polygons = [];
    getCoords(geojson).forEach(function (coords) {
        polygons.push(polygon(coords, geojson.properties));
    });
    return featureCollection(polygons);
}

/**
 * Flatten FeatureCollection
 *
 * @private
 * @param {FeatureCollection<any>} geojson GeoJSON Feature
 * @returns {FeatureCollection<any>} Feature Collection
 */
function flattenFeatureCollection(geojson) {
    var features = [];
    featureEach(geojson, function (multiFeature) {
        switch (multiFeature.geometry.type) {
        case 'MultiPoint':
        case 'MultiLineString':
        case 'MultiPolygon':
            featureEach(flatten(multiFeature), function (feature) {
                features.push(feature);
            });
            break;
        default:
            features.push(multiFeature);
        }
    });
    return featureCollection(features);
}

/**
 * Flatten GeometryCollection
 *
 * @private
 * @param {GeometryCollection<any>} geojson GeoJSON Geometry Collection
 * @param {*} [properties] translate properties to Feature
 * @returns {FeatureCollection<any>} Feature Collection
 */
function flattenGeometryCollection(geojson) {
    var features = [];
    geomEach(geojson, function (geometry) {
        switch (geometry.type) {
        case 'MultiPoint':
        case 'MultiLineString':
        case 'MultiPolygon':
            featureEach(flatten(geometry), function (feature) {
                features.push(feature);
            });
            break;
        default:
            var feature = {
                type: 'Feature',
                properties: {},
                geometry: geometry
            };
            features.push(feature);
        }
    });
    return featureCollection(features);
}

},{"@turf/helpers":47,"@turf/invariant":62,"@turf/meta":48}],47:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],48:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],49:[function(require,module,exports){
var coordEach = require('@turf/meta').coordEach;

/**
 * Takes input features and flips all of their coordinates
 * from `[x, y]` to `[y, x]`.
 *
 * @name flip
 * @param {(Feature|FeatureCollection)} input input features
 * @returns {(Feature|FeatureCollection)} a feature or set of features of the same type as `input` with flipped coordinates
 * @example
 * var serbia = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [20.566406, 43.421008]
 *   }
 * };
 *
 * //=serbia
 *
 * var saudiArabia = turf.flip(serbia);
 *
 * //=saudiArabia
 */
module.exports = function flip(input) {
    // ensure that we don't modify features in-place and changes to the
    // output do not change the previous feature, including changes to nested
    // properties.
    input = JSON.parse(JSON.stringify(input));

    coordEach(input, function (coord) {
        coord.reverse();
    });
    return input;
};

},{"@turf/meta":50}],50:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],51:[function(require,module,exports){
'use strict';

var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;

var Coord = function (lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
};

Coord.prototype.view = function () {
    return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);
};

Coord.prototype.antipode = function () {
    var anti_lat = -1 * this.lat;
    var anti_lon = (this.lon < 0) ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
};

var LineString = function () {
    this.coords = [];
    this.length = 0;
};

LineString.prototype.move_to = function (coord) {
    this.length++;
    this.coords.push(coord);
};

var Arc = function (properties) {
    this.properties = properties || {};
    this.geometries = [];
};

Arc.prototype.json = function () {
    if (this.geometries.length <= 0) {
        return {'geometry': {'type': 'LineString', 'coordinates': null},
                'type': 'Feature', 'properties': this.properties
               };
    } else if (this.geometries.length === 1) {
        return {'geometry': {'type': 'LineString', 'coordinates': this.geometries[0].coords},
                'type': 'Feature', 'properties': this.properties
               };
    } else {
        var multiline = [];
        for (var i = 0; i < this.geometries.length; i++) {
            multiline.push(this.geometries[i].coords);
        }
        return {'geometry': {'type': 'MultiLineString', 'coordinates': multiline},
                'type': 'Feature', 'properties': this.properties
               };
    }
};

// TODO - output proper multilinestring
Arc.prototype.wkt = function () {
    var wkt_string = '';
    var wkt = 'LINESTRING(';
    var collect = function (c) { wkt += c[0] + ' ' + c[1] + ','; };
    for (var i = 0; i < this.geometries.length; i++) {
        if (this.geometries[i].coords.length === 0) {
            return 'LINESTRING(empty)';
        } else {
            var coords = this.geometries[i].coords;
            coords.forEach(collect);
            wkt_string += wkt.substring(0, wkt.length - 1) + ')';
        }
    }
    return wkt_string;
};

/*
 * http://en.wikipedia.org/wiki/Great-circle_distance
 *
 */
var GreatCircle = function (start, end, properties) {
    if (!start || start.x === undefined || start.y === undefined) {
        throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties');
    }
    if (!end || end.x === undefined || end.y === undefined) {
        throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties');
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};

    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2.0), 2) +
                Math.cos(this.start.y) *
                   Math.cos(this.end.y) *
                     Math.pow(Math.sin(w / 2.0), 2);
    this.g = 2.0 * Math.asin(Math.sqrt(z));

    if (this.g === Math.PI) {
        throw new Error('it appears ' + start.view() + ' and ' + end.view() + ' are \'antipodal\', e.g diametrically opposite, thus there is no single route but rather infinite');
    } else if (isNaN(this.g)) {
        throw new Error('could not calculate great circle between ' + start + ' and ' + end);
    }
};

/*
 * http://williams.best.vwh.net/avform.htm#Intermediate
 */
GreatCircle.prototype.interpolate = function (f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B = Math.sin(f * this.g) / Math.sin(this.g);
    var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    var lon = R2D * Math.atan2(y, x);
    return [lon, lat];
};



/*
 * Generate points along the great circle
 */
GreatCircle.prototype.Arc = function (npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
        first_pass.push([this.start.lon, this.start.lat]);
        first_pass.push([this.end.lon, this.end.lat]);
    } else {
        var delta = 1.0 / (npoints - 1);
        for (var i = 0; i < npoints; ++i) {
            var step = delta * i;
            var pair = this.interpolate(step);
            first_pass.push(pair);
        }
    }
    /* partial port of dateline handling from:
      gdal/ogr/ogrgeometryfactory.cpp

      TODO - does not handle all wrapping scenarios yet
    */
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    // from http://www.gdal.org/ogr2ogr.html
    // -datelineoffset:
    // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;

    // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342
    for (var j = 1; j < first_pass.length; ++j) {
        var dfPrevX = first_pass[j - 1][0];
        var dfX = first_pass[j][0];
        var dfDiffLong = Math.abs(dfX - dfPrevX);
        if (dfDiffLong > dfDiffSpace &&
            ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) || (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))) {
            bHasBigDiff = true;
        } else if (dfDiffLong > dfMaxSmallDiffLong) {
            dfMaxSmallDiffLong = dfDiffLong;
        }
    }

    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
        var poNewLS = [];
        poMulti.push(poNewLS);
        for (var k = 0; k < first_pass.length; ++k) {
            var dfX0 = parseFloat(first_pass[k][0]);
            if (k > 0 &&  Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
                var dfX1 = parseFloat(first_pass[k - 1][0]);
                var dfY1 = parseFloat(first_pass[k - 1][1]);
                var dfX2 = parseFloat(first_pass[k][0]);
                var dfY2 = parseFloat(first_pass[k][1]);
                if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 &&
                    k + 1 < first_pass.length &&
                   first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
                    poNewLS.push([-180, first_pass[k][1]]);
                    k++;
                    poNewLS.push([first_pass[k][0], first_pass[k][1]]);
                    continue;
                } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 &&
                     k + 1 < first_pass.length &&
                     first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
                    poNewLS.push([180, first_pass[k][1]]);
                    k++;
                    poNewLS.push([first_pass[k][0], first_pass[k][1]]);
                    continue;
                }

                if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
                    // swap dfX1, dfX2
                    var tmpX = dfX1;
                    dfX1 = dfX2;
                    dfX2 = tmpX;
                    // swap dfY1, dfY2
                    var tmpY = dfY1;
                    dfY1 = dfY2;
                    dfY2 = tmpY;
                }
                if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
                    dfX2 += 360;
                }
                if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
                    var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
                    var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
                    poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180, dfY]);
                    poNewLS = [];
                    poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180, dfY]);
                    poMulti.push(poNewLS);
                } else {
                    poNewLS = [];
                    poMulti.push(poNewLS);
                }
                poNewLS.push([dfX0, first_pass[k][1]]);
            } else {
                poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            }
        }
    } else {
        // add normally
        var poNewLS0 = [];
        poMulti.push(poNewLS0);
        for (var l = 0; l < first_pass.length; ++l) {
            poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
        }
    }

    var arc = new Arc(this.properties);
    for (var m = 0; m < poMulti.length; ++m) {
        var line = new LineString();
        arc.geometries.push(line);
        var points = poMulti[m];
        for (var j0 = 0; j0 < points.length; ++j0) {
            line.move_to(points[j0]);
        }
    }
    return arc;
};

module.exports.Coord = Coord;
module.exports.Arc = Arc;
module.exports.GreatCircle = GreatCircle;

},{}],52:[function(require,module,exports){
var arc = require('./arc');
var getCoord = require('@turf/invariant').getCoord;

/**
 * Calculate great circles routes as {@link LineString}
 *
 * @name greatCircle
 * @param {Feature<Point>} start source point feature
 * @param {Feature<Point>} end destination point feature
 * @param {*} [properties={}] line feature properties
 * @param {number} [npoints=100] number of points
 * @param {number} [offset=10] offset controls the likelyhood that lines will
 * be split which cross the dateline. The higher the number the more likely.
 * @returns {Feature<LineString>} great circle line feature
 * @addToMap line
 * @example
 * var start = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-122, 48]
 *   }
 * }
 * var end = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77, 39]
 *   }
 * }
 * var line = turf.greatCircle(start, end, {'name': 'Seattle to DC'});
 * //=line
 */
module.exports = function (start, end, properties, npoints, offset) {
    start = getCoord(start);
    end = getCoord(end);
    properties = properties || {};
    npoints = npoints || 100;
    offset = offset || 10;

    var generator = new arc.GreatCircle({x: start[0], y: start[1]}, {x: end[0], y: end[1]}, properties);
    /* eslint-disable */
    var line = generator.Arc(npoints, {offset: offset});
    /* eslint-enable */

    return line.json();
};

},{"./arc":51,"@turf/invariant":62}],53:[function(require,module,exports){
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} properties properties
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var geometry = {
 *      "type": "Point",
 *      "coordinates": [
 *        67.5,
 *        32.84267363195431
 *      ]
 *    }
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties) {
    if (!geometry) throw new Error('No geometry passed');

    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}
module.exports.feature = feature;

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object=} properties an Object that is used as the {@link Feature}'s
 * properties
 * @returns {Feature<Point>} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
module.exports.point = function (coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');
    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    if (typeof coordinates[0] !== 'number' || typeof coordinates[1] !== 'number') throw new Error('Coordinates must numbers');

    return feature({
        type: 'Point',
        coordinates: coordinates
    }, properties);
};

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object=} properties a properties object
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
module.exports.polygon = function (coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *   [-21.964416, 64.148203],
 *   [-21.956176, 64.141316],
 *   [-21.93901, 64.135924],
 *   [-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *   [-21.929054, 64.127985],
 *   [-21.912918, 64.134726],
 *   [-21.916007, 64.141016],
 *   [-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
module.exports.lineString = function (coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var fc = turf.featureCollection(features);
 *
 * //=fc
 */
module.exports.featureCollection = function (features) {
    if (!features) throw new Error('No features passed');

    return {
        type: 'FeatureCollection',
        features: features
    };
};

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 *
 */
module.exports.multiLineString = function (coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 *
 */
module.exports.multiPoint = function (coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties);
};


/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
module.exports.multiPolygon = function (coordinates, properties) {
    if (!coordinates) throw new Error('No coordinates passed');

    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometryCollection([pt, line]);
 *
 * //=collection
 */
module.exports.geometryCollection = function (geometries, properties) {
    if (!geometries) throw new Error('No geometries passed');

    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties);
};

var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    kilometers: 6373,
    kilometres: 6373,
    feet: 20908792.65
};

/*
 * Convert a distance measurement from radians to a more friendly unit.
 *
 * @name radiansToDistance
 * @param {number} distance in radians across the sphere
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
module.exports.radiansToDistance = function (radians, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) throw new Error('Invalid unit');

    return radians * factor;
};

/*
 * Convert a distance measurement from a real-world unit into radians
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
module.exports.distanceToRadians = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) throw new Error('Invalid unit');

    return distance / factor;
};

/*
 * Convert a distance measurement from a real-world unit into degrees
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
module.exports.distanceToDegrees = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) throw new Error('Invalid unit');

    return (distance / factor) * 57.2958;
};

},{}],54:[function(require,module,exports){
var point = require('@turf/helpers').point;
var polygon = require('@turf/helpers').polygon;
var distance = require('@turf/distance');
var featurecollection = require('@turf/helpers').featureCollection;

//Precompute cosines and sines of angles used in hexagon creation
// for performance gain
var cosines = [];
var sines = [];
for (var i = 0; i < 6; i++) {
    var angle = 2 * Math.PI / 6 * i;
    cosines.push(Math.cos(angle));
    sines.push(Math.sin(angle));
}

/**
 * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped
 * hexagons ({@link Polygon} features) aligned in an "odd-q" vertical grid as
 * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).
 *
 * @name hexGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize dimension of cell in specified units
 * @param {string} [units=kilometers] used in calculating cellSize, can be degrees, radians, miles, or kilometers
 * @param {boolean} [triangles=false] whether to return as triangles instead of hexagons
 * @returns {FeatureCollection<Polygon>} a hexagonal grid
 * @example
 * var bbox = [-96,31,-84,40];
 * var cellSize = 50;
 * var units = 'miles';
 *
 * var hexgrid = turf.hexGrid(bbox, cellSize, units);
 *
 * //=hexgrid
 */
module.exports = function hexGrid(bbox, cellSize, units, triangles) {
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);
    var radius = cellWidth / 2;

    var hex_width = radius * 2;
    var hex_height = Math.sqrt(3) / 2 * cellHeight;

    var box_width = bbox[2] - bbox[0];
    var box_height = bbox[3] - bbox[1];

    var x_interval = 3 / 4 * hex_width;
    var y_interval = hex_height;

    var x_span = box_width / (hex_width - radius / 2);
    var x_count = Math.ceil(x_span);
    if (Math.round(x_span) === x_count) {
        x_count++;
    }

    var x_adjust = ((x_count * x_interval - radius / 2) - box_width) / 2 - radius / 2;

    var y_count = Math.ceil(box_height / hex_height);

    var y_adjust = (box_height - y_count * hex_height) / 2;

    var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
        y_adjust -= hex_height / 4;
    }

    var fc = featurecollection([]);
    for (var x = 0; x < x_count; x++) {
        for (var y = 0; y <= y_count; y++) {

            var isOdd = x % 2 === 1;
            if (y === 0 && isOdd) {
                continue;
            }

            if (y === 0 && hasOffsetY) {
                continue;
            }

            var center_x = x * x_interval + bbox[0] - x_adjust;
            var center_y = y * y_interval + bbox[1] + y_adjust;

            if (isOdd) {
                center_y -= hex_height / 2;
            }
            if (triangles) {
                fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));
            } else {
                fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));
            }
        }
    }

    return fc;
};

//Center should be [x, y]
function hexagon(center, rx, ry) {
    var vertices = [];
    for (var i = 0; i < 6; i++) {
        var x = center[0] + rx * cosines[i];
        var y = center[1] + ry * sines[i];
        vertices.push([x, y]);
    }
    //first and last vertex must be the same
    vertices.push(vertices[0]);
    return polygon([vertices]);
}

//Center should be [x, y]
function hexTriangles(center, rx, ry) {
    var triangles = [];
    for (var i = 0; i < 6; i++) {
        var vertices = [];
        vertices.push(center);
        vertices.push([
            center[0] + rx * cosines[i],
            center[1] + ry * sines[i]
        ]);
        vertices.push([
            center[0] + rx * cosines[(i + 1) % 6],
            center[1] + ry * sines[(i + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push(polygon([vertices]));
    }
    return triangles;
}

},{"@turf/distance":38,"@turf/helpers":55}],55:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],56:[function(require,module,exports){
var distance = require('@turf/distance');
var squareGrid = require('@turf/square-grid');
var centroid = require('@turf/centroid');
var bbox = require('@turf/bbox');

/**
 *
 * Takes a FeatureCollection of points with known value, a power parameter, a cell depth, a unit of measurement
 * and returns a FeatureCollection of polygons in a square-grid with an interpolated value property "IDW" for each grid cell.
 * It finds application when in need of creating a continuous surface (i.e. rainfall, temperature, chemical dispersion surface...)
 * from a set of spatially scattered points.
 *
 * @name idw
 * @param {FeatureCollection<Point>} controlPoints Sampled points with known value
 * @param {string} valueField GeoJSON field containing the known value to interpolate on
 * @param {number} b Exponent regulating the distance-decay weighting
 * @param {number} cellWidth The distance across each cell
 * @param {string} [units=kilometers] used in calculating cellSize, can be degrees, radians, miles, or kilometers
 * @returns {FeatureCollection<Polygon>} grid A grid of polygons with a property field "IDW"
 */
module.exports = function (controlPoints, valueField, b, cellWidth, units) {
    // check if field containing data exists..
    var filtered = controlPoints.features.filter(function (feature) {
        return feature.properties &&
            feature.properties.hasOwnProperty(valueField);
    });
    if (filtered.length !== 0) {
      // create a sample square grid
      // compared to a point grid helps visualizing the output (like a raster..)
        var samplingGrid = squareGrid(bbox(controlPoints), cellWidth, units);
        var N = samplingGrid.features.length;
        for (var i = 0; i < N; i++) {
            var zw = 0;
            var sw = 0;
            // calculate the distance from each control point to cell's centroid
            for (var j = 0; j < controlPoints.features.length; j++) {
                var d = distance(centroid(samplingGrid.features[i]), controlPoints.features[j], units);
                if (d === 0) {
                    zw = controlPoints.features[j].properties[valueField];
                }
                var w = 1.0 / Math.pow(d, b);
                sw += w;
                zw += w * controlPoints.features[j].properties[valueField];
            }
            // write IDW value for each grid cell
            samplingGrid.features[i].properties.z = zw / sw;
        }
        return samplingGrid;
    } else {
        console.log('Specified Data Field is Missing');
    }
};

},{"@turf/bbox":13,"@turf/centroid":57,"@turf/distance":38,"@turf/square-grid":112}],57:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"@turf/helpers":58,"@turf/meta":59,"dup":20}],58:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],59:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],60:[function(require,module,exports){
var invariant = require('@turf/invariant');

// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
 * be convex or concave. The function accounts for holes.
 *
 * @name inside
 * @param {Feature<Point>} point input point
 * @param {Feature<(Polygon|MultiPolygon)>} polygon input polygon or multipolygon
 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt = turf.point([-77, 44]);
 * var poly = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]]);
 *
 * var isInside = turf.inside(pt, poly);
 *
 * //=isInside
 */
module.exports = function (point, polygon) {
    var pt = invariant.getCoord(point);
    var polys = polygon.geometry.coordinates;
    // normalize to multipolygon
    if (polygon.geometry.type === 'Polygon') polys = [polys];

    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0])) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (inRing(pt, polys[i][k], true)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) insidePoly = true;
        }
    }
    return insidePoly;
};

// pt is [x,y] and ring is [[x,y], [x,y],..]
function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);

    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0], yi = ring[i][1];
        var xj = ring[j][0], yj = ring[j][1];
        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
        if (onBoundary) return !ignoreBoundary;
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
        if (intersect) isInside = !isInside;
    }
    return isInside;
}

},{"@turf/invariant":62}],61:[function(require,module,exports){
// depend on jsts for now http://bjornharrtell.github.io/jsts/
var jsts = require('jsts');

/**
 * Takes two {@link Polygon|polygons} and finds their intersection. If they share a border, returns the border; if they don't intersect, returns undefined.
 *
 * @name intersect
 * @param {Feature<Polygon>} poly1 the first polygon
 * @param {Feature<Polygon>} poly2 the second polygon
 * @returns {(Feature|undefined)} returns a feature representing the point(s) they share (in case of a {@link Point}  or {@link MultiPoint}), the borders they share (in case of a {@link LineString} or a {@link MultiLineString}), the area they share (in case of {@link Polygon} or {@link MultiPolygon}). If they do not share any point, returns `undefined`.
 * @example
 * var poly1 = turf.polygon([[
 *   [-122.801742, 45.48565],
 *   [-122.801742, 45.60491],
 *   [-122.584762, 45.60491],
 *   [-122.584762, 45.48565],
 *   [-122.801742, 45.48565]
 * ]]);
 *
 * var poly2 = turf.polygon([[
 *   [-122.520217, 45.535693],
 *   [-122.64038, 45.553967],
 *   [-122.720031, 45.526554],
 *   [-122.669906, 45.507309],
 *   [-122.723464, 45.446643],
 *   [-122.532577, 45.408574],
 *   [-122.487258, 45.477466],
 *   [-122.520217, 45.535693]
 * ]]);
 *
 * var intersection = turf.intersect(poly1, poly2);
 *
 * //=intersection
 */
module.exports = function (poly1, poly2) {
    var geom1, geom2;
    if (poly1.type === 'Feature') geom1 = poly1.geometry;
    else geom1 = poly1;
    if (poly2.type === 'Feature') geom2 = poly2.geometry;
    else geom2 = poly2;
    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(geom1));
    var b = reader.read(JSON.stringify(geom2));
    var intersection = a.intersection(b);

    if (intersection.isEmpty()) {
        return undefined;
    }

    var writer = new jsts.io.GeoJSONWriter();

    var geojsonGeometry = writer.write(intersection);
    return {
        type: 'Feature',
        properties: {},
        geometry: geojsonGeometry
    };
};

},{"jsts":165}],62:[function(require,module,exports){
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<any>|Geometry|Feature<Point>} obj any value
 * @returns {Array<number>} coordinates
 */
function getCoord(obj) {
    if (!obj) throw new Error('No obj passed');

    var coordinates = getCoords(obj);

    // getCoord() must contain at least two numbers (Point)
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return coordinates;
    } else {
        throw new Error('Coordinate is not a valid Point');
    }
}

/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature<any>} obj any value
 * @returns {Array<any>} coordinates
 */
function getCoords(obj) {
    if (!obj) throw new Error('No obj passed');
    var coordinates;

    // Array of numbers
    if (obj.length) {
        coordinates = obj;

    // Geometry Object
    } else if (obj.coordinates) {
        coordinates = obj.coordinates;

    // Feature
    } else if (obj.geometry && obj.geometry.coordinates) {
        coordinates = obj.geometry.coordinates;
    }
    // Checks if coordinates contains a number
    if (coordinates) {
        containsNumber(coordinates);
        return coordinates;
    }
    throw new Error('No valid coordinates');
}

/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return true;
    }

    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error('coordinates must only contain numbers');
}

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) throw new Error('No feature passed');
    if (!name) throw new Error('.featureOf() requires a name');
    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) throw new Error('No featureCollection passed');
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < featureCollection.features.length; i++) {
        var feature = featureCollection.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

module.exports = {
    geojsonType: geojsonType,
    collectionOf: collectionOf,
    featureOf: featureOf,
    getCoord: getCoord,
    getCoords: getCoords,
    containsNumber: containsNumber
};

},{}],63:[function(require,module,exports){
/* eslint-disable */

/*
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */


  module.exports = Conrec;

  var EPSILON = 1e-10;

  function pointsEqual(a, b) {
      var x = a.x - b.x, y = a.y - b.y;
      return x * x + y * y < EPSILON;
  }

  function reverseList(list) {
      var pp = list.head;

      while (pp) {
      // swap prev/next pointers
          var temp = pp.next;
          pp.next = pp.prev;
          pp.prev = temp;

      // continue through the list
          pp = temp;
      }

    // swap head/tail pointers
      var temp = list.head;
      list.head = list.tail;
      list.tail = temp;
  }

  function ContourBuilder(level) {
      this.level = level;
      this.s = null;
      this.count = 0;
  }
  ContourBuilder.prototype.remove_seq = function (list) {
    // if list is the first item, static ptr s is updated
      if (list.prev) {
          list.prev.next = list.next;
      } else {
          this.s = list.next;
      }

      if (list.next) {
          list.next.prev = list.prev;
      }
      --this.count;
  };
  ContourBuilder.prototype.addSegment = function (a, b) {
      var ss = this.s;
      var ma = null;
      var mb = null;
      var prependA = false;
      var prependB = false;

      while (ss) {
          if (ma == null) {
        // no match for a yet
              if (pointsEqual(a, ss.head.p)) {
                  ma = ss;
                  prependA = true;
              } else if (pointsEqual(a, ss.tail.p)) {
                  ma = ss;
              }
          }
          if (mb == null) {
        // no match for b yet
              if (pointsEqual(b, ss.head.p)) {
                  mb = ss;
                  prependB = true;
              } else if (pointsEqual(b, ss.tail.p)) {
                  mb = ss;
              }
          }
      // if we matched both no need to continue searching
          if (mb != null && ma != null) {
              break;
          } else {
              ss = ss.next;
          }
      }

    // c is the case selector based on which of ma and/or mb are set
      var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);

      switch (c) {
      case 0:   // both unmatched, add as new sequence
          var aa = {p: a, prev: null};
          var bb = {p: b, next: null};
          aa.next = bb;
          bb.prev = aa;

        // create sequence element and push onto head of main list. The order
        // of items in this list is unimportant
          ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};
          if (this.s) {
              this.s.prev = ma;
          }
          this.s = ma;

          ++this.count;    // not essential - tracks number of unmerged sequences
          break;

      case 1:   // a matched, b did not - thus b extends sequence ma
          var pp = {p: b};

          if (prependA) {
              pp.next = ma.head;
              pp.prev = null;
              ma.head.prev = pp;
              ma.head = pp;
          } else {
              pp.next = null;
              pp.prev = ma.tail;
              ma.tail.next = pp;
              ma.tail = pp;
          }
          break;

      case 2:   // b matched, a did not - thus a extends sequence mb
          var pp = {p: a};

          if (prependB) {
              pp.next = mb.head;
              pp.prev = null;
              mb.head.prev = pp;
              mb.head = pp;
          } else {
              pp.next = null;
              pp.prev = mb.tail;
              mb.tail.next = pp;
              mb.tail = pp;
          }
          break;

      case 3:   // both matched, can merge sequences
        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)

          if (ma === mb) {
              var pp = {p: ma.tail.p, next: ma.head, prev: null};
              ma.head.prev = pp;
              ma.head = pp;
              ma.closed = true;
              break;
          }

        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
        // one sequence needs to be reversed
          switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
          case 0:   // tail-tail
            // reverse ma and append to mb
              reverseList(ma);
            // fall through to head/tail case
          case 1:   // head-tail
            // ma is appended to mb and ma discarded
              mb.tail.next = ma.head;
              ma.head.prev = mb.tail;
              mb.tail = ma.tail;

            //discard ma sequence record
              this.remove_seq(ma);
              break;

          case 3:   // head-head
            // reverse ma and append mb to it
              reverseList(ma);
            // fall through to tail/head case
          case 2:   // tail-head
            // mb is appended to ma and mb is discarded
              ma.tail.next = mb.head;
              mb.head.prev = ma.tail;
              ma.tail = mb.tail;

            //discard mb sequence record
              this.remove_seq(mb);
              break;
          }
      }
  };

  /*
   * Implements CONREC.
   *
   * @private
   * @param {function} drawContour function for drawing contour.  Defaults to a
   *                               custom "contour builder", which populates the
   *                               contours property.
   */
  function Conrec(drawContour) {
      if (!drawContour) {
          var c = this;
          c.contours = {};
      /**
       * drawContour - interface for implementing the user supplied method to
       * render the countours.
       *
       * Draws a line between the start and end coordinates.
       *
       * @private
       * @param startX    - start coordinate for X
       * @param startY    - start coordinate for Y
       * @param endX      - end coordinate for X
       * @param endY      - end coordinate for Y
       * @param contourLevel - Contour level for line.
       */
          this.drawContour = function (startX, startY, endX, endY, contourLevel, k) {
              var cb = c.contours[k];
              if (!cb) {
                  cb = c.contours[k] = new ContourBuilder(contourLevel);
              }
              cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});
          };
          this.contourList = function () {
              var l = [];
              var a = c.contours;
              for (var k in a) {
                  var s = a[k].s;
                  var level = a[k].level;
                  while (s) {
                      var h = s.head;
                      var l2 = [];
                      l2.level = level;
                      l2.k = k;
                      while (h && h.p) {
                          l2.push(h.p);
                          h = h.next;
                      }
                      l.push(l2);
                      s = s.next;
                  }
              }
              l.sort(function (a, b) { return a.k - b.k; });
              return l;
          };
      } else {
          this.drawContour = drawContour;
      }
      this.h  = new Array(5);
      this.sh = new Array(5);
      this.xh = new Array(5);
      this.yh = new Array(5);
  }

  /*
   * contour is a contouring subroutine for rectangularily spaced data
   *
   * It emits calls to a line drawing subroutine supplied by the user which
   * draws a contour map corresponding to real*4data on a randomly spaced
   * rectangular grid. The coordinates emitted are in the same units given in
   * the x() and y() arrays.
   *
   * Any number of contour levels may be specified but they must be in order of
   * increasing value.
   *
   *
   * @param {number[][]} d - matrix of data to contour
   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix
   *
   *             The following two, one dimensional arrays (x and y) contain
   *             the horizontal and vertical coordinates of each sample points.
   * @param {number[]} x  - data matrix column coordinates
   * @param {number[]} y  - data matrix row coordinates
   * @param {number} nc   - number of contour levels
   * @param {number[]} z  - contour levels in increasing order.
   */
  Conrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z) {
      var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
      var drawContour = this.drawContour;
      this.contours = {};

      var xsect = function (p1, p2) {
          return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);
      };

      var ysect = function (p1, p2) {
          return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);
      };
      var m1;
      var m2;
      var m3;
      var case_value;
      var dmin;
      var dmax;
      var x1 = 0.0;
      var x2 = 0.0;
      var y1 = 0.0;
      var y2 = 0.0;

    // The indexing of im and jm should be noted as it has to start from zero
    // unlike the fortran counter part
      var im = [0, 1, 1, 0];
      var jm = [0, 0, 1, 1];

    // Note that castab is arranged differently from the FORTRAN code because
    // Fortran and C/C++ arrays are transposed of each other, in this case
    // it is more tricky as castab is in 3 dimensions
      var castab = [
          [
        [0, 0, 8], [0, 2, 5], [7, 6, 9]
          ],
          [
        [0, 3, 4], [1, 3, 1], [4, 3, 0]
          ],
          [
        [9, 6, 7], [5, 2, 0], [8, 0, 0]
          ]
      ];

      for (var j = (jub - 1); j >= jlb; j--) {
          for (var i = ilb; i <= iub - 1; i++) {
              var temp1, temp2;
              temp1 = Math.min(d[i][j], d[i][j + 1]);
              temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);
              dmin  = Math.min(temp1, temp2);
              temp1 = Math.max(d[i][j], d[i][j + 1]);
              temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);
              dmax  = Math.max(temp1, temp2);

              if (dmax >= z[0] && dmin <= z[nc - 1]) {
                  for (var k = 0; k < nc; k++) {
                      if (z[k] >= dmin && z[k] <= dmax) {
                          for (var m = 4; m >= 0; m--) {
                            if (m > 0) {
                  // The indexing of im and jm should be noted as it has to
                  // start from zero
                              h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];
                              xh[m] = x[i + im[m - 1]];
                              yh[m] = y[j + jm[m - 1]];
                          } else {
                              h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);
                              xh[0] = 0.5 * (x[i] + x[i + 1]);
                              yh[0] = 0.5 * (y[j] + y[j + 1]);
                          }
                            if (h[m] > EPSILON) {
                              sh[m] = 1;
                          } else if (h[m] < -EPSILON) {
                            sh[m] = -1;
                        } else
                  sh[m] = 0;
                        }
              //
              // Note: at this stage the relative heights of the corners and the
              // centre are in the h array, and the corresponding coordinates are
              // in the xh and yh arrays. The centre of the box is indexed by 0
              // and the 4 corners by 1 to 4 as shown below.
              // Each triangle is then indexed by the parameter m, and the 3
              // vertices of each triangle are indexed by parameters m1,m2,and
              // m3.
              // It is assumed that the centre of the box is always vertex 2
              // though this isimportant only when all 3 vertices lie exactly on
              // the same contour level, in which case only the side of the box
              // is drawn.
              //
              //
              //      vertex 4 +-------------------+ vertex 3
              //               | \               / |
              //               |   \    m-3    /   |
              //               |     \       /     |
              //               |       \   /       |
              //               |  m=2    X   m=2   |       the centre is vertex 0
              //               |       /   \       |
              //               |     /       \     |
              //               |   /    m=1    \   |
              //               | /               \ |
              //      vertex 1 +-------------------+ vertex 2
              //
              //
              //
              //               Scan each triangle in the box
              //
                          for (m = 1; m <= 4; m++) {
                            m1 = m;
                            m2 = 0;
                            if (m != 4) {
                              m3 = m + 1;
                          } else {
                              m3 = 1;
                          }
                            case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
                            if (case_value != 0) {
                              switch (case_value) {
                            case 1: // Line between vertices 1 and 2
                                x1 = xh[m1];
                                y1 = yh[m1];
                                x2 = xh[m2];
                                y2 = yh[m2];
                                break;
                            case 2: // Line between vertices 2 and 3
                                x1 = xh[m2];
                                y1 = yh[m2];
                                x2 = xh[m3];
                                y2 = yh[m3];
                                break;
                            case 3: // Line between vertices 3 and 1
                                x1 = xh[m3];
                                y1 = yh[m3];
                                x2 = xh[m1];
                                y2 = yh[m1];
                                break;
                            case 4: // Line between vertex 1 and side 2-3
                                x1 = xh[m1];
                                y1 = yh[m1];
                                x2 = xsect(m2, m3);
                                y2 = ysect(m2, m3);
                                break;
                            case 5: // Line between vertex 2 and side 3-1
                                x1 = xh[m2];
                                y1 = yh[m2];
                                x2 = xsect(m3, m1);
                                y2 = ysect(m3, m1);
                                break;
                            case 6: //  Line between vertex 3 and side 1-2
                                x1 = xh[m3];
                                y1 = yh[m3];
                                x2 = xsect(m1, m2);
                                y2 = ysect(m1, m2);
                                break;
                            case 7: // Line between sides 1-2 and 2-3
                                x1 = xsect(m1, m2);
                                y1 = ysect(m1, m2);
                                x2 = xsect(m2, m3);
                                y2 = ysect(m2, m3);
                                break;
                            case 8: // Line between sides 2-3 and 3-1
                                x1 = xsect(m2, m3);
                                y1 = ysect(m2, m3);
                                x2 = xsect(m3, m1);
                                y2 = ysect(m3, m1);
                                break;
                            case 9: // Line between sides 3-1 and 1-2
                                x1 = xsect(m3, m1);
                                y1 = ysect(m3, m1);
                                x2 = xsect(m1, m2);
                                y2 = ysect(m1, m2);
                                break;
                            default:
                                break;
                            }
                  // Put your processing code here and comment out the printf
                  //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                              drawContour(x1, y1, x2, y2, z[k], k);
                          }
                        }
                      }
                  }
              }
          }
      }
  };

},{}],64:[function(require,module,exports){
//https://github.com/jasondavies/conrec.js
//http://stackoverflow.com/questions/263305/drawing-a-topographical-map
var tin = require('@turf/tin');
var inside = require('@turf/inside');
var grid = require('@turf/point-grid');
var distance = require('@turf/distance');
var bbox = require('@turf/bbox');
var planepoint = require('@turf/planepoint');
var featurecollection = require('@turf/helpers').featureCollection;
var linestring = require('@turf/helpers').lineString;
var point = require('@turf/helpers').point;
var square = require('@turf/square');
var Conrec = require('./conrec');

/**
 * Takes {@link Point|points} with z-values and an array of
 * value breaks and generates [isolines](http://en.wikipedia.org/wiki/Isoline).
 *
 * @name isolines
 * @param {FeatureCollection<Point>} points input points
 * @param {string} z the property name in `points` from which z-values will be pulled
 * @param {number} resolution resolution of the underlying grid
 * @param {Array<number>} breaks where to draw contours
 * @returns {FeatureCollection<LineString>} isolines
 * @example
 * // create random points with random
 * // z-values in their properties
 * var points = turf.random('point', 100, {
 *   bbox: [0, 30, 20, 50]
 * });
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = Math.random() * 10;
 * }
 * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 * var isolined = turf.isolines(points, 'z', 15, breaks);
 * //=isolined
 */
module.exports = function (points, z, resolution, breaks) {
    var tinResult = tin(points, z);
    var bboxBBox = bbox(points);
    var squareBBox = square(bboxBBox);
    var sizeCellGrid = distance(point([squareBBox[0], squareBBox[1]]), point([squareBBox[2], squareBBox[1]]), 'kilometers') / resolution;
    var gridResult = grid(squareBBox, sizeCellGrid, 'kilometers');
    var data = [];

    for (var i = 0; i < gridResult.features.length; i++) {
        var pt = gridResult.features[i];
        for (var j = 0; j < tinResult.features.length; j++) {
            var triangle = tinResult.features[j];
            if (inside(pt, triangle)) {
                pt.properties = {};
                pt.properties[z] = planepoint(pt, triangle);
            }
        }
    }

    var depth = Math.sqrt(gridResult.features.length);
    for (var x = 0; x < depth; x++) {
        var xGroup = gridResult.features.slice(x * depth, (x + 1) * depth);
        var xFlat = [];

        for (var g = 0; g < xGroup.length; g++) {
            if (xGroup[g].properties) {
                xFlat.push(xGroup[g].properties[z]);
            } else {
                xFlat.push(0);
            }
        }
        data.push(xFlat);
    }
    var interval = (squareBBox[2] - squareBBox[0]) / depth;
    var xCoordinates = [];
    var yCoordinates = [];
    for (var d = 0; d < depth; d++) {
        xCoordinates.push(d * interval + squareBBox[0]);
        yCoordinates.push(d * interval + squareBBox[1]);
    }

    var c = new Conrec();
    c.contour(data, 0, resolution, 0, resolution, xCoordinates, yCoordinates, breaks.length, breaks);
    var contourList = c.contourList();

    var fc = featurecollection([]);
    contourList.forEach(function (c) {
        if (c.length > 2) {
            var polyCoordinates = [];
            c.forEach(function (coord) {
                polyCoordinates.push([coord.x, coord.y]);
            });
            var poly = linestring(polyCoordinates);
            poly.properties = {};
            poly.properties[z] = c.level;

            fc.features.push(poly);
        }
    });

    return fc;
};

},{"./conrec":63,"@turf/bbox":13,"@turf/distance":38,"@turf/helpers":65,"@turf/inside":60,"@turf/planepoint":99,"@turf/point-grid":100,"@turf/square":114,"@turf/tin":118}],65:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],66:[function(require,module,exports){
var point = require('@turf/helpers').point;

/**
 * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring}, {@link MultiPolygon|multi-polygon}, or {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.
 *
 * @name kinks
 * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature
 * @returns {FeatureCollection<Point>} self-intersections
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-12.034835, 8.901183],
 *       [-12.060413, 8.899826],
 *       [-12.03638, 8.873199],
 *       [-12.059383, 8.871418],
 *       [-12.034835, 8.901183]
 *     ]]
 *   }
 * };
 *
 * var kinks = turf.kinks(poly);
 *
 * var resultFeatures = kinks.features.concat(poly);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (featureIn) {
    var coordinates;
    var feature;
    var results = {
        type: 'FeatureCollection',
        features: []
    };
    if (featureIn.type === 'Feature') {
        feature = featureIn.geometry;
    } else {
        feature = featureIn;
    }
    if (feature.type === 'LineString') {
        coordinates = [feature.coordinates];
    } else if (feature.type === 'MultiLineString') {
        coordinates = feature.coordinates;
    } else if (feature.type === 'MultiPolygon') {
        coordinates = [].concat.apply([], feature.coordinates);
    } else if (feature.type === 'Polygon') {
        coordinates = feature.coordinates;
    } else {
        throw new Error('Input must be a LineString, MultiLineString, ' +
            'Polygon, or MultiPolygon Feature or Geometry');
    }
    coordinates.forEach(function (segment1) {
        coordinates.forEach(function (segment2) {
            for (var i = 0; i < segment1.length - 1; i++) {
                for (var k = 0; k < segment2.length - 1; k++) {
                    // don't check adjacent sides of a given segment, since of course they intersect in a vertex.
                    if (segment1 === segment2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === segment1.length - 2)) {
                        continue;
                    }

                    var intersection = lineIntersects(segment1[i][0], segment1[i][1], segment1[i + 1][0], segment1[i + 1][1],
                        segment2[k][0], segment2[k][1], segment2[k + 1][0], segment2[k + 1][1]);
                    if (intersection) {
                        results.features.push(point([intersection[0], intersection[1]]));
                    }
                }
            }
        });
    });
    return results;
};


// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2,
        result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a >= 0 && a <= 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b >= 0 && b <= 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    } else {
        return false;
    }
}

},{"@turf/helpers":67}],67:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],68:[function(require,module,exports){
var destination = require('@turf/destination');
var circle = require('@turf/circle');
var lineString = require('@turf/helpers').lineString;

/**
 * Creates a circular arc, of a circle of the given radius and center point, between bearing1 and bearing2;
 * 0 bearing is North of center point, positive clockwise.
 *
 * @name line-arc
 * @param {Feature<Point>} center center point
 * @param {number} radius radius of the circle
 * @param {number} bearing1 angle, in decimal degrees, of the first radius of the arc
 * @param {number} bearing2 angle, in decimal degrees, of the second radius of the arc
 * @param {number} [steps=64] number of steps
 * @param {string} [units=kilometers] miles, kilometers, degrees, or radians
 * @returns {Feature<LineString>} line arc
 * @example
 * var center = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75, 40]
 *   }
 * }
 * var radius = 5;
 * var bearing1 = 25;
 * var bearing2 = 47;
 *
 * var arc = turf.lineArc(center, radius, bearing1, bearing2);
 *
 * //addToMap
 * var addToMap = [center, arc]
 */
module.exports = function (center, radius, bearing1, bearing2, steps, units) {
    // validation
    if (!center) throw new Error('center is required');
    if (bearing1 === undefined || bearing1 === null) throw new Error('bearing1 is required');
    if (bearing2 === undefined || bearing2 === null) throw new Error('bearing2 is required');
    if (!radius) throw new Error('radius is required');

    // default params
    steps = steps || 64;

    var angle1 = convertAngleTo360(bearing1);
    var angle2 = convertAngleTo360(bearing2);
    var properties = center.properties;

    // handle angle parameters
    if (angle1 === angle2) {
        return lineString(circle(center, radius, steps, units).geometry.coordinates[0], properties);
    }
    var arcStartDegree = angle1;
    var arcEndDegree = (angle1 < angle2) ? angle2 : angle2 + 360;

    var alfa = arcStartDegree;
    var coordinates = [];
    var i = 0;

    while (alfa < arcEndDegree) {
        coordinates.push(destination(center, radius, alfa, units).geometry.coordinates);
        i++;
        alfa = arcStartDegree + i * 360 / steps;
    }
    if (alfa > arcEndDegree) {
        coordinates.push(destination(center, radius, arcEndDegree, units).geometry.coordinates);
    }
    return lineString(coordinates, properties);
};


/**
 * Takes any angle in  degrees
 * and returns a valid angle between 0-360 degrees
 *
 * @private
 * @param {number} alfa angle between -180-180 degrees
 * @returns {number} angle between 0-360 degrees
 */
function convertAngleTo360(alfa) {
    var beta = alfa % 360;
    if (beta < 0) {
        beta += 360;
    }
    return beta;
}

},{"@turf/circle":25,"@turf/destination":33,"@turf/helpers":69}],69:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],70:[function(require,module,exports){
var lineSliceAlong = require('@turf/line-slice-along');
var lineDistance = require('@turf/line-distance');
var featureCollection = require('@turf/helpers').featureCollection;
var featureEach = require('@turf/meta').featureEach;
var flatten = require('@turf/flatten');

/**
 * Divides a {@link LineString} into chunks of a specified length.
 * If the line is shorter than the segment length then the original line is returned.
 *
 * @name lineChunk
 * @param {FeatureCollection|Feature<LineString|MultiLineString>} featureIn the lines to split
 * @param {number} segmentLength how long to make each segment
 * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers
 * @param {boolean}[reverse=false] reverses coordinates to start the first chunked segment at the end
 * @returns {FeatureCollection<LineString>} collection of line segments
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-95, 40],
 *       [-93, 45],
 *       [-85, 50]
 *     ]
 *   }
 * };
 * var result = turf.lineChunk(line, 15, 'miles');
 * //=result
 */
module.exports = function (featureIn, segmentLength, units, reverse) {
    var outFeatures = [];
    var debug = arguments['4']; // Hidden @param {boolean} Enable debug mode

    // Handles FeatureCollection
    featureEach(featureIn, function (multiFeature) {

        // Handles MultiLineString
        if (multiFeature.geometry.type === 'MultiLineString') {
            multiFeature = flatten(multiFeature);
        }

        // All features are simple LineString
        featureEach(multiFeature, function (feature) {
            if (reverse) {
                feature.geometry.coordinates = feature.geometry.coordinates.reverse();
            }
            var lineSegments = sliceLineSegments(feature, segmentLength, units);
            lineSegments.forEach(function (segment, index) {
                if (debug === true) {
                    var r = (index % 2 === 0) ? 'F' : '0';
                    var g = (index % 2 === 0) ? '0' : '0';
                    var b = (index % 2 === 0) ? '0' : 'F';
                    segment.properties['stroke'] = '#' + r + g + b;
                    segment.properties['stroke-width'] = 6;
                }
                outFeatures.push(segment);
            });
        });
    });
    return featureCollection(outFeatures);
};

/**
 * Slice Line Segments
 *
 * @private
 * @param {Feature<LineString>} line GeoJSON LineString
 * @param {number} segmentLength how long to make each segment
 * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers
 * @returns {Array<Feature<LineString>>} sliced lines
 */
function sliceLineSegments(line, segmentLength, units) {
    var lineSegments = [];
    var lineLength = lineDistance(line, units);

    // If the line is shorter than the segment length then the orginal line is returned.
    if (lineLength <= segmentLength) {
        return [line];
    }

    var numberOfSegments = Math.floor(lineLength / segmentLength) + 1;

    for (var i = 0; i < numberOfSegments; i++) {
        var outline = lineSliceAlong(line, segmentLength * i, segmentLength * (i + 1), units);
        lineSegments.push(outline);
    }
    return lineSegments;
}

},{"@turf/flatten":46,"@turf/helpers":71,"@turf/line-distance":73,"@turf/line-slice-along":85,"@turf/meta":72}],71:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],72:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],73:[function(require,module,exports){
var distance = require('@turf/distance');
var featureEach = require('@turf/meta').featureEach;
var coordReduce = require('@turf/meta').coordReduce;
var geomEach = require('@turf/meta').geomEach;
var flatten = require('@turf/flatten');
var lineString = require('@turf/helpers').lineString;
var point = require('@turf/helpers').point;

/**
 * Takes a {@link LineString} or {@link Polygon} and measures its length in the specified units.
 *
 * @name lineDistance
 * @param {Feature<(LineString|Polygon)>|FeatureCollection<(LineString|Polygon)>} geojson feature to measure
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {number} length feature
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var length = turf.lineDistance(line, 'miles');
 *
 * //=line
 *
 * //=length
 */
module.exports = function lineDistance(geojson, units) {
    // Input Validation
    if (!geojson) throw new Error('geojson is required');
    geomEach(geojson, function (geometry) {
        if (geometry.type === 'Point') throw new Error('geojson cannot be a Point');
        if (geometry.type === 'MultiPoint') throw new Error('geojson cannot be a MultiPoint');
    });

    // Calculate distance from 2-vertex line segements
    return segmentReduce(geojson, function (previousValue, segment) {
        var coords = segment.geometry.coordinates;
        var start = point(coords[0]);
        var end = point(coords[1]);
        return previousValue + distance(start, end, units);
    }, 0);
};

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 *
 * @private
 * @param {FeatureCollection|Feature<any>} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, currentIndex)
 * @returns {void}
 * @example
 * var polygon = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]
 *   }
 * }
 * turf.segmentEach(polygon, function (segment) {
 *   //= segment
 * });
 */
function segmentEach(geojson, callback) {
    var count = 0;
    featureEach(geojson, function (multiFeature) {
        featureEach(flatten(multiFeature), function (feature) {
            coordReduce(feature, function (previousCoords, currentCoords) {
                var line = lineString([previousCoords, currentCoords], feature.properties);
                callback(line, count);
                count++;
                return currentCoords;
            });
        });
    });
}

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 *
 * @private
 * @param {FeatureCollection|Feature<any>} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    segmentEach(geojson, function (currentSegment, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentSegment;
        } else {
            previousValue = callback(previousValue, currentSegment, currentIndex);
        }
    });
    return previousValue;
}

},{"@turf/distance":38,"@turf/flatten":46,"@turf/helpers":74,"@turf/meta":75}],74:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],75:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],76:[function(require,module,exports){
var helpers = require('@turf/helpers');
var meta = require('@turf/meta');
var lineSegment = require('@turf/line-segment');
var getCoords = require('@turf/invariant').getCoords;
var rbush = require('geojson-rbush');
var point = helpers.point;
var featureCollection = helpers.featureCollection;
var featureEach = meta.featureEach;

/**
 * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
 *
 * @name lineIntersect
 * @param {FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @returns {FeatureCollection<Point>} point(s) that intersect both
 * @example
 * var line1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [[126, -11], [129, -21]]
 *   }
 * };
 * var line2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [[123, -18], [131, -14]]
 *   }
 * };
 * var points = turf.lineIntersect(line1, line2);
 * //= points
 */
module.exports = function (line1, line2) {
    var results = [];
    // Handles simple 2-vertex segments
    if (line1.geometry.type === 'LineString' &&
        line2.geometry.type === 'LineString' &&
        line1.geometry.coordinates.length === 2 &&
        line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) results.push(intersect);
        return featureCollection(results);
    }
    // Handles complex GeoJSON Geometries
    var tree = rbush();
    tree.load(lineSegment(line2));
    featureEach(lineSegment(line1), function (segment) {
        featureEach(tree.search(segment), function (match) {
            var intersect = intersects(segment, match);
            if (intersect) results.push(intersect);
        });
    });
    return featureCollection(results);
};

/**
 * Find a point that intersects LineStrings with two coordinates each
 *
 * @private
 * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
 * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
 * @returns {Feature<Point>} intersecting GeoJSON Point
 */
function intersects(line1, line2) {
    var coords1 = getCoords(line1);
    var coords2 = getCoords(line2);
    if (coords1.length !== 2) {
        throw new Error('<intersects> line1 must only contain 2 coordinates');
    }
    if (coords2.length !== 2) {
        throw new Error('<intersects> line2 must only contain 2 coordinates');
    }
    var x1 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));
    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));

    if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
            return null;
        }
        return null;
    }

    var uA = numeA / denom;
    var uB = numeB / denom;

    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + (uA * (x2 - x1));
        var y = y1 + (uA * (y2 - y1));
        return point([x, y]);
    }
    return null;
}

},{"@turf/helpers":77,"@turf/invariant":62,"@turf/line-segment":82,"@turf/meta":78,"geojson-rbush":158}],77:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],78:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],79:[function(require,module,exports){
var lineSegment = require('@turf/line-segment');
var getCoords = require('@turf/invariant').getCoords;
var rbush = require('geojson-rbush');
var equal = require('deep-equal');
var featureCollection = require('@turf/helpers').featureCollection;
var featureEach = require('@turf/meta').featureEach;

/**
 * Takes any LineString or Polygon and returns the overlapping lines between both features.
 *
 * @name lineOverlap
 * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features
 * @example
 * var line1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [[115, -35], [125, -30], [135, -30], [145, -35]
 *     ]
 *   }
 * }
 * var line2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [[115, -25], [125, -30], [135, -30], [145, -25]
 *     ]
 *   }
 * }
 * var overlapping = turf.lineOverlap(line1, line2);
 * //= overlapping
 */
module.exports = function (line1, line2) {
    var results = [];

    // Create Spatial Index
    var tree = rbush();
    tree.load(lineSegment(line1));
    var overlaps;

    // Iterate over line segments
    featureEach(lineSegment(line2), function (segment) {
        var doesOverlaps = false;
        featureEach(tree.search(segment), function (match) {
            if (doesOverlaps === false) {
                var coords1 = getCoords(segment).sort();
                var coords2 = getCoords(match).sort();

                // Segment overlaps feature
                if (equal(coords1, coords2)) {
                    doesOverlaps = true;
                    // Overlaps already exists - only append last coordinate of segment
                    if (overlaps) overlaps = concatSegment(overlaps, segment);
                    else overlaps = segment;
                }
            }
        });
        // Segment doesn't overlap - add overlaps to results & reset
        if (doesOverlaps === false && overlaps) {
            results.push(overlaps);
            overlaps = undefined;
        }
    });
    // Add last segment if exists
    if (overlaps) results.push(overlaps);

    return featureCollection(results);
};


/**
 * Concat Segment
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<LineString>} segment 2-vertex LineString
 * @returns {Feature<LineString>} concat linestring
 */
function concatSegment(line, segment) {
    var coords = getCoords(segment);
    var lineCoords = getCoords(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];

    if (equal(coords[0], start)) {
        line.geometry.coordinates.unshift(coords[1]);
    } else if (equal(coords[0], end)) {
        line.geometry.coordinates.push(coords[1]);
    } else if (equal(coords[1], start)) {
        line.geometry.coordinates.unshift(coords[0]);
    } else if (equal(coords[1], end)) {
        line.geometry.coordinates.push(coords[0]);
    }
    return line;
}

},{"@turf/helpers":80,"@turf/invariant":62,"@turf/line-segment":82,"@turf/meta":81,"deep-equal":146,"geojson-rbush":158}],80:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],81:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],82:[function(require,module,exports){
var flatten = require('@turf/flatten');
var featureEach = require('@turf/meta').featureEach;
var lineString = require('@turf/helpers').lineString;
var featureCollection = require('@turf/helpers').featureCollection;
var getCoords = require('@turf/invariant').getCoords;

/**
 * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString}, {@link MultiLineString}, {@link MultiPolygon} or {@link Polygon}.
 *
 * @name lineSegment
 * @param {FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString
 * @returns {FeatureCollection<LineString>} 2-vertex line segments
 * @example
 * var polygon = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]
 *   }
 * }
 * var segments = turf.lineSegment(polygon);
 * //=segments
 */
module.exports = function (geojson) {
    var results = [];
    var index = 0;
    featureEach(geojson, function (multiFeature) {
        featureEach(flatten(multiFeature), function (feature) {
            var coords = [];
            var type = (feature.geometry) ? feature.geometry.type : feature.type;
            switch (type) {
            case 'Polygon':
                coords = getCoords(feature);
                break;
            case 'LineString':
                coords = [getCoords(feature)];
            }
            coords.forEach(function (coord) {
                var segments = createSegments(coord, feature.properties);
                segments.forEach(function (segment) {
                    segment.id = index;
                    results.push(segment);
                    index++;
                });
            });
        });
    });
    return featureCollection(results);
};

/**
 * Create Segments from LineString coordinates
 *
 * @private
 * @param {LineString} coords LineString coordinates
 * @param {*} properties GeoJSON properties
 * @returns {Array<Feature<LineString>>} line segments
 */
function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function (previousCoords, currentCoords) {
        var segment = lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}

/**
 * Create BBox between two coordinates (faster than @turf/bbox)
 *
 * @private
 * @param {[number, number]} coords1 Point coordinate
 * @param {[number, number]} coords2 Point coordinate
 * @returns {BBox} [west, south, east, north]
 */
function bbox(coords1, coords2) {
    var x1 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = (x1 < x2) ? x1 : x2;
    var south = (y1 < y2) ? y1 : y2;
    var east = (x1 > x2) ? x1 : x2;
    var north = (y1 > y2) ? y1 : y2;
    return [west, south, east, north];
}

},{"@turf/flatten":46,"@turf/helpers":83,"@turf/invariant":62,"@turf/meta":84}],83:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],84:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],85:[function(require,module,exports){
var bearing = require('@turf/bearing');
var distance = require('@turf/distance');
var destination = require('@turf/destination');
var lineString = require('@turf/helpers').lineString;

/**
 * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},
 * and a specified  distance along the line to a stop point
 * and returns a subsection of the line in-between those points.
 *
 * This can be useful for extracting only the part of a route between two distances.
 *
 * @name lineSliceAlong
 * @param {Feature<LineString>|LineString} line input line
 * @param {number} startDist distance along the line to starting point
 * @param {number} stopDist distance along the line to ending point
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {Feature<LineString>} sliced line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [ 7.66845703125, 45.058001435398296 ],
 *       [ 9.20654296875, 45.460130637921004 ],
 *       [ 11.348876953125, 44.48866833139467 ],
 *       [ 12.1728515625, 45.43700828867389 ],
 *       [ 12.535400390625, 43.98491011404692 ],
 *       [ 12.425537109375, 41.86956082699455 ],
 *       [ 14.2437744140625, 40.83874913796459 ],
 *       [ 14.765625, 40.681679458715635 ]
 *     ]
 *   }
 * };
 * var start = 12.5;
 *
 * var stop = 25;
 *
 * var units = 'miles';
 *
 * var sliced = turf.lineSliceAlong(line, start, stop, units);
 *
 * //=line
 *
 * //=sliced
 */
module.exports = function (line, startDist, stopDist, units) {
    var coords;
    var slice = [];
    if (line.type === 'Feature') coords = line.geometry.coordinates;
    else if (line.type === 'LineString') coords = line.coordinates;
    else throw new Error('input must be a LineString Feature or Geometry');

    var travelled = 0;
    var overshot, direction, interpolated;
    for (var i = 0; i < coords.length; i++) {
        if (startDist >= travelled && i === coords.length - 1) break;
        else if (travelled > startDist && slice.length === 0) {
            overshot = startDist - travelled;
            if (!overshot) {
                slice.push(coords[i]);
                return lineString(slice);
            }
            direction = bearing(coords[i], coords[i - 1]) - 180;
            interpolated = destination(coords[i], overshot, direction, units);
            slice.push(interpolated.geometry.coordinates);
        }

        if (travelled >= stopDist) {
            overshot = stopDist - travelled;
            if (!overshot) {
                slice.push(coords[i]);
                return lineString(slice);
            }
            direction = bearing(coords[i], coords[i - 1]) - 180;
            interpolated = destination(coords[i], overshot, direction, units);
            slice.push(interpolated.geometry.coordinates);
            return lineString(slice);
        }

        if (travelled >= startDist) {
            slice.push(coords[i]);
        }

        if (i === coords.length - 1) {
            return lineString(slice);
        }

        travelled += distance(coords[i], coords[i + 1], units);
    }
    return lineString(coords[coords.length - 1]);
};

},{"@turf/bearing":15,"@turf/destination":33,"@turf/distance":38,"@turf/helpers":86}],86:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],87:[function(require,module,exports){
var linestring = require('@turf/helpers').lineString;
var pointOnLine = require('@turf/point-on-line');

/**
 * Takes a {@link LineString|line}, a start {@link Point}, and a stop point
 * and returns a subsection of the line in-between those points.
 * The start & stop points don't need to fall exactly on the line.
 *
 * This can be useful for extracting only the part of a route between waypoints.
 *
 * @name lineSlice
 * @param {Feature<Point>} startPt starting point
 * @param {Feature<Point>} stopPt stopping point
 * @param {Feature<LineString>|LineString} line line to slice
 * @return {Feature<LineString>} sliced line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var start = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.029609, 38.881946]
 *   }
 * };
 * var stop = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.021884, 38.889563]
 *   }
 * };
 *
 * var sliced = turf.lineSlice(start, stop, line);
 *
 * //=line
 *
 * //=sliced
 */

module.exports = function lineSlice(startPt, stopPt, line) {
    var coords;
    if (line.type === 'Feature') {
        coords = line.geometry.coordinates;
    } else if (line.type === 'LineString') {
        coords = line.coordinates;
    } else {
        throw new Error('input must be a LineString Feature or Geometry');
    }

    var startVertex = pointOnLine(line, startPt);
    var stopVertex = pointOnLine(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [startVertex, stopVertex];
    } else {
        ends = [stopVertex, startVertex];
    }
    var clipLine = linestring([ends[0].geometry.coordinates], {});
    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
        clipLine.geometry.coordinates.push(coords[i]);
    }
    clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);
    return clipLine;
};

},{"@turf/helpers":88,"@turf/point-on-line":102}],88:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],89:[function(require,module,exports){
var flatten = require('@turf/flatten');
var pointOnLine = require('@turf/point-on-line');
var lineSegment = require('@turf/line-segment');
var getCoords = require('@turf/invariant').getCoords;
var lineIntersect = require('@turf/line-intersect');
var rbush = require('geojson-rbush');
var helpers = require('@turf/helpers');
var featureCollection = helpers.featureCollection;
var lineString = helpers.lineString;
var meta = require('@turf/meta');
var featureEach = meta.featureEach;
var featureReduce = meta.featureReduce;

/**
 * Split a LineString by another GeoJSON Feature.
 *
 * @name lineSplit
 * @param {Feature<LineString>} line LineString Feature to split
 * @param {Feature<Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon>} splitter Feature used to split line
 * @returns {FeatureCollection<LineString>} Split LineStrings
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [[120, -25], [145, -25]]
 *   }
 * };
 * var splitter = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [[130, -15], [130, -35]]
 *   }
 * };
 * var split = turf.lineSplit(line, splitter);
 * //=split
 */
module.exports = function (line, splitter) {
    if (geomType(line) !== 'LineString') throw new Error('<line> must be LineString');
    if (geomType(splitter) === 'FeatureCollection') throw new Error('<splitter> cannot be a FeatureCollection');

    switch (geomType(splitter)) {
    case 'Point':
        return splitLineWithPoint(line, splitter);
    case 'MultiPoint':
        return splitLineWithPoints(line, flatten(splitter));
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
        return splitLineWithPoints(line, lineIntersect(line, splitter));
    default:
        throw new Error('<splitter> geometry type is not supported');
    }
};

/**
 * Retrieves Geometry Type from GeoJSON
 *
 * @private
 * @param {Feature<any>} geojson Feature
 * @returns {string} Geometry Type
 */
function geomType(geojson) {
    return (geojson.geometry) ? geojson.geometry.type : geojson.type;
}

/**
 * Split LineString with MultiPoint
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {FeatureCollection<Point>} splitter Point
 * @returns {FeatureCollection<LineString>} split LineStrings
 */
function splitLineWithPoints(line, splitter) {
    var results = [];
    var tree = rbush();

    featureEach(splitter, function (point) {
        // Add index/id to features (needed for filter)
        results.forEach(function (feature, index) {
            feature.id = index;
        });
        // First Point - doesn't need to handle any previous line results
        if (!results.length) {
            results = splitLineWithPoint(line, point).features;
            tree.load(featureCollection(results));
        // Split with remaining points - lines might needed to be split multiple times
        } else {
            // Find all lines that are within the splitter's bbox
            var search = tree.search(point);

            // RBush might return multiple lines - only process the closest line to splitter
            var closestLine = findClosestFeature(point, search);

            // Remove closest line from results since this will be split into two lines
            // This removes any duplicates inside the results & index
            results = results.filter(function (feature) { return feature.id !== closestLine.id; });
            tree.remove(closestLine);

            // Append the two newly split lines into the results
            featureEach(splitLineWithPoint(closestLine, point), function (line) {
                results.push(line);
                tree.insert(line);
            });
        }
    });
    return featureCollection(results);
}

/**
 * Split LineString with MultiPoint
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<Point>} splitter Point
 * @returns {FeatureCollection<LineString>} split LineStrings
 */
function splitLineWithPoint(line, splitter) {
    var results = [];

    // Create spatial index
    var tree = rbush();
    var segments = lineSegment(line);
    tree.load(segments);

    // Find all segments that are within bbox of splitter
    var search = tree.search(splitter);

    // Return itself if point is not within spatial index
    if (!search.features.length) return featureCollection([line]);

    // RBush might return multiple lines - only process the closest line to splitter
    var closestSegment = findClosestFeature(splitter, search);

    // Initial value is the first point of the first segments (begining of line)
    var initialValue = [getCoords(segments.features[0])[0]];
    var lastCoords = featureReduce(segments, function (previous, current, index) {

        // Location where segment intersects with line
        if (index === closestSegment.id) {
            var coords = getCoords(splitter);
            previous.push(coords);
            results.push(lineString(previous));
            return [coords, getCoords(current)[1]];

        // Keep iterating over coords until finished or intersection is found
        } else {
            previous.push(getCoords(current)[1]);
            return previous;
        }
    }, initialValue);
    // Append last line to final split results
    results.push(lineString(lastCoords));
    return featureCollection(results);
}

/**
 * Find Closest Feature
 *
 * @private
 * @param {Feature<Point>} point Feature must be closest to this point
 * @param {FeatureCollection<LineString>} lines Collection of Features
 * @returns {Feature<LineString>} closest LineString
 */
function findClosestFeature(point, lines) {
    // Filter to one segment that is the closest to the line
    var closestDistance;
    var closestFeature;
    if (!lines.features) throw new Error('<lines> must contain features');
    if (lines.features.length === 1) return lines.features[0];

    featureEach(lines, function (segment) {
        var pt = pointOnLine(segment, point);
        var dist = pt.properties.dist;
        if (closestDistance === undefined) {
            closestFeature = segment;
            closestDistance = dist;
        } else if (dist < closestDistance) {
            closestFeature = segment;
            closestDistance = dist;
        }
    });
    return closestFeature;
}

},{"@turf/flatten":46,"@turf/helpers":90,"@turf/invariant":62,"@turf/line-intersect":76,"@turf/line-segment":82,"@turf/meta":91,"@turf/point-on-line":102,"geojson-rbush":158}],90:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],91:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],92:[function(require,module,exports){
var featureEach = require('@turf/meta').featureEach;
var rbush = require('rbush');
var turfBBox = require('@turf/bbox');
var helpers = require('@turf/helpers');
var union = require('@turf/union');

/**
 * Takes any type of {@link Polygon|polygon} and an optional mask and returns a {@link Polygon|polygon} exterior ring with holes.
 *
 * @name mask
 * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} polygon GeoJSON Polygon used as interior rings or holes.
 * @param {Feature<Polygon>} [mask] GeoJSON Polygon used as the exterior ring (if undefined, the world extent is used)
 * @returns {Feature<Polygon>} Masked Polygon (exterior ring with holes).
 * @addToMap masked
 * @example
 * var polygon = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[[112, -21], [116, -36], [146, -39], [153, -24], [133, -10], [112, -21]]]
 *   }
 * }
 * var mask = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[[90, -55], [170, -55], [170, 10], [90, 10], [90, -55]]]
 *   }
 * }
 * var masked = turf.mask(polygon, mask);
 * //=masked
 */
module.exports = function (polygon, mask) {
    // Define mask
    var maskPolygon = createMask(mask);

    // Define polygon
    var separated = separatePolygons(polygon);
    var polygonOuters = separated[0];
    var polygonInners = separated[1];

    // Union Outers & Inners
    polygonOuters = unionPolygons(polygonOuters);
    polygonInners = unionPolygons(polygonInners);

    // Create masked area
    var masked = buildMask(maskPolygon, polygonOuters, polygonInners);
    return masked;
};

/**
 * Build Mask
 *
 * @private
 * @param {Feature<Polygon>} maskPolygon Mask Outer
 * @param {FeatureCollection<Polygon>} polygonOuters Polygon Outers
 * @param {FeatureCollection<Polygon>} polygonInners Polygon Inners
 * @returns {Feature<Polygon>} Feature Polygon
 */
function buildMask(maskPolygon, polygonOuters, polygonInners) {
    var coordinates = [];
    coordinates.push(maskPolygon.geometry.coordinates[0]);

    featureEach(polygonOuters, function (feature) {
        coordinates.push(feature.geometry.coordinates[0]);
    });

    featureEach(polygonInners, function (feature) {
        coordinates.push(feature.geometry.coordinates[0]);
    });
    return helpers.polygon(coordinates);
}

/**
 * Separate Polygons to inners & outers
 *
 * @private
 * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} polygon GeoJSON Feature
 * @returns {Array<FeatureCollection<Polygon>, FeatureCollection<Polygon>>} Outer & Inner lines
 */
function separatePolygons(polygon) {
    var outers = [];
    var inners = [];
    featureEach(polygon, function (multiFeature) {
        if (multiFeature.geometry.type === 'MultiPolygon') {
            multiFeature = flattenMultiPolygon(multiFeature);
        }
        featureEach(multiFeature, function (feature) {
            var coordinates = feature.geometry.coordinates;
            var featureOuter = coordinates[0];
            var featureInner = coordinates.slice(1);
            outers.push(helpers.polygon([featureOuter]));
            featureInner.forEach(function (inner) {
                inners.push(helpers.polygon([inner]));
            });
        });
    });
    return [helpers.featureCollection(outers), helpers.featureCollection(inners)];
}

/**
 * Flatten MultiPolygon
 *
 * @private
 * @param {Feature<MultiPolygon>} multiPolygon GeoJSON Feature
 * @returns {FeatureCollection<Polygon>} Feature Collection
 */
function flattenMultiPolygon(multiPolygon) {
    var polygons = [];
    multiPolygon.geometry.coordinates.forEach(function (coordinates) {
        polygons.push(helpers.polygon(coordinates));
    });
    return helpers.featureCollection(polygons);
}

/**
 * Create Mask Coordinates
 *
 * @private
 * @param {Feature<Polygon>} [mask] default to world if undefined
 * @returns {Feature<Polygon>} mask coordinate
 */
function createMask(mask) {
    var world = [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]];
    var coordinates = mask && mask.geometry.coordinates || world;
    return helpers.polygon(coordinates);
}

/**
 * Union Polygons
 *
 * @private
 * @param {FeatureCollection<Polygon>} polygons collection of polygons
 * @returns {FeatureCollection<Polygon>} polygons only apply union if they collide
 */
function unionPolygons(polygons) {
    if (polygons.features.length <= 1) return polygons;

    var tree = createIndex(polygons);
    var results = [];
    var removed = {};

    featureEach(polygons, function (currentFeature, currentIndex) {
        // Exclude any removed features
        if (removed[currentIndex]) return true;

        // Don't search for itself
        tree.remove({index: currentIndex}, filterByIndex);
        removed[currentIndex] = true;

        // Keep applying the union operation until no more overlapping features
        while (true) {
            var bbox = turfBBox(currentFeature);
            var search = tree.search({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3]
            });
            if (search.length > 0) {
                var polys = search.map(function (item) {
                    removed[item.index] = true;
                    tree.remove({index: item.index}, filterByIndex);
                    return item.geojson;
                });
                polys.push(currentFeature);
                currentFeature = union.apply(this, polys);
            }
            // Done
            if (search.length === 0) break;
        }
        results.push(currentFeature);
    });

    return helpers.featureCollection(results);
}

/**
 * Filter by Index - RBush helper function
 *
 * @private
 * @param {Object} a remove item
 * @param {Object} b search item
 * @returns {boolean} true if matches
 */
function filterByIndex(a, b) {
    return a.index === b.index;
}

/**
 * Create RBush Tree Index
 *
 * @private
 * @param {FeatureCollection<any>} features GeoJSON FeatureCollection
 * @returns {RBush} RBush Tree
 */
function createIndex(features) {
    var tree = rbush();
    var load = [];
    featureEach(features, function (feature, index) {
        var bbox = turfBBox(feature);
        load.push({
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3],
            geojson: feature,
            index: index
        });
    });
    tree.load(load);
    return tree;
}

},{"@turf/bbox":13,"@turf/helpers":93,"@turf/meta":94,"@turf/union":95,"rbush":174}],93:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],94:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],95:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29,"jsts":165}],96:[function(require,module,exports){
/**
 * Callback for coordEach
 *
 * @private
 * @callback coordEachCallback
 * @param {[number, number]} currentCoords The current coordinates being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentCoords, currentIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.coordEach(features, function (currentCoords, currentIndex) {
 *   //=currentCoords
 *   //=currentIndex
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
    var i, j, k, g, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        currentIndex = 0,
        isGeometryCollection,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            coords = geometry.coordinates;

            wrapShrink = (excludeWrapCoord &&
                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                1 : 0;

            if (geometry.type === 'Point') {
                callback(coords, currentIndex);
                currentIndex++;
            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                for (j = 0; j < coords.length; j++) {
                    callback(coords[j], currentIndex);
                    currentIndex++;
                }
            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        callback(coords[j][k], currentIndex);
                        currentIndex++;
                    }
            } else if (geometry.type === 'MultiPolygon') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            callback(coords[j][k][l], currentIndex);
                            currentIndex++;
                        }
            } else if (geometry.type === 'GeometryCollection') {
                for (j = 0; j < geometry.geometries.length; j++)
                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}
module.exports.coordEach = coordEach;

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {[number, number]} currentCoords The current coordinate being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {
 *   //=previousValue
 *   //=currentCoords
 *   //=currentIndex
 *   return currentCoords;
 * });
 */
function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(layer, function (currentCoords, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentCoords;
        } else {
            previousValue = callback(previousValue, currentCoords, currentIndex);
        }
    }, excludeWrapCoord);
    return previousValue;
}
module.exports.coordReduce = coordReduce;

/**
 * Callback for propEach
 *
 * @private
 * @callback propEachCallback
 * @param {*} currentProperties The current properties being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, currentIndex)
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.propEach(features, function (currentProperties, currentIndex) {
 *   //=currentProperties
 *   //=currentIndex
 * });
 */
function propEach(layer, callback) {
    var i;
    switch (layer.type) {
    case 'FeatureCollection':
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties, i);
        }
        break;
    case 'Feature':
        callback(layer.properties, 0);
        break;
    }
}
module.exports.propEach = propEach;


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current properties being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=currentIndex
 *   return currentProperties
 * });
 */
function propReduce(layer, callback, initialValue) {
    var previousValue = initialValue;
    propEach(layer, function (currentProperties, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentProperties;
        } else {
            previousValue = callback(previousValue, currentProperties, currentIndex);
        }
    });
    return previousValue;
}
module.exports.propReduce = propReduce;

/**
 * Callback for featureEach
 *
 * @private
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, currentIndex)
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.featureEach(features, function (currentFeature, currentIndex) {
 *   //=currentFeature
 *   //=currentIndex
 * });
 */
function featureEach(layer, callback) {
    if (layer.type === 'Feature') {
        callback(layer, 0);
    } else if (layer.type === 'FeatureCollection') {
        for (var i = 0; i < layer.features.length; i++) {
            callback(layer.features[i], i);
        }
    }
}
module.exports.featureEach = featureEach;

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=currentIndex
 *   return currentFeature
 * });
 */
function featureReduce(layer, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(layer, function (currentFeature, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentFeature;
        } else {
            previousValue = callback(previousValue, currentFeature, currentIndex);
        }
    });
    return previousValue;
}
module.exports.featureReduce = featureReduce;

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {Object} layer any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * var coords = turf.coordAll(features);
 * //=coords
 */
function coordAll(layer) {
    var coords = [];
    coordEach(layer, function (coord) {
        coords.push(coord);
    });
    return coords;
}
module.exports.coordAll = coordAll;

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, currentIndex)
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.geomEach(features, function (currentGeometry, currentIndex) {
 *   //=currentGeometry
 *   //=currentIndex
 * });
 */
function geomEach(layer, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        currentIndex = 0,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            if (geometry.type === 'Point' ||
                geometry.type === 'LineString' ||
                geometry.type === 'MultiPoint' ||
                geometry.type === 'Polygon' ||
                geometry.type === 'MultiLineString' ||
                geometry.type === 'MultiPolygon') {
                callback(geometry, currentIndex);
                currentIndex++;
            } else if (geometry.type === 'GeometryCollection') {
                for (j = 0; j < geometry.geometries.length; j++) {
                    callback(geometry.geometries[j], currentIndex);
                    currentIndex++;
                }
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}
module.exports.geomEach = geomEach;

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @private
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentGeometry The current Feature being processed.
 * @param {number} currentIndex The index of the current element being processed in the
 * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {"foo": "bar"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [26, 37]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {"hello": "world"},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [36, 53]
 *       }
 *     }
 *   ]
 * };
 * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=currentIndex
 *   return currentGeometry
 * });
 */
function geomReduce(layer, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(layer, function (currentGeometry, currentIndex) {
        if (currentIndex === 0 && initialValue === undefined) {
            previousValue = currentGeometry;
        } else {
            previousValue = callback(previousValue, currentGeometry, currentIndex);
        }
    });
    return previousValue;
}
module.exports.geomReduce = geomReduce;

},{}],97:[function(require,module,exports){
var bearing = require('@turf/bearing');
var destination = require('@turf/destination');
var distance = require('@turf/distance');

/**
 * Takes two {@link Point|points} and returns a point midway between them.
 * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.
 *
 * @name midpoint
 * @param {Feature<Point>} from first point
 * @param {Feature<Point>} to second point
 * @returns {Feature<Point>} a point midway between `pt1` and `pt2`
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [144.834823, -37.771257]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [145.14244, -37.830937]
 *   }
 * };
 *
 * var midpointed = turf.midpoint(pt1, pt2);
 * midpointed.properties['marker-color'] = '#f00';
 *
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, midpointed]
 * };
 *
 * //=result
 */
module.exports = function (from, to) {
    var dist = distance(from, to, 'miles');
    var heading = bearing(from, to);
    var midpoint = destination(from, dist / 2, heading, 'miles');

    return midpoint;
};

},{"@turf/bearing":15,"@turf/destination":33,"@turf/distance":38}],98:[function(require,module,exports){
var distance = require('@turf/distance');

/**
 * Takes a reference {@link Point|point} and a FeatureCollection of Features
 * with Point geometries and returns the
 * point from the FeatureCollection closest to the reference. This calculation
 * is geodesic.
 *
 * @name nearest
 * @param {Feature<Point>} targetPoint the reference point
 * @param {FeatureCollection<Point>} points against input point set
 * @returns {Feature<Point>} the closest point in the set to the reference point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [28.965797, 41.010086]
 *   }
 * };
 * var against = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.973865, 41.011122]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.948459, 41.024204]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.938674, 41.013324]
 *       }
 *     }
 *   ]
 * };
 *
 * var nearest = turf.nearest(point, against);
 * nearest.properties['marker-color'] = '#f00';
 *
 * var resultFeatures = against.features.concat(point);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (targetPoint, points) {
    var nearestPoint, minDist = Infinity;
    for (var i = 0; i < points.features.length; i++) {
        var distanceToPoint = distance(targetPoint, points.features[i], 'miles');
        if (distanceToPoint < minDist) {
            nearestPoint = points.features[i];
            minDist = distanceToPoint;
        }
    }
    return nearestPoint;
};

},{"@turf/distance":38}],99:[function(require,module,exports){
/**
 * Takes a triangular plane as a {@link Polygon}
 * and a {@link Point} within that triangle and returns the z-value
 * at that point. The Polygon needs to have properties `a`, `b`, and `c`
 * that define the values at its three corners.
 *
 * @name planepoint
 * @param {Feature<Point>} point the Point for which a z-value will be calculated
 * @param {Feature<Polygon>} triangle a Polygon feature with three vertices
 * @returns {number} the z-value for `interpolatedPoint`
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.3221, 39.529]
 *   }
 * };
 * var point = turf.point([-75.3221, 39.529]);
 * // triangle is a polygon with "a", "b",
 * // and "c" values representing
 * // the values of the coordinates in order.
 * var triangle = {
 *   "type": "Feature",
 *   "properties": {
 *     "a": 11,
 *     "b": 122,
 *     "c": 44
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-75.1221, 39.57],
 *       [-75.58, 39.18],
 *       [-75.97, 39.86],
 *       [-75.1221, 39.57]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [triangle, point]
 * };
 *
 * var zValue = turf.planepoint(point, triangle);
 *
 * //=features
 *
 * //=zValue
 */
module.exports = function (point, triangle) {
    var x = point.geometry.coordinates[0],
        y = point.geometry.coordinates[1],
        x1 = triangle.geometry.coordinates[0][0][0],
        y1 = triangle.geometry.coordinates[0][0][1],
        z1 = triangle.properties.a,
        x2 = triangle.geometry.coordinates[0][1][0],
        y2 = triangle.geometry.coordinates[0][1][1],
        z2 = triangle.properties.b,
        x3 = triangle.geometry.coordinates[0][2][0],
        y3 = triangle.geometry.coordinates[0][2][1],
        z3 = triangle.properties.c;

    var z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) -
      z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) /
      ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) -
       (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));

    return z;
};

},{}],100:[function(require,module,exports){
var point = require('@turf/helpers').point;
var featureCollection = require('@turf/helpers').featureCollection;
var distance = require('@turf/distance');
var turfBBox = require('@turf/bbox');

/**
 * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.
 *
 * @name pointGrid
 * @param {Array<number>|FeatureCollection|Feature<any>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize the distance across each cell
 * @param {string} [units=kilometers] used in calculating cellSize, can be degrees, radians, miles, or kilometers
 * @param {boolean} [centered=false] adjust points position to center the grid into bbox
 * @returns {FeatureCollection<Point>} grid of points
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var cellSize = 3;
 * var units = 'miles';
 *
 * var grid = turf.pointGrid(extent, cellSize, units);
 *
 * //=grid
 */
module.exports = function (bbox, cellSize, units, centered) {
    var results = [];

    // validation
    if (!bbox) throw new Error('bbox is required');
    if (!Array.isArray(bbox)) bbox = turfBBox(bbox); // Convert GeoJSON to bbox
    if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');

    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];

    var xFraction = cellSize / (distance(point([west, south]), point([east, south]), units));
    var cellWidth = xFraction * (east - west);
    var yFraction = cellSize / (distance(point([west, south]), point([west, north]), units));
    var cellHeight = yFraction * (north - south);

    if (centered === true) {
        var bboxHorizontalSide = (east - west);
        var bboxVerticalSide = (north - south);
        var columns = Math.floor(bboxHorizontalSide / cellWidth);
        var rows = Math.floor(bboxVerticalSide / cellHeight);
        // adjust origin of the grid
        var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;
        var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;
    }

    var currentX = west;
    if (centered === true) currentX += deltaX;
    while (currentX <= east) {
        var currentY = south;
        if (centered === true) currentY += deltaY;
        while (currentY <= north) {
            results.push(point([currentX, currentY]));
            currentY += cellHeight;
        }
        currentX += cellWidth;
    }

    return featureCollection(results);
};

},{"@turf/bbox":13,"@turf/distance":38,"@turf/helpers":101}],101:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],102:[function(require,module,exports){
var distance = require('@turf/distance');
var point = require('@turf/helpers').point;
var bearing = require('@turf/bearing');
var destination = require('@turf/destination');

/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the LineString.
 *
 * @name pointOnLine
 * @param {Feature<LineString>} line line to snap to
 * @param {Feature<Point>} pt point to snap from
 * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @return {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.037076, 38.884017]
 *   }
 * };
 *
 * var snapped = turf.pointOnLine(line, pt, 'miles');
 * snapped.properties['marker-color'] = '#00f'
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, pt, snapped]
 * };
 *
 * //=result
 */

module.exports = function (line, pt, units) {
    var coords;
    if (line.type === 'Feature') {
        coords = line.geometry.coordinates;
    } else if (line.type === 'LineString') {
        coords = line.coordinates;
    } else {
        throw new Error('input must be a LineString Feature or Geometry');
    }

    var closestPt = point([Infinity, Infinity], {
        dist: Infinity
    });
    var length = 0.0;
    for (var i = 0; i < coords.length - 1; i++) {
        var start = point(coords[i]);
        var stop = point(coords[i + 1]);
        //start
        start.properties.dist = distance(pt, start, units);
        //stop
        stop.properties.dist = distance(pt, stop, units);
        // sectionLength
        var sectionLength = distance(start, stop, units);
        //perpendicular
        var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
        var direction = bearing(start, stop);
        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);
        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);
        var intersect = lineIntersects(
            perpendicularPt1.geometry.coordinates[0],
            perpendicularPt1.geometry.coordinates[1],
            perpendicularPt2.geometry.coordinates[0],
            perpendicularPt2.geometry.coordinates[1],
            start.geometry.coordinates[0],
            start.geometry.coordinates[1],
            stop.geometry.coordinates[0],
            stop.geometry.coordinates[1]
        );
        var intersectPt;
        if (intersect) {
            intersectPt = point(intersect);
            intersectPt.properties.dist = distance(pt, intersectPt, units);
            intersectPt.properties.location = length + distance(start, closestPt, units);
        }

        if (start.properties.dist < closestPt.properties.dist) {
            closestPt = start;
            closestPt.properties.index = i;
            closestPt.properties.location = length;
        }
        if (stop.properties.dist < closestPt.properties.dist) {
            closestPt = stop;
            closestPt.properties.index = i + 1;
            closestPt.properties.location = length + sectionLength;
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
            closestPt = intersectPt;
            closestPt.properties.index = i;
        }
        // update length
        length += sectionLength;
    }

    return closestPt;
};

// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2;
    var result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a > 0 && a < 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b > 0 && b < 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    } else {
        return false;
    }
}

},{"@turf/bearing":15,"@turf/destination":33,"@turf/distance":38,"@turf/helpers":103}],103:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],104:[function(require,module,exports){
var featureCollection = require('@turf/helpers').featureCollection;
var centroid = require('@turf/center');
var distance = require('@turf/distance');
var inside = require('@turf/inside');
var explode = require('@turf/explode');

/**
 * Takes a feature and returns a {@link Point} guaranteed to be on the surface of the feature.
 *
 * * Given a {@link Polygon}, the point will be in the area of the polygon
 * * Given a {@link LineString}, the point will be along the string
 * * Given a {@link Point}, the point will the same as the input
 *
 * @param {(Feature|FeatureCollection)} fc any feature or set of features
 * @returns {Feature} a point on the surface of `input`
 * @example
 * // create a random polygon
 * var polygon = turf.random('polygon');
 *
 * //=polygon
 *
 * var pointOnPolygon = turf.pointOnSurface(polygon);
 *
* var resultFeatures = polygon.features.concat(pointOnPolygon);
* var result = {
*   "type": "FeatureCollection",
*   "features": resultFeatures
* };
 *
 * //=result
 */
function pointOnSurface(fc) {
    // normalize
    if (fc.type !== 'FeatureCollection') {
        if (fc.type !== 'Feature') {
            fc = {
                type: 'Feature',
                geometry: fc,
                properties: {}
            };
        }
        fc = featureCollection([fc]);
    }

    //get centroid
    var cent = centroid(fc);

    // check to see if centroid is on surface
    var onSurface = false;
    var i = 0;
    while (!onSurface && i < fc.features.length) {
        var geom = fc.features[i].geometry;
        var x, y, x1, y1, x2, y2, k;
        var onLine = false;
        if (geom.type === 'Point') {
            if (cent.geometry.coordinates[0] === geom.coordinates[0] &&
        cent.geometry.coordinates[1] === geom.coordinates[1]) {
                onSurface = true;
            }
        } else if (geom.type === 'MultiPoint') {
            var onMultiPoint = false;
            k = 0;
            while (!onMultiPoint && k < geom.coordinates.length) {
                if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
          cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                    onSurface = true;
                    onMultiPoint = true;
                }
                k++;
            }
        } else if (geom.type === 'LineString') {
            k = 0;
            while (!onLine && k < geom.coordinates.length - 1) {
                x = cent.geometry.coordinates[0];
                y = cent.geometry.coordinates[1];
                x1 = geom.coordinates[k][0];
                y1 = geom.coordinates[k][1];
                x2 = geom.coordinates[k + 1][0];
                y2 = geom.coordinates[k + 1][1];
                if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                    onLine = true;
                    onSurface = true;
                }
                k++;
            }
        } else if (geom.type === 'MultiLineString') {
            var j = 0;
            while (j < geom.coordinates.length) {
                onLine = false;
                k = 0;
                var line = geom.coordinates[j];
                while (!onLine && k < line.length - 1) {
                    x = cent.geometry.coordinates[0];
                    y = cent.geometry.coordinates[1];
                    x1 = line[k][0];
                    y1 = line[k][1];
                    x2 = line[k + 1][0];
                    y2 = line[k + 1][1];
                    if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                        onLine = true;
                        onSurface = true;
                    }
                    k++;
                }
                j++;
            }
        } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
            var f = {
                type: 'Feature',
                geometry: geom,
                properties: {}
            };
            if (inside(cent, f)) {
                onSurface = true;
            }
        }
        i++;
    }
    if (onSurface) {
        return cent;
    } else {
        var vertices = featureCollection([]);
        for (i = 0; i < fc.features.length; i++) {
            vertices.features = vertices.features.concat(explode(fc.features[i]).features);
        }
        var closestVertex;
        var closestDistance = Infinity;
        for (i = 0; i < vertices.features.length; i++) {
            var dist = distance(cent, vertices.features[i], 'miles');
            if (dist < closestDistance) {
                closestDistance = dist;
                closestVertex = vertices.features[i];
            }
        }
        return closestVertex;
    }
}

function pointOnSegment(x, y, x1, y1, x2, y2) {
    var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
    if (ab === ap + pb) {
        return true;
    }
}

module.exports = pointOnSurface;

},{"@turf/center":23,"@turf/distance":38,"@turf/explode":43,"@turf/helpers":105,"@turf/inside":60}],105:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],106:[function(require,module,exports){
var getCoords = require('@turf/invariant').getCoords;
var helpers = require('@turf/helpers');
var lineString = helpers.lineString;
var multiLineString = helpers.multiLineString;
var featureCollection = helpers.featureCollection;

/**
 * Converts a {@link Polygon} or {@link MultiPolygon} to a {@link FeatureCollection} of {@link LineString} or {@link MultiLineString}.
 *
 * @name polygonToLineString
 * @param {Feature<Polygon|MultiPolygon>} polygon Feature to convert
 * @returns {FeatureCollection<LineString|MultiLinestring>} converted Feature to Lines
 * @example
 * var poly = {
 *   'type': 'Feature',
 *   'properties': {},
 *   'geometry': {
 *     'type': 'Polygon',
 *     'coordinates': [[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]
 *   }
 * }
 * var lines = turf.polygonToLineString(poly);
 * //addToMap
 * var addToMap = [lines]
 */
module.exports = function (polygon) {
    var geom = getGeomType(polygon);
    var coords = getCoords(polygon);
    var properties = polygon.properties;
    if (!coords.length) throw new Error('polygon must contain coordinates');

    switch (geom) {
    case 'Polygon':
        return featureCollection([coordsToLine(coords, properties)]);
    case 'MultiPolygon':
        var lines = [];
        coords.forEach(function (coord) {
            lines.push(coordsToLine(coord, properties));
        });
        return featureCollection(lines);
    default:
        throw new Error('geom ' + geom + ' not supported');
    }
};

function coordsToLine(coords, properties) {
    if (coords.length > 1) return multiLineString(coords, properties);
    return lineString(coords[0], properties);
}

function getGeomType(feature) {
    return (feature.geometry) ? feature.geometry.type : feature.type;
}

},{"@turf/helpers":107,"@turf/invariant":62}],107:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],108:[function(require,module,exports){
var random = require('geojson-random');

/**
 * Generates random {@link GeoJSON} data, including {@link Point|Points} and {@link Polygon|Polygons}, for testing
 * and experimentation.
 *
 * @name random
 * @param {string} [type='point'] type of features desired: 'points' or 'polygons'
 * @param {number} [count=1] how many geometries should be generated.
 * @param {Object} options options relevant to the feature desired. Can include:
 * @param {Array<number>} options.bbox a bounding box inside of which geometries
 * are placed. In the case of {@link Point} features, they are guaranteed to be within this bounds,
 * while {@link Polygon} features have their centroid within the bounds.
 * @param {number} [options.num_vertices=10] options.vertices the number of vertices added
 * to polygon features.
 * @param {Number} [options.max_radial_length=10] the total number of decimal
 * degrees longitude or latitude that a polygon can extent outwards to
 * from its center.
 * @returns {FeatureCollection} generated random features
 * @example
 * var points = turf.random('points', 100, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=points
 *
 * var polygons = turf.random('polygons', 4, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=polygons
 */
module.exports = function (type, count, options) {
    options = options || {};
    count = count || 1;
    switch (type) {
    case 'point':
    case 'points':
    case undefined:
        return random.point(count, options.bbox);
    case 'polygon':
    case 'polygons':
        return random.polygon(
                count,
                options.num_vertices,
                options.max_radial_length,
                options.bbox);
    default:
        throw new Error('Unknown type given: valid options are points and polygons');
    }
};

},{"geojson-random":157}],109:[function(require,module,exports){
// http://stackoverflow.com/questions/11935175/sampling-a-random-subset-from-an-array
var featureCollection = require('@turf/helpers').featureCollection;

/**
 * Takes a {@link FeatureCollection} and returns a FeatureCollection with given number of {@link Feature|features} at random.
 *
 * @name sample
 * @param {FeatureCollection} featurecollection set of input features
 * @param {number} num number of features to select
 * @returns {FeatureCollection} a FeatureCollection with `n` features
 * @example
 * var points = turf.random('points', 1000);
 *
 * //=points
 *
 * var sample = turf.sample(points, 10);
 *
 * //=sample
 */
module.exports = function (featurecollection, num) {
    var outFC = featureCollection(getRandomSubarray(featurecollection.features, num));
    return outFC;
};

function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
    while (i-- > min) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}

},{"@turf/helpers":110}],110:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],111:[function(require,module,exports){
var simplify = require('simplify-js');

// supported GeoJSON geometries, used to check whether to wrap in simpleFeature()
var supportedTypes = ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Takes a {@link LineString} or {@link Polygon} and returns a simplified version. Internally uses [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.
 *
 * @name simplify
 * @param {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} feature feature to be simplified
 * @param {number} [tolerance=1] simplification tolerance
 * @param {boolean} [highQuality=false] whether or not to spend more time to create
 * a higher-quality simplification with a different algorithm
 * @returns {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} a simplified feature
 * @example
  * var feature = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-70.603637, -33.399918],
 *       [-70.614624, -33.395332],
 *       [-70.639343, -33.392466],
 *       [-70.659942, -33.394759],
 *       [-70.683975, -33.404504],
 *       [-70.697021, -33.419406],
 *       [-70.701141, -33.434306],
 *       [-70.700454, -33.446339],
 *       [-70.694274, -33.458369],
 *       [-70.682601, -33.465816],
 *       [-70.668869, -33.472117],
 *       [-70.646209, -33.473835],
 *       [-70.624923, -33.472117],
 *       [-70.609817, -33.468107],
 *       [-70.595397, -33.458369],
 *       [-70.587158, -33.442901],
 *       [-70.587158, -33.426283],
 *       [-70.590591, -33.414248],
 *       [-70.594711, -33.406224],
 *       [-70.603637, -33.399918]
 *     ]]
 *   }
 * };

 * var tolerance = 0.01;
 *
 * var simplified = turf.simplify(
 *  feature, tolerance, false);
 *
 * //=feature
 *
 * //=simplified
 */
module.exports = function (feature, tolerance, highQuality) {
    if (feature.type === 'Feature') {
        return simpleFeature(
            simplifyHelper(feature, tolerance, highQuality),
            feature.properties);
    } else if (feature.type === 'FeatureCollection') {
        return {
            type: 'FeatureCollection',
            features: feature.features.map(function (f) {
                var simplified = simplifyHelper(f, tolerance, highQuality);

                // we create simpleFeature here because it doesn't apply to GeometryCollection
                // so we can't create it at simplifyHelper()
                if (supportedTypes.indexOf(simplified.type) > -1) {
                    return simpleFeature(simplified, f.properties);
                } else {
                    return simplified;
                }
            })
        };
    } else if (feature.type === 'GeometryCollection') {
        return {
            type: 'GeometryCollection',
            geometries: feature.geometries.map(function (g) {
                if (supportedTypes.indexOf(g.type) > -1) {
                    return simplifyHelper({
                        type: 'Feature',
                        geometry: g
                    }, tolerance, highQuality);
                }
                return g;
            })
        };
    } else {
        return feature;
    }
};


function simplifyHelper(feature, tolerance, highQuality) {
    if (feature.geometry.type === 'LineString') {
        return {
            type: 'LineString',
            coordinates: simplifyLine(feature.geometry.coordinates, tolerance, highQuality)
        };
    } else if (feature.geometry.type === 'MultiLineString') {
        return {
            type: 'MultiLineString',
            coordinates: feature.geometry.coordinates.map(function (lines) {
                return simplifyLine(lines, tolerance, highQuality);
            })
        };
    } else if (feature.geometry.type === 'Polygon') {
        return {
            type: 'Polygon',
            coordinates: simplifyPolygon(feature.geometry.coordinates, tolerance, highQuality)
        };
    } else if (feature.geometry.type === 'MultiPolygon') {
        return {
            type: 'MultiPolygon',
            coordinates: feature.geometry.coordinates.map(function (rings) {
                return simplifyPolygon(rings, tolerance, highQuality);
            })
        };
    } else {
        // unsupported geometry type supplied
        return feature;
    }
}

/*
* returns true if ring's first coordinate is the same as its last
*/
function checkValidity(ring) {
    if (ring.length < 3) {
        return false;
    //if the last point is the same as the first, it's not a triangle
    } else if (ring.length === 3 &&
      ((ring[2][0] === ring[0][0]) && (ring[2][1] === ring[0][1]))) {
        return false;
    } else {
        return true;
    }
}

function simpleFeature(geom, properties) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: properties
    };
}

function simplifyLine(coordinates, tolerance, highQuality) {
    return simplify(coordinates.map(function (coord) {
        return {x: coord[0], y: coord[1], z: coord[2]};
    }), tolerance, highQuality).map(function (coords) {
        return (coords.z) ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];
    });
}

function simplifyPolygon(coordinates, tolerance, highQuality) {
    return coordinates.map(function (ring) {
        var pts = ring.map(function (coord) {
            return {x: coord[0], y: coord[1]};
        });
        if (pts.length < 4) {
            throw new Error('Invalid polygon');
        }
        var simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {
            return [coords.x, coords.y];
        });
        //remove 1 percent of tolerance until enough points to make a triangle
        while (!checkValidity(simpleRing)) {
            tolerance -= tolerance * 0.01;
            simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {
                return [coords.x, coords.y];
            });
        }
        if (
            (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0]) ||
                (simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1])) {
            simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
    });
}

},{"simplify-js":185}],112:[function(require,module,exports){
var featureCollection = require('@turf/helpers').featureCollection;
var point = require('@turf/helpers').point;
var polygon = require('@turf/helpers').polygon;
var distance = require('@turf/distance');
var turfBBox = require('@turf/bbox');

/**
 * Creates a square grid from a bounding box, {@link Feature} or {@link FeatureCollection}.
 *
 * @name squareGrid
 * @param {Array<number>|FeatureCollection|Feature<any>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize width of each cell
 * @param {string} [units=kilometers] used in calculating cellSize, can be degrees, radians, miles, or kilometers
 * @param {boolean} [completelyWithin=false] adjust width & height cellSize to fit exactly within bbox
 * @returns {FeatureCollection<Polygon>} grid a grid of polygons
 * @example
 * var bbox = [-95, 30 ,-85, 40];
 * var cellSize = 50;
 * var units = 'miles';
 *
 * var squareGrid = turf.squareGrid(bbox, cellSize, units);
 * //=squareGrid
 */
module.exports = function squareGrid(bbox, cellSize, units, completelyWithin) {
    var results = [];

    // validation
    if (!bbox) throw new Error('bbox is required');
    if (!Array.isArray(bbox)) bbox = turfBBox(bbox); // Convert GeoJSON to bbox
    if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');

    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];

    // distance
    var xDistance = distance(point([west, south]), point([east, south]), units);
    var yDistance = distance(point([west, south]), point([west, north]), units);

    // rows & columns
    var columns = Math.ceil(xDistance / cellSize);
    var rows = Math.ceil(yDistance / cellSize);

    // columns | width | x
    var xFraction = cellSize / xDistance;
    var cellWidth = xFraction * (east - west);
    if (completelyWithin === true) cellWidth = cellWidth * ((xDistance / cellSize) / columns);

    // rows | height | y
    var yFraction = cellSize / yDistance;
    var cellHeight = yFraction * (north - south);
    if (completelyWithin === true) cellHeight = cellHeight * ((yDistance / cellSize) / rows);

    // iterate over columns & rows
    var currentX = west;
    for (var column = 0; column < columns; column++) {
        var currentY = south;
        for (var row = 0; row < rows; row++) {
            var cellPoly = polygon([[
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
            ]]);
            results.push(cellPoly);

            currentY += cellHeight;
        }
        currentX += cellWidth;
    }
    return featureCollection(results);
};

},{"@turf/bbox":13,"@turf/distance":38,"@turf/helpers":113}],113:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],114:[function(require,module,exports){
var distance = require('@turf/distance');

/**
 * Takes a bounding box and calculates the minimum square bounding box that
 * would contain the input.
 *
 * @name square
 * @param {Array<number>} bbox extent in [west, south, east, north] order
 * @returns {Array<number>} a square surrounding `bbox`
 * @addToMap features
 * @example
 * var bbox = [-20,-20,-15,0];
 *
 * var squared = turf.square(bbox);
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     turf.bboxPolygon(bbox),
 *     turf.bboxPolygon(squared)
 *   ]
 * };
 *
 * //=features
 */
module.exports = function (bbox) {
    var west = bbox[0];
    var south = bbox[1];
    var east = bbox[2];
    var north = bbox[3];

    var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);
    var verticalDistance = distance(bbox.slice(0, 2), [west, north]);
    if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (south + north) / 2;
        return [
            west,
            verticalMidpoint - ((east - west) / 2),
            east,
            verticalMidpoint + ((east - west) / 2)
        ];
    } else {
        var horizontalMidpoint = (west + east) / 2;
        return [
            horizontalMidpoint - ((north - south) / 2),
            south,
            horizontalMidpoint + ((north - south) / 2),
            north
        ];
    }
};

},{"@turf/distance":38}],115:[function(require,module,exports){
var inside = require('@turf/inside');

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and performs a spatial join.
 *
 * @name tag
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon>} polygons input polygons
 * @param {string} field property in `polygons` to add to joined {<Point>} features
 * @param {string} outField property in `points` in which to store joined property from `polygons`
 * @returns {FeatureCollection<Point>} points with `containingPolyId` property containing values from `polyId`
 * @example
 * var pt1 = turf.point([-77, 44]);
 * var pt2 = turf.point([-77, 38]);
 * var poly1 = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]], {pop: 3000});
 * var poly2 = turf.polygon([[
 *   [-81, 35],
 *   [-81, 41],
 *   [-72, 41],
 *   [-72, 35],
 *   [-81, 35]
 * ]], {pop: 1000});
 *
 * var points = turf.featureCollection([pt1, pt2]);
 * var polygons = turf.featureCollection([poly1, poly2]);
 *
 * var tagged = turf.tag(points, polygons,
 *                       'pop', 'population');
 *
 * //=tagged
 */
module.exports = function (points, polygons, field, outField) {
    // prevent mutations
    points = JSON.parse(JSON.stringify(points));
    polygons = JSON.parse(JSON.stringify(polygons));
    points.features.forEach(function (pt) {
        if (!pt.properties) {
            pt.properties = {};
        }
        polygons.features.forEach(function (poly) {
            if (pt.properties[outField] === undefined) {
                var isInside = inside(pt, poly);
                if (isInside) {
                    pt.properties[outField] = poly.properties[field];
                }
            }
        });
    });
    return points;
};

},{"@turf/inside":60}],116:[function(require,module,exports){
var polygon = require('@turf/helpers').polygon;
var earcut = require('earcut');


/**
 * Tesselates a {@link Feature<Polygon>} into a {@link FeatureCollection<Polygon>} of triangles
 * using [earcut](https://github.com/mapbox/earcut).
 *
 * @name tesselate
 * @param {Feature<Polygon>} poly the polygon to tesselate
 * @returns {FeatureCollection<Polygon>} a geometrycollection feature
 * @example
 * var poly = turf.random('polygon').features[0];
 *
 * var triangles = turf.tesselate(poly);
 *
 * //=triangles
 */
module.exports = function (poly) {
    if (!poly.geometry || (poly.geometry.type !== 'Polygon' && poly.geometry.type !== 'MultiPolygon')) {
        throw new Error('input must be a Polygon or MultiPolygon');
    }

    var fc = {type: 'FeatureCollection', features: []};

    if (poly.geometry.type === 'Polygon') {
        fc.features = processPolygon(poly.geometry.coordinates);
    } else {
        poly.geometry.coordinates.forEach(function (coordinates) {
            fc.features = fc.features.concat(processPolygon(coordinates));
        });
    }

    return fc;
};

function processPolygon(coordinates) {
    var data = flattenCoords(coordinates);
    var dim = 2;
    var result = earcut(data.vertices, data.holes, dim);

    var features = [];
    var vertices = [];

    result.forEach(function (vert, i) {
        var index = result[i];
        vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
    });

    for (var i = 0; i < vertices.length; i += 3) {
        var coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push(polygon([coords]));
    }

    return features;
}

function flattenCoords(data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }

    return result;
}

},{"@turf/helpers":117,"earcut":149}],117:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],118:[function(require,module,exports){
//http://en.wikipedia.org/wiki/Delaunay_triangulation
//https://github.com/ironwallaby/delaunay
var polygon = require('@turf/helpers').polygon;
var featurecollection = require('@turf/helpers').featureCollection;

/**
 * Takes a set of {@link Point|points} and the name of a z-value property and
 * creates a [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
 * or a TIN for short, returned as a collection of Polygons. These are often used
 * for developing elevation contour maps or stepped heat visualizations.
 *
 * This triangulates the points, as well as adds properties called `a`, `b`,
 * and `c` representing the value of the given `propertyName` at each of
 * the points that represent the corners of the triangle.
 *
 * @name tin
 * @param {FeatureCollection<Point>} points input points
 * @param {String} [z] name of the property from which to pull z values
 * This is optional: if not given, then there will be no extra data added to the derived triangles.
 * @returns {FeatureCollection<Polygon>} TIN output
 * @example
 * // generate some random point data
 * var points = turf.random('points', 30, {
 *   bbox: [50, 30, 70, 50]
 * });
 * //=points
 * // add a random property to each point between 0 and 9
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = ~~(Math.random() * 9);
 * }
 * var tin = turf.tin(points, 'z')
 * for (var i = 0; i < tin.features.length; i++) {
 *   var properties  = tin.features[i].properties;
 *   // roughly turn the properties of each
 *   // triangle into a fill color
 *   // so we can visualize the result
 *   properties.fill = '#' + properties.a +
 *     properties.b + properties.c;
 * }
 * //=tin
 */
module.exports = function (points, z) {
    //break down points
    return featurecollection(triangulate(points.features.map(function (p) {
        var point = {
            x: p.geometry.coordinates[0],
            y: p.geometry.coordinates[1]
        };
        if (z) point.z = p.properties[z];
        return point;
    })).map(function (triangle) {
        return polygon([[
        [triangle.a.x, triangle.a.y],
        [triangle.b.x, triangle.b.y],
        [triangle.c.x, triangle.c.y],
        [triangle.a.x, triangle.a.y]
        ]], {
            a: triangle.a.z,
            b: triangle.b.z,
            c: triangle.c.z
        });
    }));
};

function Triangle(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;

    var A = b.x - a.x,
        B = b.y - a.y,
        C = c.x - a.x,
        D = c.y - a.y,
        E = A * (a.x + b.x) + B * (a.y + b.y),
        F = C * (a.x + c.x) + D * (a.y + c.y),
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
        dx, dy;

    // If the points of the triangle are collinear, then just find the
    // extremes and use the midpoint as the center of the circumcircle.
    this.x = (D * E - B * F) / G;
    this.y = (A * F - C * E) / G;
    dx = this.x - a.x;
    dy = this.y - a.y;
    this.r = dx * dx + dy * dy;
}

function byX(a, b) {
    return b.x - a.x;
}

function dedup(edges) {
    var j = edges.length,
        a, b, i, m, n;

    outer:
  while (j) {
      b = edges[--j];
      a = edges[--j];
      i = j;
      while (i) {
          n = edges[--i];
          m = edges[--i];
          if ((a === m && b === n) || (a === n && b === m)) {
              edges.splice(j, 2);
              edges.splice(i, 2);
              j -= 2;
              continue outer;
          }
      }
  }
}

function triangulate(vertices) {
    // Bail if there aren't enough vertices to form any triangles.
    if (vertices.length < 3)
        return [];

    // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points.
    vertices.sort(byX);

    var i = vertices.length - 1,
        xmin = vertices[i].x,
        xmax = vertices[0].x,
        ymin = vertices[i].y,
        ymax = ymin,
        epsilon = 1e-12;

    var a,
        b,
        c,
        A,
        B,
        G;

    while (i--) {
        if (vertices[i].y < ymin)
            ymin = vertices[i].y;
        if (vertices[i].y > ymax)
            ymax = vertices[i].y;
    }

    //Find a supertriangle, which is a triangle that surrounds all the
    //vertices. This is used like something of a sentinel value to remove
    //cases in the main algorithm, and is removed before we return any
    // results.

    // Once found, put it in the "open" list. (The "open" list is for
    // triangles who may still need to be considered; the "closed" list is
    // for triangles which do not.)
    var dx = xmax - xmin,
        dy = ymax - ymin,
        dmax = (dx > dy) ? dx : dy,
        xmid = (xmax + xmin) * 0.5,
        ymid = (ymax + ymin) * 0.5,
        open = [
            new Triangle({
                x: xmid - 20 * dmax,
                y: ymid - dmax,
                __sentinel: true
            }, {
                x: xmid,
                y: ymid + 20 * dmax,
                __sentinel: true
            }, {
                x: xmid + 20 * dmax,
                y: ymid - dmax,
                __sentinel: true
            }
        )],
        closed = [],
        edges = [],
        j;

    // Incrementally add each vertex to the mesh.
    i = vertices.length;
    while (i--) {
        // For each open triangle, check to see if the current point is
        // inside it's circumcircle. If it is, remove the triangle and add
        // it's edges to an edge list.
        edges.length = 0;
        j = open.length;
        while (j--) {
            // If this point is to the right of this triangle's circumcircle,
            // then this triangle should never get checked again. Remove it
            // from the open list, add it to the closed list, and skip.
            dx = vertices[i].x - open[j].x;
            if (dx > 0 && dx * dx > open[j].r) {
                closed.push(open[j]);
                open.splice(j, 1);
                continue;
            }

            // If not, skip this triangle.
            dy = vertices[i].y - open[j].y;
            if (dx * dx + dy * dy > open[j].r)
                continue;

            // Remove the triangle and add it's edges to the edge list.
            edges.push(
        open[j].a, open[j].b,
        open[j].b, open[j].c,
        open[j].c, open[j].a
      );
            open.splice(j, 1);
        }

        // Remove any doubled edges.
        dedup(edges);

        // Add a new triangle for each edge.
        j = edges.length;
        while (j) {
            b = edges[--j];
            a = edges[--j];
            c = vertices[i];
            // Avoid adding colinear triangles (which have error-prone
            // circumcircles)
            A = b.x - a.x;
            B = b.y - a.y;
            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));
            if (Math.abs(G) > epsilon) {
                open.push(new Triangle(a, b, c));
            }
        }
    }

    // Copy any remaining open triangles to the closed list, and then
    // remove any triangles that share a vertex with the supertriangle.
    Array.prototype.push.apply(closed, open);

    i = closed.length;
    while (i--)
        if (closed[i].a.__sentinel ||
      closed[i].b.__sentinel ||
      closed[i].c.__sentinel)
            closed.splice(i, 1);

    return closed;
}

},{"@turf/helpers":119}],119:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],120:[function(require,module,exports){
var featurecollection = require('@turf/helpers').featureCollection;
var polygon = require('@turf/helpers').polygon;
var distance = require('@turf/distance');

/**
 * Takes a bounding box and a cell depth and returns a set of triangular {@link Polygon|polygons} in a grid.
 *
 * @name triangleGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize dimension of each cell
 * @param {string} [units=kilometers] used in calculating cellSize, can be degrees, radians, miles, or kilometers
 * @returns {FeatureCollection<Polygon>} grid of polygons
 * @example
 * var bbox = [-96,31,-84,40]
 * var cellSize = 10;
 * var units = 'miles';
 *
 * var triangleGrid = turf.triangleGrid(bbox, cellSize, units);
 *
 * //=triangleGrid
 */
module.exports = function (bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var xi = 0;
    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var yi = 0;
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            if (xi % 2 === 0 && yi % 2 === 0) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY + cellHeight]
                ]]));
            } else if (xi % 2 === 0 && yi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX, currentY]
                ]]));
            } else if (yi % 2 === 0 && xi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]));
            } else if (yi % 2 === 1 && xi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY + cellHeight]
                ]]));
            }
            currentY += cellHeight;
            yi++;
        }
        xi++;
        currentX += cellWidth;
    }
    return fc;
};


},{"@turf/distance":38,"@turf/helpers":121}],121:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],122:[function(require,module,exports){
/**
 * Takes a GeoJSON Feature or FeatureCollection and truncates the precision of the geometry.
 *
 * @name truncate
 * @param {(Feature|FeatureCollection)} layer any GeoJSON Feature or FeatureCollection
 * @param {number} [precision=6] coordinate decimal precision
 * @param {number} [coordinates=2] maximum number of coordinates (primarly used to remove z coordinates)
 * @returns {(Feature|FeatureCollection)} layer with truncated geometry
 * @example
 * var point = {
 *     "type": "Feature",
 *     "geometry": {
 *         "type": "Point",
 *         "coordinates": [
 *             70.46923055566859,
 *             58.11088890802906,
 *             1508
 *         ]
 *     },
 *     "properties": {}
 * };
 * var pointTrunc = turf.truncate(point);
 * //= pointTrunc
 */
module.exports = function (layer, precision, coordinates) {
    precision = (precision !== undefined) ? precision : 6;
    coordinates = (coordinates !== undefined) ? coordinates : 2;

    if (layer === undefined) throw new Error('layer is required');

    switch (layer.type) {
    case 'FeatureCollection': {
        layer.features = layer.features.map(function (feature) {
            return truncate(feature, precision, coordinates);
        });
        return layer;
    }
    case 'Feature':
        return truncate(layer, precision, coordinates);
    default:
        throw new Error('invalid type');
    }
};

function truncate(feature, precision, coordinates) {
    if (coordinates !== undefined) { feature.geometry.coordinates = deepSlice(feature.geometry.coordinates, 0, coordinates); }
    feature.geometry.coordinates = toFix(feature.geometry.coordinates, precision);
    return feature;
}

function toFix(array, precision) {
    return array.map(function (value) {
        if (typeof value === 'object') { return toFix(value, precision); }
        return Number(value.toFixed(precision));
    });
}

/**
 * Recursive Array.prototype.slice()
 * https://github.com/DenisCarriere/deep-slice
 *
 * @private
 * @param {Array} items Array input
 * @param {number} start The beginning of the specified portion of the array.
 * @param {number} end The end of the specified portion of the array.
 * @returns {Array} Returns a section of an array.
 * @example
 * deepSlice([[10, 20, 30], [40, 50, 60]], 0, 2)
 * //=[[10, 20], [40, 50]]
 */
function deepSlice(items, start, end) {
    if (typeof items[0] !== 'object') {
        return items.slice(start, end);
    }
    return items.map(function (item) {
        return deepSlice(item, start, end);
    });
}

},{}],123:[function(require,module,exports){
/*eslint global-require: 0*/

/**
 * Turf is a modular geospatial analysis engine written in JavaScript. It performs geospatial
 * processing tasks with GeoJSON data and can be run on a server or in a browser.
 *
 * @module turf
 * @summary Geospatial analysis for JavaScript
 */
var helpers = require('@turf/helpers');
var invariant = require('@turf/invariant');
var meta = require('@turf/meta');

var turf = {
    isolines: require('@turf/isolines'),
    convex: require('@turf/convex'),
    within: require('@turf/within'),
    concave: require('@turf/concave'),
    difference: require('@turf/difference'),
    dissolve: require('@turf/dissolve'),
    collect: require('@turf/collect'),
    flip: require('@turf/flip'),
    simplify: require('@turf/simplify'),
    bezier: require('@turf/bezier'),
    tag: require('@turf/tag'),
    sample: require('@turf/sample'),
    envelope: require('@turf/envelope'),
    square: require('@turf/square'),
    circle: require('@turf/circle'),
    midpoint: require('@turf/midpoint'),
    buffer: require('@turf/buffer'),
    center: require('@turf/center'),
    centerOfMass: require('@turf/center-of-mass'),
    centroid: require('@turf/centroid'),
    combine: require('@turf/combine'),
    distance: require('@turf/distance'),
    explode: require('@turf/explode'),
    bbox: require('@turf/bbox'),
    tesselate: require('@turf/tesselate'),
    bboxPolygon: require('@turf/bbox-polygon'),
    inside: require('@turf/inside'),
    intersect: require('@turf/intersect'),
    nearest: require('@turf/nearest'),
    planepoint: require('@turf/planepoint'),
    random: require('@turf/random'),
    tin: require('@turf/tin'),
    union: require('@turf/union'),
    bearing: require('@turf/bearing'),
    destination: require('@turf/destination'),
    kinks: require('@turf/kinks'),
    pointOnSurface: require('@turf/point-on-surface'),
    area: require('@turf/area'),
    along: require('@turf/along'),
    lineDistance: require('@turf/line-distance'),
    lineSlice: require('@turf/line-slice'),
    lineSliceAlong: require('@turf/line-slice-along'),
    pointOnLine: require('@turf/point-on-line'),
    pointGrid: require('@turf/point-grid'),
    squareGrid: require('@turf/square-grid'),
    triangleGrid: require('@turf/triangle-grid'),
    hexGrid: require('@turf/hex-grid'),
    idw: require('@turf/idw'),
    truncate: require('@turf/truncate'),
    flatten: require('@turf/flatten'),
    lineIntersect: require('@turf/line-intersect'),
    mask: require('@turf/mask'),
    lineChunk: require('@turf/line-chunk'),
    unkinkPolygon: require('@turf/unkink-polygon'),
    greatCircle: require('@turf/great-circle'),
    lineSegment: require('@turf/line-segment'),
    lineSplit: require('@turf/line-split'),
    lineArc: require('@turf/line-arc'),
    polygonToLineString: require('@turf/polygon-to-linestring'),
    bboxClip: require('@turf/bbox-clip'),
    lineOverlap: require('@turf/line-overlap'),
    point: helpers.point,
    polygon: helpers.polygon,
    lineString: helpers.lineString,
    multiPoint: helpers.multiPoint,
    multiPolygon: helpers.multiPolygon,
    multiLineString: helpers.multiLineString,
    feature: helpers.feature,
    featureCollection: helpers.featureCollection,
    geometryCollection: helpers.geometryCollection,
    radiansToDistance: helpers.radiansToDistance,
    distanceToRadians: helpers.distanceToRadians,
    distanceToDegrees: helpers.distanceToDegrees,
    getCoord: invariant.getCoord,
    getCoords: invariant.getCoords,
    geojsonType: invariant.geojsonType,
    featureOf: invariant.featureOf,
    collectionOf: invariant.collectionOf,
    containsNumber: invariant.containsNumber,
    coordEach: meta.coordEach,
    coordReduce: meta.coordReduce,
    propEach: meta.propEach,
    propReduce: meta.propReduce,
    featureEach: meta.featureEach,
    featureReduce: meta.featureReduce,
    coordAll: meta.coordAll,
    geomEach: meta.geomEach,
    geomReduce: meta.geomReduce
};

module.exports = turf;

},{"@turf/along":7,"@turf/area":9,"@turf/bbox":13,"@turf/bbox-clip":11,"@turf/bbox-polygon":124,"@turf/bearing":15,"@turf/bezier":16,"@turf/buffer":125,"@turf/center":23,"@turf/center-of-mass":19,"@turf/centroid":126,"@turf/circle":25,"@turf/collect":27,"@turf/combine":127,"@turf/concave":28,"@turf/convex":30,"@turf/destination":33,"@turf/difference":35,"@turf/dissolve":36,"@turf/distance":38,"@turf/envelope":40,"@turf/explode":43,"@turf/flatten":46,"@turf/flip":49,"@turf/great-circle":52,"@turf/helpers":128,"@turf/hex-grid":54,"@turf/idw":56,"@turf/inside":60,"@turf/intersect":61,"@turf/invariant":62,"@turf/isolines":64,"@turf/kinks":66,"@turf/line-arc":68,"@turf/line-chunk":70,"@turf/line-distance":73,"@turf/line-intersect":76,"@turf/line-overlap":79,"@turf/line-segment":82,"@turf/line-slice":87,"@turf/line-slice-along":85,"@turf/line-split":89,"@turf/mask":92,"@turf/meta":129,"@turf/midpoint":97,"@turf/nearest":98,"@turf/planepoint":99,"@turf/point-grid":100,"@turf/point-on-line":102,"@turf/point-on-surface":104,"@turf/polygon-to-linestring":106,"@turf/random":108,"@turf/sample":109,"@turf/simplify":111,"@turf/square":114,"@turf/square-grid":112,"@turf/tag":115,"@turf/tesselate":116,"@turf/tin":118,"@turf/triangle-grid":120,"@turf/truncate":122,"@turf/union":130,"@turf/unkink-polygon":131,"@turf/within":134}],124:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"@turf/helpers":128,"dup":41}],125:[function(require,module,exports){
// http://stackoverflow.com/questions/839899/how-do-i-calculate-a-point-on-a-circles-circumference
// radians = degrees * (pi/180)
// https://github.com/bjornharrtell/jsts/blob/master/examples/buffer.html

var helpers = require('@turf/helpers');
var featureCollection = helpers.featureCollection;
var jsts = require('jsts');
var normalize = require('@mapbox/geojson-normalize');

/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 *
 * @name buffer
 * @param {(Feature|FeatureCollection)} feature input to be buffered
 * @param {number} radius distance to draw the buffer
 * @param {string} units any of the options supported by turf units
 * @return {FeatureCollection<Polygon>|FeatureCollection<MultiPolygon>|Polygon|MultiPolygon} buffered features
 * @addToMap pt, buffered
 * @example
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-90.548630, 14.616599]
 *   }
 * };
 * var unit = 'miles';
 *
 * var buffered = turf.buffer(pt, 500, unit);
 *
 * //=buffered
 */

module.exports = function (feature, radius, units) {

    var degrees = helpers.distanceToDegrees(radius, units);
    var fc = normalize(feature);
    var buffered = normalize(featureCollection(fc.features.map(function (f) {
        return bufferOp(f, degrees);
    })));

    if (buffered.features.length > 1) return buffered;
    else if (buffered.features.length === 1) return buffered.features[0];
};

function bufferOp(feature, radius) {
    var reader = new jsts.io.GeoJSONReader();
    var geom = reader.read(feature.geometry);
    var buffered = geom.buffer(radius);
    var writer = new jsts.io.GeoJSONWriter();
    buffered = writer.write(buffered);

    return {
        type: 'Feature',
        geometry: buffered,
        properties: {}
    };
}

},{"@mapbox/geojson-normalize":3,"@turf/helpers":128,"jsts":165}],126:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"@turf/helpers":128,"@turf/meta":129,"dup":20}],127:[function(require,module,exports){
var meta = require('@turf/meta');

/**
 * Combines a {@link FeatureCollection} of {@link Point},
 * {@link LineString}, or {@link Polygon} features
 * into {@link MultiPoint}, {@link MultiLineString}, or
 * {@link MultiPolygon} features.
 *
 * @name combine
 * @param {FeatureCollection<(Point|LineString|Polygon)>} fc a FeatureCollection of any type
 * @return {FeatureCollection<(MultiPoint|MultiLineString|MultiPolygon)>} a FeatureCollection of corresponding type to input
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.026432, 47.49134]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.074497, 47.509548]
 *       }
 *     }
 *   ]
 * };
 *
 * var combined = turf.combine(fc);
 *
 * //=combined
 */

module.exports = function (fc) {
    var groups = {
        MultiPoint: {coordinates: [], properties: []},
        MultiLineString: {coordinates: [], properties: []},
        MultiPolygon: {coordinates: [], properties: []}
    };

    var multiMapping = Object.keys(groups).reduce(function (memo, item) {
        memo[item.replace('Multi', '')] = item;
        return memo;
    }, {});

    function addToGroup(feature, key, multi) {
        if (!multi) {
            groups[key].coordinates.push(feature.geometry.coordinates);
        } else {
            groups[key].coordinates = groups[key].coordinates.concat(feature.geometry.coordinates);
        }
        groups[key].properties.push(feature.properties);
    }

    meta.featureEach(fc, function (feature) {
        if (!feature.geometry) return;
        if (groups[feature.geometry.type]) {
            addToGroup(feature, feature.geometry.type, true);
        } else if (multiMapping[feature.geometry.type]) {
            addToGroup(feature, multiMapping[feature.geometry.type], false);
        }
    });

    return {
        type: 'FeatureCollection',
        features: Object.keys(groups)
            .filter(function (key) {
                return groups[key].coordinates.length;
            })
            .sort()
            .map(function (key) {
                return {
                    type: 'Feature',
                    properties: {
                        collectedProperties: groups[key].properties
                    },
                    geometry: {
                        type: key,
                        coordinates: groups[key].coordinates
                    }
                };
            })
    };
};

},{"@turf/meta":129}],128:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],129:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],130:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29,"jsts":165}],131:[function(require,module,exports){
var simplepolygon = require('simplepolygon');
var flatten = require('@turf/flatten');
var featureEach = require('@turf/meta').featureEach;
var featureCollection = require('@turf/helpers').featureCollection;

/**
 * Takes a kinked polygon and returns a feature collection of polygons that have no kinks.
 * Uses [simplepolygon](https://github.com/mclaeysb/simplepolygon) internally.
 *
 * @name unkinkPolygon
 * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} geojson GeoJSON Polygon or MultiPolygon
 * @returns {FeatureCollection<Polygon>} Unkinked polygons
 * @example
 * var poly = {
 *    'type': 'Feature',
 *      'geometry': {
 *         'type': 'Polygon',
 *        'coordinates': [[[0, 0], [2, 0], [0, 2], [2, 2], [0, 0]]]
 *       }
 * };
 *
 * var result = turf.unkinkPolygon(poly);
 *
 * //=result
 */
module.exports = function (geojson) {
    var results = featureCollection([]);

    // Handles FeatureCollection & Feature
    featureEach(geojson, function (feature) {

        // Handle MultiPolygons as Feature or FeatureCollection
        if (feature.geometry.type === 'MultiPolygon') { feature = flatten(feature); }

        // Store simple polygons in results
        featureEach(feature, function (polygon) {
            var simple = simplepolygon(polygon);

            featureEach(simple, function (poly) {
                poly.properties = (polygon.properties) ? polygon.properties : {};
                results.features.push(poly);
            });
        });
    });
    return results;
};

},{"@turf/flatten":46,"@turf/helpers":132,"@turf/meta":133,"simplepolygon":179}],132:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],133:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],134:[function(require,module,exports){
var inside = require('@turf/inside');
var featureCollection = require('@turf/helpers').featureCollection;

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and returns the points that fall within the polygons.
 *
 * @name within
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon>} polygons input polygons
 * @returns {FeatureCollection<Point>} points that land within at least one polygon
 * @example
 * var searchWithin = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-46.653,-23.543],
 *           [-46.634,-23.5346],
 *           [-46.613,-23.543],
 *           [-46.614,-23.559],
 *           [-46.631,-23.567],
 *           [-46.653,-23.560],
 *           [-46.653,-23.543]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6318, -23.5523]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6246, -23.5325]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6062, -23.5513]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.663, -23.554]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.643, -23.557]
 *       }
 *     }
 *   ]
 * };
 *
 * var ptsWithin = turf.within(points, searchWithin);
 *
 * //=points
 *
 * //=searchWithin
 *
 * //=ptsWithin
 */
module.exports = function (points, polygons) {
    var pointsWithin = featureCollection([]);
    for (var i = 0; i < polygons.features.length; i++) {
        for (var j = 0; j < points.features.length; j++) {
            var isInside = inside(points.features[j], polygons.features[i]);
            if (isInside) {
                pointsWithin.features.push(points.features[j]);
            }
        }
    }
    return pointsWithin;
};

},{"@turf/helpers":135,"@turf/inside":60}],135:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],136:[function(require,module,exports){
'use strict'

module.exports = affineHull

var orient = require('robust-orientation')

function linearlyIndependent(points, d) {
  var nhull = new Array(d+1)
  for(var i=0; i<points.length; ++i) {
    nhull[i] = points[i]
  }
  for(var i=0; i<=points.length; ++i) {
    for(var j=points.length; j<=d; ++j) {
      var x = new Array(d)
      for(var k=0; k<d; ++k) {
        x[k] = Math.pow(j+1-i, k)
      }
      nhull[j] = x
    }
    var o = orient.apply(void 0, nhull)
    if(o) {
      return true
    }
  }
  return false
}

function affineHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  }
  if(n === 1) {
    return [0]
  }
  var d = points[0].length
  var frame = [ points[0] ]
  var index = [ 0 ]
  for(var i=1; i<n; ++i) {
    frame.push(points[i])
    if(!linearlyIndependent(frame, d)) {
      frame.pop()
      continue
    }
    index.push(i)
    if(index.length === d+1) {
      return index
    }
  }
  return index
}
},{"robust-orientation":175}],137:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],138:[function(require,module,exports){

},{}],139:[function(require,module,exports){
'use strict'; /* @flow */

module.exports = cheapRuler;

/**
 * A collection of very fast approximations to common geodesic measurements. Useful for performance-sensitive code that measures things on a city scale.
 *
 * @param {number} lat latitude
 * @param {string} [units='kilometers']
 * @returns {CheapRuler}
 * @example
 * var ruler = cheapRuler(35.05, 'miles');
 * //=ruler
 */
function cheapRuler(lat /*: number */, units /*: ?string */) {
    return new CheapRuler(lat, units);
}

/**
 * Multipliers for converting between units.
 *
 * @example
 * // convert 50 meters to yards
 * 50 * cheapRuler.units.yards / cheapRuler.units.meters;
 */
var factors = cheapRuler.units = {
    kilometers: 1,
    miles: 1000 / 1609.344,
    nauticalmiles: 1000 / 1852,
    meters: 1000,
    metres: 1000,
    yards: 1000 / 0.9144,
    feet: 1000 / 0.3048,
    inches: 1000 / 0.0254
};

/**
 * Creates a ruler object from tile coordinates (y and z). Convenient in tile-reduce scripts.
 *
 * @param {number} y
 * @param {number} z
 * @param {string} [units='kilometers']
 * @returns {CheapRuler}
 * @example
 * var ruler = cheapRuler.fromTile(1567, 12);
 * //=ruler
 */
cheapRuler.fromTile = function (y, z, units) {
    var n = Math.PI * (1 - 2 * (y + 0.5) / Math.pow(2, z));
    var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))) * 180 / Math.PI;
    return new CheapRuler(lat, units);
};

function CheapRuler(lat, units) {
    if (lat === undefined) throw new Error('No latitude given.');
    if (units && !factors[units]) throw new Error('Unknown unit ' + units + '. Use one of: ' + Object.keys(factors));

    var m = units ? factors[units] : 1;

    var cos = Math.cos(lat * Math.PI / 180);
    var cos2 = 2 * cos * cos - 1;
    var cos3 = 2 * cos * cos2 - cos;
    var cos4 = 2 * cos * cos3 - cos2;
    var cos5 = 2 * cos * cos4 - cos3;

    // multipliers for converting longitude and latitude degrees into distance (http://1.usa.gov/1Wb1bv7)
    this.kx = m * (111.41513 * cos - 0.09455 * cos3 + 0.00012 * cos5);
    this.ky = m * (111.13209 - 0.56605 * cos2 + 0.0012 * cos4);
}

CheapRuler.prototype = {
    /**
     * Given two points of the form [longitude, latitude], returns the distance.
     *
     * @param {Array<number>} a point [longitude, latitude]
     * @param {Array<number>} b point [longitude, latitude]
     * @returns {number} distance
     * @example
     * var distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
     * //=distance
     */
    distance: function (a, b) {
        var dx = (a[0] - b[0]) * this.kx;
        var dy = (a[1] - b[1]) * this.ky;
        return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the bearing between two points in angles.
     *
     * @param {Array<number>} a point [longitude, latitude]
     * @param {Array<number>} b point [longitude, latitude]
     * @returns {number} bearing
     * @example
     * var bearing = ruler.bearing([30.5, 50.5], [30.51, 50.49]);
     * //=bearing
     */
    bearing: function (a, b) {
        var dx = (b[0] - a[0]) * this.kx;
        var dy = (b[1] - a[1]) * this.ky;
        if (!dx && !dy) return 0;
        var bearing = Math.atan2(-dy, dx) * 180 / Math.PI + 90;
        if (bearing > 180) bearing -= 360;
        return bearing;
    },

    /**
     * Returns a new point given distance and bearing from the starting point.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {number} dist distance
     * @param {number} bearing
     * @returns {Array<number>} point [longitude, latitude]
     * @example
     * var point = ruler.destination([30.5, 50.5], 0.1, 90);
     * //=point
     */
    destination: function (p, dist, bearing) {
        var a = (90 - bearing) * Math.PI / 180;
        return this.offset(p,
            Math.cos(a) * dist,
            Math.sin(a) * dist);
    },

    /**
     * Returns a new point given easting and northing offsets (in ruler units) from the starting point.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {number} dx easting
     * @param {number} dy northing
     * @returns {Array<number>} point [longitude, latitude]
     * @example
     * var point = ruler.offset([30.5, 50.5], 10, 10);
     * //=point
     */
    offset: function (p, dx, dy) {
        return [
            p[0] + dx / this.kx,
            p[1] + dy / this.ky
        ];
    },

    /**
     * Given a line (an array of points), returns the total line distance.
     *
     * @param {Array<Array<number>>} points [longitude, latitude]
     * @returns {number} total line distance
     * @example
     * var length = ruler.lineDistance([
     *     [-67.031, 50.458], [-67.031, 50.534],
     *     [-66.929, 50.534], [-66.929, 50.458]
     * ]);
     * //=length
     */
    lineDistance: function (points) {
        var total = 0;
        for (var i = 0; i < points.length - 1; i++) {
            total += this.distance(points[i], points[i + 1]);
        }
        return total;
    },

    /**
     * Given a polygon (an array of rings, where each ring is an array of points), returns the area.
     *
     * @param {Array<Array<Array<number>>>} polygon
     * @returns {number} area value in the specified units (square kilometers by default)
     * @example
     * var area = ruler.area([[
     *     [-67.031, 50.458], [-67.031, 50.534], [-66.929, 50.534],
     *     [-66.929, 50.458], [-67.031, 50.458]
     * ]]);
     * //=area
     */
    area: function (polygon) {
        var sum = 0;

        for (var i = 0; i < polygon.length; i++) {
            var ring = polygon[i];

            for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
                sum += (ring[j][0] - ring[k][0]) * (ring[j][1] + ring[k][1]) * (i ? -1 : 1);
            }
        }

        return (Math.abs(sum) / 2) * this.kx * this.ky;
    },

    /**
     * Returns the point at a specified distance along the line.
     *
     * @param {Array<Array<number>>} line
     * @param {number} dist distance
     * @returns {Array<number>} point [longitude, latitude]
     * @example
     * var point = ruler.along(line, 2.5);
     * //=point
     */
    along: function (line, dist) {
        var sum = 0;

        if (dist <= 0) return line[0];

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];
            var d = this.distance(p0, p1);
            sum += d;
            if (sum > dist) return interpolate(p0, p1, (dist - (sum - d)) / d);
        }

        return line[line.length - 1];
    },

    /**
     * Returns an object of the form {point, index} where point is closest point on the line from the given point, and index is the start index of the segment with the closest point.
     *
     * @pointOnLine
     * @param {Array<Array<number>>} line
     * @param {Array<number>} p point [longitude, latitude]
     * @returns {Object} {point, index}
     * @example
     * var point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
     * //=point
     */
    pointOnLine: function (line, p) {
        var minDist = Infinity;
        var minX, minY, minI, minT;

        for (var i = 0; i < line.length - 1; i++) {

            var x = line[i][0];
            var y = line[i][1];
            var dx = (line[i + 1][0] - x) * this.kx;
            var dy = (line[i + 1][1] - y) * this.ky;

            if (dx !== 0 || dy !== 0) {

                var t = ((p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);

                if (t > 1) {
                    x = line[i + 1][0];
                    y = line[i + 1][1];

                } else if (t > 0) {
                    x += (dx / this.kx) * t;
                    y += (dy / this.ky) * t;
                }
            }

            dx = (p[0] - x) * this.kx;
            dy = (p[1] - y) * this.ky;

            var sqDist = dx * dx + dy * dy;
            if (sqDist < minDist) {
                minDist = sqDist;
                minX = x;
                minY = y;
                minI = i;
                minT = t;
            }
        }

        return {
            point: [minX, minY],
            index: minI,
            t: minT
        };
    },

    /**
     * Returns a part of the given line between the start and the stop points (or their closest points on the line).
     *
     * @param {Array<number>} start point [longitude, latitude]
     * @param {Array<number>} stop point [longitude, latitude]
     * @param {Array<Array<number>>} line
     * @returns {Array<Array<number>>} line part of a line
     * @example
     * var line2 = ruler.lineSlice([-67.04, 50.5], [-67.05, 50.56], line1);
     * //=line2
     */
    lineSlice: function (start, stop, line) {
        var p1 = this.pointOnLine(line, start);
        var p2 = this.pointOnLine(line, stop);

        if (p1.index > p2.index || (p1.index === p2.index && p1.t > p2.t)) {
            var tmp = p1;
            p1 = p2;
            p2 = tmp;
        }

        var slice = [p1.point];

        var l = p1.index + 1;
        var r = p2.index;

        if (!equals(line[l], slice[0]) && l <= r)
            slice.push(line[l]);

        for (var i = l + 1; i <= r; i++) {
            slice.push(line[i]);
        }

        if (!equals(line[r], p2.point))
            slice.push(p2.point);

        return slice;
    },

    /**
     * Returns a part of the given line between the start and the stop points indicated by distance along the line.
     *
     * @param {number} start distance
     * @param {number} stop distance
     * @param {Array<Array<number>>} line
     * @returns {Array<Array<number>>} line part of a line
     * @example
     * var line2 = ruler.lineSliceAlong(10, 20, line1);
     * //=line2
     */
    lineSliceAlong: function (start, stop, line) {
        var sum = 0;
        var slice = [];

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];
            var d = this.distance(p0, p1);

            sum += d;

            if (sum > start && slice.length === 0) {
                slice.push(interpolate(p0, p1, (start - (sum - d)) / d));
            }

            if (sum >= stop) {
                slice.push(interpolate(p0, p1, (stop - (sum - d)) / d));
                return slice;
            }

            if (sum > start) slice.push(p1);
        }

        return slice;
    },

    /**
     * Given a point, returns a bounding box object ([w, s, e, n]) created from the given point buffered by a given distance.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {number} buffer
     * @returns {Array<number>} box object ([w, s, e, n])
     * @example
     * var bbox = ruler.bufferPoint([30.5, 50.5], 0.01);
     * //=bbox
     */
    bufferPoint: function (p, buffer) {
        var v = buffer / this.ky;
        var h = buffer / this.kx;
        return [
            p[0] - h,
            p[1] - v,
            p[0] + h,
            p[1] + v
        ];
    },

    /**
     * Given a bounding box, returns the box buffered by a given distance.
     *
     * @param {Array<number>} box object ([w, s, e, n])
     * @param {number} buffer
     * @returns {Array<number>} box object ([w, s, e, n])
     * @example
     * var bbox = ruler.bufferBBox([30.5, 50.5, 31, 51], 0.2);
     * //=bbox
     */
    bufferBBox: function (bbox, buffer) {
        var v = buffer / this.ky;
        var h = buffer / this.kx;
        return [
            bbox[0] - h,
            bbox[1] - v,
            bbox[2] + h,
            bbox[3] + v
        ];
    },

    /**
     * Returns true if the given point is inside in the given bounding box, otherwise false.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {Array<number>} box object ([w, s, e, n])
     * @returns {boolean}
     * @example
     * var inside = ruler.insideBBox([30.5, 50.5], [30, 50, 31, 51]);
     * //=inside
     */
    insideBBox: function (p, bbox) {
        return p[0] >= bbox[0] &&
               p[0] <= bbox[2] &&
               p[1] >= bbox[1] &&
               p[1] <= bbox[3];
    }
};

function equals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}

function interpolate(a, b, t) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return [
        a[0] + dx * t,
        a[1] + dy * t
    ];
}

},{}],140:[function(require,module,exports){
"use strict"

var convexHull1d = require('./lib/ch1d')
var convexHull2d = require('./lib/ch2d')
var convexHullnd = require('./lib/chnd')

module.exports = convexHull

function convexHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  } else if(n === 1) {
    return [[0]]
  }
  var d = points[0].length
  if(d === 0) {
    return []
  } else if(d === 1) {
    return convexHull1d(points)
  } else if(d === 2) {
    return convexHull2d(points)
  }
  return convexHullnd(points, d)
}
},{"./lib/ch1d":141,"./lib/ch2d":142,"./lib/chnd":143}],141:[function(require,module,exports){
"use strict"

module.exports = convexHull1d

function convexHull1d(points) {
  var lo = 0
  var hi = 0
  for(var i=1; i<points.length; ++i) {
    if(points[i][0] < points[lo][0]) {
      lo = i
    }
    if(points[i][0] > points[hi][0]) {
      hi = i
    }
  }
  if(lo < hi) {
    return [[lo], [hi]]
  } else if(lo > hi) {
    return [[hi], [lo]]
  } else {
    return [[lo]]
  }
}
},{}],142:[function(require,module,exports){
'use strict'

module.exports = convexHull2D

var monotoneHull = require('monotone-convex-hull-2d')

function convexHull2D(points) {
  var hull = monotoneHull(points)
  var h = hull.length
  if(h <= 2) {
    return []
  }
  var edges = new Array(h)
  var a = hull[h-1]
  for(var i=0; i<h; ++i) {
    var b = hull[i]
    edges[i] = [a,b]
    a = b
  }
  return edges
}

},{"monotone-convex-hull-2d":168}],143:[function(require,module,exports){
'use strict'

module.exports = convexHullnD

var ich = require('incremental-convex-hull')
var aff = require('affine-hull')

function permute(points, front) {
  var n = points.length
  var npoints = new Array(n)
  for(var i=0; i<front.length; ++i) {
    npoints[i] = points[front[i]]
  }
  var ptr = front.length
  for(var i=0; i<n; ++i) {
    if(front.indexOf(i) < 0) {
      npoints[ptr++] = points[i]
    }
  }
  return npoints
}

function invPermute(cells, front) {
  var nc = cells.length
  var nf = front.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var x = c[j]
      if(x < nf) {
        c[j] = front[x]
      } else {
        x = x - nf
        for(var k=0; k<nf; ++k) {
          if(x >= front[k]) {
            x += 1
          }
        }
        c[j] = x
      }
    }
  }
  return cells
}

function convexHullnD(points, d) {
  try {
    return ich(points, true)
  } catch(e) {
    //If point set is degenerate, try to find a basis and rerun it
    var ah = aff(points)
    if(ah.length <= d) {
      //No basis, no try
      return []
    }
    var npoints = permute(points, ah)
    var nhull   = ich(npoints, true)
    return invPermute(nhull, ah)
  }
}
},{"affine-hull":136,"incremental-convex-hull":163}],144:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":145,"_process":172}],145:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":169}],146:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":147,"./lib/keys.js":148}],147:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],148:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],149:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],150:[function(require,module,exports){
module.exports = Extent;

function Extent() {
    if (!(this instanceof Extent)) {
        return new Extent();
    }
    this._bbox = [Infinity, Infinity, -Infinity, -Infinity];
    this._valid = false;
}

Extent.prototype.include = function(ll) {
    this._valid = true;
    this._bbox[0] = Math.min(this._bbox[0], ll[0]);
    this._bbox[1] = Math.min(this._bbox[1], ll[1]);
    this._bbox[2] = Math.max(this._bbox[2], ll[0]);
    this._bbox[3] = Math.max(this._bbox[3], ll[1]);
    return this;
};

Extent.prototype.union = function(other) {
    this._valid = true;
    this._bbox[0] = Math.min(this._bbox[0], other[0]);
    this._bbox[1] = Math.min(this._bbox[1], other[1]);
    this._bbox[2] = Math.max(this._bbox[2], other[2]);
    this._bbox[3] = Math.max(this._bbox[3], other[3]);
    return this;
};

Extent.prototype.bbox = function() {
    if (!this._valid) return null;
    return this._bbox;
};

Extent.prototype.contains = function(ll) {
    if (!this._valid) return null;
    return this._bbox[0] <= ll[0] &&
        this._bbox[1] <= ll[1] &&
        this._bbox[2] >= ll[0] &&
        this._bbox[3] >= ll[1];
};

Extent.prototype.polygon = function() {
    if (!this._valid) return null;
    return {
        type: 'Polygon',
        coordinates: [
            [
                // W, S
                [this._bbox[0], this._bbox[1]],
                // E, S
                [this._bbox[2], this._bbox[1]],
                // E, N
                [this._bbox[2], this._bbox[3]],
                // W, N
                [this._bbox[0], this._bbox[3]],
                // W, S
                [this._bbox[0], this._bbox[1]]
            ]
        ]
    };
};

},{}],151:[function(require,module,exports){
module.exports = function flatten(list, depth) {
    return _flatten(list);

    function _flatten(list) {
        if (Array.isArray(list) && list.length &&
            typeof list[0] === 'number') {
            return [list];
        }
        return list.reduce(function (acc, item) {
            if (Array.isArray(item) && Array.isArray(item[0])) {
                return acc.concat(_flatten(item));
            } else {
                acc.push(item);
                return acc;
            }
        }, []);
    }
};

},{}],152:[function(require,module,exports){
var geojsonNormalize = require('geojson-normalize'),
    geojsonFlatten = require('geojson-flatten'),
    flatten = require('./flatten');

module.exports = function(_) {
    if (!_) return [];
    var normalized = geojsonFlatten(geojsonNormalize(_)),
        coordinates = [];
    normalized.features.forEach(function(feature) {
        if (!feature.geometry) return;
        coordinates = coordinates.concat(flatten(feature.geometry.coordinates));
    });
    return coordinates;
};

},{"./flatten":151,"geojson-flatten":154,"geojson-normalize":155}],153:[function(require,module,exports){
var geojsonCoords = require('geojson-coords'),
    traverse = require('traverse'),
    extent = require('extent');

module.exports = function(_) {
    return getExtent(_).bbox();
};

module.exports.polygon = function(_) {
    return getExtent(_).polygon();
};

module.exports.bboxify = function(_) {
    return traverse(_).map(function(value) {
        if (value && typeof value.type === 'string') {
            value.bbox = getExtent(value).bbox();
            this.update(value);
        }
    });
};

function getExtent(_) {
    var bbox = [Infinity, Infinity, -Infinity, -Infinity],
        ext = extent(),
        coords = geojsonCoords(_);
    for (var i = 0; i < coords.length; i++) ext.include(coords[i]);
    return ext;
}

},{"extent":150,"geojson-coords":152,"traverse":186}],154:[function(require,module,exports){
module.exports = flatten;

function flatten(gj, up) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.reduce(function(mem, feature) {
                return mem.concat(flatten(feature));
            }, []);
            return gj;
        case 'Feature':
            return flatten(gj.geometry).map(function(geom) {
                return {
                    type: 'Feature',
                    properties: JSON.parse(JSON.stringify(gj.properties)),
                    geometry: geom
                };
            });
        case 'MultiPoint':
            return gj.coordinates.map(function(_) {
                return { type: 'Point', coordinates: _ };
            });
        case 'MultiPolygon':
            return gj.coordinates.map(function(_) {
                return { type: 'Polygon', coordinates: _ };
            });
        case 'MultiLineString':
            return gj.coordinates.map(function(_) {
                return { type: 'LineString', coordinates: _ };
            });
        case 'GeometryCollection':
            return gj.geometries;
        case 'Point':
        case 'Polygon':
        case 'LineString':
            return [gj];
        default:
            return gj;
    }
}

},{}],155:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"dup":3}],156:[function(require,module,exports){
// Find self-intersections in geojson polygon (possibly with interior rings)
var rbush = require('rbush');

module.exports = function(feature, filterFn, useSpatialIndex) {
  if (feature.geometry.type != "Polygon") throw new Error("The input feature must be a Polygon");
  if (!useSpatialIndex) useSpatialIndex = 1;

  var coord = feature.geometry.coordinates;

  var output = [];
  var seen = {};

  if (useSpatialIndex) {
    var allEdgesAsRbushTreeItems = [];
    for (var ring0 = 0; ring0 < coord.length; ring0++) {
      for (var edge0 = 0; edge0 < coord[ring0].length-1; edge0++) {
        allEdgesAsRbushTreeItems.push(rbushTreeItem(ring0, edge0))
      }
    }
    var tree = rbush();
    tree.load(allEdgesAsRbushTreeItems);
  }

  for (var ring0 = 0; ring0 < coord.length; ring0++) {
    for (var edge0 = 0; edge0 < coord[ring0].length-1; edge0++) {
      if (useSpatialIndex) {
        var bboxOverlaps = tree.search(rbushTreeItem(ring0, edge0));
        bboxOverlaps.forEach(function(bboxIsect) {
          var ring1 = bboxIsect.ring;
          var edge1 = bboxIsect.edge;
          ifIsectAddToOutput(ring0, edge0, ring1, edge1);
        });
      }
      else {
        for (var ring1 = 0; ring1 < coord.length; ring1++) {
          for (var edge1 = 0 ; edge1 < coord[ring1].length-1; edge1++) {
            // TODO: speedup possible if only interested in unique: start last two loops at ring0 and edge0+1
            ifIsectAddToOutput(ring0, edge0, ring1, edge1);
          }
        }
      }
    }
  }

  if (!filterFn) output = {type: "Feature", geometry: {type: "MultiPoint", coordinates: output}};
  return output;

  // Function to check if two edges intersect and add the intersection to the output
  function ifIsectAddToOutput(ring0, edge0, ring1, edge1) {
    var start0 = coord[ring0][edge0];
    var end0 = coord[ring0][edge0+1];
    var start1 = coord[ring1][edge1];
    var end1 = coord[ring1][edge1+1];

    var isect = intersect(start0, end0, start1, end1);

    if (isect == null) return; // discard parallels and coincidence
    var frac0 = (isect[0]-start0[0])/(end0[0]-start0[0]);
    var frac1 = (isect[0]-start1[0])/(end1[0]-start1[0]);
    if (frac0 >= 1 || frac0 <= 0 || frac1 >= 1 || frac1 <= 0) return; // require segment intersection

    var key = isect;
    var unique = !seen[key];
    if (unique) {
      seen[key] = true;
    }

    if (filterFn) {
      output.push(filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique));
    } else {
      output.push(isect);
    }
  }

  // Function to return a rbush tree item given an ring and edge number
  function rbushTreeItem(ring, edge) {

    var start = coord[ring][edge];
    var end = coord[ring][edge+1];

    if (start[0] < end[0]) {
      var minX = start[0], maxX = end[0];
    } else {
      var minX = end[0], maxX = start[0];
    };
    if (start[1] < end[1]) {
      var minY = start[1], maxY = end[1];
    } else {
      var minY = end[1], maxY = start[1];
    }
    return {minX: minX, minY: minY, maxX: maxX, maxY: maxY, ring: ring, edge: edge};
  }

}

// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
function intersect(start0, end0, start1, end1) {
  if (equalArrays(start0,start1) || equalArrays(start0,end1) || equalArrays(end0,start1) || equalArrays(end1,start1)) return null;
  var x0 = start0[0],
      y0 = start0[1],
      x1 = end0[0],
      y1 = end0[1],
      x2 = start1[0],
      y2 = start1[1],
      x3 = end1[0],
      y3 = end1[1];
  var denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
  if (denom == 0) return null;
  var x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
  var y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
  return [x4, y4];
}

// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
function equalArrays(array1, array2) {
    // if the other array is a falsy value, return
    if (!array1 || !array2)
        return false;

    // compare lengths - can save a lot of time
    if (array1.length != array2.length)
        return false;

    for (var i = 0, l=array1.length; i < l; i++) {
        // Check if we have nested arrays
        if (array1[i] instanceof Array && array2[i] instanceof Array) {
            // recurse into the nested arrays
            if (!equalArrays(array1[i],array2[i]))
                return false;
        }
        else if (array1[i] != array2[i]) {
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;
        }
    }
    return true;
}

},{"rbush":174}],157:[function(require,module,exports){
module.exports = function() {
    throw new Error('call .point() or .polygon() instead');
};

function position(bbox) {
    if (bbox) return coordInBBBOX(bbox);
    else return [lon(), lat()];
}

module.exports.position = position;

module.exports.point = function(count, bbox) {
    var features = [];
    for (i = 0; i < count; i++) {
        features.push(feature(bbox ? point(position(bbox)) : point()));
    }
    return collection(features);
};

module.exports.polygon = function(count, num_vertices, max_radial_length, bbox) {
    if (typeof num_vertices !== 'number') num_vertices = 10;
    if (typeof max_radial_length !== 'number') max_radial_length = 10;
    var features = [];
    for (i = 0; i < count; i++) {
        var vertices = [],
            circle_offsets = Array.apply(null,
                new Array(num_vertices + 1)).map(Math.random);

        circle_offsets.forEach(sumOffsets);
        circle_offsets.forEach(scaleOffsets);
        vertices[vertices.length - 1] = vertices[0]; // close the ring

        // center the polygon around something
        vertices = vertices.map(vertexToCoordinate(position(bbox)));
        features.push(feature(polygon([vertices])));
    }

    function sumOffsets(cur, index, arr) {
        arr[index] = (index > 0) ? cur + arr[index - 1] : cur;
    }

    function scaleOffsets(cur, index) {
        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];
        var radial_scaler = Math.random();
        vertices.push([
            radial_scaler * max_radial_length * Math.sin(cur),
            radial_scaler * max_radial_length * Math.cos(cur)
        ]);
    }

    return collection(features);
};


function vertexToCoordinate(hub) {
    return function(cur, index) { return [cur[0] + hub[0], cur[1] + hub[1]]; };
}

function rnd() { return Math.random() - 0.5; }
function lon() { return rnd() * 360; }
function lat() { return rnd() * 180; }

function point(coordinates) {
    return {
        type: 'Point',
        coordinates: coordinates || [lon(), lat()]
    };
}

function coordInBBBOX(bbox) {
    return [
        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],
        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]];
}

function pointInBBBOX() {
    return {
        type: 'Point',
        coordinates: [lon(), lat()]
    };
}

function polygon(coordinates) {
    return {
        type: 'Polygon',
        coordinates: coordinates
    };
}

function feature(geom) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: {}
    };
}

function collection(f) {
    return {
        type: 'FeatureCollection',
        features: f
    };
}

},{}],158:[function(require,module,exports){
var turfBBox = require('@turf/bbox');
var featureCollection = require('@turf/helpers').featureCollection;
var featureEach = require('@turf/meta').featureEach;
var rbush = require('rbush');

/**
 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
 *
 * @name rbush
 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
 * @returns {RBush} GeoJSON RBush
 * @example
 * var rbush = require('geojson-rbush')
 * var tree = rbush()
 */
module.exports = function (maxEntries) {
    var tree = rbush(maxEntries);
    /**
     * [insert](https://github.com/mourner/rbush#data-format)
     *
     * @param {Feature<any>} feature insert single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.insert(polygon)
     */
    tree.insert = function (feature) {
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.insert.call(this, feature);
    };

    /**
     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
     *
     * @param {FeatureCollection<any>} features load entire GeoJSON FeatureCollection
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polygons = {
     *   "type": "FeatureCollection",
     *   "features": [
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Polygon",
     *         "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *       }
     *     },
     *     {
     *       "type": "Feature",
     *       "properties": {},
     *       "geometry": {
     *         "type": "Polygon",
     *         "coordinates": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
     *       }
     *     }
     *   ]
     * }
     * tree.load(polygons)
     */
    tree.load = function (features) {
        var load = [];
        featureEach(features, function (feature) {
            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
            load.push(feature);
        });
        return rbush.prototype.load.call(this, load);
    };

    /**
     * [remove](https://github.com/mourner/rbush#removing-data)
     *
     * @param {Feature<any>} feature remove single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.remove(polygon)
     */
    tree.remove = function (feature) {
        return rbush.prototype.remove.call(this, feature);
    };

    /**
     * [clear](https://github.com/mourner/rbush#removing-data)
     *
     * @returns {RBush} GeoJSON Rbush
     * @example
     * tree.clear()
     */
    tree.clear = function () {
        return rbush.prototype.clear.call(this);
    };

    /**
     * [search](https://github.com/mourner/rbush#search)
     *
     * @param {FeatureCollection|Feature<any>} geojson search with GeoJSON
     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.search(polygon)
     */
    tree.search = function (geojson) {
        var search = rbush.prototype.search.call(this, this.toBBox(geojson));
        return featureCollection(search);
    };

    /**
     * [collides](https://github.com/mourner/rbush#collisions)
     *
     * @param {FeatureCollection|Feature<any>} geojson collides with GeoJSON
     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
     * @example
     * var polygon = {
     *   "type": "Feature",
     *   "properties": {},
     *   "geometry": {
     *     "type": "Polygon",
     *     "coordinates": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]
     *   }
     * }
     * tree.collides(polygon)
     */
    tree.collides = function (geojson) {
        return rbush.prototype.collides.call(this, this.toBBox(geojson));
    };

    /**
     * [all](https://github.com/mourner/rbush#search)
     *
     * @returns {FeatureCollection<any>} all the features in RBush
     * @example
     * tree.all()
     * //=FeatureCollection
     */
    tree.all = function () {
        var all = rbush.prototype.all.call(this);
        return featureCollection(all);
    };

    /**
     * [toJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @returns {any} export data as JSON object
     * @example
     * var exported = tree.toJSON()
     * //=JSON object
     */
    tree.toJSON = function () {
        return rbush.prototype.toJSON.call(this);
    };

    /**
     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @param {any} json import previously exported data
     * @returns {RBush} GeoJSON RBush
     * @example
     * var exported = {
     *   "children": [
     *     {
     *       "type": "Feature",
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [110, 50]
     *       },
     *       "properties": {},
     *       "bbox": [110, 50, 110, 50]
     *     }
     *   ],
     *   "height": 1,
     *   "leaf": true,
     *   "minX": 110,
     *   "minY": 50,
     *   "maxX": 110,
     *   "maxY": 50
     * }
     * tree.fromJSON(exported)
     */
    tree.fromJSON = function (json) {
        return rbush.prototype.fromJSON.call(this, json);
    };

    /**
     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
     *
     * @private
     * @param {FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from
     * @returns {Object} converted to {minX, minY, maxX, maxY}
     */
    tree.toBBox = function (geojson) {
        var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson);
        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
};

},{"@turf/bbox":159,"@turf/helpers":53,"@turf/meta":96,"rbush":174}],159:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"@turf/meta":96,"dup":13}],160:[function(require,module,exports){
(function () {
  var gju = this.gju = {};

  // Export the geojson object for **CommonJS**
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = gju;
  }

  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js
  gju.lineStringsIntersect = function (l1, l2) {
    var intersects = [];
    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {
      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {
        var a1 = {
          x: l1.coordinates[i][1],
          y: l1.coordinates[i][0]
        },
          a2 = {
            x: l1.coordinates[i + 1][1],
            y: l1.coordinates[i + 1][0]
          },
          b1 = {
            x: l2.coordinates[j][1],
            y: l2.coordinates[j][0]
          },
          b2 = {
            x: l2.coordinates[j + 1][1],
            y: l2.coordinates[j + 1][0]
          },
          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
        if (u_b != 0) {
          var ua = ua_t / u_b,
            ub = ub_t / u_b;
          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
            intersects.push({
              'type': 'Point',
              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]
            });
          }
        }
      }
    }
    if (intersects.length == 0) intersects = false;
    return intersects;
  }

  // Bounding Box

  function boundingBoxAroundPolyCoords (coords) {
    var xAll = [], yAll = []

    for (var i = 0; i < coords[0].length; i++) {
      xAll.push(coords[0][i][1])
      yAll.push(coords[0][i][0])
    }

    xAll = xAll.sort(function (a,b) { return a - b })
    yAll = yAll.sort(function (a,b) { return a - b })

    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]
  }

  gju.pointInBoundingBox = function (point, bounds) {
    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) 
  }

  // Point in Polygon
  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices

  function pnpoly (x,y,coords) {
    var vert = [ [0,0] ]

    for (var i = 0; i < coords.length; i++) {
      for (var j = 0; j < coords[i].length; j++) {
        vert.push(coords[i][j])
      }
	  vert.push(coords[i][0])
      vert.push([0,0])
    }

    var inside = false
    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {
      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside
    }

    return inside
  }

  gju.pointInPolygon = function (p, poly) {
    var coords = (poly.type == "Polygon") ? [ poly.coordinates ] : poly.coordinates

    var insideBox = false
    for (var i = 0; i < coords.length; i++) {
      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true
    }
    if (!insideBox) return false

    var insidePoly = false
    for (var i = 0; i < coords.length; i++) {
      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true
    }

    return insidePoly
  }

  // support multi (but not donut) polygons
  gju.pointInMultiPolygon = function (p, poly) {
    var coords_array = (poly.type == "MultiPolygon") ? [ poly.coordinates ] : poly.coordinates

    var insideBox = false
    var insidePoly = false
    for (var i = 0; i < coords_array.length; i++){
      var coords = coords_array[i];
      for (var j = 0; j < coords.length; j++) {
        if (!insideBox){
          if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[j]))) {
            insideBox = true
          }
        }
      }
      if (!insideBox) return false
      for (var j = 0; j < coords.length; j++) {
        if (!insidePoly){
          if (pnpoly(p.coordinates[1], p.coordinates[0], coords[j])) {
            insidePoly = true
          }
        }
      }
    }

    return insidePoly
  }

  gju.numberToRadius = function (number) {
    return number * Math.PI / 180;
  }

  gju.numberToDegree = function (number) {
    return number * 180 / Math.PI;
  }

  // written with help from @tautologe
  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {
    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],
      dist = (radiusInMeters / 1000) / 6371,
      // convert meters to radiant
      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],
      steps = steps || 15,
      // 15 sided circle
      poly = [[center[0], center[1]]];
    for (var i = 0; i < steps; i++) {
      var brng = 2 * Math.PI * i / steps;
      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)
              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));
      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),
                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));
      poly[i] = [];
      poly[i][1] = gju.numberToDegree(lat);
      poly[i][0] = gju.numberToDegree(lng);
    }
    return {
      "type": "Polygon",
      "coordinates": [poly]
    };
  }

  // assumes rectangle starts at lower left point
  gju.rectangleCentroid = function (rectangle) {
    var bbox = rectangle.coordinates[0];
    var xmin = bbox[0][0],
      ymin = bbox[0][1],
      xmax = bbox[2][0],
      ymax = bbox[2][1];
    var xwidth = xmax - xmin;
    var ywidth = ymax - ymin;
    return {
      'type': 'Point',
      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]
    };
  }

  // from http://www.movable-type.co.uk/scripts/latlong.html
  gju.pointDistance = function (pt1, pt2) {
    var lon1 = pt1.coordinates[0],
      lat1 = pt1.coordinates[1],
      lon2 = pt2.coordinates[0],
      lat2 = pt2.coordinates[1],
      dLat = gju.numberToRadius(lat2 - lat1),
      dLon = gju.numberToRadius(lon2 - lon1),
      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))
        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),
      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return (6371 * c) * 1000; // returns meters
  },

  // checks if geometry lies entirely within a circle
  // works with Point, LineString, Polygon
  gju.geometryWithinRadius = function (geometry, center, radius) {
    if (geometry.type == 'Point') {
      return gju.pointDistance(geometry, center) <= radius;
    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {
      var point = {};
      var coordinates;
      if (geometry.type == 'Polygon') {
        // it's enough to check the exterior ring of the Polygon
        coordinates = geometry.coordinates[0];
      } else {
        coordinates = geometry.coordinates;
      }
      for (var i in coordinates) {
        point.coordinates = coordinates[i];
        if (gju.pointDistance(point, center) > radius) {
          return false;
        }
      }
    }
    return true;
  }

  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
  gju.area = function (polygon) {
    var area = 0;
    // TODO: polygon holes at coordinates[1]
    var points = polygon.coordinates[0];
    var j = points.length - 1;
    var p1, p2;

    for (var i = 0; i < points.length; j = i++) {
      var p1 = {
        x: points[i][1],
        y: points[i][0]
      };
      var p2 = {
        x: points[j][1],
        y: points[j][0]
      };
      area += p1.x * p2.y;
      area -= p1.y * p2.x;
    }

    area /= 2;
    return area;
  },

  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
  gju.centroid = function (polygon) {
    var f, x = 0,
      y = 0;
    // TODO: polygon holes at coordinates[1]
    var points = polygon.coordinates[0];
    var j = points.length - 1;
    var p1, p2;

    for (var i = 0; i < points.length; j = i++) {
      var p1 = {
        x: points[i][1],
        y: points[i][0]
      };
      var p2 = {
        x: points[j][1],
        y: points[j][0]
      };
      f = p1.x * p2.y - p2.x * p1.y;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
    }

    f = gju.area(polygon) * 6;
    return {
      'type': 'Point',
      'coordinates': [y / f, x / f]
    };
  },

  gju.simplify = function (source, kink) { /* source[] array of geojson points */
    /* kink	in metres, kinks above this depth kept  */
    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */
    kink = kink || 20;
    source = source.map(function (o) {
      return {
        lng: o.coordinates[0],
        lat: o.coordinates[1]
      }
    });

    var n_source, n_stack, n_dest, start, end, i, sig;
    var dev_sqr, max_dev_sqr, band_sqr;
    var x12, y12, d12, x13, y13, d13, x23, y23, d23;
    var F = (Math.PI / 180.0) * 0.5;
    var index = new Array(); /* aray of indexes of source points to include in the reduced line */
    var sig_start = new Array(); /* indices of start & end of working section */
    var sig_end = new Array();

    /* check for simple cases */

    if (source.length < 3) return (source); /* one or two points */

    /* more complex case. initialize stack */

    n_source = source.length;
    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */
    band_sqr *= band_sqr;
    n_dest = 0;
    sig_start[0] = 0;
    sig_end[0] = n_source - 1;
    n_stack = 1;

    /* while the stack is not empty  ... */
    while (n_stack > 0) {

      /* ... pop the top-most entries off the stacks */

      start = sig_start[n_stack - 1];
      end = sig_end[n_stack - 1];
      n_stack--;

      if ((end - start) > 1) { /* any intermediate points ? */

        /* ... yes, so find most deviant intermediate point to
        either side of line joining start & end points */

        x12 = (source[end].lng() - source[start].lng());
        y12 = (source[end].lat() - source[start].lat());
        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);
        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */
        d12 = (x12 * x12) + (y12 * y12);

        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {

          x13 = source[i].lng() - source[start].lng();
          y13 = source[i].lat() - source[start].lat();
          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);
          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));
          d13 = (x13 * x13) + (y13 * y13);

          x23 = source[i].lng() - source[end].lng();
          y23 = source[i].lat() - source[end].lat();
          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);
          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));
          d23 = (x23 * x23) + (y23 * y23);

          if (d13 >= (d12 + d23)) dev_sqr = d23;
          else if (d23 >= (d12 + d13)) dev_sqr = d13;
          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle
          if (dev_sqr > max_dev_sqr) {
            sig = i;
            max_dev_sqr = dev_sqr;
          }
        }

        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */
          /* ... no, so transfer current start point */
          index[n_dest] = start;
          n_dest++;
        } else { /* ... yes, so push two sub-sections on stack for further processing */
          n_stack++;
          sig_start[n_stack - 1] = sig;
          sig_end[n_stack - 1] = end;
          n_stack++;
          sig_start[n_stack - 1] = start;
          sig_end[n_stack - 1] = sig;
        }
      } else { /* ... no intermediate points, so transfer current start point */
        index[n_dest] = start;
        n_dest++;
      }
    }

    /* transfer last point */
    index[n_dest] = n_source - 1;
    n_dest++;

    /* make return array */
    var r = new Array();
    for (var i = 0; i < n_dest; i++)
      r.push(source[index[i]]);

    return r.map(function (o) {
      return {
        type: "Point",
        coordinates: [o.lng, o.lat]
      }
    });
  }

  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint
  gju.destinationPoint = function (pt, brng, dist) {
    dist = dist/6371;  // convert dist to angular distance in radians
    brng = gju.numberToRadius(brng);

    var lon1 = gju.numberToRadius(pt.coordinates[0]);
    var lat1 = gju.numberToRadius(pt.coordinates[1]);

    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +
                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),
                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180

    return {
      'type': 'Point',
      'coordinates': [gju.numberToDegree(lon2), gju.numberToDegree(lat2)]
    };
  };

})();

},{}],161:[function(require,module,exports){
/**
* @license get-closest https://github.com/cosmosio/get-closest
*
* The MIT License (MIT)
*
* Copyright (c) 2014-2017 Olivier Scherrer <pode.fr@gmail.com>
*/
"use strict";

/**
 * Get the closest number in an array
 * @param {Number} item the base number
 * @param {Array} array the array to search into
 * @param {Function} getDiff returns the difference between the base number and
 *   and the currently read item in the array. The item which returned the smallest difference wins.
 * @private
 */
function _getClosest(item, array, getDiff) {
    var closest,
        diff;

    if (!Array.isArray(array)) {
        throw new Error("Get closest expects an array as second argument");
    }

    array.forEach(function (comparedItem, comparedItemIndex) {
        var thisDiff = getDiff(comparedItem, item);

        if (thisDiff >= 0 && (typeof diff == "undefined" || thisDiff < diff)) {
            diff = thisDiff;
            closest = comparedItemIndex;
        }
    });

    return closest;
}

module.exports = {

  /**
   * Get the closest number in an array given a base number
   * Example: closest(30, [20, 0, 50, 29]) will return 3 as 29 is the closest item
   * @param {Number} item the base number
   * @param {Array} array the array of numbers to search into
   * @returns {Number} the index of the closest item in the array
   */
  number: function closestNumber(item, array) {
      return _getClosest(item, array, function (comparedItem, item) {
          return Math.abs(comparedItem - item);
      });
  },

  /**
   * Get the closest greater number in an array given a base number
   * Example: closest(30, [20, 0, 50, 29]) will return 2 as 50 is the closest greater item
   * @param {Number} item the base number
   * @param {Array} array the array of numbers to search into
   * @returns {Number} the index of the closest item in the array
   */
  greaterNumber: function closestGreaterNumber(item, array) {
      return _getClosest(item, array, function (comparedItem, item) {
          return comparedItem - item;
      });
  },

  /**
   * Get the closest lower number in an array given a base number
   * Example: closest(30, [20, 0, 50, 29]) will return 0 as 20 is the closest lower item
   * @param {Number} item the base number
   * @param {Array} array the array of numbers to search into
   * @returns {Number} the index of the closest item in the array
   */
  lowerNumber: function closestLowerNumber(item, array) {
    return _getClosest(item, array, function (comparedItem, item) {
        return item - comparedItem;
    });
  },

  /**
   * Get the closest item in an array given a base item and a comparator function
   * Example (closest("lundi", ["mundi", "mardi"], getLevenshteinDistance)) will return 0 for "lundi"
   * @param {*} item the base item
   * @param {Array} array an array of items
   * @param {Function} comparator a comparatof function to compare the items
   *
   * The function looks like:
   *
   * // comparedItem comes from the array
   * // baseItem is the item to compare the others to
   * // It returns a number
   * function comparator(comparedItem, baseItem) {
   *     return comparedItem - baseItem;
   * }
   */
  custom: function closestCustom(item, array, comparator) {
    return _getClosest(item, array, comparator);
  }

};

},{}],162:[function(require,module,exports){
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};

},{}],163:[function(require,module,exports){
"use strict"

//High level idea:
// 1. Use Clarkson's incremental construction to find convex hull
// 2. Point location in triangulation by jump and walk

module.exports = incrementalConvexHull

var orient = require("robust-orientation")
var compareCell = require("simplicial-complex").compareCells

function compareInt(a, b) {
  return a - b
}

function Simplex(vertices, adjacent, boundary) {
  this.vertices = vertices
  this.adjacent = adjacent
  this.boundary = boundary
  this.lastVisited = -1
}

Simplex.prototype.flip = function() {
  var t = this.vertices[0]
  this.vertices[0] = this.vertices[1]
  this.vertices[1] = t
  var u = this.adjacent[0]
  this.adjacent[0] = this.adjacent[1]
  this.adjacent[1] = u
}

function GlueFacet(vertices, cell, index) {
  this.vertices = vertices
  this.cell = cell
  this.index = index
}

function compareGlue(a, b) {
  return compareCell(a.vertices, b.vertices)
}

function bakeOrient(d) {
  var code = ["function orient(){var tuple=this.tuple;return test("]
  for(var i=0; i<=d; ++i) {
    if(i > 0) {
      code.push(",")
    }
    code.push("tuple[", i, "]")
  }
  code.push(")}return orient")
  var proc = new Function("test", code.join(""))
  var test = orient[d+1]
  if(!test) {
    test = orient
  }
  return proc(test)
}

var BAKED = []

function Triangulation(dimension, vertices, simplices) {
  this.dimension = dimension
  this.vertices = vertices
  this.simplices = simplices
  this.interior = simplices.filter(function(c) {
    return !c.boundary
  })

  this.tuple = new Array(dimension+1)
  for(var i=0; i<=dimension; ++i) {
    this.tuple[i] = this.vertices[i]
  }

  var o = BAKED[dimension]
  if(!o) {
    o = BAKED[dimension] = bakeOrient(dimension)
  }
  this.orient = o
}

var proto = Triangulation.prototype

//Degenerate situation where we are on boundary, but coplanar to face
proto.handleBoundaryDegeneracy = function(cell, point) {
  var d = this.dimension
  var n = this.vertices.length - 1
  var tuple = this.tuple
  var verts = this.vertices

  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate
  var toVisit = [ cell ]
  cell.lastVisited = -n
  while(toVisit.length > 0) {
    cell = toVisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited <= -n) {
        continue
      }
      var nv = neighbor.vertices
      for(var j=0; j<=d; ++j) {
        var vv = nv[j]
        if(vv < 0) {
          tuple[j] = point
        } else {
          tuple[j] = verts[vv]
        }
      }
      var o = this.orient()
      if(o > 0) {
        return neighbor
      }
      neighbor.lastVisited = -n
      if(o === 0) {
        toVisit.push(neighbor)
      }
    }
  }
  return null
}

proto.walk = function(point, random) {
  //Alias local properties
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple

  //Compute initial jump cell
  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)
  var cell = this.interior[ initIndex ]

  //Start walking
outerLoop:
  while(!cell.boundary) {
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent

    for(var i=0; i<=d; ++i) {
      tuple[i] = verts[cellVerts[i]]
    }
    cell.lastVisited = n

    //Find farthest adjacent cell
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(neighbor.lastVisited >= n) {
        continue
      }
      var prev = tuple[i]
      tuple[i] = point
      var o = this.orient()
      tuple[i] = prev
      if(o < 0) {
        cell = neighbor
        continue outerLoop
      } else {
        if(!neighbor.boundary) {
          neighbor.lastVisited = n
        } else {
          neighbor.lastVisited = -n
        }
      }
    }
    return
  }

  return cell
}

proto.addPeaks = function(point, cell) {
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple
  var interior = this.interior
  var simplices = this.simplices

  //Walking finished at boundary, time to add peaks
  var tovisit = [ cell ]

  //Stretch initial boundary cell into a peak
  cell.lastVisited = n
  cell.vertices[cell.vertices.indexOf(-1)] = n
  cell.boundary = false
  interior.push(cell)

  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done
  var glueFacets = []

  //Do a traversal of the boundary walking outward from starting peak
  while(tovisit.length > 0) {
    //Pop off peak and walk over adjacent cells
    var cell = tovisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    var indexOfN = cellVerts.indexOf(n)
    if(indexOfN < 0) {
      continue
    }

    for(var i=0; i<=d; ++i) {
      if(i === indexOfN) {
        continue
      }

      //For each boundary neighbor of the cell
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited >= n) {
        continue
      }

      var nv = neighbor.vertices

      //Test if neighbor is a peak
      if(neighbor.lastVisited !== -n) {      
        //Compute orientation of p relative to each boundary peak
        var indexOfNeg1 = 0
        for(var j=0; j<=d; ++j) {
          if(nv[j] < 0) {
            indexOfNeg1 = j
            tuple[j] = point
          } else {
            tuple[j] = verts[nv[j]]
          }
        }
        var o = this.orient()

        //Test if neighbor cell is also a peak
        if(o > 0) {
          nv[indexOfNeg1] = n
          neighbor.boundary = false
          interior.push(neighbor)
          tovisit.push(neighbor)
          neighbor.lastVisited = n
          continue
        } else {
          neighbor.lastVisited = -n
        }
      }

      var na = neighbor.adjacent

      //Otherwise, replace neighbor with new face
      var vverts = cellVerts.slice()
      var vadj = cellAdj.slice()
      var ncell = new Simplex(vverts, vadj, true)
      simplices.push(ncell)

      //Connect to neighbor
      var opposite = na.indexOf(cell)
      if(opposite < 0) {
        continue
      }
      na[opposite] = ncell
      vadj[indexOfN] = neighbor

      //Connect to cell
      vverts[i] = -1
      vadj[i] = cell
      cellAdj[i] = ncell

      //Flip facet
      ncell.flip()

      //Add to glue list
      for(var j=0; j<=d; ++j) {
        var uu = vverts[j]
        if(uu < 0 || uu === n) {
          continue
        }
        var nface = new Array(d-1)
        var nptr = 0
        for(var k=0; k<=d; ++k) {
          var vv = vverts[k]
          if(vv < 0 || k === j) {
            continue
          }
          nface[nptr++] = vv
        }
        glueFacets.push(new GlueFacet(nface, ncell, j))
      }
    }
  }

  //Glue boundary facets together
  glueFacets.sort(compareGlue)

  for(var i=0; i+1<glueFacets.length; i+=2) {
    var a = glueFacets[i]
    var b = glueFacets[i+1]
    var ai = a.index
    var bi = b.index
    if(ai < 0 || bi < 0) {
      continue
    }
    a.cell.adjacent[a.index] = b.cell
    b.cell.adjacent[b.index] = a.cell
  }
}

proto.insert = function(point, random) {
  //Add point
  var verts = this.vertices
  verts.push(point)

  var cell = this.walk(point, random)
  if(!cell) {
    return
  }

  //Alias local properties
  var d = this.dimension
  var tuple = this.tuple

  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary
  for(var i=0; i<=d; ++i) {
    var vv = cell.vertices[i]
    if(vv < 0) {
      tuple[i] = point
    } else {
      tuple[i] = verts[vv]
    }
  }
  var o = this.orient(tuple)
  if(o < 0) {
    return
  } else if(o === 0) {
    cell = this.handleBoundaryDegeneracy(cell, point)
    if(!cell) {
      return
    }
  }

  //Add peaks
  this.addPeaks(point, cell)
}

//Extract all boundary cells
proto.boundary = function() {
  var d = this.dimension
  var boundary = []
  var cells = this.simplices
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.boundary) {
      var bcell = new Array(d)
      var cv = c.vertices
      var ptr = 0
      var parity = 0
      for(var j=0; j<=d; ++j) {
        if(cv[j] >= 0) {
          bcell[ptr++] = cv[j]
        } else {
          parity = j&1
        }
      }
      if(parity === (d&1)) {
        var t = bcell[0]
        bcell[0] = bcell[1]
        bcell[1] = t
      }
      boundary.push(bcell)
    }
  }
  return boundary
}

function incrementalConvexHull(points, randomSearch) {
  var n = points.length
  if(n === 0) {
    throw new Error("Must have at least d+1 points")
  }
  var d = points[0].length
  if(n <= d) {
    throw new Error("Must input at least d+1 points")
  }

  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process
  var initialSimplex = points.slice(0, d+1)

  //Make sure initial simplex is positively oriented
  var o = orient.apply(void 0, initialSimplex)
  if(o === 0) {
    throw new Error("Input not in general position")
  }
  var initialCoords = new Array(d+1)
  for(var i=0; i<=d; ++i) {
    initialCoords[i] = i
  }
  if(o < 0) {
    initialCoords[0] = 1
    initialCoords[1] = 0
  }

  //Create initial topological index, glue pointers together (kind of messy)
  var initialCell = new Simplex(initialCoords, new Array(d+1), false)
  var boundary = initialCell.adjacent
  var list = new Array(d+2)
  for(var i=0; i<=d; ++i) {
    var verts = initialCoords.slice()
    for(var j=0; j<=d; ++j) {
      if(j === i) {
        verts[j] = -1
      }
    }
    var t = verts[0]
    verts[0] = verts[1]
    verts[1] = t
    var cell = new Simplex(verts, new Array(d+1), true)
    boundary[i] = cell
    list[i] = cell
  }
  list[d+1] = initialCell
  for(var i=0; i<=d; ++i) {
    var verts = boundary[i].vertices
    var adj = boundary[i].adjacent
    for(var j=0; j<=d; ++j) {
      var v = verts[j]
      if(v < 0) {
        adj[j] = initialCell
        continue
      }
      for(var k=0; k<=d; ++k) {
        if(boundary[k].vertices.indexOf(v) < 0) {
          adj[j] = boundary[k]
        }
      }
    }
  }

  //Initialize triangles
  var triangles = new Triangulation(d, initialSimplex, list)

  //Insert remaining points
  var useRandom = !!randomSearch
  for(var i=d+1; i<n; ++i) {
    triangles.insert(points[i], useRandom)
  }
  
  //Extract boundary cells
  return triangles.boundary()
}
},{"robust-orientation":175,"simplicial-complex":184}],164:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var jsonlint = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,13],$V2=[1,9],$V3=[1,10],$V4=[1,11],$V5=[1,14],$V6=[1,15],$V7=[14,18,22,24],$V8=[18,22],$V9=[22,24];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 // replace escaped characters with actual character
          this.$ = yytext.replace(/\\(\\|")/g, "$"+"1")
                     .replace(/\\n/g,'\n')
                     .replace(/\\r/g,'\r')
                     .replace(/\\t/g,'\t')
                     .replace(/\\v/g,'\v')
                     .replace(/\\f/g,'\f')
                     .replace(/\\b/g,'\b');
        
break;
case 2:
this.$ = Number(yytext);
break;
case 3:
this.$ = null;
break;
case 4:
this.$ = true;
break;
case 5:
this.$ = false;
break;
case 6:
return this.$ = $$[$0-1];
break;
case 13:
this.$ = {}; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 14: case 19:
this.$ = $$[$0-1]; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 15:
this.$ = [$$[$0-2], $$[$0]];
break;
case 16:
this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
break;
case 17:

            this.$ = $$[$0-2];
            if ($$[$0-2][$$[$0][0]] !== undefined) {
                if (!this.$.__duplicateProperties__) {
                    Object.defineProperty(this.$, '__duplicateProperties__', {
                        value: [],
                        enumerable: false
                    });
                }
                this.$.__duplicateProperties__.push($$[$0][0]);
            }
            $$[$0-2][$$[$0][0]] = $$[$0][1];
        
break;
case 18:
this.$ = []; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 20:
this.$ = [$$[$0]];
break;
case 21:
this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
break;
}
},
table: [{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,12:1,13:2,15:7,16:8,17:$V5,23:$V6},{1:[3]},{14:[1,16]},o($V7,[2,7]),o($V7,[2,8]),o($V7,[2,9]),o($V7,[2,10]),o($V7,[2,11]),o($V7,[2,12]),o($V7,[2,3]),o($V7,[2,4]),o($V7,[2,5]),o([14,18,21,22,24],[2,1]),o($V7,[2,2]),{3:20,4:$V0,18:[1,17],19:18,20:19},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:23,15:7,16:8,17:$V5,23:$V6,24:[1,21],25:22},{1:[2,6]},o($V7,[2,13]),{18:[1,24],22:[1,25]},o($V8,[2,16]),{21:[1,26]},o($V7,[2,18]),{22:[1,28],24:[1,27]},o($V9,[2,20]),o($V7,[2,14]),{3:20,4:$V0,20:29},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:30,15:7,16:8,17:$V5,23:$V6},o($V7,[2,19]),{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:31,15:7,16:8,17:$V5,23:$V6},o($V8,[2,17]),o($V8,[2,15]),o($V9,[2,21])],
defaultActions: {16:[2,6]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 6
break;
case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
break;
case 3:return 17
break;
case 4:return 18
break;
case 5:return 23
break;
case 6:return 24
break;
case 7:return 22
break;
case 8:return 21
break;
case 9:return 10
break;
case 10:return 11
break;
case 11:return 8
break;
case 12:return 14
break;
case 13:return 'INVALID'
break;
}
},
rules: [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt\/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = jsonlint;
exports.Parser = jsonlint.Parser;
exports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))

},{"_process":172,"fs":138,"path":170}],165:[function(require,module,exports){
// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.jsts=t.jsts||{})}(this,function(t){"use strict";function e(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function n(){}function i(){}function r(){}function s(){}function o(){}function a(){}function u(){}function l(t){this.name="RuntimeException",this.message=t,this.stack=(new Error).stack,Error.call(this,t)}function h(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function c(){if(0===arguments.length)l.call(this);else if(1===arguments.length){var t=arguments[0];l.call(this,t)}}function f(){}function g(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.call(this,0,0);else if(1===arguments.length){var t=arguments[0];g.call(this,t.x,t.y,t.z)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];g.call(this,e,n,g.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.x=i,this.y=r,this.z=s}}function d(){if(this.dimensionsToTest=2,0===arguments.length)d.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest=t}}function p(){}function v(){}function m(t){this.message=t||""}function y(){}function x(t){this.message=t||""}function E(t){this.message=t||""}function I(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function N(){if(I.apply(this),0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}function C(){if(this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.init(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];this.init(r,s,o,a)}}function S(){}function w(){S.call(this,"Projective point not representable on the Cartesian plane.")}function L(){}function R(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1}function T(){}function P(t){this.str=t}function b(t){this.value=t}function O(){}function _(){if(this.hi=0,this.lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof _){var e=arguments[0];this.init(e)}else if("string"==typeof arguments[0]){var n=arguments[0];_.call(this,_.parse(n))}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i,r)}}function M(){}function D(){}function A(){}function F(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];this.x=e,this.y=n,this.w=1}else if(arguments[0]instanceof F&&arguments[1]instanceof F){var i=arguments[0],r=arguments[1];this.x=i.y*r.w-r.y*i.w,this.y=r.x*i.w-i.x*r.w,this.w=i.x*r.y-r.x*i.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1];this.x=s.y-o.y,this.y=o.x-s.x,this.w=s.x*o.y-o.x*s.y}}else if(3===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2];this.x=a,this.y=u,this.w=l}else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],d=arguments[3],p=h.y-c.y,v=c.x-h.x,m=h.x*c.y-c.x*h.y,y=f.y-d.y,x=d.x-f.x,E=f.x*d.y-d.x*f.y;this.x=v*E-x*m,this.y=y*m-p*E,this.w=p*x-y*v}}function G(){}function q(){}function B(){this.envelope=null,this.factory=null,this.SRID=null,this.userData=null;var t=arguments[0];this.factory=t,this.SRID=t.getSRID()}function z(){}function V(){}function k(){}function Y(){}function U(){}function X(){}function H(){}function W(){}function j(){}function K(){}function Z(){}function Q(){}function J(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function $(t){return null==t?$s:t.color}function tt(t){return null==t?null:t.parent}function et(t,e){null!==t&&(t.color=e)}function nt(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}function st(){}function ot(){}function at(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function ut(){}function lt(){}function ht(){}function ct(){}function ft(){this.geometries=null;var t=arguments[0],e=arguments[1];if(B.call(this,e),null===t&&(t=[]),B.hasNullElements(t))throw new i("geometries must not contain null elements");this.geometries=t}function gt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function dt(){if(this.geom=null,this.geomFact=null,this.bnRule=null,this.endpointMap=null,1===arguments.length){var t=arguments[0];dt.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.geom=e,this.geomFact=e.getFactory(),this.bnRule=n}}function pt(){this.count=null}function vt(){}function mt(){}function yt(){}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}function St(){this.points=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function wt(){}function Lt(){this.coordinates=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function Rt(){}function Tt(){this.shell=null,this.holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(B.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),B.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&B.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this.shell=t,this.holes=e}function Pt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function bt(){if(arguments[0]instanceof g&&arguments[1]instanceof ie){var t=arguments[0],e=arguments[1];bt.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(R(arguments[0],D)&&arguments[1]instanceof ie){var n=arguments[0],i=arguments[1];St.call(this,n,i),this.validateConstruction()}}function Ot(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function _t(){if(this.factory=null,this.isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.factory=t}}function Mt(){}function Dt(){}function At(){}function Ft(){}function Gt(){if(this.dimension=3,this.coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];Gt.call(this,t,3)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.coordinates=new Array(e).fill(null);for(var n=0;n<e;n++)this.coordinates[n]=new g}else if(R(arguments[0],D)){var i=arguments[0];if(null===i)return this.coordinates=new Array(0).fill(null),null;this.dimension=i.getDimension(),this.coordinates=new Array(i.size()).fill(null);for(var n=0;n<this.coordinates.length;n++)this.coordinates[n]=i.getCoordinateCopy(n)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],s=arguments[1];this.coordinates=r,this.dimension=s,null===r&&(this.coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var o=arguments[0],a=arguments[1];this.coordinates=new Array(o).fill(null),this.dimension=a;for(var n=0;n<o;n++)this.coordinates[n]=new g}}function qt(){}function Bt(t,e){return t===e||t!==t&&e!==e}function zt(t,e){function n(t){return this&&this.constructor===n?(this._keys=[],this._values=[],this._itp=[],this.objectOnly=e,void(t&&Vt.call(this,t))):new n(t)}return e||io(t,"size",{get:Jt}),t.constructor=n,n.prototype=t,n}function Vt(t){this.add?t.forEach(this.add,this):t.forEach(function(t){this.set(t[0],t[1])},this)}function kt(t){return this.has(t)&&(this._keys.splice(no,1),this._values.splice(no,1),this._itp.forEach(function(t){no<t[0]&&t[0]--})),no>-1}function Yt(t){return this.has(t)?this._values[no]:void 0}function Ut(t,e){if(this.objectOnly&&e!==Object(e))throw new TypeError("Invalid value used as weak collection key");if(e!==e||0===e)for(no=t.length;no--&&!Bt(t[no],e););else no=t.indexOf(e);return no>-1}function Xt(t){return Ut.call(this,this._keys,t)}function Ht(t,e){return this.has(t)?this._values[no]=e:this._values[this._keys.push(t)-1]=e,this}function Wt(){(this._keys||0).length=this._values.length=0}function jt(){return Qt(this._itp,this._keys)}function Kt(){return Qt(this._itp,this._values)}function Zt(){return Qt(this._itp,this._keys,this._values)}function Qt(t,e,n){var i=[0],r=!1;return t.push(i),{next:function(){var s,o=i[0];return!r&&o<e.length?(s=n?[e[o],n[o]]:e[o],i[0]++):(r=!0,t.splice(t.indexOf(i),1)),{done:r,value:s}}}}function Jt(){return this._values.length}function $t(t,e){for(var n=this.entries();;){var i=n.next();if(i.done)break;t.call(e,i.value[1],i.value[0],this)}}function te(){this.map_=new so}function ee(){if(this.modelType=null,this.scale=null,0===arguments.length)this.modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){var t=arguments[0];this.modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var e=arguments[0];this.modelType=ee.FIXED,this.setScale(e)}else if(arguments[0]instanceof ee){var n=arguments[0];this.modelType=n.modelType,this.scale=n.scale}}function ne(){this.name=null;var t=arguments[0];this.name=t,ne.nameToTypeMap.put(t,this)}function ie(){if(this.precisionModel=null,this.coordinateSequenceFactory=null,this.SRID=null,0===arguments.length)ie.call(this,new ee,0);else if(1===arguments.length){if(R(arguments[0],G)){var t=arguments[0];ie.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){var e=arguments[0];ie.call(this,e,0,ie.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];ie.call(this,n,i,ie.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.precisionModel=r,this.coordinateSequenceFactory=o,this.SRID=s}}function re(t){this.geometryFactory=t||new ie}function se(t){this.parser=new re(t)}function oe(){this.result=null,this.inputLines=Array(2).fill().map(function(){return Array(2)}),this.intPt=new Array(2).fill(null),this.intLineIndex=null,this._isProper=null,this.pa=null,this.pb=null,this.precisionModel=null,this.intPt[0]=new g,this.intPt[1]=new g,this.pa=this.intPt[0],this.pb=this.intPt[1],this.result=0}function ae(){oe.apply(this)}function ue(){}function le(){this.p=null,this.crossingCount=0,this.isPointOnSegment=!1;var t=arguments[0];this.p=t}function he(){}function ce(){if(this.p0=null,this.p1=null,0===arguments.length)ce.call(this,new g,new g);else if(1===arguments.length){var t=arguments[0];ce.call(this,t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0=e,this.p1=n}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];ce.call(this,new g(i,r),new g(s,o))}}function fe(){if(this.matrix=null,0===arguments.length)this.matrix=Array(3).fill().map(function(){return Array(3)}),this.setAll(lt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];fe.call(this),this.set(t)}else if(arguments[0]instanceof fe){var e=arguments[0];fe.call(this),this.matrix[L.INTERIOR][L.INTERIOR]=e.matrix[L.INTERIOR][L.INTERIOR],this.matrix[L.INTERIOR][L.BOUNDARY]=e.matrix[L.INTERIOR][L.BOUNDARY],this.matrix[L.INTERIOR][L.EXTERIOR]=e.matrix[L.INTERIOR][L.EXTERIOR],this.matrix[L.BOUNDARY][L.INTERIOR]=e.matrix[L.BOUNDARY][L.INTERIOR],this.matrix[L.BOUNDARY][L.BOUNDARY]=e.matrix[L.BOUNDARY][L.BOUNDARY],this.matrix[L.BOUNDARY][L.EXTERIOR]=e.matrix[L.BOUNDARY][L.EXTERIOR],this.matrix[L.EXTERIOR][L.INTERIOR]=e.matrix[L.EXTERIOR][L.INTERIOR],this.matrix[L.EXTERIOR][L.BOUNDARY]=e.matrix[L.EXTERIOR][L.BOUNDARY],this.matrix[L.EXTERIOR][L.EXTERIOR]=e.matrix[L.EXTERIOR][L.EXTERIOR]}}function ge(){this.areaBasePt=null,this.triangleCent3=new g,this.areasum2=0,this.cg3=new g,this.lineCentSum=new g,this.totalLength=0,this.ptCount=0,this.ptCentSum=new g;var t=arguments[0];this.areaBasePt=null,this.add(t)}function de(t){this.message=t||""}function pe(){this.array_=[]}function ve(){this.treeSet=new at,this.list=new I}function me(){if(this.geomFactory=null,this.inputPts=null,1===arguments.length){var t=arguments[0];me.call(this,me.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputPts=ve.filterCoordinates(e),this.geomFactory=n}}function ye(){this.origin=null;var t=arguments[0];this.origin=t}function xe(){this.inputGeom=null,this.factory=null,this.pruneEmptyGeometry=!0,this.preserveGeometryCollectionType=!0,this.preserveCollections=!1,this.preserveType=!1}function Ee(){if(this.snapTolerance=0,this.srcPts=null,this.seg=new ce,this.allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof St&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];Ee.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.srcPts=n,this._isClosed=Ee.isClosed(n),this.snapTolerance=i}}function Ie(){this.srcGeom=null;var t=arguments[0];this.srcGeom=t}function Ne(){if(xe.apply(this),this.snapTolerance=null,this.snapPts=null,this.isSelfSnap=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this.snapTolerance=t,this.snapPts=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.snapTolerance=n,this.snapPts=i,this.isSelfSnap=r}}function Ce(){this.isFirst=!0,this.commonMantissaBitsCount=53,this.commonBits=0,this.commonSignExp=null}function Se(){this.commonCoord=null,this.ccFilter=new we}function we(){this.commonBitsX=new Ce,this.commonBitsY=new Ce}function Le(){this.trans=null;var t=arguments[0];this.trans=t}function Re(){this.parent=null,this.atStart=null,this.max=null,this.index=null,this.subcollectionIterator=null;var t=arguments[0];this.parent=t,this.atStart=!0,this.index=0,this.max=t.getNumGeometries()}function Te(){if(this.boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this.isIn=null,this.numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new i("Rule must be non-null");this.boundaryRule=t}}function Pe(){}function be(){}function Oe(){this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function _e(){}function Me(){this.bounds=null,this.item=null;var t=arguments[0],e=arguments[1];this.bounds=t,this.item=e}function De(){this._size=null,this.items=null,this._size=0,this.items=new I,this.items.add(null)}function Ae(){}function Fe(){}function Ge(){if(this.childBoundables=new I,this.bounds=null,this.level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.level=t}}function qe(){this.boundable1=null,this.boundable2=null,this._distance=null,this.itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.boundable1=t,this.boundable2=e,this.itemDistance=n,this._distance=this.distance()}function Be(){if(this.root=null,this.built=!1,this.itemBoundables=new I,this.nodeCapacity=null,0===arguments.length)Be.call(this,Be.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];f.isTrue(t>1,"Node capacity must be greater than 1"),this.nodeCapacity=t}}function ze(){}function Ve(){}function ke(){if(0===arguments.length)ke.call(this,ke.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];Be.call(this,t)}}function Ye(){var t=arguments[0];Ge.call(this,t)}function Ue(){}function Xe(){this.segString=null,this.coord=null,this.segmentIndex=null,this.segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.segString=t,this.coord=new g(e),this.segmentIndex=n,this.segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))}function He(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function We(){this.nodeList=null,this.edge=null,this.nodeIt=null,this.currNode=null,this.nextNode=null,this.currSegIndex=0;var t=arguments[0];this.nodeList=t,this.edge=t.getEdge(),this.nodeIt=t.iterator(),this.readNextNode()}function je(){}function Ke(){this.nodeList=new He(this),this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function Ze(){this.tempEnv1=new C,this.tempEnv2=new C,this.overlapSeg1=new ce,this.overlapSeg2=new ce}function Qe(){this.pts=null,this.start=null,this.end=null,this.env=null,this.context=null,this.id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.pts=t,this.start=e,this.end=n,this.context=i}function Je(){}function $e(){}function tn(){}function en(){if(this.segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}function nn(){if(this.monoChains=new I,this.index=new ke,this.idCounter=0,this.nodedSegStrings=null,this.nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];en.call(this,t)}}function rn(){Ze.apply(this),this.si=null;var t=arguments[0];this.si=t}function sn(){if(this.pt=null,1===arguments.length){var t=arguments[0];l.call(this,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];l.call(this,sn.msgWithCoord(e,n)),this.name="TopologyException",this.pt=new g(n)}}function on(){}function an(){this.findAllIntersections=!1,this.isCheckEndSegmentsOnly=!1,this.li=null,this.interiorIntersection=null,this.intSegments=null,this.intersections=new I,this.intersectionCount=0,this.keepIntersections=!0;var t=arguments[0];this.li=t,this.interiorIntersection=null}function un(){this.li=new ae,this.segStrings=null,this.findAllIntersections=!1,this.segInt=null,this._isValid=!0;var t=arguments[0];this.segStrings=t}function ln(){this.nv=null;var t=arguments[0];this.nv=new un(ln.toSegmentStrings(t))}function hn(){this.mapOp=null;var t=arguments[0];this.mapOp=t}function cn(){}function fn(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.init(1),this.location[cn.ON]=e}else if(arguments[0]instanceof fn){var n=arguments[0];if(this.init(n.location.length),null!==n)for(var i=0;i<this.location.length;i++)this.location[i]=n.location[i]}}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.init(3),this.location[cn.ON]=r,this.location[cn.LEFT]=s,this.location[cn.RIGHT]=o}}function gn(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new fn(t),this.elt[1]=new fn(t)}else if(arguments[0]instanceof gn){var e=arguments[0];this.elt[0]=new fn(e.elt[0]),this.elt[1]=new fn(e.elt[1])}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.elt[0]=new fn(L.NONE),this.elt[1]=new fn(L.NONE),this.elt[n].setLocation(i)}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.elt[0]=new fn(r,s,o),this.elt[1]=new fn(r,s,o)}else if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3];this.elt[0]=new fn(L.NONE,L.NONE,L.NONE),this.elt[1]=new fn(L.NONE,L.NONE,L.NONE),this.elt[a].setLocations(u,l,h)}}function dn(){this.startDe=null,this.maxNodeDegree=-1,this.edges=new I,this.pts=new I,this.label=new gn(L.NONE),this.ring=null,this._isHole=null,this.shell=null,this.holes=new I,this.geometryFactory=null;var t=arguments[0],e=arguments[1];this.geometryFactory=e,this.computePoints(t),this.computeRing()}function pn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function vn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function mn(){if(this.label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.label=t}}function yn(){mn.apply(this),this.coord=null,this.edges=null;var t=arguments[0],e=arguments[1];this.coord=t,this.edges=e,this.label=new gn(0,L.NONE)}function xn(){this.nodeMap=new rt,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}function En(){if(this.edge=null,this.label=null,this.node=null,this.p0=null,this.p1=null,this.dx=null,this.dy=null,this.quadrant=null,1===arguments.length){var t=arguments[0];this.edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];En.call(this,e,n,i,null)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];En.call(this,r),this.init(s,o),this.label=a}}function In(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this.sym=null,this.next=null,this.nextMin=null,this.edgeRing=null,this.minEdgeRing=null,this.depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(En.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}function Nn(){}function Cn(){if(this.edges=new I,this.nodes=null,this.edgeEndList=new I,0===arguments.length)this.nodes=new xn(new Nn);else if(1===arguments.length){var t=arguments[0];this.nodes=new xn(t)}}function Sn(){this.geometryFactory=null,this.shellList=new I;var t=arguments[0];this.geometryFactory=t}function wn(){this.op=null,this.geometryFactory=null,this.ptLocator=null,this.lineEdgesList=new I,this.resultLineList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.op=t,this.geometryFactory=e,this.ptLocator=n}function Ln(){this.op=null,this.geometryFactory=null,this.resultPointList=new I;var t=arguments[0],e=arguments[1];arguments[2];this.op=t,this.geometryFactory=e}function Rn(){}function Tn(){this.geom=null;var t=arguments[0];this.geom=t}function Pn(){this.edgeMap=new rt,this.edgeList=null,this.ptInAreaLocation=[L.NONE,L.NONE]}function bn(){Pn.apply(this),this.resultAreaEdgeList=null,this.label=null,this.SCANNING_FOR_INCOMING=1,this.LINKING_TO_OUTGOING=2}function On(){Nn.apply(this)}function _n(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}function Mn(){if(this.label=null,this.xValue=null,this.eventType=null,this.insertEvent=null,this.deleteEventIndex=null,this.obj=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.eventType=Mn.DELETE,this.xValue=t,this.insertEvent=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.eventType=Mn.INSERT,this.label=n,this.xValue=i,this.obj=r}}function Dn(){}function An(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.properIntersectionPoint=null,this.li=null,this.includeProper=null,this.recordIsolated=null,this.isSelfIntersection=null,this.numIntersections=0,this.numTests=0,this.bdyNodes=null,this._isDone=!1,this.isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.li=t,this.includeProper=e,this.recordIsolated=n}function Fn(){Dn.apply(this),this.events=new I,this.nOverlaps=null}function Gn(){this.min=r.POSITIVE_INFINITY,this.max=r.NEGATIVE_INFINITY}function qn(){}function Bn(){Gn.apply(this),this.item=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.min=t,this.max=e,this.item=n}function zn(){Gn.apply(this),this.node1=null,this.node2=null;var t=arguments[0],e=arguments[1];this.node1=t,this.node2=e,this.buildExtent(this.node1,this.node2)}function Vn(){this.leaves=new I,this.root=null,this.level=0}function kn(){if(this.lines=null,this.isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this.lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.lines=e,this.isForcedToLineString=n}}function Yn(){this.items=new I}function Un(){this.index=null;var t=arguments[0];if(!R(t,Rt))throw new i("Argument must be Polygonal");this.index=new Hn(t)}function Xn(){this.counter=null;var t=arguments[0];this.counter=t}function Hn(){this.index=new Vn;var t=arguments[0];this.init(t)}function Wn(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n}function jn(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function Kn(){}function Zn(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new C,this.env2=new C;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}function Qn(){this.depth=Array(2).fill().map(function(){return Array(3)});for(var t=0;t<2;t++)for(var e=0;e<3;e++)this.depth[t][e]=Qn.NULL_VALUE}function Jn(){if(mn.apply(this),this.pts=null,this.env=null,this.eiList=new jn(this),this.name=null,this.mce=null,this._isIsolated=!0,this.depth=new Qn,this.depthDelta=0,1===arguments.length){var t=arguments[0];Jn.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this.label=n}}function $n(){if(Cn.apply(this),this.parentGeom=null,this.lineEdgeMap=new te,this.boundaryNodeRule=null,this.useBoundaryDeterminationRule=!0,this.argIndex=null,this.boundaryNodes=null,this._hasTooFewPoints=!1,this.invalidPoint=null,this.areaPtLocator=null,this.ptLocator=new Te,2===arguments.length){var t=arguments[0],e=arguments[1];$n.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.argIndex=n,this.parentGeom=i,this.boundaryNodeRule=r,null!==i&&this.add(i)}}function ti(){if(this.li=new ae,this.resultPrecisionModel=null,this.arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this.arg=new Array(1).fill(null),this.arg[0]=new $n(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];ti.call(this,e,n,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel())>=0?this.setComputationPrecision(i.getPrecisionModel()):this.setComputationPrecision(r.getPrecisionModel()),this.arg=new Array(2).fill(null),this.arg[0]=new $n(0,i,s),this.arg[1]=new $n(1,r,s)}}function ei(){this.pts=null,this._orientation=null;var t=arguments[0];this.pts=t,this._orientation=ei.orientation(t)}function ni(){this.edges=new I,this.ocaMap=new rt}function ii(){this.ptLocator=new Te,this.geomFact=null,this.resultGeom=null,this.graph=null,this.edgeList=new ni,this.resultPolyList=new I,this.resultLineList=new I,this.resultPointList=new I;var t=arguments[0],e=arguments[1];ti.call(this,t,e),this.graph=new Cn(new On),this.geomFact=t.getFactory()}function ri(){this.geom=new Array(2).fill(null),this.snapTolerance=null,this.cbr=null;var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e,this.computeSnapTolerance()}function si(){this.geom=new Array(2).fill(null);var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e}function oi(){this.factory=null,this.interiorPoint=null,this.maxWidth=0;var t=arguments[0];this.factory=t.getFactory(),this.add(t)}function ai(){this.poly=null,this.centreY=null,this.hiY=r.MAX_VALUE,this.loY=-r.MAX_VALUE;var t=arguments[0];this.poly=t,this.hiY=t.getEnvelopeInternal().getMaxY(),this.loY=t.getEnvelopeInternal().getMinY(),this.centreY=oi.avg(this.loY,this.hiY)}function ui(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.addInterior(t),null===this.interiorPoint&&this.addEndpoints(t)}function li(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.add(t)}function hi(){this.tempEnv1=new C,this.selectedSegment=new ce}function ci(){this.items=new I,this.subnode=[null,null]}function fi(){if(this.min=null,this.max=null,0===arguments.length)this.min=0,this.max=0;else if(1===arguments.length){var t=arguments[0];this.init(t.min,t.max)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.init(e,n)}}function gi(){}function di(t,e){var n,i,r,s,o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},a={32:8,64:11}[t];if(s||(n=e<0||1/e<0,isFinite(e)||(s=o[t],n&&(s.d+=1<<t/4-1),i=Math.pow(2,a)-1,r=0)),!s){for(i={32:127,64:1023}[t],r=Math.abs(e);r>=2;)i++,r/=2;for(;r<1&&i>0;)i--,r*=2;i<=0&&(r/=2),32===t&&i>254&&(s={d:n?255:127,c:128,b:0,a:0},i=Math.pow(2,a)-1,r=0)}return i}function pi(){this.pt=0,this.level=0,this.interval=null;var t=arguments[0];this.computeKey(t)}function vi(){ci.apply(this),this.interval=null,this.centre=null,this.level=null;var t=arguments[0],e=arguments[1];this.interval=t,this.level=e,this.centre=(t.getMin()+t.getMax())/2}function mi(){}function yi(){ci.apply(this)}function xi(){this.root=null,this.minExtent=1,this.root=new yi}function Ei(){}function Ii(){this.ring=null,this.tree=null,this.crossings=0,this.interval=new fi;var t=arguments[0];this.ring=t,this.buildIndex()}function Ni(){hi.apply(this),this.mcp=null,this.p=null;var t=arguments[0],e=arguments[1];this.mcp=t,this.p=e}function Ci(){}function Si(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}function wi(){this.input=null,this.extremalPts=null,this.centre=null,this.radius=0;var t=arguments[0];this.input=t}function Li(){if(this.inputGeom=null,this.isConvex=null,this.convexHullPts=null,this.minBaseSeg=new ce,this.minWidthPt=null,this.minPtIndex=null,this.minWidth=0,1===arguments.length){var t=arguments[0];Li.call(this,t,!1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isConvex=n}}function Ri(){this.inputGeom=null,this.distanceTolerance=null;var t=arguments[0];this.inputGeom=t}function Ti(){xe.apply(this),this.distanceTolerance=null;var t=arguments[0];this.distanceTolerance=t}function Pi(){this._orig=null,this._sym=null,this._next=null;var t=arguments[0];this._orig=t}function bi(){this._isMarked=!1;var t=arguments[0];Pi.call(this,t)}function Oi(){this.vertexMap=new te}function _i(){this._isStart=!1;var t=arguments[0];bi.call(this,t)}function Mi(){Oi.apply(this)}function Di(){this.result=null,this.factory=null,this.graph=null,this.lines=new I,this.nodeEdgeStack=new pe,this.ringStartEdge=null,this.graph=new Mi}function Ai(){this.items=new I,this.subnode=new Array(4).fill(null)}function Fi(){this.pt=new g,this.level=0,this.env=null;var t=arguments[0];this.computeKey(t)}function Gi(){Ai.apply(this),this.env=null,this.centrex=null,this.centrey=null,this.level=null;var t=arguments[0],e=arguments[1];this.env=t,this.level=e,this.centrex=(t.getMinX()+t.getMaxX())/2,this.centrey=(t.getMinY()+t.getMaxY())/2}function qi(){Ai.apply(this)}function Bi(){this.root=null,this.minExtent=1,this.root=new qi}function zi(t){this.geometryFactory=t||new ie}function Vi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new zi(this.geometryFactory)}function ki(){this.parser=new zi(this.geometryFactory)}function Yi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new re(this.geometryFactory)}function Ui(t){return[t.x,t.y]}function Xi(t,e){this.geometryFactory=t||new ie,this.ol=e||"undefined"!=typeof ol&&ol}function Hi(){if(this.noder=null,this.scaleFactor=null,this.offsetX=null,this.offsetY=null,this.isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];Hi.call(this,t,e,0,0)}else if(4===arguments.length){var n=arguments[0],i=arguments[1];arguments[2],arguments[3];this.noder=n,this.scaleFactor=i,this.isScaled=!this.isIntegerPrecision()}}function Wi(){if(this.inputGeom=null,this.isClosedEndpointsInInterior=!0,this.nonSimpleLocation=null,1===arguments.length){var t=arguments[0];this.inputGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];
this.inputGeom=e,this.isClosedEndpointsInInterior=!n.isInBoundary(2)}}function ji(){this.pt=null,this.isClosed=null,this.degree=null;var t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}function Ki(){if(this.quadrantSegments=Ki.DEFAULT_QUADRANT_SEGMENTS,this.endCapStyle=Ki.CAP_ROUND,this.joinStyle=Ki.JOIN_ROUND,this.mitreLimit=Ki.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this.simplifyFactor=Ki.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.setQuadrantSegments(e),this.setEndCapStyle(n)}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(r),this.setJoinStyle(s),this.setMitreLimit(o)}}function Zi(){this.minIndex=-1,this.minCoord=null,this.minDe=null,this.orientedDe=null}function Qi(){this.array_=[]}function Ji(){this.finder=null,this.dirEdgeList=new I,this.nodes=new I,this.rightMostCoord=null,this.env=null,this.finder=new Zi}function $i(){this.inputLine=null,this.distanceTol=null,this.isDeleted=null,this.angleOrientation=he.COUNTERCLOCKWISE;var t=arguments[0];this.inputLine=t}function tr(){this.ptList=null,this.precisionModel=null,this.minimimVertexDistance=0,this.ptList=new I}function er(){this.maxCurveSegmentError=0,this.filletAngleQuantum=null,this.closingSegLengthFactor=1,this.segList=null,this.distance=0,this.precisionModel=null,this.bufParams=null,this.li=null,this.s0=null,this.s1=null,this.s2=null,this.seg0=new ce,this.seg1=new ce,this.offset0=new ce,this.offset1=new ce,this.side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.precisionModel=t,this.bufParams=e,this.li=new ae,this.filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===Ki.JOIN_ROUND&&(this.closingSegLengthFactor=er.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}function nr(){this.distance=0,this.precisionModel=null,this.bufParams=null;var t=arguments[0],e=arguments[1];this.precisionModel=t,this.bufParams=e}function ir(){this.subgraphs=null,this.seg=new ce,this.cga=new he;var t=arguments[0];this.subgraphs=t}function rr(){this.upwardSeg=null,this.leftDepth=null;var t=arguments[0],e=arguments[1];this.upwardSeg=new ce(t),this.leftDepth=e}function sr(){this.inputGeom=null,this.distance=null,this.curveBuilder=null,this.curveList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.inputGeom=t,this.distance=e,this.curveBuilder=n}function or(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.hasInterior=!1,this.properIntersectionPoint=null,this.li=null,this.isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this.li=t}function ar(){this.bufParams=null,this.workingPrecisionModel=null,this.workingNoder=null,this.geomFact=null,this.graph=null,this.edgeList=new ni;var t=arguments[0];this.bufParams=t}function ur(){this.li=new ae,this.segStrings=null;var t=arguments[0];this.segStrings=t}function lr(){this.li=null,this.pt=null,this.originalPt=null,this.ptScaled=null,this.p0Scaled=null,this.p1Scaled=null,this.scaleFactor=null,this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,this.corner=new Array(4).fill(null),this.safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this.originalPt=t,this.pt=t,this.scaleFactor=e,this.li=n,e<=0)throw new i("Scale factor must be non-zero");1!==e&&(this.pt=new g(this.scale(t.x),this.scale(t.y)),this.p0Scaled=new g,this.p1Scaled=new g),this.initCorners(this.pt)}function hr(){this.index=null;var t=arguments[0];this.index=t}function cr(){hi.apply(this),this.hotPixel=null,this.parentEdge=null,this.hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.hotPixel=t,this.parentEdge=e,this.hotPixelVertexIndex=n}function fr(){this.li=null,this.interiorIntersections=null;var t=arguments[0];this.li=t,this.interiorIntersections=new I}function gr(){this.pm=null,this.li=null,this.scaleFactor=null,this.noder=null,this.pointSnapper=null,this.nodedSegStrings=null;var t=arguments[0];this.pm=t,this.li=new ae,this.li.setPrecisionModel(t),this.scaleFactor=t.getScale()}function dr(){if(this.argGeom=null,this.distance=null,this.bufParams=new Ki,this.resultGeometry=null,this.saveException=null,1===arguments.length){var t=arguments[0];this.argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.argGeom=e,this.bufParams=n}}function pr(){this.comps=null;var t=arguments[0];this.comps=t}function vr(){if(this.component=null,this.segIndex=null,this.pt=null,2===arguments.length){var t=arguments[0],e=arguments[1];vr.call(this,t,vr.INSIDE_AREA,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.component=n,this.segIndex=i,this.pt=r}}function mr(){this.pts=null;var t=arguments[0];this.pts=t}function yr(){this.locations=null;var t=arguments[0];this.locations=t}function xr(){if(this.geom=null,this.terminateDistance=0,this.ptLocator=new Te,this.minDistanceLocation=null,this.minDistance=r.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];xr.call(this,t,e,0)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],s=arguments[2];this.geom=new Array(2).fill(null),this.geom[0]=n,this.geom[1]=i,this.terminateDistance=s}}function Er(){this.factory=null,this.directedEdges=new I,this.coordinates=null;var t=arguments[0];this.factory=t}function Ir(){this._isMarked=!1,this._isVisited=!1,this.data=null}function Nr(){Ir.apply(this),this.parentEdge=null,this.from=null,this.to=null,this.p0=null,this.p1=null,this.sym=null,this.edgeDirection=null,this.quadrant=null,this.angle=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.from=t,this.to=e,this.edgeDirection=i,this.p0=t.getCoordinate(),this.p1=n;var r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;this.quadrant=Je.quadrant(r,s),this.angle=Math.atan2(s,r)}function Cr(){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Nr.call(this,t,e,n,i)}function Sr(){if(Ir.apply(this),this.dirEdge=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}function wr(){this.outEdges=new I,this.sorted=!1}function Lr(){if(Ir.apply(this),this.pt=null,this.deStar=null,1===arguments.length){var t=arguments[0];Lr.call(this,t,new wr)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pt=e,this.deStar=n}}function Rr(){Sr.apply(this),this.line=null;var t=arguments[0];this.line=t}function Tr(){this.nodeMap=new rt}function Pr(){this.edges=new J,this.dirEdges=new J,this.nodeMap=new Tr}function br(){Pr.apply(this)}function Or(){this.graph=new br,this.mergedLineStrings=null,this.factory=null,this.edgeStrings=null}function _r(){this.edgeRing=null,this.next=null,this.label=-1;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];Nr.call(this,t,e,n,i)}function Mr(){Sr.apply(this),this.line=null;var t=arguments[0];this.line=t}function Dr(){this.geometryFactory=new ie,this.geomGraph=null,this.disconnectedRingcoord=null;var t=arguments[0];this.geomGraph=t}function Ar(){}function Fr(){if(this.edgeEnds=new I,1===arguments.length){var t=arguments[0];Fr.call(this,null,t)}else if(2===arguments.length){var e=(arguments[0],arguments[1]);En.call(this,e.getEdge(),e.getCoordinate(),e.getDirectedCoordinate(),new gn(e.getLabel())),this.insert(e)}}function Gr(){Pn.apply(this)}function qr(){var t=arguments[0],e=arguments[1];yn.call(this,t,e)}function Br(){Nn.apply(this)}function zr(){this.nodes=new xn(new Br)}function Vr(){this.li=new ae,this.geomGraph=null,this.nodeGraph=new zr,this.invalidPoint=null;var t=arguments[0];this.geomGraph=t}function kr(){this.graph=null,this.rings=new I,this.totalEnv=new C,this.index=null,this.nestedPt=null;var t=arguments[0];this.graph=t}function Yr(){if(this.errorType=null,this.pt=null,1===arguments.length){var t=arguments[0];Yr.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.errorType=e,null!==n&&(this.pt=n.copy())}}function Ur(){this.parentGeometry=null,this.isSelfTouchingRingFormingHoleValid=!1,this.validErr=null;var t=arguments[0];this.parentGeometry=t}function Xr(){this.factory=null,this.deList=new I,this.lowestEdge=null,this.ring=null,this.ringPts=null,this.holes=null,this.shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;var t=arguments[0];this.factory=t}function Hr(){}function Wr(){Pr.apply(this),this.factory=null;var t=arguments[0];this.factory=t}function jr(){if(this.lineStringAdder=new Kr(this),this.graph=null,this.dangles=new I,this.cutEdges=new I,this.invalidRingLines=new I,this.holeList=null,this.shellList=null,this.polyList=null,this.isCheckingRingsValid=!0,this.extractOnlyPolygonal=null,this.geomFactory=null,0===arguments.length)jr.call(this,!1);else if(1===arguments.length){var t=arguments[0];this.extractOnlyPolygonal=t}}function Kr(){this.p=null;var t=arguments[0];this.p=t}function Zr(){this.li=new ae,this.ptLocator=new Te,this.arg=null,this.nodes=new xn(new Br),this.im=null,this.isolatedEdges=new I,this.invalidPoint=null;var t=arguments[0];this.arg=t}function Qr(){this.rectEnv=null;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal()}function Jr(){this.li=new ae,this.rectEnv=null,this.diagUp0=null,this.diagUp1=null,this.diagDown0=null,this.diagDown1=null;var t=arguments[0];this.rectEnv=t,this.diagUp0=new g(t.getMinX(),t.getMinY()),this.diagUp1=new g(t.getMaxX(),t.getMaxY()),this.diagDown0=new g(t.getMinX(),t.getMaxY()),this.diagDown1=new g(t.getMaxX(),t.getMinY())}function $r(){this._isDone=!1}function ts(){this.rectangle=null,this.rectEnv=null;var t=arguments[0];this.rectangle=t,this.rectEnv=t.getEnvelopeInternal()}function es(){$r.apply(this),this.rectEnv=null,this._intersects=!1;var t=arguments[0];this.rectEnv=t}function ns(){$r.apply(this),this.rectSeq=null,this.rectEnv=null,this._containsPoint=!1;var t=arguments[0];this.rectSeq=t.getExteriorRing().getCoordinateSequence(),this.rectEnv=t.getEnvelopeInternal()}function is(){$r.apply(this),this.rectEnv=null,this.rectIntersector=null,this.hasIntersection=!1,this.p0=new g,this.p1=new g;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal(),this.rectIntersector=new Jr(this.rectEnv)}function rs(){if(this._relate=null,2===arguments.length){var t=arguments[0],e=arguments[1];ti.call(this,t,e),this._relate=new Zr(this.arg)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];ti.call(this,n,i,r),this._relate=new Zr(this.arg)}}function ss(){this.geomFactory=null,this.skipEmpty=!1,this.inputGeoms=null;var t=arguments[0];this.geomFactory=ss.extractFactory(t),this.inputGeoms=t}function os(){this.pointGeom=null,this.otherGeom=null,this.geomFact=null;var t=arguments[0],e=arguments[1];this.pointGeom=t,this.otherGeom=e,this.geomFact=e.getFactory()}function as(){this.sortIndex=-1,this.comps=null;var t=arguments[0],e=arguments[1];this.sortIndex=t,this.comps=e}function us(){this.inputPolys=null,this.geomFactory=null;var t=arguments[0];this.inputPolys=t,null===this.inputPolys&&(this.inputPolys=new I)}function ls(){if(this.polygons=new I,this.lines=new I,this.points=new I,this.geomFact=null,1===arguments.length){if(R(arguments[0],v)){var t=arguments[0];this.extract(t)}else if(arguments[0]instanceof B){var e=arguments[0];this.extract(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.geomFact=i,this.extract(n)}}function hs(){_t.CoordinateOperation.apply(this),this.targetPM=null,this.removeCollapsed=!0;var t=arguments[0],e=arguments[1];this.targetPM=t,this.removeCollapsed=e}function cs(){this.targetPM=null,this.removeCollapsed=!0,this.changePrecisionModel=!1,this.isPointwise=!1;var t=arguments[0];this.targetPM=t}function fs(){this.pts=null,this.usePt=null,this.distanceTolerance=null,this.seg=new ce;var t=arguments[0];this.pts=t}function gs(){this.inputGeom=null,this.distanceTolerance=null,this.isEnsureValidTopology=!0;var t=arguments[0];this.inputGeom=t}function ds(){xe.apply(this),this.isEnsureValidTopology=!0,this.distanceTolerance=null;var t=arguments[0],e=arguments[1];this.isEnsureValidTopology=t,this.distanceTolerance=e}function ps(){if(this.parent=null,this.index=null,2===arguments.length){var t=arguments[0],e=arguments[1];ps.call(this,t,e,null,-1)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=arguments[3];ce.call(this,n,i),this.parent=r,this.index=s}}function vs(){if(this.parentLine=null,this.segs=null,this.resultSegs=new I,this.minimumSize=null,1===arguments.length){var t=arguments[0];vs.call(this,t,2)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.parentLine=e,this.minimumSize=n,this.init()}}function ms(){this.index=new Bi}function ys(){this.querySeg=null,this.items=new I;var t=arguments[0];this.querySeg=t}function xs(){this.li=new ae,this.inputIndex=new ms,this.outputIndex=new ms,this.line=null,this.linePts=null,this.distanceTolerance=0;var t=arguments[0],e=arguments[1];this.inputIndex=t,this.outputIndex=e}function Es(){this.inputIndex=new ms,this.outputIndex=new ms,this.distanceTolerance=0}function Is(){this.inputGeom=null,this.lineSimplifier=new Es,this.linestringMap=null;var t=arguments[0];this.inputGeom=t}function Ns(){xe.apply(this),this.linestringMap=null;var t=arguments[0];this.linestringMap=t}function Cs(){this.tps=null;var t=arguments[0];this.tps=t}function Ss(){this.seg=null,this.segLen=null,this.splitPt=null,this.minimumLen=0;var t=arguments[0];this.seg=t,this.segLen=t.getLength()}function ws(){}function Ls(){}function Rs(){}function Ts(){if(this.p=null,1===arguments.length){var t=arguments[0];this.p=new g(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p=new g(e,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.p=new g(i,r,s)}}function Ps(){this._isOnConstraint=null,this.constraint=null;var t=arguments[0];Ts.call(this,t)}function bs(){this._rot=null,this.vertex=null,this.next=null,this.data=null}function Os(){this.subdiv=null,this.isUsingTolerance=!1;var t=arguments[0];this.subdiv=t,this.isUsingTolerance=t.getTolerance()>0}function _s(){}function Ms(){this.subdiv=null,this.lastEdge=null;var t=arguments[0];this.subdiv=t,this.init()}function Ds(){if(this.seg=null,1===arguments.length){if("string"==typeof arguments[0]){var t=arguments[0];l.call(this,t)}else if(arguments[0]instanceof ce){var e=arguments[0];l.call(this,"Locate failed to converge (at edge: "+e+").  Possible causes include invalid Subdivision topology or very close sites"),this.seg=new ce(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];l.call(this,Ds.msgWithSpatial(n,i)),this.seg=new ce(i)}}function As(){}function Fs(){this.visitedKey=0,this.quadEdges=new I,this.startingEdge=null,this.tolerance=null,this.edgeCoincidenceTolerance=null,this.frameVertex=new Array(3).fill(null),this.frameEnv=null,this.locator=null,this.seg=new ce,this.triEdges=new Array(3).fill(null);var t=arguments[0],e=arguments[1];this.tolerance=e,this.edgeCoincidenceTolerance=e/Fs.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this.startingEdge=this.initSubdiv(),this.locator=new Ms(this)}function Gs(){}function qs(){this.triList=new I}function Bs(){this.triList=new I}function zs(){this.coordList=new N,this.triCoords=new I}function Vs(){if(this.ls=null,this.data=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.ls=new ce(t,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.ls=new ce(n,i),this.data=r}else if(6===arguments.length){var s=arguments[0],o=arguments[1],a=arguments[2],u=arguments[3],l=arguments[4],h=arguments[5];Vs.call(this,new g(s,o,a),new g(u,l,h))}else if(7===arguments.length){var c=arguments[0],f=arguments[1],d=arguments[2],p=arguments[3],v=arguments[4],m=arguments[5],y=arguments[6];Vs.call(this,new g(c,f,d),new g(p,v,m),y)}}function ks(){}function Ys(){if(this.p=null,this.data=null,this.left=null,this.right=null,this.count=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.p=new g(t),this.left=null,this.right=null,this.count=1,this.data=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.p=new g(n,i),this.left=null,this.right=null,this.count=1,this.data=r}}function Us(){if(this.root=null,this.numberOfNodes=null,this.tolerance=null,0===arguments.length)Us.call(this,0);else if(1===arguments.length){var t=arguments[0];this.tolerance=t}}function Xs(){this.tolerance=null,this.matchNode=null,this.matchDist=0,this.p=null;var t=arguments[0],e=arguments[1];this.p=t,this.tolerance=e}function Hs(){this.initialVertices=null,this.segVertices=null,this.segments=new I,this.subdiv=null,this.incDel=null,this.convexHull=null,this.splitFinder=new Ls,this.kdt=null,this.vertexFactory=null,this.computeAreaEnv=null,this.splitPt=null,this.tolerance=null;var t=arguments[0],e=arguments[1];this.initialVertices=new I(t),this.tolerance=e,this.kdt=new Us(e)}function Ws(){this.siteCoords=null,this.tolerance=0,this.subdiv=null}function js(){this.siteCoords=null,this.constraintLines=null,this.tolerance=0,this.subdiv=null,this.constraintVertexMap=new rt}function Ks(){this.siteCoords=null,this.tolerance=0,this.subdiv=null,this.clipEnv=null,this.diagramEnv=null}function Zs(){}"fill"in Array.prototype||Object.defineProperty(Array.prototype,"fill",{configurable:!0,value:function(t){if(void 0===this||null===this)throw new TypeError(this+" is not an object");var e=Object(this),n=Math.max(Math.min(e.length,9007199254740991),0)||0,i=1 in arguments?parseInt(Number(arguments[1]),10)||0:0;i=i<0?Math.max(n+i,0):Math.min(i,n);var r=2 in arguments&&void 0!==arguments[2]?parseInt(Number(arguments[2]),10)||0:n;for(r=r<0?Math.max(n+arguments[2],0):Math.min(r,n);i<r;)e[i]=t,++i;return e},writable:!0}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!==t},Math.trunc=Math.trunc||function(t){return t<0?Math.ceil(t):Math.floor(t)},e(n.prototype,{interfaces_:function(){return[]},getClass:function(){return n}}),n.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n},r.isNaN=function(t){return Number.isNaN(t)},r.doubleToLongBits=function(t){return t},r.longBitsToDouble=function(t){return t},r.isInfinite=function(t){return!Number.isFinite(t)},r.MAX_VALUE=Number.MAX_VALUE,l.prototype=Object.create(Error.prototype),l.prototype.constructor=Error,h(c,l),e(c.prototype,{interfaces_:function(){return[]},getClass:function(){return c}}),e(f.prototype,{interfaces_:function(){return[]},getClass:function(){return f}}),f.shouldNeverReachHere=function(){if(0===arguments.length)f.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}},f.isTrue=function(){if(1===arguments.length){var t=arguments[0];f.isTrue(t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!e)throw null===n?new c:new c(n)}},f.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];f.equals(t,e,null)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(!i.equals(n))throw new c("Expected "+n+" but encountered "+i+(null!==r?": "+r:""))}},e(g.prototype,{setOrdinate:function(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new i("Invalid ordinate index: "+t)}},equals2D:function(){if(1===arguments.length){var t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){var e=arguments[0],i=arguments[1];return!!n.equalsWithTolerance(this.x,e.x,i)&&!!n.equalsWithTolerance(this.y,e.y,i)}},getOrdinate:function(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new i("Invalid ordinate index: "+t)},equals3D:function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||r.isNaN(this.z)&&r.isNaN(t.z))},equals:function(t){return t instanceof g&&this.equals2D(t)},equalInZ:function(t,e){return n.equalsWithTolerance(this.z,t.z,e)},compareTo:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},clone:function(){try{var t=null;return t}catch(t){if(t instanceof CloneNotSupportedException)return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}finally{}},copy:function(){return new g(this)},toString:function(){return"("+this.x+", "+this.y+", "+this.z+")"},distance3D:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},distance:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y)},setCoordinate:function(t){this.x=t.x,this.y=t.y,this.z=t.z},interfaces_:function(){return[s,o,u]},getClass:function(){return g}}),g.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=r.doubleToLongBits(t);return Math.trunc(e^e>>>32)}},e(d.prototype,{compare:function(t,e){var n=t,i=e,r=d.compare(n.x,i.x);if(0!==r)return r;var s=d.compare(n.y,i.y);if(0!==s)return s;if(this.dimensionsToTest<=2)return 0;var o=d.compare(n.z,i.z);return o},interfaces_:function(){return[a]},getClass:function(){return d}}),d.compare=function(t,e){return t<e?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0},g.DimensionalComparator=d,g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=r.NaN,g.X=0,g.Y=1,g.Z=2,p.prototype.hasNext=function(){},p.prototype.next=function(){},p.prototype.remove=function(){},v.prototype.add=function(){},v.prototype.addAll=function(){},v.prototype.isEmpty=function(){},v.prototype.iterator=function(){},v.prototype.size=function(){},v.prototype.toArray=function(){},v.prototype.remove=function(){},m.prototype=new Error,m.prototype.name="IndexOutOfBoundsException",y.prototype=Object.create(v.prototype),y.prototype.constructor=y,y.prototype.get=function(){},y.prototype.set=function(){},y.prototype.isEmpty=function(){},x.prototype=new Error,x.prototype.name="NoSuchElementException",E.prototype=new Error,E.prototype.name="OperationNotSupported",I.prototype=Object.create(y.prototype),I.prototype.constructor=I,I.prototype.ensureCapacity=function(){},I.prototype.interfaces_=function(){return[y,v]},I.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],arguments[1]),!0},I.prototype.clear=function(){this.array_=[]},I.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},I.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},I.prototype.iterator=function(){return new Qs(this)},I.prototype.get=function(t){if(t<0||t>=this.size())throw new m;return this.array_[t]},I.prototype.isEmpty=function(){return 0===this.array_.length},I.prototype.size=function(){return this.array_.length},I.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},I.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;n<i;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e};var Qs=function(t){this.arrayList_=t,this.position_=0};Qs.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new x;return this.arrayList_.get(this.position_++)},Qs.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},Qs.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},Qs.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))},h(N,I),e(N.prototype,{getCoordinate:function(t){return this.get(t)},addAll:function(){if(2===arguments.length){for(var t=arguments[0],e=arguments[1],n=!1,i=t.iterator();i.hasNext();)this.add(i.next(),e),n=!0;return n}return I.prototype.addAll.apply(this,arguments)},clone:function t(){for(var t=I.prototype.clone.call(this),e=0;e<this.size();e++)t.add(e,this.get(e).copy());return t},toCoordinateArray:function(){return this.toArray(N.coordArrayType)},add:function(){if(1===arguments.length){var t=arguments[0];I.prototype.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){var i=arguments[0],r=arguments[1];if(!r&&this.size()>=1){var s=this.get(this.size()-1);if(s.equals2D(i))return null}I.prototype.add.call(this,i)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2];if(h)for(var c=0;c<u.length;c++)this.add(u[c],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){var f=arguments[0],d=arguments[1],p=arguments[2];if(!p){var v=this.size();if(v>0){if(f>0){var m=this.get(f-1);if(m.equals2D(d))return null}if(f<v){var y=this.get(f);if(y.equals2D(d))return null}}}I.prototype.add.call(this,f,d)}}else if(4===arguments.length){var x=arguments[0],E=arguments[1],N=arguments[2],C=arguments[3],S=1;N>C&&(S=-1);for(var c=N;c!==C;c+=S)this.add(x[c],E);return!0}},closeRing:function(){this.size()>0&&this.add(new g(this.get(0)),!1)},interfaces_:function(){return[]},getClass:function(){return N}}),N.coordArrayType=new Array(0).fill(null),e(C.prototype,{getArea:function(){return this.getWidth()*this.getHeight()},equals:function(t){if(!(t instanceof C))return!1;var e=t;return this.isNull()?e.isNull():this.maxx===e.getMaxX()&&this.maxy===e.getMaxY()&&this.minx===e.getMinX()&&this.miny===e.getMinY()},intersection:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new C;var e=this.minx>t.minx?this.minx:t.minx,n=this.miny>t.miny?this.miny:t.miny,i=this.maxx<t.maxx?this.maxx:t.maxx,r=this.maxy<t.maxy?this.maxy:t.maxy;return new C(e,i,n,r)},isNull:function(){return this.maxx<this.minx},getMaxX:function(){return this.maxx},covers:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof C){var e=arguments[0];return!this.isNull()&&!e.isNull()&&(e.getMinX()>=this.minx&&e.getMaxX()<=this.maxx&&e.getMinY()>=this.miny&&e.getMaxY()<=this.maxy)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return!this.isNull()&&(n>=this.minx&&n<=this.maxx&&i>=this.miny&&i<=this.maxy)}},intersects:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t.minx>this.maxx||t.maxx<this.minx||t.miny>this.maxy||t.maxy<this.miny)}if(arguments[0]instanceof g){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return!this.isNull()&&!(n>this.maxx||n<this.minx||i>this.maxy||i<this.miny)}},getMinY:function(){return this.miny},getMinX:function(){return this.minx},expandToInclude:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this.minx=e.getMinX(),this.maxx=e.getMaxX(),this.miny=e.getMinY(),this.maxy=e.getMaxY()):(e.minx<this.minx&&(this.minx=e.minx),e.maxx>this.maxx&&(this.maxx=e.maxx),e.miny<this.miny&&(this.miny=e.miny),e.maxy>this.maxy&&(this.maxy=e.maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this.minx=n,this.maxx=n,this.miny=i,this.maxy=i):(n<this.minx&&(this.minx=n),n>this.maxx&&(this.maxx=n),i<this.miny&&(this.miny=i),i>this.maxy&&(this.maxy=i))}},minExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t<e?t:e},getWidth:function(){return this.isNull()?0:this.maxx-this.minx},compareTo:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this.minx<e.minx?-1:this.minx>e.minx?1:this.miny<e.miny?-1:this.miny>e.miny?1:this.maxx<e.maxx?-1:this.maxx>e.maxx?1:this.maxy<e.maxy?-1:this.maxy>e.maxy?1:0},translate:function(t,e){return this.isNull()?null:void this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},toString:function(){return"Env["+this.minx+" : "+this.maxx+", "+this.miny+" : "+this.maxy+"]"},setToNull:function(){this.minx=0,this.maxx=-1,this.miny=0,this.maxy=-1},getHeight:function(){return this.isNull()?0:this.maxy-this.miny},maxExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},expandBy:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this.minx-=e,this.maxx+=e,this.miny-=n,this.maxy+=n,(this.minx>this.maxx||this.miny>this.maxy)&&this.setToNull()}},contains:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},centre:function(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},init:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.minx=e.minx,this.maxx=e.maxx,this.miny=e.miny,this.maxy=e.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];r<s?(this.minx=r,this.maxx=s):(this.minx=s,this.maxx=r),o<a?(this.miny=o,this.maxy=a):(this.miny=a,this.maxy=o)}},getMaxY:function(){return this.maxy},distance:function(t){if(this.intersects(t))return 0;var e=0;this.maxx<t.minx?e=t.minx-this.maxx:this.minx>t.maxx&&(e=this.minx-t.maxx);var n=0;return this.maxy<t.miny?n=t.miny-this.maxy:this.miny>t.maxy&&(n=this.miny-t.maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.minx),t=37*t+g.hashCode(this.maxx),t=37*t+g.hashCode(this.miny),t=37*t+g.hashCode(this.maxy)},interfaces_:function(){return[s,u]},getClass:function(){return C}}),C.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=Math.min(s.x,o.x),u=Math.max(s.x,o.x),l=Math.min(i.x,r.x),h=Math.max(i.x,r.x);return!(l>u)&&(!(h<a)&&(a=Math.min(s.y,o.y),u=Math.max(s.y,o.y),l=Math.min(i.y,r.y),h=Math.max(i.y,r.y),!(l>u)&&!(h<a)))}},C.serialVersionUID=0x51845cd552189800,h(w,S),e(w.prototype,{interfaces_:function(){return[]},getClass:function(){return w}}),e(L.prototype,{interfaces_:function(){return[]},getClass:function(){return L}}),L.toLocationSymbol=function(t){switch(t){case L.EXTERIOR:return"e";case L.BOUNDARY:return"b";case L.INTERIOR:return"i";case L.NONE:return"-"}throw new i("Unknown location value: "+t)},L.INTERIOR=0,L.BOUNDARY=1,L.EXTERIOR=2,L.NONE=-1,e(T.prototype,{interfaces_:function(){return[]},getClass:function(){return T}}),T.log10=function(t){var e=Math.log(t);return r.isInfinite(e)?e:r.isNaN(e)?e:e/T.LOG_10},T.min=function(t,e,n,i){var r=t;return e<r&&(r=e),n<r&&(r=n),i<r&&(r=i),r},T.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];
return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],s=arguments[2];return i<r?r:i>s?s:i}},T.wrap=function(t,e){return t<0?e- -t%e:t%e},T.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],i=r;return s>i&&(i=s),o>i&&(i=o),a>i&&(i=a),i}},T.average=function(t,e){return(t+e)/2},T.LOG_10=Math.log(10),P.prototype.append=function(t){this.str+=t},P.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},P.prototype.toString=function(t){return this.str},b.prototype.intValue=function(){return this.value},b.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},b.isNaN=function(t){return Number.isNaN(t)},O.isWhitespace=function(t){return t<=32&&t>=0||127==t},O.toUpperCase=function(t){return t.toUpperCase()},e(_.prototype,{le:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<=t.lo},extractSignificantDigits:function(t,e){var n=this.abs(),i=_.magnitude(n.hi),r=_.TEN.pow(i);n=n.divide(r),n.gt(_.TEN)?(n=n.divide(_.TEN),i+=1):n.lt(_.ONE)&&(n=n.multiply(_.TEN),i-=1);for(var s=i+1,o=new P,a=_.MAX_PRINT_DIGITS-1,u=0;u<=a;u++){t&&u===s&&o.append(".");var l=Math.trunc(n.hi);if(l<0)break;var h=!1,c=0;l>9?(h=!0,c="9"):c="0"+l,o.append(c),n=n.subtract(_.valueOf(l)).multiply(_.TEN),h&&n.selfAdd(_.TEN);var f=!0,g=_.magnitude(n.hi);if(g<0&&Math.abs(g)>=a-u&&(f=!1),!f)break}return e[0]=i,o.toString()},sqr:function(){return this.multiply(this)},doubleValue:function(){return this.hi+this.lo},subtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},equals:function(){if(1===arguments.length){var t=arguments[0];return this.hi===t.hi&&this.lo===t.lo}},isZero:function(){return 0===this.hi&&0===this.lo},selfSubtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.hi,-t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},getSpecialNumberString:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},min:function(t){return this.le(t)?this:t},selfDivide:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfDivide(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null,h=null,c=null;return u=this.hi/n,l=_.SPLIT*u,r=l-u,c=_.SPLIT*n,r=l-r,s=u-r,o=c-n,h=u*n,o=c-o,a=n-o,c=r*o-h+r*a+s*o+s*a,l=(this.hi-h-c+this.lo-u*i)/n,c=u+l,this.hi=c,this.lo=u-c+l,this}},dump:function(){return"DD<"+this.hi+", "+this.lo+">"},divide:function(){if(arguments[0]instanceof _){var t=arguments[0],e=null,n=null,i=null,s=null,o=null,a=null,u=null,l=null;o=this.hi/t.hi,a=_.SPLIT*o,e=a-o,l=_.SPLIT*t.hi,e=a-e,n=o-e,i=l-t.hi,u=o*t.hi,i=l-i,s=t.hi-i,l=e*i-u+e*s+n*i+n*s,a=(this.hi-u-l+this.lo-o*t.lo)/t.hi,l=o+a;var h=l,c=o-l+a;return new _(h,c)}if("number"==typeof arguments[0]){var f=arguments[0];return r.isNaN(f)?_.createNaN():_.copy(this).selfDivide(f,0)}},ge:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>=t.lo},pow:function(t){if(0===t)return _.valueOf(1);var e=new _(this),n=_.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2===1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n},ceil:function(){if(this.isNaN())return _.NaN;var t=Math.ceil(this.hi),e=0;return t===this.hi&&(e=Math.ceil(this.lo)),new _(t,e)},compareTo:function(t){var e=t;return this.hi<e.hi?-1:this.hi>e.hi?1:this.lo<e.lo?-1:this.lo>e.lo?1:0},rint:function(){if(this.isNaN())return this;var t=this.add(.5);return t.floor()},setValue:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},max:function(t){return this.ge(t)?this:t},sqrt:function(){if(this.isZero())return _.valueOf(0);if(this.isNegative())return _.NaN;var t=1/Math.sqrt(this.hi),e=this.hi*t,n=_.valueOf(e),i=this.subtract(n.sqr()),r=i.hi*(.5*t);return n.add(r)},selfAdd:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfAdd(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,s=null,o=null,a=null;return r=this.hi+e,o=r-this.hi,s=r-o,s=e-o+(this.hi-s),a=s+this.lo,n=r+a,i=a+(r-n),this.hi=n+i,this.lo=i+(n-this.hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],n=null,i=null,h=null,c=null,r=null,s=null,o=null,a=null;r=this.hi+u,h=this.lo+l,o=r-this.hi,a=h-this.lo,s=r-o,c=h-a,s=u-o+(this.hi-s),c=l-a+(this.lo-c),o=s+h,n=r+o,i=o+(r-n),o=c+i;var f=n+o,g=o+(n-f);return this.hi=f,this.lo=g,this}},selfMultiply:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfMultiply(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null;u=_.SPLIT*this.hi,r=u-this.hi,l=_.SPLIT*n,r=u-r,s=this.hi-r,o=l-n,u=this.hi*n,o=l-o,a=n-o,l=r*o-u+r*a+s*o+s*a+(this.hi*i+this.lo*n);var h=u+l;r=u-h;var c=l+r;return this.hi=h,this.lo=c,this}},selfSqr:function(){return this.selfMultiply(this)},floor:function(){if(this.isNaN())return _.NaN;var t=Math.floor(this.hi),e=0;return t===this.hi&&(e=Math.floor(this.lo)),new _(t,e)},negate:function(){return this.isNaN()?this:new _((-this.hi),(-this.lo))},clone:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}finally{}},multiply:function(){if(arguments[0]instanceof _){var t=arguments[0];return t.isNaN()?_.createNaN():_.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return r.isNaN(e)?_.createNaN():_.copy(this).selfMultiply(e,0)}},isNaN:function(){return r.isNaN(this.hi)},intValue:function(){return Math.trunc(this.hi)},toString:function(){var t=_.magnitude(this.hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()},toStandardNotation:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(i<0)r="0."+_.stringOfChar("0",-i)+n;else if(n.indexOf(".")===-1){var s=i-n.length,o=_.stringOfChar("0",s);r=n+o+".0"}return this.isNegative()?"-"+r:r},reciprocal:function(){var t=null,e=null,n=null,i=null,r=null,s=null,o=null,a=null;r=1/this.hi,s=_.SPLIT*r,t=s-r,a=_.SPLIT*this.hi,t=s-t,e=r-t,n=a-this.hi,o=r*this.hi,n=a-n,i=this.hi-n,a=t*n-o+t*i+e*n+e*i,s=(1-o-a-r*this.lo)/this.hi;var u=r+s,l=r-u+s;return new _(u,l)},toSciNotation:function(){if(this.isZero())return _.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=_.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var s=n.charAt(0)+"."+r;return this.isNegative()?"-"+s+i:s+i},abs:function(){return this.isNaN()?_.NaN:this.isNegative()?this.negate():new _(this)},isPositive:function(){return this.hi>0||0===this.hi&&this.lo>0},lt:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<t.lo},add:function(){if(arguments[0]instanceof _){var t=arguments[0];return _.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return _.copy(this).selfAdd(e)}},init:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.hi=t,this.lo=0}else if(arguments[0]instanceof _){var e=arguments[0];this.hi=e.hi,this.lo=e.lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.hi=n,this.lo=i}},gt:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>t.lo},isNegative:function(){return this.hi<0||0===this.hi&&this.lo<0},trunc:function(){return this.isNaN()?_.NaN:this.isPositive()?this.floor():this.ceil()},signum:function(){return this.hi>0?1:this.hi<0?-1:this.lo>0?1:this.lo<0?-1:0},interfaces_:function(){return[u,s,o]},getClass:function(){return _}}),_.sqr=function(t){return _.valueOf(t).selfMultiply(t)},_.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return _.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new _(e)}},_.sqrt=function(t){return _.valueOf(t).sqrt()},_.parse=function(t){for(var e=0,n=t.length;O.isWhitespace(t.charAt(e));)e++;var i=!1;if(e<n){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var s=new _,o=0,a=0,u=0;;){if(e>=n)break;var l=t.charAt(e);if(e++,O.isDigit(l)){var h=l-"0";s.selfMultiply(_.TEN),s.selfAdd(h),o++}else{if("."!==l){if("e"===l||"E"===l){var c=t.substring(e);try{u=b.parseInt(c)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+c+" in string "+t):e}finally{}break}throw new NumberFormatException("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=o}}var f=s,g=o-a-u;if(0===g)f=s;else if(g>0){var d=_.TEN.pow(g);f=s.divide(d)}else if(g<0){var d=_.TEN.pow(-g);f=s.multiply(d)}return i?f.negate():f},_.createNaN=function(){return new _(r.NaN,r.NaN)},_.copy=function(t){return new _(t)},_.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n)),r=Math.pow(10,i);return 10*r<=e&&(i+=1),i},_.stringOfChar=function(t,e){for(var n=new P,i=0;i<e;i++)n.append(t);return n.toString()},_.PI=new _(3.141592653589793,1.2246467991473532e-16),_.TWO_PI=new _(6.283185307179586,2.4492935982947064e-16),_.PI_2=new _(1.5707963267948966,6.123233995736766e-17),_.E=new _(2.718281828459045,1.4456468917292502e-16),_.NaN=new _(r.NaN,r.NaN),_.EPS=1.23259516440783e-32,_.SPLIT=134217729,_.MAX_PRINT_DIGITS=32,_.TEN=_.valueOf(10),_.ONE=_.valueOf(1),_.SCI_NOT_EXPONENT_CHAR="E",_.SCI_NOT_ZERO="0.0E0",e(M.prototype,{interfaces_:function(){return[]},getClass:function(){return M}}),M.orientationIndex=function(t,e,n){var i=M.orientationIndexFilter(t,e,n);if(i<=1)return i;var r=_.valueOf(e.x).selfAdd(-t.x),s=_.valueOf(e.y).selfAdd(-t.y),o=_.valueOf(n.x).selfAdd(-e.x),a=_.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum()},M.signOfDet2x2=function(t,e,n,i){var r=t.multiply(i).selfSubtract(e.multiply(n));return r.signum()},M.intersection=function(t,e,n,i){var r=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),s=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),o=r.subtract(s),a=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),u=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u),h=l.selfDivide(o).doubleValue(),c=_.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),f=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),d=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),p=f.subtract(d),v=p.selfDivide(o).doubleValue(),m=_.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c,m)},M.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),s=(t.y-n.y)*(e.x-n.x),o=r-s;if(r>0){if(s<=0)return M.signum(o);i=r+s}else{if(!(r<0))return M.signum(o);if(s>=0)return M.signum(o);i=-r-s}var a=M.DP_SAFE_EPSILON*i;return o>=a||-o>=a?M.signum(o):2},M.signum=function(t){return t>0?1:t<0?-1:0},M.DP_SAFE_EPSILON=1e-15,e(D.prototype,{setOrdinate:function(t,e,n){},size:function(){},getOrdinate:function(t,e){},getCoordinate:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},getCoordinateCopy:function(t){},getDimension:function(){},getX:function(t){},clone:function(){},expandEnvelope:function(t){},copy:function(){},getY:function(t){},toCoordinateArray:function(){},interfaces_:function(){return[o]},getClass:function(){return D}}),D.X=0,D.Y=1,D.Z=2,D.M=3,A.arraycopy=function(t,e,n,i,r){for(var s=0,o=e;o<e+r;o++)n[i+s]=t[o],s++},A.getProperty=function(t){return{"line.separator":"\n"}[t]},e(F.prototype,{getY:function(){var t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getX:function(){var t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getCoordinate:function(){var t=new g;return t.x=this.getX(),t.y=this.getY(),t},interfaces_:function(){return[]},getClass:function(){return F}}),F.intersection=function(t,e,n,i){var s=t.y-e.y,o=e.x-t.x,a=t.x*e.y-e.x*t.y,u=n.y-i.y,l=i.x-n.x,h=n.x*i.y-i.x*n.y,c=o*h-l*a,f=u*a-s*h,d=s*l-u*o,p=c/d,v=f/d;if(r.isNaN(p)||r.isInfinite(p)||r.isNaN(v)||r.isInfinite(v))throw new w;return new g(p,v)},e(G.prototype,{create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){arguments[0]}else if(R(arguments[0],D)){arguments[0]}}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return G}}),e(q.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return q}}),e(B.prototype,{isGeometryCollection:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION},getFactory:function(){return this.factory},getGeometryN:function(t){return this},getArea:function(){return 0},isRectangle:function(){return!1},equals:function(){if(1===arguments.length){if(arguments[0]instanceof B){var t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof B))return!1;var n=e;return this.equalsExact(n)}}},equalsExact:function(t){return this===t||this.equalsExact(t,0)},geometryChanged:function(){this.apply(B.geometryChangedFilter)},geometryChangedAction:function(){this.envelope=null},equalsNorm:function(t){return null!==t&&this.norm().equalsExact(t.norm())},getLength:function(){return 0},getNumGeometries:function(){return 1},compareTo:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(n,i)}},getUserData:function(){return this.userData},getSRID:function(){return this.SRID},getEnvelope:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},checkNotGeometryCollection:function(t){if(t.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")},equal:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},norm:function(){var t=this.copy();return t.normalize(),t},getPrecisionModel:function(){return this.factory.getPrecisionModel()},getEnvelopeInternal:function(){return null===this.envelope&&(this.envelope=this.computeEnvelopeInternal()),new C(this.envelope)},setSRID:function(t){this.SRID=t},setUserData:function(t){this.userData=t},compare:function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),s=i.next(),o=r.compareTo(s);if(0!==o)return o}return n.hasNext()?1:i.hasNext()?-1:0},hashCode:function(){return this.getEnvelopeInternal().hashCode()},isGeometryCollectionOrDerived:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===B.SORTINDEX_MULTIPOINT||this.getSortIndex()===B.SORTINDEX_MULTILINESTRING||this.getSortIndex()===B.SORTINDEX_MULTIPOLYGON},interfaces_:function(){return[o,s,u]},getClass:function(){return B}}),B.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},B.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},B.serialVersionUID=0x799ea46522854c00,B.SORTINDEX_POINT=0,B.SORTINDEX_MULTIPOINT=1,B.SORTINDEX_LINESTRING=2,B.SORTINDEX_LINEARRING=3,B.SORTINDEX_MULTILINESTRING=4,B.SORTINDEX_POLYGON=5,B.SORTINDEX_MULTIPOLYGON=6,B.SORTINDEX_GEOMETRYCOLLECTION=7,B.geometryChangedFilter={interfaces_:function(){return[q]},filter:function(t){t.geometryChangedAction()}},e(z.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return z}}),e(V.prototype,{isInBoundary:function(t){},interfaces_:function(){return[]},getClass:function(){return V}}),e(k.prototype,{isInBoundary:function(t){return t%2===1},interfaces_:function(){return[V]},getClass:function(){return k}}),e(Y.prototype,{isInBoundary:function(t){return t>0},interfaces_:function(){return[V]},getClass:function(){return Y}}),e(U.prototype,{isInBoundary:function(t){return t>1},interfaces_:function(){return[V]},getClass:function(){return U}}),e(X.prototype,{isInBoundary:function(t){return 1===t},interfaces_:function(){return[V]},getClass:function(){return X}}),V.Mod2BoundaryNodeRule=k,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=X,V.MOD2_BOUNDARY_RULE=new k,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new X,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE,e(H.prototype,{interfaces_:function(){return[]},getClass:function(){return H}}),H.isRing=function(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])},H.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(H.indexOf(i,e)<0)return i}return null},H.scroll=function(t,e){var n=H.indexOf(e,t);if(n<0)return null;var i=new Array(t.length).fill(null);A.arraycopy(t,n,i,0,t.length-n),A.arraycopy(t,0,i,t.length-n,n),A.arraycopy(i,0,t,0,t.length)},H.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var n=0;n<i.length;n++)if(0!==s.compare(i[n],r[n]))return!1;return!0}},H.intersection=function(t,e){for(var n=new N,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},H.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},H.removeRepeatedPoints=function(t){if(!H.hasRepeatedPoints(t))return t;var e=new N(t,(!1));return e.toCoordinateArray()},H.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;i<=n;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},H.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,n=0;n<t.length;n++)null!==t[n]&&(i[r++]=t[n]);return i},H.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=arguments[4],n=0;n<a;n++)s[o+n]=new g(i[r+n])},H.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},H.envelope=function(t){for(var e=new C,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},H.toCoordinateArray=function(t){return t.toArray(H.coordArrayType)},H.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},H.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},H.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},H.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},H.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},H.extract=function(t,e,n){e=T.clamp(e,0,t.length),n=T.clamp(n,-1,t.length);var i=n-e+1;n<0&&(i=0),e>=t.length&&(i=0),n<e&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var s=0,o=e;o<=n;o++)r[s++]=t[o];return r},e(W.prototype,{compare:function(t,e){var n=t,i=e;return H.compare(n,i)},interfaces_:function(){return[a]},getClass:function(){return W}}),e(j.prototype,{compare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=H.compare(n,i),s=H.isEqualReversed(n,i);return s?0:r},OLDcompare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=H.increasingDirection(n),s=H.increasingDirection(i),o=r>0?0:n.length-1,a=s>0?0:n.length-1,u=0;u<n.length;u++){var l=n[o].compareTo(i[a]);if(0!==l)return l;o+=r,a+=s}return 0},interfaces_:function(){return[a]},getClass:function(){return j}}),H.ForwardComparator=W,H.BidirectionalComparator=j,H.coordArrayType=new Array(0).fill(null),K.prototype.get=function(){},K.prototype.put=function(){},K.prototype.size=function(){},K.prototype.values=function(){},K.prototype.entrySet=function(){},Z.prototype=new K,Q.prototype=new v,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(var e=0,n=this.array_.length;e<n;e++){var i=this.array_[e];if(i===t)return!0}return!1},J.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new javascript.util.OperationNotSupported},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new Js(this)};var Js=function(t){this.hashSet_=t,this.position_=0};Js.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new x;return this.hashSet_.array_[this.position_++]},Js.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},Js.prototype.remove=function(){throw new E};var $s=0,to=1;rt.prototype=new Z,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do if(n=r,i=t.compareTo(r.key),i<0)r=r.left;else{if(!(i>0)){var s=r.value;return r.value=e,s}r=r.right}while(null!==r);var o={key:t,left:null,right:null,value:e,parent:n,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}};return i<0?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){for(t.color=to;null!=t&&t!=this.root_&&t.parent.color==to;)if(tt(t)==nt(tt(tt(t)))){var e=it(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==it(tt(t))&&(t=tt(t),this.rotateLeft(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateRight(tt(tt(t))))}else{var e=nt(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==nt(tt(t))&&(t=tt(t),this.rotateRight(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateLeft(tt(tt(t))))}this.root_.color=$s},rt.prototype.values=function(){var t=new I,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left==t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right==t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var e=t.parent,n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},e(st.prototype,{interfaces_:function(){return[]},getClass:function(){return st}}),ot.prototype=new Q,at.prototype=new ot,at.prototype.contains=function(t){for(var e=0,n=this.array_.length;e<n;e++){var i=this.array_[e];if(0===i.compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;e<n;e++){var i=this.array_[e];if(1===i.compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new E},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new eo(this)};var eo=function(t){this.treeSet_=t,this.position_=0};eo.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new x;return this.treeSet_.array_[this.position_++]},eo.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},eo.prototype.remove=function(){throw new E},ut.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)return i=function(t,e){return t.compareTo(e)},void r.sort(i);if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else{if(3===arguments.length){e=r.slice(arguments[1],arguments[2]),e.sort();var s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}if(4===arguments.length){for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}}},ut.asList=function(t){for(var e=new I,n=0,i=t.length;n<i;n++)e.add(t[n]);return e},e(lt.prototype,{interfaces_:function(){return[]},getClass:function(){return lt}}),lt.toDimensionSymbol=function(t){switch(t){case lt.FALSE:return lt.SYM_FALSE;case lt.TRUE:return lt.SYM_TRUE;case lt.DONTCARE:return lt.SYM_DONTCARE;case lt.P:return lt.SYM_P;case lt.L:return lt.SYM_L;case lt.A:return lt.SYM_A}throw new i("Unknown dimension value: "+t)},lt.toDimensionValue=function(t){switch(O.toUpperCase(t)){case lt.SYM_FALSE:return lt.FALSE;case lt.SYM_TRUE:return lt.TRUE;case lt.SYM_DONTCARE:return lt.DONTCARE;case lt.SYM_P:return lt.P;case lt.SYM_L:return lt.L;case lt.SYM_A:return lt.A}throw new i("Unknown dimension symbol: "+t)},lt.P=0,lt.L=1,lt.A=2,lt.FALSE=-1,lt.TRUE=-2,lt.DONTCARE=-3,lt.SYM_FALSE="F",lt.SYM_TRUE="T",lt.SYM_DONTCARE="*",lt.SYM_P="0",lt.SYM_L="1",lt.SYM_A="2",e(ht.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return ht}}),e(ct.prototype,{filter:function(t,e){},isDone:function(){},isGeometryChanged:function(){},interfaces_:function(){return[]},getClass:function(){return ct}}),h(ft,B),e(ft.prototype,{computeEnvelopeInternal:function(){for(var t=new C,e=0;e<this.geometries.length;e++)t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t},getGeometryN:function(t){return this.geometries[t]},getSortIndex:function(){return B.SORTINDEX_GEOMETRYCOLLECTION},getCoordinates:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this.geometries.length;n++)for(var i=this.geometries[n].getCoordinates(),r=0;r<i.length;r++)e++,t[e]=i[r];return t},getArea:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getArea();return t},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.geometries.length!==n.geometries.length)return!1;for(var i=0;i<this.geometries.length;i++)if(!this.geometries[i].equalsExact(n.geometries[i],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<this.geometries.length;t++)this.geometries[t].normalize();ut.sort(this.geometries)},getCoordinate:function(){return this.isEmpty()?null:this.geometries[0].getCoordinate()},getBoundaryDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getBoundaryDimension());return t},getDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getDimension());return t},getLength:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getLength();return t},getNumPoints:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getNumPoints();return t},getNumGeometries:function(){return this.geometries.length},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=new at(ut.asList(this.geometries)),n=new at(ut.asList(t.geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s=i,o=this.getNumGeometries(),a=s.getNumGeometries(),u=0;u<o&&u<a;){var l=this.getGeometryN(u),h=s.getGeometryN(u),c=l.compareToSameClass(h,r);if(0!==c)return c;u++}return u<o?1:u<a?-1:0}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.geometries.length;e++)this.geometries[e].apply(t);else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.geometries.length)return null;for(var e=0;e<this.geometries.length&&(this.geometries[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(i)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(r)}},getBoundary:function(){return this.checkNotGeometryCollection(this),f.shouldNeverReachHere(),null},clone:function(){var t=B.prototype.clone.call(this);t.geometries=new Array(this.geometries.length).fill(null);for(var e=0;e<this.geometries.length;e++)t.geometries[e]=this.geometries[e].clone();return t},getGeometryType:function(){return"GeometryCollection"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new ft(t,this.factory)},isEmpty:function(){for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isEmpty())return!1;return!0},interfaces_:function(){return[]},getClass:function(){return ft}}),ft.serialVersionUID=-0x4f07bcb1f857d800,h(gt,ft),e(gt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTILINESTRING},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&ft.prototype.equalsExact.call(this,t,e)}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){if(this.isEmpty())return!1;for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isClosed())return!1;return!0;
},getDimension:function(){return 1},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[t-1-n]=this.geometries[n].reverse();return this.getFactory().createMultiLineString(e)},getBoundary:function(){return new dt(this).getBoundary()},getGeometryType:function(){return"MultiLineString"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new gt(t,this.factory)},interfaces_:function(){return[st]},getClass:function(){return gt}}),gt.serialVersionUID=0x7155d2ab4afa8000,e(dt.prototype,{boundaryMultiLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this.geomFact.createPoint(e[0]):this.geomFact.createMultiPointFromCoords(e)},getBoundary:function(){return this.geom instanceof St?this.boundaryLineString(this.geom):this.geom instanceof gt?this.boundaryMultiLineString(this.geom):this.geom.getBoundary()},boundaryLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){var e=this.bnRule.isInBoundary(2);return e?t.getStartPoint():this.geomFact.createMultiPoint()}return this.geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},getEmptyMultiPoint:function(){return this.geomFact.createMultiPoint()},computeBoundaryCoordinates:function(t){var e=new I;this.endpointMap=new rt;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this.endpointMap.entrySet().iterator();r.hasNext();){var s=r.next(),o=s.getValue(),a=o.count;this.bnRule.isInBoundary(a)&&e.add(s.getKey())}return H.toCoordinateArray(e)},addEndpoint:function(t){var e=this.endpointMap.get(t);null===e&&(e=new pt,this.endpointMap.put(t,e)),e.count++},interfaces_:function(){return[]},getClass:function(){return dt}}),dt.getBoundary=function(){if(1===arguments.length){var t=arguments[0],e=new dt(t);return e.getBoundary()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new dt(n,i);return e.getBoundary()}},e(pt.prototype,{interfaces_:function(){return[]},getClass:function(){return pt}}),e(Nt.prototype,{interfaces_:function(){return[]},getClass:function(){return Nt}}),Nt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;i<e;i++)n[i]=t;return new String(n)},Nt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new xt,n=new vt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s="",o=new mt(Nt.getStackTrace(i)),a=new It(o),u=0;u<r;u++)try{s+=a.readLine()+Nt.NEWLINE}catch(t){if(!(t instanceof Et))throw t;f.shouldNeverReachHere()}finally{}return s}},Nt.split=function(t,e){for(var n=e.length,i=new I,r=""+t,s=r.indexOf(e);s>=0;){var o=r.substring(0,s);i.add(o),r=r.substring(s+n),s=r.indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},Nt.toString=function(){if(1===arguments.length){var t=arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t)}},Nt.spaces=function(t){return Nt.chars(" ",t)},Nt.NEWLINE=A.getProperty("line.separator"),Nt.SIMPLE_ORDINATE_FORMAT=new yt("0.#"),e(Ct.prototype,{interfaces_:function(){return[]},getClass:function(){return Ct}}),Ct.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),s=0;s<r;s++)n.setOrdinate(i,s,t.getOrdinate(e,s))},Ct.isRing=function(t){var e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,D.X)===t.getOrdinate(e-1,D.X)&&t.getOrdinate(0,D.Y)===t.getOrdinate(e-1,D.Y))},Ct.isEqual=function(t,e){var n=t.size(),i=e.size();if(n!==i)return!1;for(var s=Math.min(t.getDimension(),e.getDimension()),o=0;o<n;o++)for(var a=0;a<s;a++){var u=t.getOrdinate(o,a),l=e.getOrdinate(o,a);if(!(t.getOrdinate(o,a)===e.getOrdinate(o,a)||r.isNaN(u)&&r.isNaN(l)))return!1}return!0},Ct.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Ct.copy(e,0,i,0,r),r>0)for(var s=r;s<n;s++)Ct.copy(e,r-1,i,s,1);return i},Ct.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;i<=n;i++)Ct.swap(t,i,e-i)},Ct.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Ct.copy=function(t,e,n,i,r){for(var s=0;s<r;s++)Ct.copyCoord(t,e+s,n,i+s)},Ct.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new P;i.append("(");for(var r=0;r<e;r++){r>0&&i.append(" ");for(var s=0;s<n;s++)s>0&&i.append(","),i.append(Nt.toString(t.getOrdinate(r,s)))}return i.append(")"),i.toString()}},Ct.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(n<=3)return Ct.createClosedRing(t,e,4);var i=e.getOrdinate(0,D.X)===e.getOrdinate(n-1,D.X)&&e.getOrdinate(0,D.Y)===e.getOrdinate(n-1,D.Y);return i?e:Ct.createClosedRing(t,e,n+1)},Ct.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Ct.copy(e,0,i,0,r);for(var s=r;s<n;s++)Ct.copy(e,0,i,s,1);return i},h(St,B),e(St.prototype,{computeEnvelopeInternal:function(){return this.isEmpty()?new C:this.points.expandEnvelope(new C)},isRing:function(){return this.isClosed()&&this.isSimple()},getSortIndex:function(){return B.SORTINDEX_LINESTRING},getCoordinates:function(){return this.points.toCoordinateArray()},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.points.size()!==n.points.size())return!1;for(var i=0;i<this.points.size();i++)if(!this.equal(this.points.getCoordinate(i),n.points.getCoordinate(i),e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<Math.trunc(this.points.size()/2);t++){var e=this.points.size()-1-t;if(!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e))>0&&Ct.reverse(this.points),null}},getCoordinate:function(){return this.isEmpty()?null:this.points.getCoordinate(0)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},getEndPoint:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},getDimension:function(){return 1},getLength:function(){return he.computeLength(this.points)},getNumPoints:function(){return this.points.size()},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLineString(t);return e},compareToSameClass:function(){if(1===arguments.length){for(var t=arguments[0],e=t,n=0,i=0;n<this.points.size()&&i<e.points.size();){var r=this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if(0!==r)return r;n++,i++}return n<this.points.size()?1:i<e.points.size()?-1:0}if(2===arguments.length){var s=arguments[0],o=arguments[1],e=s;return o.compare(this.points,e.points)}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.points.size();e++)t.filter(this.points.getCoordinate(e));else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.points.size())return null;for(var e=0;e<this.points.size()&&(n.filter(this.points,e),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this)}},getBoundary:function(){return new dt(this).getBoundary()},isEquivalentClass:function(t){return t instanceof St},clone:function(){var t=B.prototype.clone.call(this);return t.points=this.points.clone(),t},getCoordinateN:function(t){return this.points.getCoordinate(t)},getGeometryType:function(){return"LineString"},copy:function(){return new St(this.points.copy(),this.factory)},getCoordinateSequence:function(){return this.points},isEmpty:function(){return 0===this.points.size()},init:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.points=t},isCoordinate:function(t){for(var e=0;e<this.points.size();e++)if(this.points.getCoordinate(e).equals(t))return!0;return!1},getStartPoint:function(){return this.isEmpty()?null:this.getPointN(0)},getPointN:function(t){return this.getFactory().createPoint(this.points.getCoordinate(t))},interfaces_:function(){return[st]},getClass:function(){return St}}),St.serialVersionUID=0x2b2b51ba435c8e00,e(wt.prototype,{interfaces_:function(){return[]},getClass:function(){return wt}}),h(Lt,B),e(Lt.prototype,{computeEnvelopeInternal:function(){if(this.isEmpty())return new C;var t=new C;return t.expandToInclude(this.coordinates.getX(0),this.coordinates.getY(0)),t},getSortIndex:function(){return B.SORTINDEX_POINT},getCoordinates:function(){return this.isEmpty()?[]:[this.getCoordinate()]},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){},getCoordinate:function(){return 0!==this.coordinates.size()?this.coordinates.getCoordinate(0):null},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getNumPoints:function(){return this.isEmpty()?0:1},reverse:function(){return this.copy()},getX:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getCoordinate().compareTo(e.getCoordinate())}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return i.compare(this.coordinates,e.coordinates)}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(R(arguments[0],ct)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this.coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var n=arguments[0];n.filter(this)}else if(R(arguments[0],q)){var i=arguments[0];i.filter(this)}},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},clone:function(){var t=B.prototype.clone.call(this);return t.coordinates=this.coordinates.clone(),t},getGeometryType:function(){return"Point"},copy:function(){return new Lt(this.coordinates.copy(),this.factory)},getCoordinateSequence:function(){return this.coordinates},getY:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y},isEmpty:function(){return 0===this.coordinates.size()},init:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),f.isTrue(t.size()<=1),this.coordinates=t},isSimple:function(){return!0},interfaces_:function(){return[wt]},getClass:function(){return Lt}}),Lt.serialVersionUID=0x44077bad161cbc00,e(Rt.prototype,{interfaces_:function(){return[]},getClass:function(){return Rt}}),h(Tt,B),e(Tt.prototype,{computeEnvelopeInternal:function(){return this.shell.getEnvelopeInternal()},getSortIndex:function(){return B.SORTINDEX_POLYGON},getCoordinates:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this.shell.getCoordinates(),i=0;i<n.length;i++)e++,t[e]=n[i];for(var r=0;r<this.holes.length;r++)for(var s=this.holes[r].getCoordinates(),o=0;o<s.length;o++)e++,t[e]=s[o];return t},getArea:function(){var t=0;t+=Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for(var e=0;e<this.holes.length;e++)t-=Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t},isRectangle:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this.shell)return!1;if(5!==this.shell.getNumPoints())return!1;for(var t=this.shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;n<5;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var s=t.getX(0),o=t.getY(0),n=1;n<=4;n++){var i=t.getX(n),r=t.getY(n),a=i!==s,u=r!==o;if(a===u)return!1;s=i,o=r}return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,i=this.shell,r=n.shell;if(!i.equalsExact(r,e))return!1;if(this.holes.length!==n.holes.length)return!1;for(var s=0;s<this.holes.length;s++)if(!this.holes[s].equalsExact(n.holes[s],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){if(0===arguments.length){this.normalize(this.shell,!0);for(var t=0;t<this.holes.length;t++)this.normalize(this.holes[t],!1);ut.sort(this.holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);A.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=H.minCoordinate(e.getCoordinates());H.scroll(i,r),A.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],he.isCCW(e.getCoordinates())===n&&H.reverse(e.getCoordinates())}},getCoordinate:function(){return this.shell.getCoordinate()},getNumInteriorRing:function(){return this.holes.length},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},getLength:function(){var t=0;t+=this.shell.getLength();for(var e=0;e<this.holes.length;e++)t+=this.holes[e].getLength();return t},getNumPoints:function(){for(var t=this.shell.getNumPoints(),e=0;e<this.holes.length;e++)t+=this.holes[e].getNumPoints();return t},reverse:function(){var t=this.copy();t.shell=this.shell.copy().reverse(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].copy().reverse();return t},convexHull:function(){return this.getExteriorRing().convexHull()},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=this.shell,n=t.shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],s=i,e=this.shell,n=s.shell,o=e.compareToSameClass(n,r);if(0!==o)return o;for(var a=this.getNumInteriorRing(),u=s.getNumInteriorRing(),l=0;l<a&&l<u;){var h=this.getInteriorRingN(l),c=s.getInteriorRingN(l),f=h.compareToSameClass(c,r);if(0!==f)return f;l++}return l<a?1:l<u?-1:0}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];this.shell.apply(t);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(t)}else if(R(arguments[0],ct)){var n=arguments[0];if(this.shell.apply(n),!n.isDone())for(var e=0;e<this.holes.length&&(this.holes[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this),this.shell.apply(r);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(r)}},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this.holes.length+1).fill(null);t[0]=this.shell;for(var e=0;e<this.holes.length;e++)t[e+1]=this.holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},clone:function(){var t=B.prototype.clone.call(this);t.shell=this.shell.clone(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].clone();return t},getGeometryType:function(){return"Polygon"},copy:function(){for(var t=this.shell.copy(),e=new Array(this.holes.length).fill(null),n=0;n<e.length;n++)e[n]=this.holes[n].copy();return new Tt(t,e,this.factory)},getExteriorRing:function(){return this.shell},isEmpty:function(){return this.shell.isEmpty()},getInteriorRingN:function(t){return this.holes[t]},interfaces_:function(){return[Rt]},getClass:function(){return Tt}}),Tt.serialVersionUID=-0x307ffefd8dc97200,h(Pt,ft),e(Pt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOINT},isValid:function(){return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&ft.prototype.equalsExact.call(this,t,e)}return ft.prototype.equalsExact.apply(this,arguments)},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.geometries[t].getCoordinate()}return ft.prototype.getCoordinate.apply(this,arguments)},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},getGeometryType:function(){return"MultiPoint"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Pt(t,this.factory)},interfaces_:function(){return[wt]},getClass:function(){return Pt}}),Pt.serialVersionUID=-0x6fb1ed4162e0fc00,h(bt,St),e(bt.prototype,{getSortIndex:function(){return B.SORTINDEX_LINEARRING},getBoundaryDimension:function(){return lt.FALSE},isClosed:function(){return!!this.isEmpty()||St.prototype.isClosed.call(this)},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLinearRing(t);return e},validateConstruction:function(){if(!this.isEmpty()&&!St.prototype.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<bt.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},getGeometryType:function(){return"LinearRing"},copy:function(){return new bt(this.points.copy(),this.factory)},interfaces_:function(){return[]},getClass:function(){return bt}}),bt.MINIMUM_VALID_SIZE=4,bt.serialVersionUID=-0x3b229e262367a600,h(Ot,ft),e(Ot.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOLYGON},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&ft.prototype.equalsExact.call(this,t,e)}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new I,e=0;e<this.geometries.length;e++)for(var n=this.geometries[e],i=n.getBoundary(),r=0;r<i.getNumGeometries();r++)t.add(i.getGeometryN(r));var s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))},getGeometryType:function(){return"MultiPolygon"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Ot(t,this.factory)},interfaces_:function(){return[Rt]},getClass:function(){return Ot}}),Ot.serialVersionUID=-0x7a5aa1369171980,e(_t.prototype,{setCopyUserData:function(t){this.isUserDataCopied=t},edit:function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this.isUserDataCopied&&n.setUserData(t.getUserData()),n},editInternal:function(t,e){return null===this.factory&&(this.factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,e):t instanceof Tt?this.editPolygon(t,e):t instanceof Lt?e.edit(t,this.factory):t instanceof St?e.edit(t,this.factory):(f.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},editGeometryCollection:function(t,e){for(var n=e.edit(t,this.factory),i=new I,r=0;r<n.getNumGeometries();r++){var s=this.edit(n.getGeometryN(r),e);null===s||s.isEmpty()||i.add(s)}return n.getClass()===Pt?this.factory.createMultiPoint(i.toArray([])):n.getClass()===gt?this.factory.createMultiLineString(i.toArray([])):n.getClass()===Ot?this.factory.createMultiPolygon(i.toArray([])):this.factory.createGeometryCollection(i.toArray([]))},editPolygon:function(t,e){var n=e.edit(t,this.factory);if(null===n&&(n=this.factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this.factory.createPolygon();for(var r=new I,s=0;s<n.getNumInteriorRing();s++){var o=this.edit(n.getInteriorRingN(s),e);null===o||o.isEmpty()||r.add(o)}return this.factory.createPolygon(i,r.toArray([]))},interfaces_:function(){return[]},getClass:function(){return _t}}),_t.GeometryEditorOperation=Mt,e(Dt.prototype,{edit:function(t,e){return t},interfaces_:function(){return[Mt]},getClass:function(){return Dt}}),e(At.prototype,{edit:function(t,e){var n=this.editCoordinates(t.getCoordinates(),t);return null===n?t:t instanceof bt?e.createLinearRing(n):t instanceof St?e.createLineString(n):t instanceof Lt?n.length>0?e.createPoint(n[0]):e.createPoint():t},interfaces_:function(){return[Mt]},getClass:function(){return At}}),e(Ft.prototype,{edit:function(t,e){return t instanceof bt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof St?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Lt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},interfaces_:function(){return[Mt]},getClass:function(){return Ft}}),_t.NoOpGeometryOperation=Dt,_t.CoordinateOperation=At,_t.CoordinateSequenceOperation=Ft,e(Gt.prototype,{setOrdinate:function(t,e,n){switch(e){case D.X:this.coordinates[t].x=n;break;case D.Y:this.coordinates[t].y=n;break;case D.Z:this.coordinates[t].z=n;break;default:throw new i("invalid ordinateIndex")}},size:function(){return this.coordinates.length},getOrdinate:function(t,e){switch(e){case D.X:return this.coordinates[t].x;case D.Y:return this.coordinates[t].y;case D.Z:return this.coordinates[t].z}return r.NaN},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this.coordinates[e].x,n.y=this.coordinates[e].y,n.z=this.coordinates[e].z}},getCoordinateCopy:function(t){return new g(this.coordinates[t])},getDimension:function(){return this.dimension},getX:function(t){return this.coordinates[t].x},clone:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].clone();return new Gt(t,this.dimension)},expandEnvelope:function(t){for(var e=0;e<this.coordinates.length;e++)t.expandToInclude(this.coordinates[e]);return t},copy:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].copy();return new Gt(t,this.dimension)},toString:function(){if(this.coordinates.length>0){var t=new P(17*this.coordinates.length);t.append("("),t.append(this.coordinates[0]);for(var e=1;e<this.coordinates.length;e++)t.append(", "),t.append(this.coordinates[e]);return t.append(")"),t.toString()}return"()"},getY:function(t){return this.coordinates[t].y},toCoordinateArray:function(){return this.coordinates},interfaces_:function(){return[D,u]},getClass:function(){return Gt}}),Gt.serialVersionUID=-0xcb44a778db18e00,e(qt.prototype,{readResolve:function(){return qt.instance()},create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Gt(t)}if(R(arguments[0],D)){var e=arguments[0];return new Gt(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),i<2?new Gt(n):new Gt(n,i)}},interfaces_:function(){return[G,u]},getClass:function(){return qt}}),qt.instance=function(){return qt.instanceObject},qt.serialVersionUID=-0x38e49fa6cf6f2e00,qt.instanceObject=new qt;var no,io=Object.defineProperty,ro=zt({delete:kt,has:Xt,get:Yt,set:Ht,keys:jt,values:Kt,entries:Zt,forEach:$t,clear:Wt}),so="undefined"!=typeof Map&&Map.prototype.values?Map:ro;te.prototype=new K,te.prototype.get=function(t){return this.map_.get(t)||null},te.prototype.put=function(t,e){return this.map_.set(t,e),e},te.prototype.values=function(){for(var t=new I,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},te.prototype.entrySet=function(){var t=new J;return this.map_.entries().forEach(function(e){return t.add(e)}),t},te.prototype.size=function(){return this.map_.size()},e(ee.prototype,{equals:function(t){if(!(t instanceof ee))return!1;var e=t;return this.modelType===e.modelType&&this.scale===e.scale},compareTo:function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i))},getScale:function(){return this.scale},isFloating:function(){return this.modelType===ee.FLOATING||this.modelType===ee.FLOATING_SINGLE},getType:function(){return this.modelType},toString:function(){var t="UNKNOWN";return this.modelType===ee.FLOATING?t="Floating":this.modelType===ee.FLOATING_SINGLE?t="Floating-Single":this.modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},makePrecise:function(){if("number"==typeof arguments[0]){var t=arguments[0];if(r.isNaN(t))return t;if(this.modelType===ee.FLOATING_SINGLE){var e=t;return e}return this.modelType===ee.FIXED?Math.round(t*this.scale)/this.scale:t}if(arguments[0]instanceof g){var n=arguments[0];if(this.modelType===ee.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}},getMaximumSignificantDigits:function(){var t=16;return this.modelType===ee.FLOATING?t=16:this.modelType===ee.FLOATING_SINGLE?t=6:this.modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},setScale:function(t){this.scale=Math.abs(t)},interfaces_:function(){return[u,s]},getClass:function(){return ee}}),ee.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},e(ne.prototype,{readResolve:function(){return ne.nameToTypeMap.get(this.name)},toString:function(){return this.name},interfaces_:function(){return[u]},getClass:function(){return ne}}),ne.serialVersionUID=-552860263173159e4,ne.nameToTypeMap=new te,ee.Type=ne,ee.serialVersionUID=0x6bee6404e9a25c00,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992,e(ie.prototype,{toGeometry:function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)},createLineString:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new St(e,this)}}},createMultiLineString:function(){if(0===arguments.length)return new gt(null,this);if(1===arguments.length){var t=arguments[0];return new gt(t,this)}},buildGeometry:function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var s=r.next(),o=s.getClass();null===e&&(e=o),o!==e&&(n=!0),s.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ie.toGeometryArray(t));var a=t.iterator().next(),u=t.size()>1;if(u){if(a instanceof Tt)return this.createMultiPolygon(ie.toPolygonArray(t));if(a instanceof St)return this.createMultiLineString(ie.toLineStringArray(t));if(a instanceof Lt)return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},createMultiPointFromCoords:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},createPoint:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(R(arguments[0],D)){var e=arguments[0];return new Lt(e,this)}}},getCoordinateSequenceFactory:function(){return this.coordinateSequenceFactory},createPolygon:function(){if(0===arguments.length)return new Tt(null,null,this);if(1===arguments.length){if(R(arguments[0],D)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof bt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new Tt(i,r,this)}},getSRID:function(){return this.SRID},createGeometryCollection:function(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){var t=arguments[0];return new ft(t,this)}},createGeometry:function(t){var e=new _t(this);return e.edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t)}}})},getPrecisionModel:function(){return this.precisionModel},createLinearRing:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new bt(e,this)}}},createMultiPolygon:function(){if(0===arguments.length)return new Ot(null,this);if(1===arguments.length){var t=arguments[0];return new Ot(t,this)}},createMultiPoint:function(){if(0===arguments.length)return new Pt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Pt(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(R(arguments[0],D)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var s=this.getCoordinateSequenceFactory().create(1,n.getDimension());Ct.copy(n,r,s,0,1),i[r]=this.createPoint(s)}return this.createMultiPoint(i)}}},interfaces_:function(){return[u]},getClass:function(){return ie}}),ie.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.getDefaultCoordinateSequenceFactory=function(){return qt.instance()},ie.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},ie.serialVersionUID=-0x5ea75f2051eeb400;var oo={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};e(re.prototype,{read:function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=oo.typeStr.exec(t);if(t.search("EMPTY")!==-1&&(r=oo.emptyTypeStr.exec(t),r[2]=void 0),r&&(n=r[1].toLowerCase(),
i=r[2],uo[n]&&(e=uo[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},write:function(t){return this.extractGeometry(t)},extractGeometry:function(t){var e=t.getGeometryType().toLowerCase();if(!ao[e])return null;var n,i=e.toUpperCase();return n=t.isEmpty()?i+" EMPTY":i+"("+ao[e].apply(this,[t])+")"}});var ao={coordinate:function(t){return t.x+" "+t.y},point:function(t){return ao.coordinate.call(this,t.coordinates.coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t.geometries.length;n<i;++n)e.push("("+ao.point.apply(this,[t.geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;n<i;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;n<i;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t.geometries.length;n<i;++n)e.push("("+ao.linestring.apply(this,[t.geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+ao.linestring.apply(this,[t.shell])+")");for(var n=0,i=t.holes.length;n<i;++n)e.push("("+ao.linestring.apply(this,[t.holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t.geometries.length;n<i;++n)e.push("("+ao.polygon.apply(this,[t.geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t.geometries.length;n<i;++n)e.push(this.extractGeometry(t.geometries[n]));return e.join(",")}},uo={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;r<s;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;r<s;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;r<s;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(oo.parenComma),i=[],r=0,s=n.length;r<s;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,s=t.trim().split(oo.parenComma),o=[],a=0,u=s.length;a<u;++a)e=s[a].replace(oo.trimParens,"$1"),n=uo.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n.points),0===a?r=i:o.push(i);return this.geometryFactory.createPolygon(r,o)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(oo.doubleParenComma),i=[],r=0,s=n.length;r<s;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();t=t.replace(/,\s*([A-Za-z])/g,"|$1");for(var e=t.trim().split("|"),n=[],i=0,r=e.length;i<r;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}};e(se.prototype,{write:function(t){return this.parser.write(t)}}),e(se,{toLineString:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}),e(oe.prototype,{getIndexAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intLineIndex[t][e]},getTopologySummary:function(){var t=new P;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},computeIntersection:function(t,e,n,i){this.inputLines[0][0]=t,this.inputLines[0][1]=e,this.inputLines[1][0]=n,this.inputLines[1][1]=i,this.result=this.computeIntersect(t,e,n,i)},getIntersectionNum:function(){return this.result},computeIntLineIndex:function(){if(0===arguments.length)null===this.intLineIndex&&(this.intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0],e=this.getEdgeDistance(t,0),n=this.getEdgeDistance(t,1);e>n?(this.intLineIndex[t][0]=0,this.intLineIndex[t][1]=1):(this.intLineIndex[t][0]=1,this.intLineIndex[t][1]=0)}},isProper:function(){return this.hasIntersection()&&this._isProper},setPrecisionModel:function(t){this.precisionModel=t},isInteriorIntersection:function(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this.result;e++)if(!this.intPt[e].equals2D(this.inputLines[t][0])&&!this.intPt[e].equals2D(this.inputLines[t][1]))return!0;return!1}},getIntersection:function(t){return this.intPt[t]},isEndPoint:function(){return this.hasIntersection()&&!this._isProper},hasIntersection:function(){return this.result!==oe.NO_INTERSECTION},getEdgeDistance:function(t,e){var n=oe.computeEdgeDistance(this.intPt[e],this.inputLines[t][0],this.inputLines[t][1]);return n},isCollinear:function(){return this.result===oe.COLLINEAR_INTERSECTION},toString:function(){return se.toLineString(this.inputLines[0][0],this.inputLines[0][1])+" - "+se.toLineString(this.inputLines[1][0],this.inputLines[1][1])+this.getTopologySummary()},getEndpoint:function(t,e){return this.inputLines[t][e]},isIntersection:function(t){for(var e=0;e<this.result;e++)if(this.intPt[e].equals2D(t))return!0;return!1},getIntersectionAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intPt[this.intLineIndex[t][e]]},interfaces_:function(){return[]},getClass:function(){return oe}}),oe.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=-1;if(t.equals(e))s=0;else if(t.equals(n))s=i>r?i:r;else{var o=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);s=i>r?o:a,0!==s||t.equals(e)||(s=Math.max(o,a))}return f.isTrue(!(0===s&&!t.equals(e)),"Bad distance calculation"),s},oe.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=Math.sqrt(i*i+r*r);return f.isTrue(!(0===s&&!t.equals(e)),"Invalid distance calculation"),s},oe.DONT_INTERSECT=0,oe.DO_INTERSECT=1,oe.COLLINEAR=2,oe.NO_INTERSECTION=0,oe.POINT_INTERSECTION=1,oe.COLLINEAR_INTERSECTION=2,h(ae,oe),e(ae.prototype,{isInSegmentEnvelopes:function(t){var e=new C(this.inputLines[0][0],this.inputLines[0][1]),n=new C(this.inputLines[1][0],this.inputLines[1][1]);return e.contains(t)&&n.contains(t)},computeIntersection:function(){if(3!==arguments.length)return oe.prototype.computeIntersection.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];return this._isProper=!1,C.intersects(e,n,t)&&0===he.orientationIndex(e,n,t)&&0===he.orientationIndex(n,e,t)?(this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this.result=oe.POINT_INTERSECTION,null):void(this.result=oe.NO_INTERSECTION)},normalizeToMinimum:function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},safeHCoordinateIntersection:function(t,e,n,i){var r=null;try{r=F.intersection(t,e,n,i)}catch(s){if(!(s instanceof w))throw s;r=ae.nearestEndpoint(t,e,n,i)}finally{}return r},intersection:function(t,e,n,i){var r=this.intersectionWithNormalization(t,e,n,i);return this.isInSegmentEnvelopes(r)||(r=new g(ae.nearestEndpoint(t,e,n,i))),null!==this.precisionModel&&this.precisionModel.makePrecise(r),r},smallestInAbsValue:function(t,e,n,i){var r=t,s=Math.abs(r);return Math.abs(e)<s&&(r=e,s=Math.abs(e)),Math.abs(n)<s&&(r=n,s=Math.abs(n)),Math.abs(i)<s&&(r=i),r},checkDD:function(t,e,n,i,r){var s=M.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(s);A.out.println("DD in env = "+o+"  --------------------- "+s),r.distance(s)>1e-4&&A.out.println("Distance = "+r.distance(s))},intersectionWithNormalization:function(t,e,n,i){var r=new g(t),s=new g(e),o=new g(n),a=new g(i),u=new g;this.normalizeToEnvCentre(r,s,o,a,u);var l=this.safeHCoordinateIntersection(r,s,o,a);return l.x+=u.x,l.y+=u.y,l},computeCollinearIntersection:function(t,e,n,i){var r=C.intersects(t,e,n),s=C.intersects(t,e,i),o=C.intersects(n,i,t),a=C.intersects(n,i,e);return r&&s?(this.intPt[0]=n,this.intPt[1]=i,oe.COLLINEAR_INTERSECTION):o&&a?(this.intPt[0]=t,this.intPt[1]=e,oe.COLLINEAR_INTERSECTION):r&&o?(this.intPt[0]=n,this.intPt[1]=t,!n.equals(t)||s||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):r&&a?(this.intPt[0]=n,this.intPt[1]=e,!n.equals(e)||s||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&o?(this.intPt[0]=i,this.intPt[1]=t,!i.equals(t)||r||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&a?(this.intPt[0]=i,this.intPt[1]=e,!i.equals(e)||r||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):oe.NO_INTERSECTION},normalizeToEnvCentre:function(t,e,n,i,r){var s=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,h=n.y<i.y?n.y:i.y,c=n.x>i.x?n.x:i.x,f=n.y>i.y?n.y:i.y,g=s>l?s:l,d=a<c?a:c,p=o>h?o:h,v=u<f?u:f,m=(g+d)/2,y=(p+v)/2;r.x=m,r.y=y,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},computeIntersect:function(t,e,n,i){if(this._isProper=!1,!C.intersects(t,e,n,i))return oe.NO_INTERSECTION;var r=he.orientationIndex(t,e,n),s=he.orientationIndex(t,e,i);if(r>0&&s>0||r<0&&s<0)return oe.NO_INTERSECTION;var o=he.orientationIndex(n,i,t),a=he.orientationIndex(n,i,e);if(o>0&&a>0||o<0&&a<0)return oe.NO_INTERSECTION;var u=0===r&&0===s&&0===o&&0===a;return u?this.computeCollinearIntersection(t,e,n,i):(0===r||0===s||0===o||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this.intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this.intPt[0]=e:0===r?this.intPt[0]=new g(n):0===s?this.intPt[0]=new g(i):0===o?this.intPt[0]=new g(t):0===a&&(this.intPt[0]=new g(e))):(this._isProper=!0,this.intPt[0]=this.intersection(t,e,n,i)),oe.POINT_INTERSECTION)},interfaces_:function(){return[]},getClass:function(){return ae}}),ae.nearestEndpoint=function(t,e,n,i){var r=t,s=he.distancePointLine(t,n,i),o=he.distancePointLine(e,n,i);return o<s&&(s=o,r=e),o=he.distancePointLine(n,t,e),o<s&&(s=o,r=n),o=he.distancePointLine(i,t,e),o<s&&(s=o,r=i),r},e(ue.prototype,{interfaces_:function(){return[]},getClass:function(){return ue}}),ue.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-e.x,o=n.y-e.y;return ue.signOfDet2x2(i,r,s,o)},ue.signOfDet2x2=function(t,e,n,i){var r=null,s=null,o=null,a=0;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(0<e?0<i?e<=i||(r=-r,s=t,t=n,n=s,s=e,e=i,i=s):e<=-i?(r=-r,n=-n,i=-i):(s=t,t=-n,n=s,s=e,e=-i,i=s):0<i?-e<=i?(r=-r,t=-t,e=-e):(s=-t,t=n,n=s,s=-e,e=i,i=s):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,s=-t,t=-n,n=s,s=-e,e=-i,i=s),0<t){if(!(0<n))return r;if(!(t<=n))return r}else{if(0<n)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(a+=1,o=Math.floor(n/t),n-=o*t,i-=o*e,i<0)return-r;if(i>e)return r;if(t>n+n){if(e<i+i)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(o=Math.floor(t/n),t-=o*n,e-=o*i,e<0)return r;if(e>i)return-r;if(n>t+t){if(i<e+e)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}},e(le.prototype,{countSegment:function(t,e){if(t.x<this.p.x&&e.x<this.p.x)return null;if(this.p.x===e.x&&this.p.y===e.y)return this.isPointOnSegment=!0,null;if(t.y===this.p.y&&e.y===this.p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this.p.x>=n&&this.p.x<=i&&(this.isPointOnSegment=!0),null}if(t.y>this.p.y&&e.y<=this.p.y||e.y>this.p.y&&t.y<=this.p.y){var r=t.x-this.p.x,s=t.y-this.p.y,o=e.x-this.p.x,a=e.y-this.p.y,u=ue.signOfDet2x2(r,s,o,a);if(0===u)return this.isPointOnSegment=!0,null;a<s&&(u=-u),u>0&&this.crossingCount++}},isPointInPolygon:function(){return this.getLocation()!==L.EXTERIOR},getLocation:function(){return this.isPointOnSegment?L.BOUNDARY:this.crossingCount%2===1?L.INTERIOR:L.EXTERIOR},isOnSegment:function(){return this.isPointOnSegment},interfaces_:function(){return[]},getClass:function(){return le}}),le.locatePointInRing=function(){if(arguments[0]instanceof g&&R(arguments[1],D)){for(var t=arguments[0],e=arguments[1],n=new le(t),i=new g,r=new g,s=1;s<e.size();s++)if(e.getCoordinate(s,i),e.getCoordinate(s-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){for(var o=arguments[0],a=arguments[1],n=new le(o),s=1;s<a.length;s++){var i=a[s],r=a[s-1];if(n.countSegment(i,r),n.isOnSegment())return n.getLocation()}return n.getLocation()}},e(he.prototype,{interfaces_:function(){return[]},getClass:function(){return he}}),he.orientationIndex=function(t,e,n){return M.orientationIndex(t,e,n)},he.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,s=t[i+1].y,o=t[i-1].y;e+=r*(o-s)}return e/2}if(R(arguments[0],D)){var a=arguments[0],u=a.size();if(u<3)return 0;var l=new g,h=new g,c=new g;a.getCoordinate(0,h),a.getCoordinate(1,c);var n=h.x;c.x-=n;for(var e=0,i=1;i<u-1;i++)l.y=h.y,h.x=c.x,h.y=c.y,a.getCoordinate(i+1,c),c.x-=n,e+=h.x*(l.y-c.y);return e/2}},he.distanceLineLine=function(t,e,n,i){if(t.equals(e))return he.distancePointLine(t,n,i);if(n.equals(i))return he.distancePointLine(i,t,e);var r=!1;if(C.intersects(t,e,n,i)){var s=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===s)r=!0;else{var o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y),u=a/s,l=o/s;(l<0||l>1||u<0||u>1)&&(r=!0)}}else r=!0;return r?T.min(he.distancePointLine(t,n,i),he.distancePointLine(e,n,i),he.distancePointLine(n,t,e),he.distancePointLine(i,t,e)):0},he.isPointInRing=function(t,e){return he.locatePointInRing(t,e)!==L.EXTERIOR},he.computeLength=function(t){var e=t.size();if(e<=1)return 0;var n=0,i=new g;t.getCoordinate(0,i);for(var r=i.x,s=i.y,o=1;o<e;o++){t.getCoordinate(o,i);var a=i.x,u=i.y,l=a-r,h=u-s;n+=Math.sqrt(l*l+h*h),r=a,s=u}return n},he.isCCW=function(t){var e=t.length-1;if(e<3)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],r=0,s=1;s<=e;s++){var o=t[s];o.y>n.y&&(n=o,r=s)}var a=r;do a-=1,a<0&&(a=e);while(t[a].equals2D(n)&&a!==r);var u=r;do u=(u+1)%e;while(t[u].equals2D(n)&&u!==r);var l=t[a],h=t[u];if(l.equals2D(n)||h.equals2D(n)||l.equals2D(h))return!1;var c=he.computeOrientation(l,n,h),f=!1;return f=0===c?l.x>h.x:c>0},he.locatePointInRing=function(t,e){return le.locatePointInRing(t,e)},he.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},he.computeOrientation=function(t,e,n){return he.orientationIndex(t,e,n)},he.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new i("Line array must contain at least one vertex");for(var n=t.distance(e[0]),r=0;r<e.length-1;r++){var s=he.distancePointLine(t,e[r],e[r+1]);s<n&&(n=s)}return n}if(3===arguments.length){var o=arguments[0],a=arguments[1],u=arguments[2];if(a.x===u.x&&a.y===u.y)return o.distance(a);var l=(u.x-a.x)*(u.x-a.x)+(u.y-a.y)*(u.y-a.y),h=((o.x-a.x)*(u.x-a.x)+(o.y-a.y)*(u.y-a.y))/l;if(h<=0)return o.distance(a);if(h>=1)return o.distance(u);var c=((a.y-o.y)*(u.x-a.x)-(a.x-o.x)*(u.y-a.y))/l;return Math.abs(c)*Math.sqrt(l)}},he.isOnLine=function(t,e){for(var n=new ae,i=1;i<e.length;i++){var r=e[i-1],s=e[i];if(n.computeIntersection(t,r,s),n.hasIntersection())return!0}return!1},he.CLOCKWISE=-1,he.RIGHT=he.CLOCKWISE,he.COUNTERCLOCKWISE=1,he.LEFT=he.COUNTERCLOCKWISE,he.COLLINEAR=0,he.STRAIGHT=he.COLLINEAR,e(ce.prototype,{minX:function(){return Math.min(this.p0.x,this.p1.x)},orientationIndex:function(){if(arguments[0]instanceof ce){var t=arguments[0],e=he.orientationIndex(this.p0,this.p1,t.p0),n=he.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof g){var i=arguments[0];return he.orientationIndex(this.p0,this.p1,i)}},toGeometry:function(t){return t.createLineString([this.p0,this.p1])},isVertical:function(){return this.p0.x===this.p1.x},equals:function(t){if(!(t instanceof ce))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},intersection:function(t){var e=new ae;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},project:function(){if(arguments[0]instanceof g){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);var e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ce){var i=arguments[0],r=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(r>=1&&s>=1)return null;if(r<=0&&s<=0)return null;var o=this.project(i.p0);r<0&&(o=this.p0),r>1&&(o=this.p1);var a=this.project(i.p1);return s<0&&(a=this.p0),s>1&&(a=this.p1),new ce(o,a)}},normalize:function(){this.p1.compareTo(this.p0)<0&&this.reverse()},angle:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},getCoordinate:function(t){return 0===t?this.p0:this.p1},distancePerpendicular:function(t){return he.distancePointLinePerpendicular(t,this.p0,this.p1)},minY:function(){return Math.min(this.p0.y,this.p1.y)},midPoint:function(){return ce.midPoint(this.p0,this.p1)},projectionFactor:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(i<=0)return r.NaN;var s=((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i;return s},closestPoints:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=r.MAX_VALUE,s=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var a=this.closestPoint(t.p1);s=a.distance(t.p1),s<i&&(i=s,n[0]=a,n[1]=t.p1);var u=t.closestPoint(this.p0);s=u.distance(this.p0),s<i&&(i=s,n[0]=this.p0,n[1]=u);var l=t.closestPoint(this.p1);return s=l.distance(this.p1),s<i&&(i=s,n[0]=this.p1,n[1]=l),n},closestPoint:function(t){var e=this.projectionFactor(t);if(e>0&&e<1)return this.project(t);var n=this.p0.distance(t),i=this.p1.distance(t);return n<i?this.p0:this.p1},maxX:function(){return Math.max(this.p0.x,this.p1.x)},getLength:function(){return this.p0.distance(this.p1)},compareTo:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},reverse:function(){var t=this.p0;this.p0=this.p1,this.p1=t},equalsTopo:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)},lineIntersection:function(t){try{var e=F.intersection(this.p0,this.p1,t.p0,t.p1);return e}catch(t){if(!(t instanceof w))throw t}finally{}return null},maxY:function(){return Math.max(this.p0.y,this.p1.y)},pointAlongOffset:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y,o=Math.sqrt(r*r+s*s),a=0,u=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*r/o,u=e*s/o}var l=n-u,h=i+a,c=new g(l,h);return c},setCoordinates:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},segmentFraction:function(t){var e=this.projectionFactor(t);return e<0?e=0:(e>1||r.isNaN(e))&&(e=1),e},toString:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},isHorizontal:function(){return this.p0.y===this.p1.y},distance:function(){if(arguments[0]instanceof ce){var t=arguments[0];return he.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){var e=arguments[0];return he.distancePointLine(e,this.p0,this.p1)}},pointAlong:function(t){var e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},hashCode:function(){var t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=java.lang.Double.doubleToLongBits(this.p1.x);n^=31*java.lang.Double.doubleToLongBits(this.p1.y);var i=Math.trunc(n)^Math.trunc(n>>32);return e^i},interfaces_:function(){return[s,u]},getClass:function(){return ce}}),ce.midPoint=function(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)},ce.serialVersionUID=0x2d2172135f411c00,e(fe.prototype,{isIntersects:function(){return!this.isDisjoint()},isCovers:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},isCoveredBy:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},set:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.matrix[n][i]=lt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]=o}},isContains:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},setAtLeast:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,lt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]<o&&(this.matrix[r][s]=o)}},setAtLeastIfValid:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)},isWithin:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},isTouches:function(t,e){return t>e?this.isTouches(e,t):(t===lt.A&&e===lt.A||t===lt.L&&e===lt.L||t===lt.L&&e===lt.A||t===lt.P&&e===lt.A||t===lt.P&&e===lt.L)&&(this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&(fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])))},isOverlaps:function(t,e){return t===lt.P&&e===lt.P||t===lt.A&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L&&(1===this.matrix[L.INTERIOR][L.INTERIOR]&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]))},isEquals:function(t,e){return t===e&&(fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE)},toString:function(){for(var t=new P("123456789"),e=0;e<3;e++)for(var n=0;n<3;n++)t.setCharAt(3*e+n,lt.toDimensionSymbol(this.matrix[e][n]));return t.toString()},setAll:function(t){for(var e=0;e<3;e++)for(var n=0;n<3;n++)this.matrix[e][n]=t},get:function(t,e){return this.matrix[t][e]},transpose:function(){var t=this.matrix[1][0];return this.matrix[1][0]=this.matrix[0][1],this.matrix[0][1]=t,t=this.matrix[2][0],this.matrix[2][0]=this.matrix[0][2],this.matrix[0][2]=t,t=this.matrix[2][1],this.matrix[2][1]=this.matrix[1][2],this.matrix[1][2]=t,this},matches:function(t){if(9!==t.length)throw new i("Should be length 9: "+t);for(var e=0;e<3;e++)for(var n=0;n<3;n++)if(!fe.matches(this.matrix[e][n],t.charAt(3*e+n)))return!1;return!0},add:function(t){for(var e=0;e<3;e++)for(var n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))},isDisjoint:function(){return this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.INTERIOR][L.BOUNDARY]===lt.FALSE&&this.matrix[L.BOUNDARY][L.INTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.BOUNDARY]===lt.FALSE},isCrosses:function(t,e){return t===lt.P&&e===lt.L||t===lt.P&&e===lt.A||t===lt.L&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]):t===lt.L&&e===lt.P||t===lt.A&&e===lt.P||t===lt.A&&e===lt.L?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L&&0===this.matrix[L.INTERIOR][L.INTERIOR]},interfaces_:function(){return[o]},getClass:function(){return fe}}),fe.matches=function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],e=arguments[1];return e===lt.SYM_DONTCARE||(e===lt.SYM_TRUE&&(t>=0||t===lt.TRUE)||(e===lt.SYM_FALSE&&t===lt.FALSE||(e===lt.SYM_P&&t===lt.P||(e===lt.SYM_L&&t===lt.L||e===lt.SYM_A&&t===lt.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=new fe(n);return r.matches(i)}},fe.isTrue=function(t){return t>=0||t===lt.TRUE};var lo=Object.freeze({Coordinate:g,CoordinateList:N,Envelope:C,LineSegment:ce,GeometryFactory:ie,Geometry:B,Point:Lt,LineString:St,LinearRing:bt,Polygon:Tt,GeometryCollection:ft,MultiPoint:Pt,MultiLineString:gt,MultiPolygon:Ot,Dimension:lt,IntersectionMatrix:fe,PrecisionModel:ee});e(ge.prototype,{addPoint:function(t){this.ptCount+=1,this.ptCentSum.x+=t.x,this.ptCentSum.y+=t.y},setBasePoint:function(t){null===this.areaBasePt&&(this.areaBasePt=t)},addLineSegments:function(t){for(var e=0,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);if(0!==i){e+=i;var r=(t[n].x+t[n+1].x)/2;this.lineCentSum.x+=i*r;var s=(t[n].y+t[n+1].y)/2;this.lineCentSum.y+=i*s}}this.totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])},addHole:function(t){for(var e=he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},getCentroid:function(){var t=new g;if(Math.abs(this.areasum2)>0)t.x=this.cg3.x/3/this.areasum2,t.y=this.cg3.y/3/this.areasum2;else if(this.totalLength>0)t.x=this.lineCentSum.x/this.totalLength,t.y=this.lineCentSum.y/this.totalLength;else{if(!(this.ptCount>0))return null;t.x=this.ptCentSum.x/this.ptCount,t.y=this.ptCentSum.y/this.ptCount}return t},addShell:function(t){t.length>0&&this.setBasePoint(t[0]);for(var e=!he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},addTriangle:function(t,e,n,i){var r=i?1:-1;ge.centroid3(t,e,n,this.triangleCent3);var s=ge.area2(t,e,n);this.cg3.x+=r*s*this.triangleCent3.x,this.cg3.y+=r*s*this.triangleCent3.y,this.areasum2+=r*s},add:function(){if(arguments[0]instanceof Tt){var t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(var e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof B){var n=arguments[0];if(n.isEmpty())return null;if(n instanceof Lt)this.addPoint(n.getCoordinate());else if(n instanceof St)this.addLineSegments(n.getCoordinates());else if(n instanceof Tt){var i=n;this.add(i)}else if(n instanceof ft)for(var r=n,e=0;e<r.getNumGeometries();e++)this.add(r.getGeometryN(e))}},interfaces_:function(){return[]},getClass:function(){return ge}}),ge.area2=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)},ge.centroid3=function(t,e,n,i){return i.x=t.x+e.x+n.x,i.y=t.y+e.y+n.y,null},ge.getCentroid=function(t){var e=new ge(t);return e.getCentroid()},de.prototype=new Error,de.prototype.name="EmptyStackException",pe.prototype=new y,pe.prototype.add=function(t){return this.array_.push(t),!0},pe.prototype.get=function(t){if(t<0||t>=this.size())throw new IndexOutOfBoundsException;return this.array_[t]},pe.prototype.push=function(t){return this.array_.push(t),t},pe.prototype.pop=function(t){if(0===this.array_.length)throw new de;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new de;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(t){return this.array_.indexOf(t)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},e(ve.prototype,{filter:function(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))},getCoordinates:function(){var t=new Array(this.list.size()).fill(null);return this.list.toArray(t)},interfaces_:function(){return[z]},getClass:function(){return ve}}),ve.filterCoordinates=function(t){for(var e=new ve,n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()},e(me.prototype,{preSort:function(t){for(var e=null,n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ut.sort(t,1,t.length,new ye(t[0])),t},computeOctRing:function(t){var e=this.computeOctPts(t),n=new N;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())},lineOrPolygon:function(t){if(t=this.cleanRing(t),3===t.length)return this.geomFactory.createLineString([t[0],t[1]]);var e=this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e,null)},cleanRing:function(t){f.equals(t[0],t[t.length-1]);for(var e=new I,n=null,i=0;i<=t.length-2;i++){var r=t[i],s=t[i+1];r.equals(s)||null!==n&&this.isBetween(n,r,s)||(e.add(r),n=r)}e.add(t[t.length-1]);var o=new Array(e.size()).fill(null);return e.toArray(o)},isBetween:function(t,e,n){if(0!==he.computeOrientation(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1},reduce:function(t){var e=this.computeOctRing(t);if(null===e)return t;for(var n=new at,i=0;i<e.length;i++)n.add(e[i]);for(var i=0;i<t.length;i++)he.isPointInRing(t[i],e)||n.add(t[i]);var r=H.toCoordinateArray(n);return r.length<3?this.padArray3(r):r},getConvexHull:function(){if(0===this.inputPts.length)return this.geomFactory.createGeometryCollection(null);if(1===this.inputPts.length)return this.geomFactory.createPoint(this.inputPts[0]);if(2===this.inputPts.length)return this.geomFactory.createLineString(this.inputPts);var t=this.inputPts;this.inputPts.length>50&&(t=this.reduce(this.inputPts));var e=this.preSort(t),n=this.grahamScan(e),i=this.toCoordinateArray(n);return this.lineOrPolygon(i)},padArray3:function(t){for(var e=new Array(3).fill(null),n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e},computeOctPts:function(t){for(var e=new Array(8).fill(null),n=0;n<e.length;n++)e[n]=t[0];for(var i=1;i<t.length;i++)t[i].x<e[0].x&&(e[0]=t[i]),t[i].x-t[i].y<e[1].x-e[1].y&&(e[1]=t[i]),t[i].y>e[2].y&&(e[2]=t[i]),t[i].x+t[i].y>e[3].x+e[3].y&&(e[3]=t[i]),t[i].x>e[4].x&&(e[4]=t[i]),t[i].x-t[i].y>e[5].x-e[5].y&&(e[5]=t[i]),t[i].y<e[6].y&&(e[6]=t[i]),t[i].x+t[i].y<e[7].x+e[7].y&&(e[7]=t[i]);return e},toCoordinateArray:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var i=t.get(n);e[n]=i}return e},grahamScan:function(t){var e=null,n=new pe;e=n.push(t[0]),e=n.push(t[1]),e=n.push(t[2]);for(var i=3;i<t.length;i++){for(e=n.pop();!n.empty()&&he.computeOrientation(n.peek(),e,t[i])>0;)e=n.pop();e=n.push(e),e=n.push(t[i]);
}return e=n.push(t[0]),n},interfaces_:function(){return[]},getClass:function(){return me}}),me.extractCoordinates=function(t){var e=new ve;return t.apply(e),e.getCoordinates()},e(ye.prototype,{compare:function(t,e){var n=t,i=e;return ye.polarCompare(this.origin,n,i)},interfaces_:function(){return[a]},getClass:function(){return ye}}),ye.polarCompare=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-t.x,o=n.y-t.y,a=he.computeOrientation(t,e,n);if(a===he.COUNTERCLOCKWISE)return 1;if(a===he.CLOCKWISE)return-1;var u=i*i+r*r,l=s*s+o*o;return u<l?-1:u>l?1:0},me.RadialComparator=ye,e(xe.prototype,{transformPoint:function(t,e){return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},transformPolygon:function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof bt&&!i.isEmpty()||(n=!1);for(var r=new I,s=0;s<t.getNumInteriorRing();s++){var o=this.transformLinearRing(t.getInteriorRingN(s),t);null===o||o.isEmpty()||(o instanceof bt||(n=!1),r.add(o))}if(n)return this.factory.createPolygon(i,r.toArray([]));var a=new I;return null!==i&&a.add(i),a.addAll(r),this.factory.buildGeometry(a)},createCoordinateSequence:function(t){return this.factory.getCoordinateSequenceFactory().create(t)},getInputGeometry:function(){return this.inputGeom},transformMultiLineString:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformCoordinates:function(t,e){return this.copy(t)},transformLineString:function(t,e){return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},transformMultiPoint:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformMultiPolygon:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},copy:function(t){return t.copy()},transformGeometryCollection:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this.pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this.preserveGeometryCollectionType?this.factory.createGeometryCollection(ie.toGeometryArray(n)):this.factory.buildGeometry(n)},transform:function(t){if(this.inputGeom=t,this.factory=t.getFactory(),t instanceof Lt)return this.transformPoint(t,null);if(t instanceof Pt)return this.transformMultiPoint(t,null);if(t instanceof bt)return this.transformLinearRing(t,null);if(t instanceof St)return this.transformLineString(t,null);if(t instanceof gt)return this.transformMultiLineString(t,null);if(t instanceof Tt)return this.transformPolygon(t,null);if(t instanceof Ot)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new i("Unknown Geometry subtype: "+t.getClass().getName())},transformLinearRing:function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this.factory.createLinearRing(null);var i=n.size();return i>0&&i<4&&!this.preserveType?this.factory.createLineString(n):this.factory.createLinearRing(n)},interfaces_:function(){return[]},getClass:function(){return xe}}),e(Ee.prototype,{snapVertices:function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;i<n;i++){var r=t.get(i),s=this.findSnapForVertex(r,e);null!==s&&(t.set(i,new g(s)),0===i&&this._isClosed&&t.set(t.size()-1,new g(s)))}},findSnapForVertex:function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this.snapTolerance)return e[n]}return null},snapTo:function(t){var e=new N(this.srcPts);this.snapVertices(e,t),this.snapSegments(e,t);var n=e.toCoordinateArray();return n},snapSegments:function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;i<n;i++){var r=e[i],s=this.findSegmentIndexToSnap(r,t);s>=0&&t.add(s+1,new g(r),!1)}},findSegmentIndexToSnap:function(t,e){for(var n=r.MAX_VALUE,i=-1,s=0;s<e.size()-1;s++){if(this.seg.p0=e.get(s),this.seg.p1=e.get(s+1),this.seg.p0.equals2D(t)||this.seg.p1.equals2D(t)){if(this.allowSnappingToSourceVertices)continue;return-1}var o=this.seg.distance(t);o<this.snapTolerance&&o<n&&(n=o,i=s)}return i},setAllowSnappingToSourceVertices:function(t){this.allowSnappingToSourceVertices=t},interfaces_:function(){return[]},getClass:function(){return Ee}}),Ee.isClosed=function(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])},e(Ie.prototype,{snapTo:function(t,e){var n=this.extractTargetCoordinates(t),i=new Ne(e,n);return i.transform(this.srcGeom)},snapToSelf:function(t,e){var n=this.extractTargetCoordinates(this.srcGeom),i=new Ne(t,n,(!0)),r=i.transform(this.srcGeom),s=r;return e&&R(s,Rt)&&(s=r.buffer(0)),s},computeSnapTolerance:function(t){var e=this.computeMinimumSegmentLength(t),n=e/10;return n},extractTargetCoordinates:function(t){for(var e=new at,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},computeMinimumSegmentLength:function(t){for(var e=r.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);i<e&&(e=i)}return e},interfaces_:function(){return[]},getClass:function(){return Ie}}),Ie.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ie(t);i[0]=r.snapTo(e,n);var s=new Ie(e);return i[1]=s.snapTo(i[0],n),i},Ie.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ie.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===ee.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r),Ie.computeOverlaySnapTolerance(s))}},Ie.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal(),n=Math.min(e.getHeight(),e.getWidth()),i=n*Ie.SNAP_PRECISION_FACTOR;return i},Ie.snapToSelf=function(t,e,n){var i=new Ie(t);return i.snapToSelf(e,n)},Ie.SNAP_PRECISION_FACTOR=1e-9,h(Ne,xe),e(Ne.prototype,{snapLine:function(t,e){var n=new Ee(t,this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap),n.snapTo(e)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i)},interfaces_:function(){return[]},getClass:function(){return Ne}}),e(Ce.prototype,{getCommon:function(){return r.longBitsToDouble(this.commonBits)},add:function(t){var e=r.doubleToLongBits(t);if(this.isFirst)return this.commonBits=e,this.commonSignExp=Ce.signExpBits(this.commonBits),this.isFirst=!1,null;var n=Ce.signExpBits(e);return n!==this.commonSignExp?(this.commonBits=0,null):(this.commonMantissaBitsCount=Ce.numCommonMostSigMantissaBits(this.commonBits,e),void(this.commonBits=Ce.zeroLowerBits(this.commonBits,64-(12+this.commonMantissaBitsCount))))},toString:function(){if(1===arguments.length){var t=arguments[0],e=r.longBitsToDouble(t),n=Long.toBinaryString(t),i="0000000000000000000000000000000000000000000000000000000000000000"+n,s=i.substring(i.length-64),o=s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]";return o}},interfaces_:function(){return[]},getClass:function(){return Ce}}),Ce.getBit=function(t,e){var n=1<<e;return 0!==(t&n)?1:0},Ce.signExpBits=function(t){return t>>52},Ce.zeroLowerBits=function(t,e){var n=(1<<e)-1,i=~n,r=t&i;return r},Ce.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if(Ce.getBit(t,i)!==Ce.getBit(e,i))return n;n++}return 52},e(Se.prototype,{addCommonBits:function(t){var e=new Le(this.commonCoord);t.apply(e),t.geometryChanged()},removeCommonBits:function(t){if(0===this.commonCoord.x&&0===this.commonCoord.y)return t;var e=new g(this.commonCoord);e.x=-e.x,e.y=-e.y;var n=new Le(e);return t.apply(n),t.geometryChanged(),t},getCommonCoordinate:function(){return this.commonCoord},add:function(t){t.apply(this.ccFilter),this.commonCoord=this.ccFilter.getCommonCoordinate()},interfaces_:function(){return[]},getClass:function(){return Se}}),e(we.prototype,{filter:function(t){this.commonBitsX.add(t.x),this.commonBitsY.add(t.y)},getCommonCoordinate:function(){return new g(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())},interfaces_:function(){return[z]},getClass:function(){return we}}),e(Le.prototype,{filter:function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},isDone:function(){return!1},isGeometryChanged:function(){return!0},interfaces_:function(){return[ct]},getClass:function(){return Le}}),Se.CommonCoordinateFilter=we,Se.Translater=Le,e(Re.prototype,{next:function(){if(this.atStart)return this.atStart=!1,Re.isAtomic(this.parent)&&this.index++,this.parent;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return this.subcollectionIterator.next();this.subcollectionIterator=null}if(this.index>=this.max)throw new x;var t=this.parent.getGeometryN(this.index++);return t instanceof ft?(this.subcollectionIterator=new Re(t),this.subcollectionIterator.next()):t},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){if(this.atStart)return!0;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return!0;this.subcollectionIterator=null}return!(this.index>=this.max)},interfaces_:function(){return[p]},getClass:function(){return Re}}),Re.isAtomic=function(t){return!(t instanceof ft)},e(Te.prototype,{locateInternal:function(){if(arguments[0]instanceof g&&arguments[1]instanceof Tt){var t=arguments[0],e=arguments[1];if(e.isEmpty())return L.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===L.EXTERIOR)return L.EXTERIOR;if(i===L.BOUNDARY)return L.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var s=e.getInteriorRingN(r),o=this.locateInPolygonRing(t,s);if(o===L.INTERIOR)return L.EXTERIOR;if(o===L.BOUNDARY)return L.BOUNDARY}return L.INTERIOR}if(arguments[0]instanceof g&&arguments[1]instanceof St){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return L.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?he.isOnLine(a,l)?L.INTERIOR:L.EXTERIOR:L.BOUNDARY}if(arguments[0]instanceof g&&arguments[1]instanceof Lt){var h=arguments[0],c=arguments[1],f=c.getCoordinate();return f.equals2D(h)?L.INTERIOR:L.EXTERIOR}},locateInPolygonRing:function(t,e){return e.getEnvelopeInternal().intersects(t)?he.locatePointInRing(t,e.getCoordinates()):L.EXTERIOR},intersects:function(t,e){return this.locate(t,e)!==L.EXTERIOR},updateLocationInfo:function(t){t===L.INTERIOR&&(this.isIn=!0),t===L.BOUNDARY&&this.numBoundaries++},computeLocation:function(t,e){if(e instanceof Lt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof St)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Tt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof gt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof Ot)for(var s=e,i=0;i<s.getNumGeometries();i++){var o=s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,o))}else if(e instanceof ft)for(var a=new Re(e);a.hasNext();){var u=a.next();u!==e&&this.computeLocation(t,u)}},locate:function(t,e){return e.isEmpty()?L.EXTERIOR:e instanceof St?this.locateInternal(t,e):e instanceof Tt?this.locateInternal(t,e):(this.isIn=!1,this.numBoundaries=0,this.computeLocation(t,e),this.boundaryRule.isInBoundary(this.numBoundaries)?L.BOUNDARY:this.numBoundaries>0||this.isIn?L.INTERIOR:L.EXTERIOR)},interfaces_:function(){return[]},getClass:function(){return Te}}),e(Pe.prototype,{interfaces_:function(){return[]},getClass:function(){return Pe}}),Pe.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),r=Math.abs(e);return t>=0?e>=0?n>=r?0:1:n>=r?7:6:e>=0?n>=r?3:2:n>=r?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1],a=o.x-s.x,u=o.y-s.y;if(0===a&&0===u)throw new i("Cannot compute the octant for two identical points "+s);return Pe.octant(a,u)}},e(be.prototype,{getCoordinates:function(){},size:function(){},getCoordinate:function(t){},isClosed:function(){},setData:function(t){},getData:function(){},interfaces_:function(){return[]},getClass:function(){return be}}),e(Oe.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:Pe.octant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},getData:function(){return this.data},toString:function(){return se.toLineString(new Gt(this.pts))},interfaces_:function(){return[be]},getClass:function(){return Oe}}),e(_e.prototype,{getBounds:function(){},interfaces_:function(){return[]},getClass:function(){return _e}}),e(Me.prototype,{getItem:function(){return this.item},getBounds:function(){return this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Me}}),e(De.prototype,{poll:function(){if(this.isEmpty())return null;var t=this.items.get(1);return this.items.set(1,this.items.get(this._size)),this._size-=1,this.reorder(1),t},size:function(){return this._size},reorder:function(t){for(var e=null,n=this.items.get(t);2*t<=this._size&&(e=2*t,e!==this._size&&this.items.get(e+1).compareTo(this.items.get(e))<0&&e++,this.items.get(e).compareTo(n)<0);t=e)this.items.set(t,this.items.get(e));this.items.set(t,n)},clear:function(){this._size=0,this.items.clear()},isEmpty:function(){return 0===this._size},add:function(t){this.items.add(null),this._size+=1;var e=this._size;for(this.items.set(0,t);t.compareTo(this.items.get(Math.trunc(e/2)))<0;e/=2)this.items.set(e,this.items.get(Math.trunc(e/2)));this.items.set(e,t)},interfaces_:function(){return[]},getClass:function(){return De}}),e(Ae.prototype,{visitItem:function(t){},interfaces_:function(){return[]},getClass:function(){return Ae}}),e(Fe.prototype,{insert:function(t,e){},remove:function(t,e){},query:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return Fe}}),e(Ge.prototype,{getLevel:function(){return this.level},size:function(){return this.childBoundables.size()},getChildBoundables:function(){return this.childBoundables},addChildBoundable:function(t){f.isTrue(null===this.bounds),this.childBoundables.add(t)},isEmpty:function(){return this.childBoundables.isEmpty()},getBounds:function(){return null===this.bounds&&(this.bounds=this.computeBounds()),this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Ge}}),Ge.serialVersionUID=0x5a1e55ec41369800;var ho={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return ho.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?ut.sort(n,e):ut.sort(n);for(var i=t.iterator(),r=0,s=n.length;r<s;r++)i.next(),i.set(n[r])},singletonList:function(t){var e=new I;return e.add(t),e}};e(qe.prototype,{expandToQueue:function(t,e){var n=qe.isComposite(this.boundable1),r=qe.isComposite(this.boundable2);if(n&&r)return qe.area(this.boundable1)>qe.area(this.boundable2)?(this.expand(this.boundable1,this.boundable2,t,e),null):(this.expand(this.boundable2,this.boundable1,t,e),null);if(n)return this.expand(this.boundable1,this.boundable2,t,e),null;if(r)return this.expand(this.boundable2,this.boundable1,t,e),null;throw new i("neither boundable is composite")},isLeaves:function(){return!(qe.isComposite(this.boundable1)||qe.isComposite(this.boundable2))},compareTo:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},expand:function(t,e,n,i){for(var r=t.getChildBoundables(),s=r.iterator();s.hasNext();){var o=s.next(),a=new qe(o,e,this.itemDistance);a.getDistance()<i&&n.add(a)}},getBoundable:function(t){return 0===t?this.boundable1:this.boundable2},getDistance:function(){return this._distance},distance:function(){return this.isLeaves()?this.itemDistance.distance(this.boundable1,this.boundable2):this.boundable1.getBounds().distance(this.boundable2.getBounds())},interfaces_:function(){return[s]},getClass:function(){return qe}}),qe.area=function(t){return t.getBounds().getArea()},qe.isComposite=function(t){return t instanceof Ge},e(Be.prototype,{getNodeCapacity:function(){return this.nodeCapacity},lastNode:function(t){return t.get(t.size()-1)},size:function t(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.root));if(1===arguments.length){for(var e=arguments[0],t=0,n=e.getChildBoundables().iterator();n.hasNext();){var i=n.next();i instanceof Ge?t+=this.size(i):i instanceof Me&&(t+=1)}return t}},removeItem:function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof Me&&r.getItem()===e&&(n=r)}return null!==n&&(t.getChildBoundables().remove(n),!0)},itemsTree:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this.root);return null===t?new I:t}if(1===arguments.length){for(var e=arguments[0],n=new I,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Ge){var s=this.itemsTree(r);null!==s&&n.add(s)}else r instanceof Me?n.add(r.getItem()):f.shouldNeverReachHere()}return n.size()<=0?null:n}},insert:function(t,e){f.isTrue(!this.built,"Cannot insert items into an STR packed R-tree after it has been built."),this.itemBoundables.add(new Me(t,e))},boundablesAtLevel:function(){if(1===arguments.length){var t=arguments[0],e=new I;return this.boundablesAtLevel(t,this.root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(f.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var s=i.getChildBoundables().iterator();s.hasNext();){var o=s.next();o instanceof Ge?this.boundablesAtLevel(n,o,r):(f.isTrue(o instanceof Me),n===-1&&r.add(o))}return null}},query:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new I;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.query(t,this.root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.root.getBounds(),n)&&this.query(n,this.root,i)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var r=arguments[0],s=arguments[1],o=arguments[2],a=s.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Ge?this.query(r,l,o):l instanceof Me?o.visitItem(l.getItem()):f.shouldNeverReachHere())}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var h=arguments[0],c=arguments[1],g=arguments[2],a=c.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),h)&&(l instanceof Ge?this.query(h,l,g):l instanceof Me?g.add(l.getItem()):f.shouldNeverReachHere())}},build:function(){return this.built?null:(this.root=this.itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1),this.itemBoundables=null,void(this.built=!0))},getRoot:function(){return this.build(),this.root},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.remove(t,this.root,e)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=this.removeItem(i,r);if(s)return!0;for(var o=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof Ge&&(s=this.remove(n,u,r))){o=u;break}}return null!==o&&o.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(o),s}},createHigherLevels:function(t,e){f.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},depth:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.root));if(1===arguments.length){for(var t=arguments[0],e=0,n=t.getChildBoundables().iterator();n.hasNext();){var i=n.next();if(i instanceof Ge){var r=this.depth(i);r>e&&(e=r)}}return e+1}},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=new I;n.add(this.createNode(e));var i=new I(t);ho.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var s=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n},isEmpty:function(){return this.built?this.root.isEmpty():this.itemBoundables.isEmpty()},interfaces_:function(){return[u]},getClass:function(){return Be}}),Be.compareDoubles=function(t,e){return t>e?1:t<e?-1:0},Be.IntersectsOp=ze,Be.serialVersionUID=-0x35ef64c82d4c5400,Be.DEFAULT_NODE_CAPACITY=10,e(Ve.prototype,{distance:function(t,e){},interfaces_:function(){return[]},getClass:function(){return Ve}}),h(ke,Be),e(ke.prototype,{createParentBoundablesFromVerticalSlices:function(t,e){f.isTrue(t.length>0);for(var n=new I,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},createNode:function(t){return new Ye(t)},size:function(){return 0===arguments.length?Be.prototype.size.call(this):Be.prototype.size.apply(this,arguments)},insert:function(){if(2!==arguments.length)return Be.prototype.insert.apply(this,arguments);var t=arguments[0],e=arguments[1];return t.isNull()?null:void Be.prototype.insert.call(this,t,e)},getIntersectsOp:function(){return ke.intersectsOp},verticalSlices:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),s=0;s<e;s++){i[s]=new I;for(var o=0;r.hasNext()&&o<n;){var a=r.next();i[s].add(a),o++}}return i},query:function(){if(1===arguments.length){var t=arguments[0];return Be.prototype.query.call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];Be.prototype.query.call(this,e,n)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var i=arguments[0],r=arguments[1],s=arguments[2];Be.prototype.query.call(this,i,r,s)}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var o=arguments[0],a=arguments[1],u=arguments[2];Be.prototype.query.call(this,o,a,u)}},getComparator:function(){return ke.yComparator},createParentBoundablesFromVerticalSlice:function(t,e){return Be.prototype.createParentBoundables.call(this,t,e)},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Be.prototype.remove.call(this,t,e)}return Be.prototype.remove.apply(this,arguments)},depth:function(){return 0===arguments.length?Be.prototype.depth.call(this):Be.prototype.depth.apply(this,arguments)},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),i=new I(t);ho.sort(i,ke.xComparator);var r=this.verticalSlices(i,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r,e)},nearestNeighbour:function(){if(1===arguments.length){if(R(arguments[0],Ve)){var t=arguments[0],e=new qe(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe){var n=arguments[0];return this.nearestNeighbour(n,r.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof ke&&R(arguments[1],Ve)){var i=arguments[0],s=arguments[1],e=new qe(this.getRoot(),i.getRoot(),s);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe&&"number"==typeof arguments[1]){var o=arguments[0],a=arguments[1],u=a,l=null,h=new De;for(h.add(o);!h.isEmpty()&&u>0;){var c=h.poll(),f=c.getDistance();if(f>=u)break;c.isLeaves()?(u=f,l=c):c.expandToQueue(h,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var g=arguments[0],d=arguments[1],p=arguments[2],v=new Me(g,d),e=new qe(this.getRoot(),v,p);return this.nearestNeighbour(e)[0]}},interfaces_:function(){return[Fe,u]},getClass:function(){return ke}}),ke.centreX=function(t){return ke.avg(t.getMinX(),t.getMaxX())},ke.avg=function(t,e){return(t+e)/2},ke.centreY=function(t){return ke.avg(t.getMinY(),t.getMaxY())},h(Ye,Ge),e(Ye.prototype,{computeBounds:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new C(n.getBounds()):t.expandToInclude(n.getBounds())}return t},interfaces_:function(){return[]},getClass:function(){return Ye}}),ke.STRtreeNode=Ye,ke.serialVersionUID=0x39920f7d5f261e0,ke.xComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreX(t.getBounds()),ke.centreX(e.getBounds()))}},ke.yComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreY(t.getBounds()),ke.centreY(e.getBounds()))}},ke.intersectsOp={interfaces_:function(){return[IntersectsOp]},intersects:function(t,e){return t.intersects(e)}},ke.DEFAULT_NODE_CAPACITY=10,e(Ue.prototype,{interfaces_:function(){return[]},getClass:function(){return Ue}}),Ue.relativeSign=function(t,e){return t<e?-1:t>e?1:0},Ue.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=Ue.relativeSign(e.x,n.x),r=Ue.relativeSign(e.y,n.y);switch(t){case 0:return Ue.compareValue(i,r);case 1:return Ue.compareValue(r,i);case 2:return Ue.compareValue(r,-i);case 3:return Ue.compareValue(-i,r);case 4:return Ue.compareValue(-i,-r);case 5:return Ue.compareValue(-r,-i);case 6:return Ue.compareValue(-r,i);case 7:return Ue.compareValue(i,-r)}return f.shouldNeverReachHere("invalid octant value"),0},Ue.compareValue=function(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0},e(Xe.prototype,{getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},compareTo:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:Ue.compare(this.segmentOctant,this.coord,e.coord)},isEndPoint:function(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t},isInterior:function(){return this._isInterior},interfaces_:function(){return[s]},getClass:function(){return Xe}}),e(He.prototype,{getSplitCoordinates:function(){var t=new N;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},addCollapsedNodes:function(){var t=new I;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this.edge.getCoordinate(n),n)}},print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},findCollapsesFromExistingVertices:function(t){for(var e=0;e<this.edge.size()-2;e++){var n=this.edge.getCoordinate(e),i=(this.edge.getCoordinate(e+1),this.edge.getCoordinate(e+2));n.equals2D(i)&&t.add(new b(e+1))}},addEdgeCoordinates:function(t,e,n){var i=e.segmentIndex-t.segmentIndex+2,r=this.edge.getCoordinate(e.segmentIndex),s=e.isInterior()||!e.coord.equals2D(r);s||i--;n.add(new g(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this.edge.getCoordinate(o));s&&n.add(new g(e.coord))},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},findCollapseIndex:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i&&(n[0]=t.segmentIndex+1,!0)},findCollapsesFromInsertedNodes:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next(),s=this.findCollapseIndex(i,r,e);s&&t.add(new b(e[0])),i=r}},getEdge:function(){return this.edge},addEndpoints:function(){var t=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0),this.add(this.edge.getCoordinate(t),t)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.getCoordinate(a);return r&&(s[o]=new g(e.coord)),new Ke(s,this.edge.getData())},add:function(t,e){var n=new Xe(this.edge,t,e,this.edge.getSegmentOctant(e)),i=this.nodeMap.get(n);return null!==i?(f.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this.nodeMap.put(n,n),n)},checkSplitEdgesCorrectness:function(t){var e=this.edge.getCoordinates(),n=t.get(0),i=n.getCoordinate(0);if(!i.equals2D(e[0]))throw new l("bad split edge start point at "+i);var r=t.get(t.size()-1),s=r.getCoordinates(),o=s[s.length-1];if(!o.equals2D(e[e.length-1]))throw new l("bad split edge end point at "+o)},interfaces_:function(){return[]},getClass:function(){return He}}),e(We.prototype,{next:function(){return null===this.currNode?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):null===this.nextNode?null:this.nextNode.segmentIndex===this.currNode.segmentIndex?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):(this.nextNode.segmentIndex>this.currNode.segmentIndex,null)},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){return null!==this.nextNode},readNextNode:function(){this.nodeIt.hasNext()?this.nextNode=this.nodeIt.next():this.nextNode=null},interfaces_:function(){return[p]},getClass:function(){return We}}),e(je.prototype,{addIntersection:function(t,e){},interfaces_:function(){return[be]},getClass:function(){return je}}),e(Ke.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},safeOctant:function(t,e){return t.equals2D(e)?0:Pe.octant(t,e)},getData:function(){return this.data},addIntersection:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=(arguments[2],arguments[3]),s=new g(n.getIntersection(r));this.addIntersection(s,i)}},toString:function(){return se.toLineString(new Gt(this.pts))},getNodeList:function(){return this.nodeList},addIntersectionNode:function(t,e){var n=e,i=n+1;if(i<this.pts.length){var r=this.pts[i];t.equals2D(r)&&(n=i)}var s=this.nodeList.add(t,n);return s},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[je]},getClass:function(){return Ke}}),Ke.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new I;return Ke.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var s=r.next();s.getNodeList().addSplitEdges(i)}},e(Ze.prototype,{overlap:function(){if(2===arguments.length){arguments[0],arguments[1]}else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this.overlapSeg1),
n.getLineSegment(i,this.overlapSeg2),this.overlap(this.overlapSeg1,this.overlapSeg2)}},interfaces_:function(){return[]},getClass:function(){return Ze}}),e(Qe.prototype,{getLineSegment:function(t,e){e.p0=this.pts[t],e.p1=this.pts[t+1]},computeSelect:function(t,e,n,i){var r=this.pts[e],s=this.pts[n];if(i.tempEnv1.init(r,s),n-e===1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,i),o<n&&this.computeSelect(t,o,n,i)},getCoordinates:function(){for(var t=new Array(this.end-this.start+1).fill(null),e=0,n=this.start;n<=this.end;n++)t[e++]=this.pts[n];return t},computeOverlaps:function(t,e){this.computeOverlapsInternal(this.start,this.end,t,t.start,t.end,e)},setId:function(t){this.id=t},select:function(t,e){this.computeSelect(t,this.start,this.end,e)},getEnvelope:function(){if(null===this.env){var t=this.pts[this.start],e=this.pts[this.end];this.env=new C(t,e)}return this.env},getEndIndex:function(){return this.end},getStartIndex:function(){return this.start},getContext:function(){return this.context},getId:function(){return this.id},computeOverlapsInternal:function(t,e,n,i,r,s){var o=this.pts[t],a=this.pts[e],u=n.pts[i],l=n.pts[r];if(e-t===1&&r-i===1)return s.overlap(this,t,n,i),null;if(s.tempEnv1.init(o,a),s.tempEnv2.init(u,l),!s.tempEnv1.intersects(s.tempEnv2))return null;var h=Math.trunc((t+e)/2),c=Math.trunc((i+r)/2);t<h&&(i<c&&this.computeOverlapsInternal(t,h,n,i,c,s),c<r&&this.computeOverlapsInternal(t,h,n,c,r,s)),h<e&&(i<c&&this.computeOverlapsInternal(h,e,n,i,c,s),c<r&&this.computeOverlapsInternal(h,e,n,c,r,s))},interfaces_:function(){return[]},getClass:function(){return Qe}}),e(Je.prototype,{interfaces_:function(){return[]},getClass:function(){return Je}}),Je.isNorthern=function(t){return t===Je.NE||t===Je.NW},Je.isOpposite=function(t,e){if(t===e)return!1;var n=(t-e+4)%4;return 2===n},Je.commonHalfPlane=function(t,e){if(t===e)return t;var n=(t-e+4)%4;if(2===n)return-1;var i=t<e?t:e,r=t>e?t:e;return 0===i&&3===r?3:i},Je.isInHalfPlane=function(t,e){return e===Je.SE?t===Je.SE||t===Je.SW:t===e||t===e+1},Je.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Je.NE:Je.SE:e>=0?Je.NW:Je.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){var n=arguments[0],r=arguments[1];if(r.x===n.x&&r.y===n.y)throw new i("Cannot compute the quadrant for two identical points "+n);return r.x>=n.x?r.y>=n.y?Je.NE:Je.SE:r.y>=n.y?Je.NW:Je.SW}},Je.NE=0,Je.NW=1,Je.SW=2,Je.SE=3,e($e.prototype,{interfaces_:function(){return[]},getClass:function(){return $e}}),$e.getChainStartIndices=function(t){var e=0,n=new I;n.add(new b(e));do{var i=$e.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=$e.toIntArray(n);return r},$e.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Je.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){var s=Je.quadrant(t[r-1],t[r]);if(s!==i)break}r++}return r-1},$e.getChains=function(){if(1===arguments.length){var t=arguments[0];return $e.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new I,r=$e.getChainStartIndices(e),s=0;s<r.length-1;s++){var o=new Qe(e,r[s],r[s+1],n);i.add(o)}return i}},$e.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(tn.prototype,{computeNodes:function(t){},getNodedSubstrings:function(){},interfaces_:function(){return[]},getClass:function(){return tn}}),e(en.prototype,{setSegmentIntersector:function(t){this.segInt=t},interfaces_:function(){return[tn]},getClass:function(){return en}}),h(nn,en),e(nn.prototype,{getMonotoneChains:function(){return this.monoChains},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},getIndex:function(){return this.index},add:function(t){for(var e=$e.getChains(t.getCoordinates(),t),n=e.iterator();n.hasNext();){var i=n.next();i.setId(this.idCounter++),this.index.insert(i.getEnvelope(),i),this.monoChains.add(i)}},computeNodes:function(t){this.nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},intersectChains:function(){for(var t=new rn(this.segInt),e=this.monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this.index.query(n.getEnvelope()),r=i.iterator();r.hasNext();){var s=r.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this.nOverlaps++),this.segInt.isDone())return null}},interfaces_:function(){return[]},getClass:function(){return nn}}),h(rn,Ze),e(rn.prototype,{overlap:function(){if(4!==arguments.length)return Ze.prototype.overlap.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],r=t.getContext(),s=n.getContext();this.si.processIntersections(r,e,s,i)},interfaces_:function(){return[]},getClass:function(){return rn}}),nn.SegmentOverlapAction=rn,h(sn,l),e(sn.prototype,{getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return sn}}),sn.msgWithCoord=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(on.prototype,{processIntersections:function(t,e,n,i){},isDone:function(){},interfaces_:function(){return[]},getClass:function(){return on}}),e(an.prototype,{getInteriorIntersection:function(){return this.interiorIntersection},setCheckEndSegmentsOnly:function(t){this.isCheckEndSegmentsOnly=t},getIntersectionSegments:function(){return this.intSegments},count:function(){return this.intersectionCount},getIntersections:function(){return this.intersections},setFindAllIntersections:function(t){this.findAllIntersections=t},setKeepIntersections:function(t){this.keepIntersections=t},processIntersections:function(t,e,n,i){if(!this.findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this.isCheckEndSegmentsOnly){var r=this.isEndSegment(t,e)||this.isEndSegment(n,i);if(!r)return null}var s=t.getCoordinates()[e],o=t.getCoordinates()[e+1],a=n.getCoordinates()[i],u=n.getCoordinates()[i+1];this.li.computeIntersection(s,o,a,u),this.li.hasIntersection()&&this.li.isInteriorIntersection()&&(this.intSegments=new Array(4).fill(null),this.intSegments[0]=s,this.intSegments[1]=o,this.intSegments[2]=a,this.intSegments[3]=u,this.interiorIntersection=this.li.getIntersection(0),this.keepIntersections&&this.intersections.add(this.interiorIntersection),this.intersectionCount++)},isEndSegment:function(t,e){return 0===e||e>=t.size()-2},hasIntersection:function(){return null!==this.interiorIntersection},isDone:function(){return!this.findAllIntersections&&null!==this.interiorIntersection},interfaces_:function(){return[on]},getClass:function(){return an}}),an.createAllIntersectionsFinder=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e},an.createAnyIntersectionFinder=function(t){return new an(t)},an.createIntersectionCounter=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e},e(un.prototype,{execute:function(){return null!==this.segInt?null:void this.checkInteriorIntersections()},getIntersections:function(){return this.segInt.getIntersections()},isValid:function(){return this.execute(),this._isValid},setFindAllIntersections:function(t){this.findAllIntersections=t},checkInteriorIntersections:function(){this._isValid=!0,this.segInt=new an(this.li),this.segInt.setFindAllIntersections(this.findAllIntersections);var t=new nn;if(t.setSegmentIntersector(this.segInt),t.computeNodes(this.segStrings),this.segInt.hasIntersection())return this._isValid=!1,null},checkValid:function(){if(this.execute(),!this._isValid)throw new sn(this.getErrorMessage(),this.segInt.getInteriorIntersection())},getErrorMessage:function(){if(this._isValid)return"no intersections found";var t=this.segInt.getIntersectionSegments();return"found non-noded intersection between "+se.toLineString(t[0],t[1])+" and "+se.toLineString(t[2],t[3])},interfaces_:function(){return[]},getClass:function(){return un}}),un.computeIntersections=function(t){var e=new un(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()},e(ln.prototype,{checkValid:function(){this.nv.checkValid()},interfaces_:function(){return[]},getClass:function(){return ln}}),ln.toSegmentStrings=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Oe(i.getCoordinates(),i))}return e},ln.checkValid=function(t){var e=new ln(t);e.checkValid()},e(hn.prototype,{map:function(t){for(var e=new I,n=0;n<t.getNumGeometries();n++){var i=this.mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(e))},interfaces_:function(){return[]},getClass:function(){return hn}}),hn.map=function(t,e){var n=new hn(e);return n.map(t)},e(cn.prototype,{interfaces_:function(){return[]},getClass:function(){return cn}}),cn.opposite=function(t){return t===cn.LEFT?cn.RIGHT:t===cn.RIGHT?cn.LEFT:t},cn.ON=0,cn.LEFT=1,cn.RIGHT=2,e(fn.prototype,{setAllLocations:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},isNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==L.NONE)return!1;return!0},setAllLocationsIfNull:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===L.NONE&&(this.location[e]=t)},isLine:function(){return 1===this.location.length},merge:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[cn.ON]=this.location[cn.ON],e[cn.LEFT]=L.NONE,e[cn.RIGHT]=L.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===L.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},getLocations:function(){return this.location},flip:function(){if(this.location.length<=1)return null;var t=this.location[cn.LEFT];this.location[cn.LEFT]=this.location[cn.RIGHT],this.location[cn.RIGHT]=t},toString:function(){var t=new P;return this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.LEFT])),t.append(L.toLocationSymbol(this.location[cn.ON])),this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.RIGHT])),t.toString()},setLocations:function(t,e,n){this.location[cn.ON]=t,this.location[cn.LEFT]=e,this.location[cn.RIGHT]=n},get:function(t){return t<this.location.length?this.location[t]:L.NONE},isArea:function(){return this.location.length>1},isAnyNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===L.NONE)return!0;return!1},setLocation:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(cn.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},init:function(t){this.location=new Array(t).fill(null),this.setAllLocations(L.NONE)},isEqualOnSide:function(t,e){return this.location[e]===t.location[e]},allPositionsEqual:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},interfaces_:function(){return[]},getClass:function(){return fn}}),e(gn.prototype,{getGeometryCount:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},setAllLocations:function(t,e){this.elt[t].setAllLocations(e)},isNull:function(t){return this.elt[t].isNull()},setAllLocationsIfNull:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},isLine:function(t){return this.elt[t].isLine()},merge:function(t){for(var e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new fn(t.elt[e]):this.elt[e].merge(t.elt[e])},flip:function(){this.elt[0].flip(),this.elt[1].flip()},getLocation:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(cn.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},toString:function(){var t=new P;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},isArea:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},isAnyNull:function(t){return this.elt[t].isAnyNull()},setLocation:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(cn.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},isEqualOnSide:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},allPositionsEqual:function(t,e){return this.elt[t].allPositionsEqual(e)},toLine:function(t){this.elt[t].isArea()&&(this.elt[t]=new fn(this.elt[t].location[0]))},interfaces_:function(){return[]},getClass:function(){return gn}}),gn.toLineLabel=function(t){for(var e=new gn(L.NONE),n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e},e(dn.prototype,{computeRing:function(){if(null!==this.ring)return null;for(var t=new Array(this.pts.size()).fill(null),e=0;e<this.pts.size();e++)t[e]=this.pts.get(e);this.ring=this.geometryFactory.createLinearRing(t),this._isHole=he.isCCW(this.ring.getCoordinates())},isIsolated:function(){return 1===this.label.getGeometryCount()},computePoints:function(t){this.startDe=t;var e=t,n=!0;do{if(null===e)throw new sn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new sn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this.edges.add(e);var i=e.getLabel();f.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this.startDe)},getLinearRing:function(){return this.ring},getCoordinate:function(t){return this.pts.get(t)},computeMaxNodeDegree:function(){this.maxNodeDegree=0;var t=this.startDe;do{var e=t.getNode(),n=e.getEdges().getOutgoingDegree(this);n>this.maxNodeDegree&&(this.maxNodeDegree=n),t=this.getNext(t)}while(t!==this.startDe);this.maxNodeDegree*=2},addPoints:function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var s=r;s<i.length;s++)this.pts.add(i[s])}else{var r=i.length-2;n&&(r=i.length-1);for(var s=r;s>=0;s--)this.pts.add(i[s])}},isHole:function(){return this._isHole},setInResult:function(){var t=this.startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this.startDe)},containsPoint:function(t){var e=this.getLinearRing(),n=e.getEnvelopeInternal();if(!n.contains(t))return!1;if(!he.isPointInRing(t,e.getCoordinates()))return!1;for(var i=this.holes.iterator();i.hasNext();){var r=i.next();if(r.containsPoint(t))return!1}return!0},addHole:function(t){this.holes.add(t)},isShell:function(){return null===this.shell},getLabel:function(){return this.label},getEdges:function(){return this.edges},getMaxNodeDegree:function(){return this.maxNodeDegree<0&&this.computeMaxNodeDegree(),this.maxNodeDegree},getShell:function(){return this.shell},mergeLabel:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,cn.RIGHT);if(i===L.NONE)return null;if(this.label.getLocation(n)===L.NONE)return this.label.setLocation(n,i),null}},setShell:function(t){this.shell=t,null!==t&&t.addHole(this)},toPolygon:function(t){for(var e=new Array(this.holes.size()).fill(null),n=0;n<this.holes.size();n++)e[n]=this.holes.get(n).getLinearRing();var i=t.createPolygon(this.getLinearRing(),e);return i},interfaces_:function(){return[]},getClass:function(){return dn}}),h(pn,dn),e(pn.prototype,{setEdgeRing:function(t,e){t.setMinEdgeRing(e)},getNext:function(t){return t.getNextMin()},interfaces_:function(){return[]},getClass:function(){return pn}}),h(vn,dn),e(vn.prototype,{buildMinimalRings:function(){var t=new I,e=this.startDe;do{if(null===e.getMinEdgeRing()){var n=new pn(e,this.geometryFactory);t.add(n)}e=e.getNext()}while(e!==this.startDe);return t},setEdgeRing:function(t,e){t.setEdgeRing(e)},linkDirectedEdgesForMinimalEdgeRings:function(){var t=this.startDe;do{var e=t.getNode();e.getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.startDe)},getNext:function(t){return t.getNext()},interfaces_:function(){return[]},getClass:function(){return vn}}),e(mn.prototype,{setVisited:function(t){this._isVisited=t},setInResult:function(t){this._isInResult=t},isCovered:function(){return this._isCovered},isCoveredSet:function(){return this._isCoveredSet},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setCovered:function(t){this._isCovered=t,this._isCoveredSet=!0},updateIM:function(t){f.isTrue(this.label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},isInResult:function(){return this._isInResult},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return mn}}),h(yn,mn),e(yn.prototype,{isIncidentEdgeInResult:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){var e=t.next();if(e.getEdge().isInResult())return!0}return!1},isIsolated:function(){return 1===this.label.getGeometryCount()},getCoordinate:function(){return this.coord},print:function(t){t.println("node "+this.coord+" lbl: "+this.label)},computeIM:function(t){},computeMergedLocation:function(t,e){var n=L.NONE;if(n=this.label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==L.BOUNDARY&&(n=i)}return n},setLabel:function(){if(2!==arguments.length)return mn.prototype.setLabel.apply(this,arguments);var t=arguments[0],e=arguments[1];null===this.label?this.label=new gn(t,e):this.label.setLocation(t,e)},getEdges:function(){return this.edges},mergeLabel:function(){if(arguments[0]instanceof yn){var t=arguments[0];this.mergeLabel(t.label)}else if(arguments[0]instanceof gn)for(var e=arguments[0],n=0;n<2;n++){var i=this.computeMergedLocation(e,n),r=this.label.getLocation(n);r===L.NONE&&this.label.setLocation(n,i)}},add:function(t){this.edges.insert(t),t.setNode(this)},setLabelBoundary:function(t){if(null===this.label)return null;var e=L.NONE;null!==this.label&&(e=this.label.getLocation(t));var n=null;switch(e){case L.BOUNDARY:n=L.INTERIOR;break;case L.INTERIOR:n=L.BOUNDARY;break;default:n=L.BOUNDARY}this.label.setLocation(t,n)},interfaces_:function(){return[]},getClass:function(){return yn}}),e(xn.prototype,{find:function(t){return this.nodeMap.get(t)},addNode:function(){if(arguments[0]instanceof g){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof yn){var n=arguments[0],e=this.nodeMap.get(n.getCoordinate());return null===e?(this.nodeMap.put(n.getCoordinate(),n),n):(e.mergeLabel(n),e)}},print:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},values:function(){return this.nodeMap.values()},getBoundaryNodes:function(t){for(var e=new I,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===L.BOUNDARY&&e.add(i)}return e},add:function(t){var e=t.getCoordinate(),n=this.addNode(e);n.add(t)},interfaces_:function(){return[]},getClass:function(){return xn}}),e(En.prototype,{compareDirection:function(t){return this.dx===t.dx&&this.dy===t.dy?0:this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getDy:function(){return this.dy},getCoordinate:function(){return this.p0},setNode:function(t){this.node=t},print:function(t){var e=Math.atan2(this.dy,this.dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+e+"   "+this.label)},compareTo:function(t){var e=t;return this.compareDirection(e)},getDirectedCoordinate:function(){return this.p1},getDx:function(){return this.dx},getLabel:function(){return this.label},getEdge:function(){return this.edge},getQuadrant:function(){return this.quadrant},getNode:function(){return this.node},toString:function(){var t=Math.atan2(this.dy,this.dx),e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);return"  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+t+"   "+this.label},computeLabel:function(t){},init:function(t,e){this.p0=t,this.p1=e,this.dx=e.x-t.x,this.dy=e.y-t.y,this.quadrant=Je.quadrant(this.dx,this.dy),f.isTrue(!(0===this.dx&&0===this.dy),"EdgeEnd with identical endpoints found")},interfaces_:function(){return[s]},getClass:function(){return En}}),h(In,En),e(In.prototype,{getNextMin:function(){return this.nextMin},getDepth:function(t){return this.depth[t]},setVisited:function(t){this._isVisited=t},computeDirectedLabel:function(){this.label=new gn(this.edge.getLabel()),this._isForward||this.label.flip()},getNext:function(){return this.next},setDepth:function(t,e){if(this.depth[t]!==-999&&this.depth[t]!==e)throw new sn("assigned depths do not match",this.getCoordinate());this.depth[t]=e},isInteriorAreaEdge:function t(){for(var t=!0,e=0;e<2;e++)this.label.isArea(e)&&this.label.getLocation(e,cn.LEFT)===L.INTERIOR&&this.label.getLocation(e,cn.RIGHT)===L.INTERIOR||(t=!1);return t},setNextMin:function(t){this.nextMin=t},print:function(t){En.prototype.print.call(this,t),t.print(" "+this.depth[cn.LEFT]+"/"+this.depth[cn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")},setMinEdgeRing:function(t){this.minEdgeRing=t},isLineEdge:function(){var t=this.label.isLine(0)||this.label.isLine(1),e=!this.label.isArea(0)||this.label.allPositionsEqual(0,L.EXTERIOR),n=!this.label.isArea(1)||this.label.allPositionsEqual(1,L.EXTERIOR);return t&&e&&n},setEdgeRing:function(t){this.edgeRing=t},getMinEdgeRing:function(){return this.minEdgeRing},getDepthDelta:function(){var t=this.edge.getDepthDelta();return this._isForward||(t=-t),t},setInResult:function(t){this._isInResult=t},getSym:function(){return this.sym},isForward:function(){return this._isForward},getEdge:function(){return this.edge},printEdge:function(t){this.print(t),t.print(" "),this._isForward?this.edge.print(t):this.edge.printReverse(t)},setSym:function(t){this.sym=t},setVisitedEdge:function(t){this.setVisited(t),this.sym.setVisited(t)},setEdgeDepths:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===cn.LEFT&&(i=-1);var r=cn.opposite(t),s=n*i,o=e+s;this.setDepth(t,e),this.setDepth(r,o)},getEdgeRing:function(){return this.edgeRing},isInResult:function(){return this._isInResult},setNext:function(t){this.next=t},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return In}}),In.depthFactor=function(t,e){return t===L.EXTERIOR&&e===L.INTERIOR?1:t===L.INTERIOR&&e===L.EXTERIOR?-1:0},e(Nn.prototype,{createNode:function(t){return new yn(t,null)},interfaces_:function(){return[]},getClass:function(){return Nn}}),e(Cn.prototype,{printEdges:function(t){t.println("Edges:");for(var e=0;e<this.edges.size();e++){t.println("edge "+e+":");var n=this.edges.get(e);n.print(t),n.eiList.print(t)}},find:function(t){return this.nodes.find(t)},addNode:function(){if(arguments[0]instanceof yn){var t=arguments[0];return this.nodes.addNode(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.nodes.addNode(e)}},getNodeIterator:function(){return this.nodes.iterator()},linkResultDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkResultDirectedEdges()}},debugPrintln:function(t){A.out.println(t)},isBoundaryNode:function(t,e){var n=this.nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===L.BOUNDARY},linkAllDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkAllDirectedEdges()}},matchInSameDirection:function(t,e,n,i){return!!t.equals(n)&&(he.computeOrientation(t,e,i)===he.COLLINEAR&&Je.quadrant(t,e)===Je.quadrant(n,i))},getEdgeEnds:function(){return this.edgeEndList},debugPrint:function(t){A.out.print(t)},getEdgeIterator:function(){return this.edges.iterator()},findEdgeInSameDirection:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},insertEdge:function(t){this.edges.add(t)},findEdgeEnd:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},addEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.edges.add(n);var i=new In(n,(!0)),r=new In(n,(!1));i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},add:function(t){this.nodes.add(t),this.edgeEndList.add(t)},getNodes:function(){return this.nodes.values()},findEdge:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},interfaces_:function(){return[]},getClass:function(){return Cn}}),Cn.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.getEdges().linkResultDirectedEdges()}},e(Sn.prototype,{sortShellsAndHoles:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},computePolygons:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=i.toPolygon(this.geometryFactory);e.add(r)}return e},placeFreeHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new sn("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},buildMinimalEdgeRings:function(t,e,n){for(var i=new I,r=t.iterator();r.hasNext();){var s=r.next();if(s.getMaxNodeDegree()>2){s.linkDirectedEdgesForMinimalEdgeRings();var o=s.buildMinimalRings(),a=this.findShell(o);null!==a?(this.placePolygonHoles(a,o),e.add(a)):n.addAll(o)}else i.add(s)}return i},containsPoint:function(t){for(var e=this.shellList.iterator();e.hasNext();){var n=e.next();if(n.containsPoint(t))return!0}return!1},buildMaximalEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);e.add(r),r.setInResult()}}return e},placePolygonHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},getPolygons:function(){var t=this.computePolygons(this.shellList);return t},findEdgeRingContaining:function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();null!==s&&(o=s.getLinearRing().getEnvelopeInternal());var c=!1;h.contains(i)&&he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u)}return s},findShell:function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return f.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n},add:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Cn.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new I,s=this.buildMinimalEdgeRings(i,this.shellList,r);this.sortShellsAndHoles(s,this.shellList,r),this.placeFreeHoles(this.shellList,r)}},interfaces_:function(){return[]},getClass:function(){return Sn}}),e(wn.prototype,{collectLines:function(t){for(var e=this.op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this.lineEdgesList),this.collectBoundaryTouchEdge(n,t,this.lineEdgesList)}},labelIsolatedLine:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.op.getArgGeometry(e));t.getLabel().setLocation(e,n)},build:function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this.resultLineList},collectLineEdge:function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!ii.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},findCoveredLineEdges:function(){for(var t=this.op.getGraph().getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().findCoveredLineEdges()}for(var n=this.op.getGraph().getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getEdge();if(i.isLineEdge()&&!r.isCoveredSet()){var s=this.op.isCoveredByA(i.getCoordinate());r.setCovered(s)}}},labelIsolatedLines:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},buildLines:function(t){for(var e=this.lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=(n.getLabel(),this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i),n.setInResult(!0)}},collectBoundaryTouchEdge:function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(f.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(ii.isResultOfOp(i,e)&&e===ii.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},interfaces_:function(){return[]},getClass:function(){return wn}}),e(Ln.prototype,{filterCoveredNodeToPoint:function(t){var e=t.getCoordinate();if(!this.op.isCoveredByLA(e)){var n=this.geometryFactory.createPoint(e);this.resultPointList.add(n)}},extractNonCoveredResultNodes:function(t){for(var e=this.op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!(n.isInResult()||n.isIncidentEdgeInResult()||0!==n.getEdges().getDegree()&&t!==ii.INTERSECTION)){var i=n.getLabel();ii.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},build:function(t){return this.extractNonCoveredResultNodes(t),this.resultPointList},interfaces_:function(){return[]},getClass:function(){return Ln}}),e(Rn.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return Rn}}),e(Tn.prototype,{locate:function(t){return Tn.locate(t,this.geom)},interfaces_:function(){return[Rn]},getClass:function(){return Tn}}),Tn.isPointInRing=function(t,e){return!!e.getEnvelopeInternal().intersects(t)&&he.isPointInRing(t,e.getCoordinates())},Tn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!Tn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(Tn.isPointInRing(t,r))return!1}return!0},Tn.containsPoint=function(t,e){if(e instanceof Tt)return Tn.containsPointInPolygon(t,e);if(e instanceof ft)for(var n=new Re(e);n.hasNext();){var i=n.next();if(i!==e&&Tn.containsPoint(t,i))return!0}return!1},Tn.locate=function(t,e){return e.isEmpty()?L.EXTERIOR:Tn.containsPoint(t,e)?L.INTERIOR:L.EXTERIOR},e(Pn.prototype,{getNextCW:function(t){this.getEdges();var e=this.edgeList.indexOf(t),n=e-1;return 0===e&&(n=this.edgeList.size()-1),this.edgeList.get(n)},propagateSideLabels:function(t){for(var e=L.NONE,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea(t)&&r.getLocation(t,cn.LEFT)!==L.NONE&&(e=r.getLocation(t,cn.LEFT))}if(e===L.NONE)return null;for(var s=e,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();if(r.getLocation(t,cn.ON)===L.NONE&&r.setLocation(t,cn.ON,s),r.isArea(t)){var o=r.getLocation(t,cn.LEFT),a=r.getLocation(t,cn.RIGHT);if(a!==L.NONE){if(a!==s)throw new sn("side location conflict",i.getCoordinate());o===L.NONE&&f.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),s=o}else f.isTrue(r.getLocation(t,cn.LEFT)===L.NONE,"found single null side"),r.setLocation(t,cn.RIGHT,s),r.setLocation(t,cn.LEFT,s)}}},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},print:function(t){A.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();
n.print(t)}},isAreaLabelsConsistent:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},checkAreaLabelsConsistent:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel(),r=i.getLocation(t,cn.LEFT);f.isTrue(r!==L.NONE,"Found unlabelled area edge");for(var s=r,o=this.iterator();o.hasNext();){var a=o.next(),u=a.getLabel();f.isTrue(u.isArea(t),"Found non-area edge");var l=u.getLocation(t,cn.LEFT),h=u.getLocation(t,cn.RIGHT);if(l===h)return!1;if(h!==s)return!1;s=l}return!0},findIndex:function(t){this.iterator();for(var e=0;e<this.edgeList.size();e++){var n=this.edgeList.get(e);if(n===t)return e}return-1},iterator:function(){return this.getEdges().iterator()},getEdges:function(){return null===this.edgeList&&(this.edgeList=new I(this.edgeMap.values())),this.edgeList},getLocation:function(t,e,n){return this.ptInAreaLocation[t]===L.NONE&&(this.ptInAreaLocation[t]=Tn.locate(e,n[t].getGeometry())),this.ptInAreaLocation[t]},toString:function(){var t=new P;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},computeEdgeEndLabels:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.computeLabel(t)}},computeLabelling:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;s<2;s++)r.isLine(s)&&r.getLocation(s)===L.BOUNDARY&&(e[s]=!0);for(var n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;s<2;s++)if(r.isAnyNull(s)){var o=L.NONE;if(e[s])o=L.EXTERIOR;else{var a=i.getCoordinate();o=this.getLocation(s,a,t)}r.setAllLocationsIfNull(s,o)}},getDegree:function(){return this.edgeMap.size()},insertEdgeEnd:function(t,e){this.edgeMap.put(t,e),this.edgeList=null},interfaces_:function(){return[]},getClass:function(){return Pn}}),h(bn,Pn),e(bn.prototype,{linkResultDirectedEdges:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this.SCANNING_FOR_INCOMING,i=0;i<this.resultAreaEdgeList.size();i++){var r=this.resultAreaEdgeList.get(i),s=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this.SCANNING_FOR_INCOMING:if(!s.isInResult())continue;e=s,n=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this.SCANNING_FOR_INCOMING}}if(n===this.LINKING_TO_OUTGOING){if(null===t)throw new sn("no outgoing dirEdge found",this.getCoordinate());f.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},insert:function(t){var e=t;this.insertEdgeEnd(e,e)},getRightmostEdge:function(){var t=this.getEdges(),e=t.size();if(e<1)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),s=i.getQuadrant();if(Je.isNorthern(r)&&Je.isNorthern(s))return n;if(!Je.isNorthern(r)&&!Je.isNorthern(s))return i;return 0!==n.getDy()?n:0!==i.getDy()?i:(f.shouldNeverReachHere("found two horizontal edges incident on node"),null)},print:function(t){A.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},getResultAreaEdges:function(){if(null!==this.resultAreaEdgeList)return this.resultAreaEdgeList;this.resultAreaEdgeList=new I;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this.resultAreaEdgeList.add(e)}return this.resultAreaEdgeList},updateLabelling:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}},linkAllDirectedEdges:function(){this.getEdges();for(var t=null,e=null,n=this.edgeList.size()-1;n>=0;n--){var i=this.edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},computeDepths:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=(t.getLabel(),t.getDepth(cn.LEFT)),i=t.getDepth(cn.RIGHT),r=this.computeDepths(e+1,this.edgeList.size(),n),s=this.computeDepths(0,e,r);if(s!==i)throw new sn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=u,h=o;h<a;h++){var c=this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT,l),l=c.getDepth(cn.LEFT)}return l}},mergeSymLabels:function(){for(var t=this.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();n.merge(e.getSym().getLabel())}},linkMinimalDirectedEdges:function(t){for(var e=null,n=null,i=this.SCANNING_FOR_INCOMING,r=this.resultAreaEdgeList.size()-1;r>=0;r--){var s=this.resultAreaEdgeList.get(r),o=s.getSym();switch(null===e&&s.getEdgeRing()===t&&(e=s),i){case this.SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,i=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(s.getEdgeRing()!==t)continue;n.setNextMin(s),i=this.SCANNING_FOR_INCOMING}}i===this.LINKING_TO_OUTGOING&&(f.isTrue(null!==e,"found null for first outgoing dirEdge"),f.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},getOutgoingDegree:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){var n=e.next();n.isInResult()&&t++}return t}if(1===arguments.length){for(var i=arguments[0],t=0,e=this.iterator();e.hasNext();){var n=e.next();n.getEdgeRing()===i&&t++}return t}},getLabel:function(){return this.label},findCoveredLineEdges:function(){for(var t=L.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=L.INTERIOR;break}if(i.isInResult()){t=L.EXTERIOR;break}}}if(t===L.NONE)return null;for(var r=t,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();n.isLineEdge()?n.getEdge().setCovered(r===L.INTERIOR):(n.isInResult()&&(r=L.EXTERIOR),i.isInResult()&&(r=L.INTERIOR))}},computeLabelling:function(t){Pn.prototype.computeLabelling.call(this,t),this.label=new gn(L.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge(),r=i.getLabel(),s=0;s<2;s++){var o=r.getLocation(s);o!==L.INTERIOR&&o!==L.BOUNDARY||this.label.setLocation(s,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return bn}}),h(On,Nn),e(On.prototype,{createNode:function(t){return new yn(t,new bn)},interfaces_:function(){return[]},getClass:function(){return On}}),e(_n.prototype,{computeIntersections:function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},interfaces_:function(){return[]},getClass:function(){return _n}}),e(Mn.prototype,{isDelete:function(){return this.eventType===Mn.DELETE},setDeleteEventIndex:function(t){this.deleteEventIndex=t},getObject:function(){return this.obj},compareTo:function(t){var e=t;return this.xValue<e.xValue?-1:this.xValue>e.xValue?1:this.eventType<e.eventType?-1:this.eventType>e.eventType?1:0},getInsertEvent:function(){return this.insertEvent},isInsert:function(){return this.eventType===Mn.INSERT},isSameLabel:function(t){return null!==this.label&&this.label===t.label},getDeleteEventIndex:function(){return this.deleteEventIndex},interfaces_:function(){return[s]},getClass:function(){return Mn}}),Mn.INSERT=1,Mn.DELETE=2,e(Dn.prototype,{interfaces_:function(){return[]},getClass:function(){return Dn}}),e(An.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(An.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},setIsDoneIfProperInt:function(t){this.isDoneWhenProperInt=t},hasProperInteriorIntersection:function(){return this.hasProperInterior},isBoundaryPointInternal:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinate();if(t.isIntersection(r))return!0}return!1},hasProperIntersection:function(){return this.hasProper},hasIntersection:function(){return this._hasIntersection},isDone:function(){return this._isDone},isBoundaryPoint:function(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))},setBoundaryNodes:function(t,e){this.bdyNodes=new Array(2).fill(null),this.bdyNodes[0]=t,this.bdyNodes[1]=e},addIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this.numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this.includeProper&&this.li.isProper()||(t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)),this.li.isProper()&&(this.properIntersectionPoint=this.li.getIntersection(0).copy(),this.hasProper=!0,this.isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this.li,this.bdyNodes)||(this.hasProperInterior=!0))))},interfaces_:function(){return[]},getClass:function(){return An}}),An.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},h(Fn,Dn),e(Fn.prototype,{prepareEvents:function(){ho.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},computeIntersections:function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&R(arguments[0],y)&&R(arguments[1],y)){var i=arguments[0],r=arguments[1],s=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(s)}else if("boolean"==typeof arguments[2]&&R(arguments[0],y)&&arguments[1]instanceof An){var o=arguments[0],a=arguments[1],u=arguments[2];u?this.addEdges(o,null):this.addEdges(o),this.computeIntersections(a)}},addEdge:function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var s=new _n(n,r),o=new Mn(e,n.getMinX(r),s);this.events.add(o),this.events.add(new Mn(n.getMaxX(r),o))}},processOverlaps:function(t,e,n,i){for(var r=n.getObject(),s=t;s<e;s++){var o=this.events.get(s);if(o.isInsert()){var a=o.getObject();n.isSameLabel(o)||(r.computeIntersections(a,i),this.nOverlaps++)}}},addEdges:function(){if(1===arguments.length)for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.addEdge(n,n)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],e=i.iterator();e.hasNext();){var n=e.next();this.addEdge(n,r)}},interfaces_:function(){return[]},getClass:function(){return Fn}}),e(Gn.prototype,{getMin:function(){return this.min},intersects:function(t,e){return!(this.min>e||this.max<t)},getMax:function(){return this.max},toString:function(){return se.toLineString(new g(this.min,0),new g(this.max,0))},interfaces_:function(){return[]},getClass:function(){return Gn}}),e(qn.prototype,{compare:function(t,e){var n=t,i=e,r=(n.min+n.max)/2,s=(i.min+i.max)/2;return r<s?-1:r>s?1:0},interfaces_:function(){return[a]},getClass:function(){return qn}}),Gn.NodeComparator=qn,h(Bn,Gn),e(Bn.prototype,{query:function(t,e,n){return this.intersects(t,e)?void n.visitItem(this.item):null},interfaces_:function(){return[]},getClass:function(){return Bn}}),h(zn,Gn),e(zn.prototype,{buildExtent:function(t,e){this.min=Math.min(t.min,e.min),this.max=Math.max(t.max,e.max)},query:function(t,e,n){return this.intersects(t,e)?(null!==this.node1&&this.node1.query(t,e,n),void(null!==this.node2&&this.node2.query(t,e,n))):null},interfaces_:function(){return[]},getClass:function(){return zn}}),e(Vn.prototype,{buildTree:function(){ho.sort(this.leaves,new IntervalRTreeNode.NodeComparator);for(var t=this.leaves,e=null,n=new I;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},insert:function(t,e,n){if(null!==this.root)throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t,e,n))},query:function(t,e,n){this.init(),this.root.query(t,e,n)},buildRoot:function(){return null!==this.root?null:void(this.root=this.buildTree())},printNode:function(t){A.out.println(se.toLineString(new g(t.min,this.level),new g(t.max,this.level)))},init:function(){return null!==this.root?null:void this.buildRoot()},buildLevel:function(t,e){this.level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n),r=n+1<t.size()?t.get(n):null;if(null===r)e.add(i);else{var s=new zn(t.get(n),t.get(n+1));e.add(s)}}},interfaces_:function(){return[]},getClass:function(){return Vn}}),e(kn.prototype,{filter:function(t){if(this.isForcedToLineString&&t instanceof bt){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e),null}t instanceof St&&this.lines.add(t)},setForceToLineString:function(t){this.isForcedToLineString=t},interfaces_:function(){return[q]},getClass:function(){return kn}}),kn.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(kn.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(kn.getLines(e,n))}},kn.getLines=function(){if(1===arguments.length){var t=arguments[0];return kn.getLines(t,!1)}if(2===arguments.length){if(R(arguments[0],v)&&R(arguments[1],v)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();kn.getLines(r,n)}return n}if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var s=arguments[0],o=arguments[1],a=new I;return s.apply(new kn(a,o)),a}if(arguments[0]instanceof B&&R(arguments[1],v)){var u=arguments[0],l=arguments[1];return u instanceof St?l.add(u):u.apply(new kn(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&R(arguments[0],v)&&R(arguments[1],v)){for(var h=arguments[0],c=arguments[1],f=arguments[2],i=h.iterator();i.hasNext();){var r=i.next();kn.getLines(r,c,f)}return c}if("boolean"==typeof arguments[2]&&arguments[0]instanceof B&&R(arguments[1],v)){var g=arguments[0],d=arguments[1],p=arguments[2];return g.apply(new kn(d,p)),d}}},e(Yn.prototype,{visitItem:function(t){this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return Yn}}),e(Un.prototype,{locate:function(t){var e=new le(t),n=new Xn(e);return this.index.query(t.y,t.y,n),e.getLocation()},interfaces_:function(){return[Rn]},getClass:function(){return Un}}),e(Xn.prototype,{visitItem:function(t){var e=t;this.counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},interfaces_:function(){return[Ae]},getClass:function(){return Xn}}),e(Hn.prototype,{init:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinates();this.addLine(r)}},addLine:function(t){for(var e=1;e<t.length;e++){var n=new ce(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this.index.insert(i,r,n)}},query:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yn;return this.index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.index.query(i,r,s)}},interfaces_:function(){return[]},getClass:function(){return Hn}}),Un.SegmentVisitor=Xn,Un.IntervalIndexedGeometry=Hn,e(Wn.prototype,{getSegmentIndex:function(){return this.segmentIndex},getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},compareTo:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},isEndPoint:function(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t},toString:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},getDistance:function(){return this.dist},compare:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},interfaces_:function(){return[s]},getClass:function(){return Wn}}),e(jn.prototype,{print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},addEndpoints:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.pts[a];return r&&(s[o]=e.coord),new Jn(s,new gn(this.edge.label))},add:function(t,e,n){var i=new Wn(t,e,n),r=this.nodeMap.get(i);return null!==r?r:(this.nodeMap.put(i,i),i)},isIntersection:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();if(n.coord.equals(t))return!0}return!1},interfaces_:function(){return[]},getClass:function(){return jn}}),e(Kn.prototype,{getChainStartIndices:function(t){var e=0,n=new I;n.add(new b(e));do{var i=this.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=Kn.toIntArray(n);return r},findChainEnd:function(t,e){for(var n=Je.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){var r=Je.quadrant(t[i-1],t[i]);if(r!==n)break;i++}return i-1},interfaces_:function(){return[]},getClass:function(){return Kn}}),Kn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(Zn.prototype,{getCoordinates:function(){return this.pts},getMaxX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},getMinX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n},computeIntersectsForChain:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],h=this.pts[r],c=this.pts[s],f=o.pts[a],g=o.pts[u];if(s-r===1&&u-a===1)return l.addIntersections(this.e,r,o.e,a),null;if(this.env1.init(h,c),this.env2.init(f,g),!this.env1.intersects(this.env2))return null;var d=Math.trunc((r+s)/2),p=Math.trunc((a+u)/2);r<d&&(a<p&&this.computeIntersectsForChain(r,d,o,a,p,l),p<u&&this.computeIntersectsForChain(r,d,o,p,u,l)),d<s&&(a<p&&this.computeIntersectsForChain(d,s,o,a,p,l),p<u&&this.computeIntersectsForChain(d,s,o,p,u,l))}},getStartIndexes:function(){return this.startIndex},computeIntersects:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},interfaces_:function(){return[]},getClass:function(){return Zn}}),e(Qn.prototype,{getDepth:function(t,e){return this.depth[t][e]},setDepth:function(t,e,n){this.depth[t][e]=n},isNull:function(){if(0===arguments.length){for(var t=0;t<2;t++)for(var e=0;e<3;e++)if(this.depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this.depth[n][1]===Qn.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this.depth[i][r]===Qn.NULL_VALUE}},normalize:function(){for(var t=0;t<2;t++)if(!this.isNull(t)){var e=this.depth[t][1];this.depth[t][2]<e&&(e=this.depth[t][2]),e<0&&(e=0);for(var n=1;n<3;n++){var i=0;this.depth[t][n]>e&&(i=1),this.depth[t][n]=i}}},getDelta:function(t){return this.depth[t][cn.RIGHT]-this.depth[t][cn.LEFT]},getLocation:function(t,e){return this.depth[t][e]<=0?L.EXTERIOR:L.INTERIOR},toString:function(){return"A: "+this.depth[0][1]+","+this.depth[0][2]+" B: "+this.depth[1][1]+","+this.depth[1][2]},add:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<2;e++)for(var n=1;n<3;n++){var i=t.getLocation(e,n);i!==L.EXTERIOR&&i!==L.INTERIOR||(this.isNull(e,n)?this.depth[e][n]=Qn.depthAtLocation(i):this.depth[e][n]+=Qn.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];o===L.INTERIOR&&this.depth[r][s]++}},interfaces_:function(){return[]},getClass:function(){return Qn}}),Qn.depthAtLocation=function(t){return t===L.EXTERIOR?0:t===L.INTERIOR?1:Qn.NULL_VALUE},Qn.NULL_VALUE=-1,h(Jn,mn),e(Jn.prototype,{getDepth:function(){return this.depth},getCollapsedEdge:function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];var e=new Jn(t,gn.toLineLabel(this.label));return e},isIsolated:function(){return this._isIsolated},getCoordinates:function(){return this.pts},setIsolated:function(t){this._isIsolated=t},setName:function(t){this.name=t},equals:function(t){if(!(t instanceof Jn))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,i=!0,r=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(e.pts[s])||(n=!1),this.pts[s].equals2D(e.pts[--r])||(i=!1),!n&&!i)return!1;return!0},getCoordinate:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},print:function(t){t.print("edge "+this.name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this.label+" "+this.depthDelta)},computeIM:function(t){Jn.updateIM(this.label,t)},isCollapsed:function(){return!!this.label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getMaximumSegmentIndex:function(){return this.pts.length-1},getDepthDelta:function(){return this.depthDelta},getNumPoints:function(){return this.pts.length},printReverse:function(t){t.print("edge "+this.name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},getMonotoneChainEdge:function(){return null===this.mce&&(this.mce=new Zn(this)),this.mce},getEnvelope:function(){if(null===this.env){this.env=new C;for(var t=0;t<this.pts.length;t++)this.env.expandToInclude(this.pts[t])}return this.env},addIntersection:function(t,e,n,i){var r=new g(t.getIntersection(i)),s=e,o=t.getEdgeDistance(n,i),a=s+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(s=a,o=0)}this.eiList.add(r,s,o)},toString:function(){var t=new P;t.append("edge "+this.name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this.label+" "+this.depthDelta),t.toString()},isPointwiseEqual:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},setDepthDelta:function(t){this.depthDelta=t},getEdgeIntersectionList:function(){return this.eiList},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[]},getClass:function(){return Jn}}),Jn.updateIM=function(){if(2!==arguments.length)return mn.prototype.updateIM.apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,cn.ON),t.getLocation(1,cn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,cn.LEFT),t.getLocation(1,cn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,cn.RIGHT),t.getLocation(1,cn.RIGHT),2))},h($n,Cn),e($n.prototype,{insertBoundaryPoint:function(t,e){var n=this.nodes.addNode(e),i=n.getLabel(),r=1,s=L.NONE;s=i.getLocation(t,cn.ON),s===L.BOUNDARY&&r++;var o=$n.determineBoundary(this.boundaryNodeRule,r);i.setLocation(t,o)},computeSelfNodes:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=new An(n,(!0),(!1));s.setIsDoneIfProperInt(r);var o=this.createEdgeSetIntersector(),a=this.parentGeom instanceof bt||this.parentGeom instanceof Tt||this.parentGeom instanceof Ot,u=i||!a;return o.computeIntersections(this.edges,s,u),this.addSelfIntersectionNodes(this.argIndex),s}},computeSplitEdges:function(t){for(var e=this.edges.iterator();e.hasNext();){var n=e.next();n.eiList.addSplitEdges(t)}},computeEdgeIntersections:function(t,e,n){var i=new An(e,n,(!0));i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());var r=this.createEdgeSetIntersector();return r.computeIntersections(this.edges,t.edges,i),i},getGeometry:function(){return this.parentGeom},getBoundaryNodeRule:function(){return this.boundaryNodeRule},hasTooFewPoints:function(){return this._hasTooFewPoints},addPoint:function(){if(arguments[0]instanceof Lt){var t=arguments[0],e=t.getCoordinate();this.insertPoint(this.argIndex,e,L.INTERIOR)}else if(arguments[0]instanceof g){var n=arguments[0];this.insertPoint(this.argIndex,n,L.INTERIOR)}},addPolygon:function(t){this.addPolygonRing(t.getExteriorRing(),L.EXTERIOR,L.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,L.INTERIOR,L.EXTERIOR)}},addEdge:function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this.argIndex,e[0],L.BOUNDARY),this.insertPoint(this.argIndex,e[e.length-1],L.BOUNDARY)},addLineString:function(t){var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this.invalidPoint=e[0],null;var n=new Jn(e,new gn(this.argIndex,L.INTERIOR));this.lineEdgeMap.put(t,n),this.insertEdge(n),f.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.argIndex,e[0]),this.insertBoundaryPoint(this.argIndex,e[e.length-1])},getInvalidPoint:function(){return this.invalidPoint},getBoundaryPoints:function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},getBoundaryNodes:function(){return null===this.boundaryNodes&&(this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex)),this.boundaryNodes},addSelfIntersectionNode:function(t,e,n){return this.isBoundaryNode(t,e)?null:void(n===L.BOUNDARY&&this.useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n))},addPolygonRing:function(t,e,n){if(t.isEmpty())return null;var i=H.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this.invalidPoint=i[0],null;var r=e,s=n;he.isCCW(i)&&(r=n,s=e);var o=new Jn(i,new gn(this.argIndex,L.BOUNDARY,r,s));this.lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this.argIndex,i[0],L.BOUNDARY)},insertPoint:function(t,e,n){var i=this.nodes.addNode(e),r=i.getLabel();null===r?i.label=new gn(t,n):r.setLocation(t,n)},createEdgeSetIntersector:function(){return new Fn},addSelfIntersectionNodes:function(t){for(var e=this.edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var s=r.next();this.addSelfIntersectionNode(t,s.coord,i)}},add:function(){if(1!==arguments.length)return Cn.prototype.add.apply(this,arguments);var t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ot&&(this.useBoundaryDeterminationRule=!1),t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},locate:function(t){return R(this.parentGeom,Rt)&&this.parentGeom.getNumGeometries()>50?(null===this.areaPtLocator&&(this.areaPtLocator=new Un(this.parentGeom)),this.areaPtLocator.locate(t)):this.ptLocator.locate(t,this.parentGeom)},findEdge:function(){if(1===arguments.length){var t=arguments[0];return this.lineEdgeMap.get(t)}return Cn.prototype.findEdge.apply(this,arguments)},interfaces_:function(){return[]},getClass:function(){return $n}}),$n.determineBoundary=function(t,e){return t.isInBoundary(e)?L.BOUNDARY:L.INTERIOR},e(ti.prototype,{getArgGeometry:function(t){return this.arg[t].getGeometry()},setComputationPrecision:function(t){this.resultPrecisionModel=t,this.li.setPrecisionModel(this.resultPrecisionModel)},interfaces_:function(){return[]},getClass:function(){return ti}}),e(ei.prototype,{compareTo:function(t){var e=t,n=ei.compareOriented(this.pts,this._orientation,e.pts,e._orientation);return n},interfaces_:function(){return[s]},getClass:function(){return ei}}),ei.orientation=function(t){return 1===H.increasingDirection(t)},ei.compareOriented=function(t,e,n,i){for(var r=e?1:-1,s=i?1:-1,o=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;u+=r,l+=s;var c=u===o,f=l===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}},e(ni.prototype,{print:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this.edges.size();e++){var n=this.edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},addAll:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},findEdgeIndex:function(t){for(var e=0;e<this.edges.size();e++)if(this.edges.get(e).equals(t))return e;return-1},iterator:function(){return this.edges.iterator()},getEdges:function(){return this.edges},get:function(t){return this.edges.get(t)},findEqualEdge:function(t){var e=new ei(t.getCoordinates()),n=this.ocaMap.get(e);return n},add:function(t){this.edges.add(t);var e=new ei(t.getCoordinates());this.ocaMap.put(e,t)},interfaces_:function(){return[]},getClass:function(){return ni}}),h(ii,ti),e(ii.prototype,{insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip());var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this.edgeList.add(t)},getGraph:function(){return this.graph},cancelDuplicateResultEdges:function(){for(var t=this.graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},isCoveredByLA:function(t){return!!this.isCovered(t,this.resultLineList)||!!this.isCovered(t,this.resultPolyList)},computeGeometry:function(t,e,n,i){var r=new I;return r.addAll(t),r.addAll(e),r.addAll(n),r.isEmpty()?ii.createEmptyResult(i,this.arg[0].getGeometry(),this.arg[1].getGeometry(),this.geomFact):this.geomFact.buildGeometry(r)},mergeSymLabels:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().mergeSymLabels()}},isCovered:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=this.ptLocator.locate(t,i);if(r!==L.EXTERIOR)return!0}return!1},replaceCollapsedEdges:function(){for(var t=new I,e=this.edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this.edgeList.addAll(t)},updateNodeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},getResultGeometry:function(t){return this.computeOverlay(t),this.resultGeom},insertUniqueEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},computeOverlay:function(t){this.copyPoints(0),this.copyPoints(1),this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1),this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!0);var e=new I;this.arg[0].computeSplitEdges(e),this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),
ln.checkValid(this.edgeList.getEdges()),this.graph.addEdges(this.edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new Sn(this.geomFact);n.add(this.graph),this.resultPolyList=n.getPolygons();var i=new wn(this,this.geomFact,this.ptLocator);this.resultLineList=i.build(t);var r=new Ln(this,this.geomFact,this.ptLocator);this.resultPointList=r.build(t),this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,t)},labelIncompleteNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setLocation(e,n)},copyPoints:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.graph.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},findResultAreaEdges:function(t){for(var e=this.graph.getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.isArea()&&!n.isInteriorAreaEdge()&&ii.isResultOfOp(i.getLocation(0,cn.RIGHT),i.getLocation(1,cn.RIGHT),t)&&n.setInResult(!0)}},computeLabelsFromDepths:function(){for(var t=this.edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;r<2;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(f.isTrue(!i.isNull(r,cn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,cn.LEFT,i.getLocation(r,cn.LEFT)),f.isTrue(!i.isNull(r,cn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,cn.RIGHT,i.getLocation(r,cn.RIGHT))))}}},computeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}this.mergeSymLabels(),this.updateNodeLabelling()},labelIncompleteNodes:function(){for(var t=0,e=this.graph.getNodes().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(t++,i.isNull(0)?this.labelIncompleteNode(n,0):this.labelIncompleteNode(n,1)),n.getEdges().updateLabelling(i)}},isCoveredByA:function(t){return!!this.isCovered(t,this.resultPolyList)},interfaces_:function(){return[]},getClass:function(){return ii}}),ii.overlayOp=function(t,e,n){var i=new ii(t,e),r=i.getResultGeometry(n);return r},ii.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return hn.map(t,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.INTERSECTION)},ii.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.SYMDIFFERENCE)},ii.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),s=-1;switch(t){case ii.INTERSECTION:s=Math.min(i,r);break;case ii.UNION:s=Math.max(i,r);break;case ii.DIFFERENCE:s=i;break;case ii.SYMDIFFERENCE:s=Math.max(i,r)}return s},ii.createEmptyResult=function(t,e,n,i){var r=null;switch(ii.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},ii.difference=function(t,e){return t.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.DIFFERENCE))},ii.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return ii.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];switch(r===L.BOUNDARY&&(r=L.INTERIOR),s===L.BOUNDARY&&(s=L.INTERIOR),o){case ii.INTERSECTION:return r===L.INTERIOR&&s===L.INTERIOR;case ii.UNION:return r===L.INTERIOR||s===L.INTERIOR;case ii.DIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR;case ii.SYMDIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR||r!==L.INTERIOR&&s===L.INTERIOR}return!1}},ii.INTERSECTION=1,ii.UNION=2,ii.DIFFERENCE=3,ii.SYMDIFFERENCE=4,e(ri.prototype,{selfSnap:function(t){var e=new Ie(t),n=e.snapTo(t,this.snapTolerance);return n},removeCommonBits:function(t){this.cbr=new Se,this.cbr.add(t[0]),this.cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this.cbr.removeCommonBits(t[0].copy()),e[1]=this.cbr.removeCommonBits(t[1].copy()),e},prepareResult:function(t){return this.cbr.addCommonBits(t),t},getResultGeometry:function(t){var e=this.snap(this.geom),n=ii.overlayOp(e[0],e[1],t);return this.prepareResult(n)},checkValid:function(t){t.isValid()||A.out.println("Snapped geometry is invalid")},computeSnapTolerance:function(){this.snapTolerance=Ie.computeOverlaySnapTolerance(this.geom[0],this.geom[1])},snap:function(t){var e=this.removeCommonBits(t),n=Ie.snap(e[0],e[1],this.snapTolerance);return n},interfaces_:function(){return[]},getClass:function(){return ri}}),ri.overlayOp=function(t,e,n){var i=new ri(t,e);return i.getResultGeometry(n)},ri.union=function(t,e){return ri.overlayOp(t,e,ii.UNION)},ri.intersection=function(t,e){return ri.overlayOp(t,e,ii.INTERSECTION)},ri.symDifference=function(t,e){return ri.overlayOp(t,e,ii.SYMDIFFERENCE)},ri.difference=function(t,e){return ri.overlayOp(t,e,ii.DIFFERENCE)},e(si.prototype,{getResultGeometry:function(t){var e=null,n=!1,i=null;try{e=ii.overlayOp(this.geom[0],this.geom[1],t);var r=!0;r&&(n=!0)}catch(t){if(!(t instanceof l))throw t;i=t}finally{}if(!n)try{e=ri.overlayOp(this.geom[0],this.geom[1],t)}catch(t){throw t instanceof l?i:t}finally{}return e},interfaces_:function(){return[]},getClass:function(){return si}}),si.overlayOp=function(t,e,n){var i=new si(t,e);return i.getResultGeometry(n)},si.union=function(t,e){return si.overlayOp(t,e,ii.UNION)},si.intersection=function(t,e){return si.overlayOp(t,e,ii.INTERSECTION)},si.symDifference=function(t,e){return si.overlayOp(t,e,ii.SYMDIFFERENCE)},si.difference=function(t,e){return si.overlayOp(t,e,ii.DIFFERENCE)},e(oi.prototype,{addPolygon:function(t){if(t.isEmpty())return null;var e=null,n=0,i=this.horizontalBisector(t);if(0===i.getLength())n=0,e=i.getCoordinate();else{var r=si.overlayOp(i,t,ii.INTERSECTION),s=this.widestGeometry(r);n=s.getEnvelopeInternal().getWidth(),e=oi.centre(s.getEnvelopeInternal())}(null===this.interiorPoint||n>this.maxWidth)&&(this.interiorPoint=e,this.maxWidth=n)},getInteriorPoint:function(){return this.interiorPoint},widestGeometry:function t(){if(arguments[0]instanceof ft){var e=arguments[0];if(e.isEmpty())return e;for(var t=e.getGeometryN(0),n=1;n<e.getNumGeometries();n++)e.getGeometryN(n).getEnvelopeInternal().getWidth()>t.getEnvelopeInternal().getWidth()&&(t=e.getGeometryN(n));return t}if(arguments[0]instanceof B){var i=arguments[0];return i instanceof ft?this.widestGeometry(i):i}},horizontalBisector:function(t){var e=t.getEnvelopeInternal(),n=ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])},add:function(t){if(t instanceof Tt)this.addPolygon(t);else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))},interfaces_:function(){return[]},getClass:function(){return oi}}),oi.centre=function(t){return new g(oi.avg(t.getMinX(),t.getMaxX()),oi.avg(t.getMinY(),t.getMaxY()))},oi.avg=function(t,e){return(t+e)/2},e(ai.prototype,{updateInterval:function(t){t<=this.centreY?t>this.loY&&(this.loY=t):t>this.centreY&&t<this.hiY&&(this.hiY=t)},getBisectorY:function(){this.process(this.poly.getExteriorRing());for(var t=0;t<this.poly.getNumInteriorRing();t++)this.process(this.poly.getInteriorRingN(t));var e=oi.avg(this.hiY,this.loY);return e},process:function(t){for(var e=t.getCoordinateSequence(),n=0;n<e.size();n++){var i=e.getY(n);this.updateInterval(i)}},interfaces_:function(){return[]},getClass:function(){return ai}}),ai.getBisectorY=function(t){var e=new ai(t);return e.getBisectorY()},oi.SafeBisectorFinder=ai,e(ui.prototype,{addEndpoints:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addEndpoints(e.getGeometryN(n))}else if(arguments[0]instanceof Array){var i=arguments[0];this.add(i[0]),this.add(i[i.length-1])}},getInteriorPoint:function(){return this.interiorPoint},addInterior:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addInterior(e.getGeometryN(n))}else if(arguments[0]instanceof Array)for(var i=arguments[0],n=1;n<i.length-1;n++)this.add(i[n])},add:function(t){var e=t.distance(this.centroid);e<this.minDistance&&(this.interiorPoint=new g(t),this.minDistance=e)},interfaces_:function(){return[]},getClass:function(){return ui}}),e(li.prototype,{getInteriorPoint:function(){return this.interiorPoint},add:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof Lt)this.add(t.getCoordinate());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))}else if(arguments[0]instanceof g){var i=arguments[0],r=i.distance(this.centroid);r<this.minDistance&&(this.interiorPoint=new g(i),this.minDistance=r)}},interfaces_:function(){return[]},getClass:function(){return li}}),e(hi.prototype,{select:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},interfaces_:function(){return[]},getClass:function(){return hi}}),e(ci.prototype,{hasChildren:function(){for(var t=0;t<2;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;e<2;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},size:function(){for(var t=0,e=0;e<2;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){return null===t||this.isSearchMatch(t)?(e.addAll(this.items),null!==this.subnode[0]&&this.subnode[0].addAllItemsFromOverlapping(t,e),void(null!==this.subnode[1]&&this.subnode[1].addAllItemsFromOverlapping(t,e))):null},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;i<2;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;e<2;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},nodeSize:function(){for(var t=0,e=0;e<2;e++)null!==this.subnode[e]&&(t+=this.subnode[e].nodeSize());return t+1},add:function(t){this.items.add(t)},interfaces_:function(){return[]},getClass:function(){return ci}}),ci.getSubnodeIndex=function(t,e){var n=-1;return t.min>=e&&(n=1),t.max<=e&&(n=0),n},e(fi.prototype,{expandToInclude:function(t){t.max>this.max&&(this.max=t.max),t.min<this.min&&(this.min=t.min)},getWidth:function(){return this.max-this.min},overlaps:function(){if(1===arguments.length){var t=arguments[0];return this.overlaps(t.min,t.max)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!(this.min>n||this.max<e)}},getMin:function(){return this.min},toString:function(){return"["+this.min+", "+this.max+"]"},contains:function(){if(1===arguments.length){if(arguments[0]instanceof fi){var t=arguments[0];return this.contains(t.min,t.max)}if("number"==typeof arguments[0]){var e=arguments[0];return e>=this.min&&e<=this.max}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return n>=this.min&&i<=this.max}},init:function(t,e){this.min=t,this.max=e,t>e&&(this.min=e,this.max=t)},getMax:function(){return this.max},interfaces_:function(){return[]},getClass:function(){return fi}}),gi.exponent=function(t){return di(64,t)-1023},gi.powerOf2=function(t){return Math.pow(2,t)},e(pi.prototype,{getInterval:function(){return this.interval},getLevel:function(){return this.level},computeKey:function(t){for(this.level=pi.computeLevel(t),this.interval=new fi,this.computeInterval(this.level,t);!this.interval.contains(t);)this.level+=1,this.computeInterval(this.level,t)},computeInterval:function(t,e){var n=gi.powerOf2(t);this.pt=Math.floor(e.getMin()/n)*n,this.interval.init(this.pt,this.pt+n)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return pi}}),pi.computeLevel=function(t){var e=t.getWidth(),n=gi.exponent(e)+1;return n},h(vi,ci),e(vi.prototype,{getInterval:function(){return this.interval},find:function(t){var e=ci.getSubnodeIndex(t,this.centre);if(e===-1)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},insert:function(t){f.isTrue(null===this.interval||this.interval.contains(t.interval));var e=ci.getSubnodeIndex(t.interval,this.centre);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insert(t),this.subnode[e]=n}},isSearchMatch:function(t){return t.overlaps(this.interval)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getNode:function(t){var e=ci.getSubnodeIndex(t,this.centre);if(e!==-1){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0;switch(t){case 0:e=this.interval.getMin(),n=this.centre;break;case 1:e=this.centre,n=this.interval.getMax()}var i=new fi(e,n),r=new vi(i,this.level-1);return r},interfaces_:function(){return[]},getClass:function(){return vi}}),vi.createNode=function(t){var e=new pi(t),n=new vi(e.getInterval(),e.getLevel());return n},vi.createExpanded=function(t,e){var n=new fi(e);null!==t&&n.expandToInclude(t.interval);var i=vi.createNode(n);return null!==t&&i.insert(t),i},e(mi.prototype,{interfaces_:function(){return[]},getClass:function(){return mi}});mi.isZeroWidth=function(t,e){var n=e-t;if(0===n)return!0;var i=Math.max(Math.abs(t),Math.abs(e)),r=n/i,s=gi.exponent(r);return s<=mi.MIN_BINARY_EXPONENT};mi.MIN_BINARY_EXPONENT=-50,h(yi,ci),e(yi.prototype,{insert:function(t,e){var n=ci.getSubnodeIndex(t,yi.origin);if(n===-1)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getInterval().contains(t)){var r=vi.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getInterval().contains(e));var i=mi.isZeroWidth(e.getMin(),e.getMax()),r=null;r=i?t.find(e):t.getNode(e),r.add(n)},interfaces_:function(){return[]},getClass:function(){return yi}}),yi.origin=0,e(xi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=xi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];return this.query(new fi(t,t))}if(arguments[0]instanceof fi){var e=arguments[0],n=new I;return this.query(e,n),n}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.root.addAllItemsFromOverlapping(i,r)}},iterator:function(){var t=new I;return this.root.addAllItems(t),t.iterator()},remove:function(t,e){var n=xi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e)},depth:function(){return null!==this.root?this.root.depth():0},nodeSize:function(){return null!==this.root?this.root.nodeSize():0},interfaces_:function(){return[]},getClass:function(){return xi}}),xi.ensureExtent=function(t,e){var n=t.getMin(),i=t.getMax();return n!==i?t:(n===i&&(n-=e/2,i=n+e/2),new fi(n,i))},e(Ei.prototype,{isInside:function(t){},interfaces_:function(){return[]},getClass:function(){return Ei}}),e(Ii.prototype,{testLineSegment:function(t,e){var n=null,i=null,r=null,s=null,o=null,a=e.p0,u=e.p1;i=a.x-t.x,r=a.y-t.y,s=u.x-t.x,o=u.y-t.y,(r>0&&o<=0||o>0&&r<=0)&&(n=ue.signOfDet2x2(i,r,s,o)/(o-r),0<n&&this.crossings++)},buildIndex:function(){this.tree=new xi;for(var t=H.removeRepeatedPoints(this.ring.getCoordinates()),e=$e.getChains(t),n=0;n<e.size();n++){var i=e.get(n),r=i.getEnvelope();this.interval.min=r.getMinY(),this.interval.max=r.getMaxY(),this.tree.insert(this.interval,i)}},testMonotoneChain:function(t,e,n){n.select(t,e)},isInside:function(t){this.crossings=0;var e=new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);this.interval.min=t.y,this.interval.max=t.y;for(var n=this.tree.query(this.interval),i=new Ni(this,t),s=n.iterator();s.hasNext();){var o=s.next();this.testMonotoneChain(e,i,o)}return this.crossings%2===1},interfaces_:function(){return[Ei]},getClass:function(){return Ii}}),h(Ni,hi),e(Ni.prototype,{select:function(){if(1!==arguments.length)return hi.prototype.select.apply(this,arguments);var t=arguments[0];this.mcp.testLineSegment(this.p,t)},interfaces_:function(){return[]},getClass:function(){return Ni}}),Ii.MCSelecter=Ni,e(Ci.prototype,{interfaces_:function(){return[]},getClass:function(){return Ci}}),Ci.toDegrees=function(t){return 180*t/Math.PI},Ci.normalize=function(t){for(;t>Math.PI;)t-=Ci.PI_TIMES_2;for(;t<=-Math.PI;)t+=Ci.PI_TIMES_2;return t},Ci.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},Ci.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a>0},Ci.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a<0},Ci.interiorAngle=function(t,e,n){var i=Ci.angle(e,t),r=Ci.angle(e,n);return Math.abs(r-i)},Ci.normalizePositive=function(t){if(t<0){for(;t<0;)t+=Ci.PI_TIMES_2;t>=Ci.PI_TIMES_2&&(t=0)}else{for(;t>=Ci.PI_TIMES_2;)t-=Ci.PI_TIMES_2;t<0&&(t=0)}return t},Ci.angleBetween=function(t,e,n){var i=Ci.angle(e,t),r=Ci.angle(e,n);return Ci.diff(i,r)},Ci.diff=function(t,e){var n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n},Ci.toRadians=function(t){return t*Math.PI/180},Ci.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?Ci.COUNTERCLOCKWISE:n<0?Ci.CLOCKWISE:Ci.NONE},Ci.angleBetweenOriented=function(t,e,n){var i=Ci.angle(e,t),r=Ci.angle(e,n),s=r-i;return s<=-Math.PI?s+Ci.PI_TIMES_2:s>Math.PI?s-Ci.PI_TIMES_2:s},Ci.PI_TIMES_2=2*Math.PI,Ci.PI_OVER_2=Math.PI/2,Ci.PI_OVER_4=Math.PI/4,Ci.COUNTERCLOCKWISE=he.COUNTERCLOCKWISE,Ci.CLOCKWISE=he.CLOCKWISE,Ci.NONE=he.COLLINEAR,e(Si.prototype,{area:function(){return Si.area(this.p0,this.p1,this.p2)},signedArea:function(){return Si.signedArea(this.p0,this.p1,this.p2)},interpolateZ:function(t){if(null===t)throw new i("Supplied point is null.");return Si.interpolateZ(t,this.p0,this.p1,this.p2)},longestSideLength:function(){return Si.longestSideLength(this.p0,this.p1,this.p2)},isAcute:function(){return Si.isAcute(this.p0,this.p1,this.p2)},circumcentre:function(){return Si.circumcentre(this.p0,this.p1,this.p2)},area3D:function(){return Si.area3D(this.p0,this.p1,this.p2)},centroid:function(){return Si.centroid(this.p0,this.p1,this.p2)},inCentre:function(){return Si.inCentre(this.p0,this.p1,this.p2)},interfaces_:function(){return[]},getClass:function(){return Si}}),Si.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},Si.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},Si.det=function(t,e,n,i){return t*i-e*n},Si.interpolateZ=function(t,e,n,i){var r=e.x,s=e.y,o=n.x-r,a=i.x-r,u=n.y-s,l=i.y-s,h=o*l-a*u,c=t.x-r,f=t.y-s,g=(l*c-a*f)/h,d=(-u*c+o*f)/h,p=e.z+g*(n.z-e.z)+d*(i.z-e.z);return p},Si.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),s=n.distance(t),o=i;return r>o&&(o=r),s>o&&(o=s),o},Si.isAcute=function(t,e,n){return!!Ci.isAcute(t,e,n)&&(!!Ci.isAcute(e,n,t)&&!!Ci.isAcute(n,t,e))},Si.circumcentre=function(t,e,n){var i=n.x,r=n.y,s=t.x-i,o=t.y-r,a=e.x-i,u=e.y-r,l=2*Si.det(s,o,a,u),h=Si.det(o,s*s+o*o,u,a*a+u*u),c=Si.det(s,s*s+o*o,a,a*a+u*u),f=i-h/l,d=r+c/l;return new g(f,d)},Si.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new F(t.x+n/2,t.y+i/2,1),s=new F(t.x-i+n/2,t.y+n+i/2,1);return new F(r,s)},Si.angleBisector=function(t,e,n){var i=e.distance(t),r=e.distance(n),s=i/(i+r),o=n.x-t.x,a=n.y-t.y,u=new g(t.x+s*o,t.y+s*a);return u},Si.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=e.z-t.z,o=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-s*a,h=s*o-i*u,c=i*a-r*o,f=l*l+h*h+c*c,g=Math.sqrt(f)/2;return g},Si.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new g(i,r)},Si.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),s=t.distance(e),o=i+r+s,a=(i*t.x+r*e.x+s*n.x)/o,u=(i*t.y+r*e.y+s*n.y)/o;return new g(a,u)},e(wi.prototype,{getRadius:function(){return this.compute(),this.radius},getDiameter:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[1];return this.input.getFactory().createLineString([t,e])},getExtremalPoints:function(){return this.compute(),this.extremalPts},computeCirclePoints:function(){if(this.input.isEmpty())return this.extremalPts=new Array(0).fill(null),null;if(1===this.input.getNumPoints()){var t=this.input.getCoordinates();return this.extremalPts=[new g(t[0])],null}var e=this.input.convexHull(),n=e.getCoordinates(),t=n;if(n[0].equals2D(n[n.length-1])&&(t=new Array(n.length-1).fill(null),H.copyDeep(n,0,t,0,n.length-1)),t.length<=2)return this.extremalPts=H.copyDeep(t),null;for(var i=wi.lowestPoint(t),r=wi.pointWitMinAngleWithX(t,i),s=0;s<t.length;s++){var o=wi.pointWithMinAngleWithSegment(t,i,r);if(Ci.isObtuse(i,o,r))return this.extremalPts=[new g(i),new g(r)],null;if(Ci.isObtuse(o,i,r))i=o;else{if(!Ci.isObtuse(o,r,i))return this.extremalPts=[new g(i),new g(r),new g(o)],null;r=o}}f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")},compute:function(){return null!==this.extremalPts?null:(this.computeCirclePoints(),this.computeCentre(),void(null!==this.centre&&(this.radius=this.centre.distance(this.extremalPts[0]))))},getFarthestPoints:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[this.extremalPts.length-1];return this.input.getFactory().createLineString([t,e])},getCircle:function(){if(this.compute(),null===this.centre)return this.input.getFactory().createPolygon();var t=this.input.getFactory().createPoint(this.centre);return 0===this.radius?t:t.buffer(this.radius)},getCentre:function(){return this.compute(),this.centre},computeCentre:function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new g((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=Si.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2])}},interfaces_:function(){return[]},getClass:function(){return wi}}),wi.pointWitMinAngleWithX=function(t,e){for(var n=r.MAX_VALUE,i=null,s=0;s<t.length;s++){var o=t[s];if(o!==e){var a=o.x-e.x,u=o.y-e.y;u<0&&(u=-u);var l=Math.sqrt(a*a+u*u),h=u/l;h<n&&(n=h,i=o)}}return i},wi.lowestPoint=function(t){for(var e=t[0],n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e},wi.pointWithMinAngleWithSegment=function(t,e,n){for(var i=r.MAX_VALUE,s=null,o=0;o<t.length;o++){var a=t[o];if(a!==e&&a!==n){var u=Ci.angleBetween(e,a,n);u<i&&(i=u,s=a)}}return s},e(Li.prototype,{getWidthCoordinate:function(){return this.computeMinimumDiameter(),this.minWidthPt},getSupportingSegment:function(){return this.computeMinimumDiameter(),this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0,this.minBaseSeg.p1])},getDiameter:function(){if(this.computeMinimumDiameter(),null===this.minWidthPt)return this.inputGeom.getFactory().createLineString(null);var t=this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t,this.minWidthPt])},computeWidthConvex:function(t){t instanceof Tt?this.convexHullPts=t.getExteriorRing().getCoordinates():this.convexHullPts=t.getCoordinates(),0===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=null,this.minBaseSeg=null):1===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[0]):2===this.convexHullPts.length||3===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[1]):this.computeConvexRingMinDiameter(this.convexHullPts)},computeConvexRingMinDiameter:function(t){this.minWidth=r.MAX_VALUE;for(var e=1,n=new ce,i=0;i<t.length-1;i++)n.p0=t[i],n.p1=t[i+1],e=this.findMaxPerpDistance(t,n,e)},computeMinimumDiameter:function(){if(null!==this.minWidthPt)return null;if(this.isConvex)this.computeWidthConvex(this.inputGeom);else{var t=new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t)}},getLength:function(){return this.computeMinimumDiameter(),this.minWidth},findMaxPerpDistance:function(t,e,n){for(var i=e.distancePerpendicular(t[n]),r=i,s=n,o=s;r>=i;)i=r,s=o,o=Li.nextIndex(t,s),r=e.distancePerpendicular(t[o]);return i<this.minWidth&&(this.minPtIndex=s,this.minWidth=i,this.minWidthPt=t[this.minPtIndex],this.minBaseSeg=new ce(e)),s},getMinimumRectangle:function(){if(this.computeMinimumDiameter(),0===this.minWidth)return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)?this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0):this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for(var t=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x,e=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y,n=r.MAX_VALUE,i=-r.MAX_VALUE,s=r.MAX_VALUE,o=-r.MAX_VALUE,a=0;a<this.convexHullPts.length;a++){var u=Li.computeC(t,e,this.convexHullPts[a]);u>i&&(i=u),u<n&&(n=u);var l=Li.computeC(-e,t,this.convexHullPts[a]);l>o&&(o=l),l<s&&(s=l)}var h=Li.computeSegmentForLine(-t,-e,o),c=Li.computeSegmentForLine(-t,-e,s),f=Li.computeSegmentForLine(-e,t,i),g=Li.computeSegmentForLine(-e,t,n),d=f.lineIntersection(h),p=g.lineIntersection(h),v=g.lineIntersection(c),m=f.lineIntersection(c),y=this.inputGeom.getFactory().createLinearRing([d,p,v,m,d]);return this.inputGeom.getFactory().createPolygon(y,null)},interfaces_:function(){return[]},getClass:function(){return Li}}),Li.nextIndex=function(t,e){return e++,e>=t.length&&(e=0),e},Li.computeC=function(t,e,n){return t*n.y-e*n.x},Li.getMinimumDiameter=function(t){return new Li(t).getDiameter()},Li.getMinimumRectangle=function(t){return new Li(t).getMinimumRectangle()},Li.computeSegmentForLine=function(t,e,n){var i=null,r=null;return Math.abs(e)>Math.abs(t)?(i=new g(0,n/e),r=new g(1,n/e-t/e)):(i=new g(n/t,0),r=new g(n/t-e/t,1)),new ce(i,r)};var co=Object.freeze({Centroid:ge,CGAlgorithms:he,ConvexHull:me,InteriorPointArea:oi,InteriorPointLine:ui,InteriorPointPoint:li,RobustLineIntersector:ae,MCPointInRing:Ii,MinimumBoundingCircle:wi,MinimumDiameter:Li});e(Ri.prototype,{getResultGeometry:function(){return new Ti(this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(t<=0)throw new i("Tolerance must be positive");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return Ri}}),Ri.densifyPoints=function(t,e,n){for(var i=new ce,r=new N,s=0;s<t.length-1;s++){i.p0=t[s],i.p1=t[s+1],r.add(i.p0,!1);var o=i.getLength(),a=Math.trunc(o/e)+1;if(a>1)for(var u=o/a,l=1;l<a;l++){var h=l*u/o,c=i.pointAlong(h);n.makePrecise(c),r.add(c,!1)}}return r.add(t[t.length-1],!1),r.toCoordinateArray()},Ri.densify=function(t,e){var n=new Ri(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ti,xe),e(Ti.prototype,{transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformPolygon:function(t,e){var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=Ri.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof St&&1===i.length&&(i=new Array(0).fill(null)),this.factory.getCoordinateSequenceFactory().create(i)},createValidArea:function(t){return t.buffer(0)},interfaces_:function(){return[]},getClass:function(){return Ti}}),Ri.DensifyTransformer=Ti;var fo=Object.freeze({Densifier:Ri});e(Pi.prototype,{find:function(t){var e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null},dest:function(){return this._sym._orig},oNext:function(){return this._sym._next},insert:function(t){if(this.oNext()===this)return this.insertAfter(t),null;var e=this.compareTo(t),n=this;do{var i=n.oNext(),r=i.compareTo(t);if(r!==e||i===this)return n.insertAfter(t),null;n=i}while(n!==this);f.shouldNeverReachHere()},insertAfter:function(t){f.equals(this._orig,t.orig());var e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)},degree:function t(){var t=0,e=this;do t++,e=e.oNext();while(e!==this);return t},equals:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}},deltaY:function(){return this._sym._orig.y-this._orig.y},sym:function(){return this._sym},prev:function(){return this._sym.next()._sym},compareAngularDirection:function(t){var e=this.deltaX(),n=this.deltaY(),i=t.deltaX(),r=t.deltaY();if(e===i&&n===r)return 0;var s=Je.quadrant(e,n),o=Je.quadrant(i,r);return s>o?1:s<o?-1:he.computeOrientation(t._orig,t.dest(),this.dest())},prevNode:function(){for(var t=this;2===t.degree();)if(t=t.prev(),t===this)return null;return t},compareTo:function(t){var e=t,n=this.compareAngularDirection(e);return n},next:function(){return this._next},setSym:function(t){this._sym=t},orig:function(){return this._orig},toString:function(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"},setNext:function(t){this._next=t},init:function(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)},deltaX:function(){return this._sym._orig.x-this._orig.x},interfaces_:function(){return[]},getClass:function(){return Pi}}),Pi.init=function(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t},Pi.create=function(t,e){var n=new Pi(t),i=new Pi(e);return n.init(i),n},h(bi,Pi),e(bi.prototype,{mark:function(){this._isMarked=!0},setMark:function(t){this._isMarked=t},isMarked:function(){return this._isMarked},interfaces_:function(){return[]},getClass:function(){return bi}}),bi.setMarkBoth=function(t,e){t.setMark(e),t.sym().setMark(e)},bi.isMarked=function(t){return t.isMarked()},bi.setMark=function(t,e){t.setMark(e)},bi.markBoth=function(t){t.mark(),t.sym().mark()},bi.mark=function(t){t.mark()},e(Oi.prototype,{insert:function(t,e,n){var i=this.create(t,e);null!==n?n.insert(i):this.vertexMap.put(t,i);var r=this.vertexMap.get(e);return null!==r?r.insert(i.sym()):this.vertexMap.put(e,i.sym()),i},create:function(t,e){var n=this.createEdge(t),i=this.createEdge(e);return Pi.init(n,i),n},createEdge:function(t){return new Pi(t)},addEdge:function(t,e){if(!Oi.isValidEdge(t,e))return null;var n=this.vertexMap.get(t),i=null;if(null!==n&&(i=n.find(e)),null!==i)return i;var r=this.insert(t,e,n);return r},getVertexEdges:function(){return this.vertexMap.values()},findEdge:function(t,e){var n=this.vertexMap.get(t);return null===n?null:n.find(e)},interfaces_:function(){
return[]},getClass:function(){return Oi}}),Oi.isValidEdge=function(t,e){var n=e.compareTo(t);return 0!==n},h(_i,bi),e(_i.prototype,{setStart:function(){this._isStart=!0},isStart:function(){return this._isStart},interfaces_:function(){return[]},getClass:function(){return _i}}),h(Mi,Oi),e(Mi.prototype,{createEdge:function(t){return new _i(t)},interfaces_:function(){return[]},getClass:function(){return Mi}}),e(Di.prototype,{addLine:function(t){this.lines.add(this.factory.createLineString(t.toCoordinateArray()))},updateRingStartEdge:function(t){return t.isStart()||(t=t.sym(),t.isStart())?null===this.ringStartEdge?(this.ringStartEdge=t,null):void(t.orig().compareTo(this.ringStartEdge.orig())<0&&(this.ringStartEdge=t)):null},getResult:function(){return null===this.result&&this.computeResult(),this.result},process:function(t){var e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()},buildRing:function(t){var e=new N,n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){var i=n.next();if(i===t)break;e.add(i.orig().copy(),!1),n=i}e.add(n.dest().copy(),!1),this.addLine(e)},buildLine:function(t){var e=new N,n=t;for(this.ringStartEdge=null,bi.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);var i=n.next();if(i===t)return this.buildRing(this.ringStartEdge),null;e.add(i.orig().copy(),!1),n=i,bi.markBoth(n)}e.add(n.dest().copy(),!1),this.stackEdges(n.sym()),this.addLine(e)},stackEdges:function(t){var e=t;do bi.isMarked(e)||this.nodeEdgeStack.add(e),e=e.oNext();while(e!==t)},computeResult:function(){for(var t=this.graph.getVertexEdges(),e=t.iterator();e.hasNext();){var n=e.next();bi.isMarked(n)||this.process(n)}this.result=this.factory.buildGeometry(this.lines)},buildLines:function(){for(;!this.nodeEdgeStack.empty();){var t=this.nodeEdgeStack.pop();bi.isMarked(t)||this.buildLine(t)}},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v))for(var e=arguments[0],n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory());for(var s=r.getCoordinateSequence(),o=!1,n=1;n<s.size();n++){var a=this.graph.addEdge(s.getCoordinate(n-1),s.getCoordinate(n));null!==a&&(o||(a.setStart(),o=!0))}}},interfaces_:function(){return[]},getClass:function(){return Di}}),Di.dissolve=function(t){var e=new Di;return e.add(t),e.getResult()};var go=Object.freeze({LineDissolver:Di}),po=Object.freeze({GeometryGraph:$n});e(Ai.prototype,{hasChildren:function(){for(var t=0;t<4;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;e<4;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},getNodeCount:function(){for(var t=0,e=0;e<4;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+1},size:function(){for(var t=0,e=0;e<4;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this.items);for(var n=0;n<4;n++)null!==this.subnode[n]&&this.subnode[n].addAllItemsFromOverlapping(t,e)},visitItems:function(t,e){for(var n=this.items.iterator();n.hasNext();)e.visitItem(n.next())},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;i<4;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},visit:function(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(var n=0;n<4;n++)null!==this.subnode[n]&&this.subnode[n].visit(t,e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;e<4;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},isEmpty:function t(){var t=!0;this.items.isEmpty()||(t=!1);for(var e=0;e<4;e++)null!==this.subnode[e]&&(this.subnode[e].isEmpty()||(t=!1));return t},add:function(t){this.items.add(t)},interfaces_:function(){return[u]},getClass:function(){return Ai}}),Ai.getSubnodeIndex=function(t,e,n){var i=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(i=3),t.getMaxY()<=n&&(i=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(i=2),t.getMaxY()<=n&&(i=0)),i},e(Fi.prototype,{getLevel:function(){return this.level},computeKey:function(){if(1===arguments.length){var t=arguments[0];for(this.level=Fi.computeQuadLevel(t),this.env=new C,this.computeKey(this.level,t);!this.env.contains(t);)this.level+=1,this.computeKey(this.level,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=gi.powerOf2(e);this.pt.x=Math.floor(n.getMinX()/i)*i,this.pt.y=Math.floor(n.getMinY()/i)*i,this.env.init(this.pt.x,this.pt.x+i,this.pt.y,this.pt.y+i)}},getEnvelope:function(){return this.env},getCentre:function(){return new g((this.env.getMinX()+this.env.getMaxX())/2,(this.env.getMinY()+this.env.getMaxY())/2)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return Fi}}),Fi.computeQuadLevel=function(t){var e=t.getWidth(),n=t.getHeight(),i=e>n?e:n,r=gi.exponent(i)+1;return r},h(Gi,Ai),e(Gi.prototype,{find:function(t){var e=Ai.getSubnodeIndex(t,this.centrex,this.centrey);if(e===-1)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},isSearchMatch:function(t){return this.env.intersects(t)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getEnvelope:function(){return this.env},getNode:function(t){var e=Ai.getSubnodeIndex(t,this.centrex,this.centrey);if(e!==-1){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0,i=0,r=0;switch(t){case 0:e=this.env.getMinX(),n=this.centrex,i=this.env.getMinY(),r=this.centrey;break;case 1:e=this.centrex,n=this.env.getMaxX(),i=this.env.getMinY(),r=this.centrey;break;case 2:e=this.env.getMinX(),n=this.centrex,i=this.centrey,r=this.env.getMaxY();break;case 3:e=this.centrex,n=this.env.getMaxX(),i=this.centrey,r=this.env.getMaxY()}var s=new C(e,n,i,r),o=new Gi(s,this.level-1);return o},insertNode:function(t){f.isTrue(null===this.env||this.env.contains(t.env));var e=Ai.getSubnodeIndex(t.env,this.centrex,this.centrey);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insertNode(t),this.subnode[e]=n}},interfaces_:function(){return[]},getClass:function(){return Gi}}),Gi.createNode=function(t){var e=new Fi(t),n=new Gi(e.getEnvelope(),e.getLevel());return n},Gi.createExpanded=function(t,e){var n=new C(e);null!==t&&n.expandToInclude(t.env);var i=Gi.createNode(n);return null!==t&&i.insertNode(t),i},h(qi,Ai),e(qi.prototype,{insert:function(t,e){var n=Ai.getSubnodeIndex(t,qi.origin.x,qi.origin.y);if(n===-1)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getEnvelope().contains(t)){var r=Gi.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getEnvelope().contains(e));var i=mi.isZeroWidth(e.getMinX(),e.getMaxX()),r=mi.isZeroWidth(e.getMinY(),e.getMaxY()),s=null;s=i||r?t.find(e):t.getNode(e),s.add(n)},interfaces_:function(){return[]},getClass:function(){return qi}}),qi.origin=new g(0,0),e(Bi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=Bi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){var t=arguments[0],e=new Yn;return this.query(t,e),e.getItems()}if(2===arguments.length){var n=arguments[0],i=arguments[1];this.root.visit(n,i)}},queryAll:function(){var t=new I;return this.root.addAllItems(t),t},remove:function(t,e){var n=Bi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e);var n=t.getHeight();n<this.minExtent&&n>0&&(this.minExtent=n)},depth:function(){return null!==this.root?this.root.depth():0},isEmpty:function(){return null===this.root},interfaces_:function(){return[Fe,u]},getClass:function(){return Bi}}),Bi.ensureExtent=function(t,e){var n=t.getMinX(),i=t.getMaxX(),r=t.getMinY(),s=t.getMaxY();return n!==i&&r!==s?t:(n===i&&(n-=e/2,i=n+e/2),r===s&&(r-=e/2,s=r+e/2),new C(n,i,r,s))},Bi.serialVersionUID=-0x678b60c967a25400;var vo=Object.freeze({Quadtree:Bi}),mo=Object.freeze({STRtree:ke}),yo=Object.freeze({quadtree:vo,strtree:mo}),xo=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];e(zi.prototype,{read:function(t){var e=void 0;e="string"==typeof t?JSON.parse(t):t;var n=e.type;if(!Eo[n])throw new Error("Unknown GeoJSON type: "+e.type);return xo.indexOf(n)!==-1?Eo[n].apply(this,[e.coordinates]):"GeometryCollection"===n?Eo[n].apply(this,[e.geometries]):Eo[n].apply(this,[e])},write:function(t){var e=t.getGeometryType();if(!Io[e])throw new Error("Geometry is not supported");return Io[e].apply(this,[t])}});var Eo={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!Eo[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Eo.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function t(e){for(var t=[],n=0;n<e.length;++n){var i=e[n];t.push(new g(i[0],i[1]))}return t},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){var e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Eo.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=Eo.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(Eo.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=Eo.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var s=t[r],o=Eo.coordinates.apply(this,[s]),a=this.geometryFactory.createLinearRing(o);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(Eo.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},Io={coordinate:function(t){return[t.x,t.y]},Point:function(t){var e=Io.coordinate.apply(this,[t.getCoordinate()]);return{type:"Point",coordinates:e}},MultiPoint:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Io.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(Io.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Io.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=Io.LineString.apply(this,[t.shell]);e.push(n.coordinates);for(var i=0;i<t.holes.length;++i){var r=t.holes[i],s=Io.LineString.apply(this,[r]);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Io.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=i.getGeometryType();e.push(Io[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}};e(Vi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;e<n;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;e<n;e++)this.reducePrecision(t.geometries[e])}}),e(ki.prototype,{write:function(t){return this.parser.write(t)}}),e(Yi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(var e=0,n=t.points.coordinates.length;e<n;e++)this.precisionModel.makePrecise(t.points.coordinates[e]);else if(t.geometries)for(var i=0,r=t.geometries.length;i<r;i++)this.reducePrecision(t.geometries[i])}}),e(Xi.prototype,{read:function(t){var e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0},convertFromPoint:function(t){var e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))},convertFromLineString:function(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromLinearRing:function(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromPolygon:function(t){for(var e=t.getLinearRings(),n=null,i=[],r=0;r<e.length;r++){var s=this.convertFromLinearRing(e[r]);0===r?n=s:i.push(s)}return this.geometryFactory.createPolygon(n,i)},convertFromMultiPoint:function(t){var e=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(e)},convertFromMultiLineString:function(t){var e=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(e)},convertFromMultiPolygon:function(t){var e=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(e)},convertFromCollection:function(t){var e=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(e)},write:function(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0},convertToPoint:function(t){return new this.ol.geom.Point([t.x,t.y])},convertToLineString:function(t){var e=t.points.coordinates.map(Ui);return new this.ol.geom.LineString(e)},convertToLinearRing:function(t){var e=t.points.coordinates.map(Ui);return new this.ol.geom.LinearRing(e)},convertToPolygon:function(t){for(var e=[t.shell.points.coordinates.map(Ui)],n=0;n<t.holes.length;n++)e.push(t.holes[n].points.coordinates.map(Ui));return new this.ol.geom.Polygon(e)},convertToMultiPoint:function(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Ui))},convertToMultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)},convertToMultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)},convertToCollection:function(t){for(var e=[],n=0;n<t.geometries.length;n++){var i=t.geometries[n];e.push(this.write(i))}return new this.ol.geom.GeometryCollection(e)}});var No=Object.freeze({GeoJSONReader:Vi,GeoJSONWriter:ki,OL3Parser:Xi,WKTReader:Yi,WKTWriter:se});e(Hi.prototype,{rescale:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.rescale(n.getCoordinates())}else if(arguments[0]instanceof Array){var i=arguments[0],r=null,s=null;2===i.length&&(r=new g(i[0]),s=new g(i[1]));for(var e=0;e<i.length;e++)i[e].x=i[e].x/this.scaleFactor+this.offsetX,i[e].y=i[e].y/this.scaleFactor+this.offsetY;2===i.length&&i[0].equals2D(i[1])&&A.out.println(i)}},scale:function(){if(R(arguments[0],v)){for(var t=arguments[0],e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ke(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],s=new Array(r.length).fill(null),n=0;n<r.length;n++)s[n]=new g(Math.round((r[n].x-this.offsetX)*this.scaleFactor),Math.round((r[n].y-this.offsetY)*this.scaleFactor),r[n].z);var o=H.removeRepeatedPoints(s);return o}},isIntegerPrecision:function(){return 1===this.scaleFactor},getNodedSubstrings:function(){var t=this.noder.getNodedSubstrings();return this.isScaled&&this.rescale(t),t},computeNodes:function(t){var e=t;this.isScaled&&(e=this.scale(t)),this.noder.computeNodes(e)},interfaces_:function(){return[tn]},getClass:function(){return Hi}});var Co=Object.freeze({MCIndexNoder:nn,ScaledNoder:Hi,SegmentString:be});e(Wi.prototype,{isSimpleMultiPoint:function(t){if(t.isEmpty())return!0;for(var e=new at,n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n),r=i.getCoordinate();if(e.contains(r))return this.nonSimpleLocation=r,!1;e.add(r)}return!0},isSimplePolygonal:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next();if(!this.isSimpleLinearGeometry(i))return!1}return!0},hasClosedEndpointIntersection:function(t){for(var e=new rt,n=t.getEdgeIterator();n.hasNext();){var i=n.next(),r=(i.getMaximumSegmentIndex(),i.isClosed()),s=i.getCoordinate(0);this.addEndpoint(e,s,r);var o=i.getCoordinate(i.getNumPoints()-1);this.addEndpoint(e,o,r)}for(var n=e.values().iterator();n.hasNext();){var a=n.next();if(a.isClosed&&2!==a.degree)return this.nonSimpleLocation=a.getCoordinate(),!0}return!1},getNonSimpleLocation:function(){return this.nonSimpleLocation},isSimpleLinearGeometry:function(t){if(t.isEmpty())return!0;var e=new $n(0,t),n=new ae,i=e.computeSelfNodes(n,!0);return!i.hasIntersection()||(i.hasProperIntersection()?(this.nonSimpleLocation=i.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this.isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))},hasNonEndpointIntersection:function(t){for(var e=t.getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getMaximumSegmentIndex(),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next();if(!s.isEndPoint(i))return this.nonSimpleLocation=s.getCoordinate(),!0}return!1},addEndpoint:function(t,e,n){var i=t.get(e);null===i&&(i=new ji(e),t.put(e,i)),i.addEndpoint(n)},computeSimple:function(t){return this.nonSimpleLocation=null,!!t.isEmpty()||(t instanceof St?this.isSimpleLinearGeometry(t):t instanceof gt?this.isSimpleLinearGeometry(t):t instanceof Pt?this.isSimpleMultiPoint(t):R(t,Rt)?this.isSimplePolygonal(t):!(t instanceof ft)||this.isSimpleGeometryCollection(t))},isSimple:function(){return this.nonSimpleLocation=null,this.computeSimple(this.inputGeom)},isSimpleGeometryCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0},interfaces_:function(){return[]},getClass:function(){return Wi}}),e(ji.prototype,{addEndpoint:function(t){this.degree++,this.isClosed|=t},getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return ji}}),Wi.EndpointInfo=ji,e(Ki.prototype,{getEndCapStyle:function(){return this.endCapStyle},isSingleSided:function(){return this._isSingleSided},setQuadrantSegments:function(t){this.quadrantSegments=t,0===this.quadrantSegments&&(this.joinStyle=Ki.JOIN_BEVEL),this.quadrantSegments<0&&(this.joinStyle=Ki.JOIN_MITRE,this.mitreLimit=Math.abs(this.quadrantSegments)),t<=0&&(this.quadrantSegments=1),this.joinStyle!==Ki.JOIN_ROUND&&(this.quadrantSegments=Ki.DEFAULT_QUADRANT_SEGMENTS)},getJoinStyle:function(){return this.joinStyle},setJoinStyle:function(t){this.joinStyle=t},setSimplifyFactor:function(t){this.simplifyFactor=t<0?0:t},getSimplifyFactor:function(){return this.simplifyFactor},getQuadrantSegments:function(){return this.quadrantSegments},setEndCapStyle:function(t){this.endCapStyle=t},getMitreLimit:function(){return this.mitreLimit},setMitreLimit:function(t){this.mitreLimit=t},setSingleSided:function(t){this._isSingleSided=t},interfaces_:function(){return[]},getClass:function(){return Ki}}),Ki.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Ki.CAP_ROUND=1,Ki.CAP_FLAT=2,Ki.CAP_SQUARE=3,Ki.JOIN_ROUND=1,Ki.JOIN_MITRE=2,Ki.JOIN_BEVEL=3,Ki.DEFAULT_QUADRANT_SEGMENTS=8,Ki.DEFAULT_MITRE_LIMIT=5,Ki.DEFAULT_SIMPLIFY_FACTOR=.01,e(Zi.prototype,{getCoordinate:function(){return this.minCoord},getRightmostSide:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this.minCoord=null,this.checkForRightmostCoordinate(t)),n},findRightmostEdgeAtVertex:function(){var t=this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex>0&&this.minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this.minIndex-1],n=t[this.minIndex+1],i=he.computeOrientation(this.minCoord,n,e),r=!1;e.y<this.minCoord.y&&n.y<this.minCoord.y&&i===he.COUNTERCLOCKWISE?r=!0:e.y>this.minCoord.y&&n.y>this.minCoord.y&&i===he.CLOCKWISE&&(r=!0),r&&(this.minIndex=this.minIndex-1)},getRightmostSideOfSegment:function(t,e){var n=t.getEdge(),i=n.getCoordinates();if(e<0||e+1>=i.length)return-1;if(i[e].y===i[e+1].y)return-1;var r=cn.LEFT;return i[e].y<i[e+1].y&&(r=cn.RIGHT),r},getEdge:function(){return this.orientedDe},checkForRightmostCoordinate:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this.minCoord||e[n].x>this.minCoord.x)&&(this.minDe=t,this.minIndex=n,this.minCoord=e[n])},findRightmostEdgeAtNode:function(){var t=this.minDe.getNode(),e=t.getEdges();this.minDe=e.getRightmostEdge(),this.minDe.isForward()||(this.minDe=this.minDe.getSym(),this.minIndex=this.minDe.getEdge().getCoordinates().length-1)},findEdge:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}f.isTrue(0!==this.minIndex||this.minCoord.equals(this.minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this.minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this.orientedDe=this.minDe;var i=this.getRightmostSide(this.minDe,this.minIndex);i===cn.LEFT&&(this.orientedDe=this.minDe.getSym())},interfaces_:function(){return[]},getClass:function(){return Zi}}),Qi.prototype.addLast=function(t){this.array_.push(t)},Qi.prototype.removeFirst=function(){return this.array_.shift()},Qi.prototype.isEmpty=function(){return 0===this.array_.length},e(Ji.prototype,{clearVisitedEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.setVisited(!1)}},getRightmostCoordinate:function(){return this.rightMostCoord},computeNodeDepth:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new sn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();i.setVisited(!0),this.copySymDepths(i)}},computeDepth:function(t){this.clearVisitedEdges();var e=this.finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(cn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},create:function(t){this.addReachable(t),this.finder.findEdge(this.dirEdgeList),this.rightMostCoord=this.finder.getCoordinate()},findResultEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(cn.RIGHT)>=1&&e.getDepth(cn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},computeDepths:function(t){var e=new J,n=new Qi,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var s=r.getEdges().iterator();s.hasNext();){var o=s.next(),a=o.getSym();if(!a.isVisited()){var u=a.getNode();e.contains(u)||(n.addLast(u),e.add(u))}}}},compareTo:function(t){var e=t;return this.rightMostCoord.x<e.rightMostCoord.x?-1:this.rightMostCoord.x>e.rightMostCoord.x?1:0},getEnvelope:function(){if(null===this.env){for(var t=new C,e=this.dirEdgeList.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge().getCoordinates(),r=0;r<i.length-1;r++)t.expandToInclude(i[r]);this.env=t}return this.env},addReachable:function(t){var e=new pe;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},copySymDepths:function(t){var e=t.getSym();e.setDepth(cn.LEFT,t.getDepth(cn.RIGHT)),e.setDepth(cn.RIGHT,t.getDepth(cn.LEFT))},add:function(t,e){t.setVisited(!0),this.nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this.dirEdgeList.add(i);var r=i.getSym(),s=r.getNode();s.isVisited()||e.push(s)}},getNodes:function(){return this.nodes},getDirectedEdges:function(){return this.dirEdgeList},interfaces_:function(){return[s]},getClass:function(){return Ji}}),e($i.prototype,{isDeletable:function(t,e,n,i){var r=this.inputLine[t],s=this.inputLine[e],o=this.inputLine[n];return!!this.isConcave(r,s,o)&&(!!this.isShallow(r,s,o,i)&&this.isShallowSampled(r,s,t,n,i))},deleteShallowConcavities:function(){for(var t=1,e=(this.inputLine.length-1,this.findNextNonDeletedIndex(t)),n=this.findNextNonDeletedIndex(e),i=!1;n<this.inputLine.length;){var r=!1;this.isDeletable(t,e,n,this.distanceTol)&&(this.isDeleted[e]=$i.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},isShallowConcavity:function(t,e,n,i){var r=he.computeOrientation(t,e,n),s=r===this.angleOrientation;if(!s)return!1;var o=he.distancePointLine(e,t,n);return o<i},isShallowSampled:function(t,e,n,i,r){var s=Math.trunc((i-n)/$i.NUM_PTS_TO_CHECK);s<=0&&(s=1);for(var o=n;o<i;o+=s)if(!this.isShallow(t,e,this.inputLine[o],r))return!1;return!0},isConcave:function t(e,n,i){var r=he.computeOrientation(e,n,i),t=r===this.angleOrientation;return t},simplify:function(t){this.distanceTol=Math.abs(t),t<0&&(this.angleOrientation=he.CLOCKWISE),this.isDeleted=new Array(this.inputLine.length).fill(null);var e=!1;do e=this.deleteShallowConcavities();while(e);return this.collapseLine()},findNextNonDeletedIndex:function(t){for(var e=t+1;e<this.inputLine.length&&this.isDeleted[e]===$i.DELETE;)e++;return e},isShallow:function(t,e,n,i){var r=he.distancePointLine(e,t,n);return r<i},collapseLine:function(){for(var t=new N,e=0;e<this.inputLine.length;e++)this.isDeleted[e]!==$i.DELETE&&t.add(this.inputLine[e]);return t.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return $i}}),$i.simplify=function(t,e){var n=new $i(t);return n.simplify(e)},$i.INIT=0,$i.DELETE=1,$i.KEEP=1,$i.NUM_PTS_TO_CHECK=10,e(tr.prototype,{getCoordinates:function(){var t=this.ptList.toArray(tr.COORDINATE_ARRAY_TYPE);return t},setPrecisionModel:function(t){this.precisionModel=t},addPt:function(t){var e=new g(t);return this.precisionModel.makePrecise(e),this.isRedundant(e)?null:void this.ptList.add(e)},reverse:function(){},addPts:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var n=t.length-1;n>=0;n--)this.addPt(t[n])},isRedundant:function(t){if(this.ptList.size()<1)return!1;var e=this.ptList.get(this.ptList.size()-1),n=t.distance(e);return n<this.minimimVertexDistance},toString:function(){var t=new ie,e=t.createLineString(this.getCoordinates());return e.toString()},closeRing:function(){if(this.ptList.size()<1)return null;var t=new g(this.ptList.get(0)),e=this.ptList.get(this.ptList.size()-1),n=null;return this.ptList.size()>=2&&(n=this.ptList.get(this.ptList.size()-2)),t.equals(e)?null:void this.ptList.add(t)},setMinimumVertexDistance:function(t){this.minimimVertexDistance=t},interfaces_:function(){return[]},getClass:function(){return tr}}),tr.COORDINATE_ARRAY_TYPE=new Array(0).fill(null),e(er.prototype,{addNextSegment:function(t,e){if(this.s0=this.s1,this.s1=this.s2,this.s2=t,this.seg0.setCoordinates(this.s0,this.s1),this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0),this.seg1.setCoordinates(this.s1,this.s2),this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1),this.s1.equals(this.s2))return null;var n=he.computeOrientation(this.s0,this.s1,this.s2),i=n===he.CLOCKWISE&&this.side===cn.LEFT||n===he.COUNTERCLOCKWISE&&this.side===cn.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},addLineEndCap:function(t,e){var n=new ce(t,e),i=new ce;this.computeOffsetSegment(n,cn.LEFT,this.distance,i);var r=new ce;this.computeOffsetSegment(n,cn.RIGHT,this.distance,r);var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s);switch(this.bufParams.getEndCapStyle()){case Ki.CAP_ROUND:this.segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,he.CLOCKWISE,this.distance),this.segList.addPt(r.p1);break;case Ki.CAP_FLAT:this.segList.addPt(i.p1),this.segList.addPt(r.p1);break;case Ki.CAP_SQUARE:var u=new g;u.x=Math.abs(this.distance)*Math.cos(a),u.y=Math.abs(this.distance)*Math.sin(a);var l=new g(i.p1.x+u.x,i.p1.y+u.y),h=new g(r.p1.x+u.x,r.p1.y+u.y);this.segList.addPt(l),this.segList.addPt(h)}},getCoordinates:function(){var t=this.segList.getCoordinates();return t},addMitreJoin:function(t,e,n,i){var r=!0,s=null;try{s=F.intersection(e.p0,e.p1,n.p0,n.p1);var o=i<=0?1:s.distance(t)/Math.abs(i);o>this.bufParams.getMitreLimit()&&(r=!1)}catch(t){if(!(t instanceof w))throw t;s=new g(0,0),r=!1}finally{}r?this.segList.addPt(s):this.addLimitedMitreJoin(e,n,i,this.bufParams.getMitreLimit())},addFilletCorner:function(t,e,n,i,r){var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);i===he.CLOCKWISE?a<=h&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this.segList.addPt(e),this.addFilletArc(t,a,h,i,r),this.segList.addPt(n)},addOutsideTurn:function(t,e){return this.offset0.p1.distance(this.offset1.p0)<this.distance*er.OFFSET_SEGMENT_SEPARATION_FACTOR?(this.segList.addPt(this.offset0.p1),null):void(this.bufParams.getJoinStyle()===Ki.JOIN_MITRE?this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance):this.bufParams.getJoinStyle()===Ki.JOIN_BEVEL?this.addBevelJoin(this.offset0,this.offset1):(e&&this.segList.addPt(this.offset0.p1),this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,t,this.distance),this.segList.addPt(this.offset1.p0)))},createSquare:function(t){this.segList.addPt(new g(t.x+this.distance,t.y+this.distance)),this.segList.addPt(new g(t.x+this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y+this.distance)),this.segList.closeRing()},addSegments:function(t,e){this.segList.addPts(t,e)},addFirstSegment:function(){this.segList.addPt(this.offset1.p0)},addLastSegment:function(){this.segList.addPt(this.offset1.p1)},initSideSegments:function(t,e,n){this.s1=t,this.s2=e,this.side=n,this.seg1.setCoordinates(t,e),this.computeOffsetSegment(this.seg1,n,this.distance,this.offset1);
},addLimitedMitreJoin:function(t,e,n,i){var r=this.seg0.p1,s=Ci.angle(r,this.seg0.p0),o=(Ci.angle(r,this.seg1.p1),Ci.angleBetweenOriented(this.seg0.p0,r,this.seg1.p1)),a=o/2,u=Ci.normalize(s+a),l=Ci.normalize(u+Math.PI),h=i*n,c=h*Math.abs(Math.sin(a)),f=n-c,d=r.x+h*Math.cos(l),p=r.y+h*Math.sin(l),v=new g(d,p),m=new ce(r,v),y=m.pointAlongOffset(1,f),x=m.pointAlongOffset(1,-f);this.side===cn.LEFT?(this.segList.addPt(y),this.segList.addPt(x)):(this.segList.addPt(x),this.segList.addPt(y))},computeOffsetSegment:function(t,e,n,i){var r=e===cn.LEFT?1:-1,s=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,a=Math.sqrt(s*s+o*o),u=r*n*s/a,l=r*n*o/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},addFilletArc:function(t,e,n,i,r){var s=i===he.CLOCKWISE?-1:1,o=Math.abs(e-n),a=Math.trunc(o/this.filletAngleQuantum+.5);if(a<1)return null;var u=null,l=null;u=0,l=o/a;for(var h=u,c=new g;h<o;){var f=e+s*h;c.x=t.x+r*Math.cos(f),c.y=t.y+r*Math.sin(f),this.segList.addPt(c),h+=l}},addInsideTurn:function(t,e){if(this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1),this.li.hasIntersection())this.segList.addPt(this.li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this.offset0.p1.distance(this.offset1.p0)<this.distance*er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this.segList.addPt(this.offset0.p1);else{if(this.segList.addPt(this.offset0.p1),this.closingSegLengthFactor>0){var n=new g((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(n);var i=new g((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(i)}else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0)}},createCircle:function(t){var e=new g(t.x+this.distance,t.y);this.segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this.distance),this.segList.closeRing()},addBevelJoin:function(t,e){this.segList.addPt(t.p1),this.segList.addPt(e.p0)},init:function(t){this.distance=t,this.maxCurveSegmentError=t*(1-Math.cos(this.filletAngleQuantum/2)),this.segList=new tr,this.segList.setPrecisionModel(this.precisionModel),this.segList.setMinimumVertexDistance(t*er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},addCollinear:function(t){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var e=this.li.getIntersectionNum();e>=2&&(this.bufParams.getJoinStyle()===Ki.JOIN_BEVEL||this.bufParams.getJoinStyle()===Ki.JOIN_MITRE?(t&&this.segList.addPt(this.offset0.p1),this.segList.addPt(this.offset1.p0)):this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,he.CLOCKWISE,this.distance))},closeRing:function(){this.segList.closeRing()},hasNarrowConcaveAngle:function(){return this._hasNarrowConcaveAngle},interfaces_:function(){return[]},getClass:function(){return er}}),er.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,er.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,er.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,er.MAX_CLOSING_SEG_LEN_FACTOR=80,e(nr.prototype,{getOffsetCurve:function(t,e){if(this.distance=e,0===e)return null;var n=e<0,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var s=r.getCoordinates();return n&&H.reverse(s),s},computeSingleSidedBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){n.addSegments(t,!0);var r=$i.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{n.addSegments(t,!1);var a=$i.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;o<=u;o++)n.addNextSegment(a[o],!0)}n.addLastSegment(),n.closeRing()},computeRingBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);e===cn.RIGHT&&(i=-i);var r=$i.simplify(t,i),s=r.length-1;n.initSideSegments(r[s-1],r[0],e);for(var o=1;o<=s;o++){var a=1!==o;n.addNextSegment(r[o],a)}n.closeRing()},computeLineBufferCurve:function(t,e){var n=this.simplifyTolerance(this.distance),i=$i.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],cn.LEFT);for(var s=2;s<=r;s++)e.addNextSegment(i[s],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var o=$i.simplify(t,-n),a=o.length-1;e.initSideSegments(o[a],o[a-1],cn.LEFT);for(var s=a-2;s>=0;s--)e.addNextSegment(o[s],!0);e.addLastSegment(),e.addLineEndCap(o[1],o[0]),e.closeRing()},computePointCurve:function(t,e){switch(this.bufParams.getEndCapStyle()){case Ki.CAP_ROUND:e.createCircle(t);break;case Ki.CAP_SQUARE:e.createSquare(t)}},getLineCurve:function(t,e){if(this.distance=e,e<0&&!this.bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this.bufParams.isSingleSided()){var r=e<0;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);var s=i.getCoordinates();return s},getBufferParameters:function(){return this.bufParams},simplifyTolerance:function(t){return t*this.bufParams.getSimplifyFactor()},getRingCurve:function(t,e,n){if(this.distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return nr.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},computeOffsetCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){var r=$i.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{var a=$i.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;o<=u;o++)n.addNextSegment(a[o],!0)}n.addLastSegment()},getSegGen:function(t){return new er(this.precisionModel,this.bufParams,t)},interfaces_:function(){return[]},getClass:function(){return nr}}),nr.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new g(t[n]);return e},e(ir.prototype,{findStabbedSegments:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=this.subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(R(arguments[2],y)&&arguments[0]instanceof g&&arguments[1]instanceof In)for(var s=arguments[0],o=arguments[1],a=arguments[2],u=o.getEdge().getCoordinates(),n=0;n<u.length-1;n++){this.seg.p0=u[n],this.seg.p1=u[n+1],this.seg.p0.y>this.seg.p1.y&&this.seg.reverse();var l=Math.max(this.seg.p0.x,this.seg.p1.x);if(!(l<s.x||this.seg.isHorizontal()||s.y<this.seg.p0.y||s.y>this.seg.p1.y||he.computeOrientation(this.seg.p0,this.seg.p1,s)===he.RIGHT)){var h=o.getDepth(cn.LEFT);this.seg.p0.equals(u[n])||(h=o.getDepth(cn.RIGHT));var c=new rr(this.seg,h);a.add(c)}}else if(R(arguments[2],y)&&arguments[0]instanceof g&&R(arguments[1],y))for(var f=arguments[0],d=arguments[1],p=arguments[2],n=d.iterator();n.hasNext();){var v=n.next();v.isForward()&&this.findStabbedSegments(f,v,p)}},getDepth:function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;var n=ho.min(e);return n.leftDepth},interfaces_:function(){return[]},getClass:function(){return ir}}),e(rr.prototype,{compareTo:function(t){var e=t;if(this.upwardSeg.minX()>=e.upwardSeg.maxX())return 1;if(this.upwardSeg.maxX()<=e.upwardSeg.minX())return-1;var n=this.upwardSeg.orientationIndex(e.upwardSeg);return 0!==n?n:(n=-1*e.upwardSeg.orientationIndex(this.upwardSeg),0!==n?n:this.upwardSeg.compareTo(e.upwardSeg))},compareX:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},toString:function(){return this.upwardSeg.toString()},interfaces_:function(){return[s]},getClass:function(){return rr}}),ir.DepthSegment=rr,e(sr.prototype,{addPoint:function(t){if(this.distance<=0)return null;var e=t.getCoordinates(),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addPolygon:function(t){var e=this.distance,n=cn.LEFT;this.distance<0&&(e=-this.distance,n=cn.RIGHT);var i=t.getExteriorRing(),r=H.removeRepeatedPoints(i.getCoordinates());if(this.distance<0&&this.isErodedCompletely(i,this.distance))return null;if(this.distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,L.EXTERIOR,L.INTERIOR);for(var s=0;s<t.getNumInteriorRing();s++){var o=t.getInteriorRingN(s),a=H.removeRepeatedPoints(o.getCoordinates());this.distance>0&&this.isErodedCompletely(o,-this.distance)||this.addPolygonRing(a,e,cn.opposite(n),L.INTERIOR,L.EXTERIOR)}},isTriangleErodedCompletely:function(t,e){var n=new Si(t[0],t[1],t[2]),i=n.inCentre(),r=he.distancePointLine(i,n.p0,n.p1);return r<Math.abs(e)},addLineString:function(t){if(this.distance<=0&&!this.curveBuilder.getBufferParameters().isSingleSided())return null;var e=H.removeRepeatedPoints(t.getCoordinates()),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addCurve:function(t,e,n){if(null===t||t.length<2)return null;var i=new Ke(t,new gn(0,L.BOUNDARY,e,n));this.curveList.add(i)},getCurves:function(){return this.add(this.inputGeom),this.curveList},addPolygonRing:function(t,e,n,i,r){if(0===e&&t.length<bt.MINIMUM_VALID_SIZE)return null;var s=i,o=r;t.length>=bt.MINIMUM_VALID_SIZE&&he.isCCW(t)&&(s=r,o=i,n=cn.opposite(n));var a=this.curveBuilder.getRingCurve(t,n,e);this.addCurve(a,s,o)},add:function(t){if(t.isEmpty())return null;if(t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},isErodedCompletely:function(t,e){var n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return e<0&&2*Math.abs(e)>r},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},interfaces_:function(){return[]},getClass:function(){return sr}}),e(or.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(or.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},hasProperInteriorIntersection:function(){return this.hasProperInterior},getLineIntersector:function(){return this.li},hasProperIntersection:function(){return this.hasProper},processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.numIntersections++,this.li.isInteriorIntersection()&&(this.numInteriorIntersections++,this.hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1),this.li.isProper()&&(this.numProperIntersections++,this.hasProper=!0,this.hasProperInterior=!0)))},hasIntersection:function(){return this._hasIntersection},isDone:function(){return!1},hasInteriorIntersection:function(){return this.hasInterior},interfaces_:function(){return[on]},getClass:function(){return or}}),or.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},e(ar.prototype,{setWorkingPrecisionModel:function(t){this.workingPrecisionModel=t},insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip()),n.merge(i);var r=ar.depthDelta(i),s=e.getDepthDelta(),o=s+r;e.setDepthDelta(o)}else this.edgeList.add(t),t.setDepthDelta(ar.depthDelta(t.getLabel()))},buildSubgraphs:function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next(),s=r.getRightmostCoordinate(),o=new ir(n),a=o.getDepth(s);r.computeDepth(a),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},createSubgraphs:function(t){for(var e=new I,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new Ji;r.create(i),e.add(r)}}return ho.sort(e,ho.reverseOrder()),e},createEmptyResultGeometry:function(){var t=this.geomFact.createPolygon();return t},getNoder:function(t){if(null!==this.workingNoder)return this.workingNoder;var e=new nn,n=new ae;return n.setPrecisionModel(t),e.setSegmentIntersector(new or(n)),e},buffer:function(t,e){var n=this.workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this.geomFact=t.getFactory();var i=new nr(n,this.bufParams),r=new sr(t,e,i),s=r.getCurves();if(s.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(s,n),this.graph=new Cn(new On),this.graph.addEdges(this.edgeList.getEdges());var o=this.createSubgraphs(this.graph),a=new Sn(this.geomFact);this.buildSubgraphs(o,a);var u=a.getPolygons();if(u.size()<=0)return this.createEmptyResultGeometry();var l=this.geomFact.buildGeometry(u);return l},computeNodedEdges:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings(),r=i.iterator();r.hasNext();){var s=r.next(),o=s.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var a=s.getData(),u=new Jn(s.getCoordinates(),new gn(a));this.insertUniqueEdge(u)}}},setNoder:function(t){this.workingNoder=t},interfaces_:function(){return[]},getClass:function(){return ar}}),ar.depthDelta=function(t){var e=t.getLocation(0,cn.LEFT),n=t.getLocation(0,cn.RIGHT);return e===L.INTERIOR&&n===L.EXTERIOR?1:e===L.EXTERIOR&&n===L.INTERIOR?-1:0},ar.convertSegStrings=function(t){for(var e=new ie,n=new I;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)},e(ur.prototype,{checkEndPtVertexIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next(),n=e.getCoordinates();this.checkEndPtVertexIntersections(n[0],this.segStrings),this.checkEndPtVertexIntersections(n[n.length-1],this.segStrings)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],t=r.iterator();t.hasNext();)for(var e=t.next(),n=e.getCoordinates(),s=1;s<n.length-1;s++)if(n[s].equals(i))throw new l("found endpt/interior pt intersection at index "+s+" :pt "+i)},checkInteriorIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this.segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],s=arguments[1],o=r.getCoordinates(),a=s.getCoordinates(),u=0;u<o.length-1;u++)for(var h=0;h<a.length-1;h++)this.checkInteriorIntersections(r,u,s,h);else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3];if(c===g&&f===d)return null;var p=c.getCoordinates()[f],v=c.getCoordinates()[f+1],m=g.getCoordinates()[d],y=g.getCoordinates()[d+1];if(this.li.computeIntersection(p,v,m,y),this.li.hasIntersection()&&(this.li.isProper()||this.hasInteriorIntersection(this.li,p,v)||this.hasInteriorIntersection(this.li,m,y)))throw new l("found non-noded intersection at "+p+"-"+v+" and "+m+"-"+y)}},checkValid:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},checkCollapses:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0],i=n.getCoordinates(),t=0;t<i.length-2;t++)this.checkCollapse(i[t],i[t+1],i[t+2])},hasInteriorIntersection:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},checkCollapse:function(t,e,n){if(t.equals(n))throw new l("found non-noded collapse at "+ur.fact.createLineString([t,e,n]))},interfaces_:function(){return[]},getClass:function(){return ur}}),ur.fact=new ie,e(lr.prototype,{intersectsScaled:function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),s=Math.max(t.y,e.y),o=this.maxx<n||this.minx>i||this.maxy<r||this.miny>s;if(o)return!1;var a=this.intersectsToleranceSquare(t,e);return f.isTrue(!(o&&a),"Found bad envelope test"),a},initCorners:function(t){var e=.5;this.minx=t.x-e,this.maxx=t.x+e,this.miny=t.y-e,this.maxy=t.y+e,this.corner[0]=new g(this.maxx,this.maxy),this.corner[1]=new g(this.minx,this.maxy),this.corner[2]=new g(this.minx,this.miny),this.corner[3]=new g(this.maxx,this.miny)},intersects:function(t,e){return 1===this.scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this.p0Scaled),this.copyScaled(e,this.p1Scaled),this.intersectsScaled(this.p0Scaled,this.p1Scaled))},scale:function(t){return Math.round(t*this.scaleFactor)},getCoordinate:function(){return this.originalPt},copyScaled:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},getSafeEnvelope:function(){if(null===this.safeEnv){var t=lr.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new C(this.originalPt.x-t,this.originalPt.x+t,this.originalPt.y-t,this.originalPt.y+t)}return this.safeEnv},intersectsPixelClosure:function(t,e){return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),!!this.li.hasIntersection()||(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),!!this.li.hasIntersection()||(this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),!!this.li.hasIntersection()||(this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.hasIntersection())))},intersectsToleranceSquare:function(t,e){var n=!1,i=!1;return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),!!this.li.isProper()||(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),!!this.li.isProper()||(this.li.hasIntersection()&&(n=!0),this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),!!this.li.isProper()||(this.li.hasIntersection()&&(i=!0),this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.isProper()||(!(!n||!i)||(!!t.equals(this.pt)||!!e.equals(this.pt))))))},addSnappedNode:function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return!!this.intersects(n,i)&&(t.addIntersection(this.getCoordinate(),e),!0)},interfaces_:function(){return[]},getClass:function(){return lr}}),lr.SAFE_ENV_EXPANSION_FACTOR=.75,e(hr.prototype,{snap:function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),s=new cr(e,n,i);return this.index.query(r,{interfaces_:function(){return[Ae]},visitItem:function(t){var e=t;e.select(r,s)}}),s.isNodeAdded()}},interfaces_:function(){return[]},getClass:function(){return hr}}),h(cr,hi),e(cr.prototype,{isNodeAdded:function(){return this._isNodeAdded},select:function(){if(2!==arguments.length)return hi.prototype.select.apply(this,arguments);var t=arguments[0],e=arguments[1],n=t.getContext();return null!==this.parentEdge&&n===this.parentEdge&&e===this.hotPixelVertexIndex?null:void(this._isNodeAdded=this.hotPixel.addSnappedNode(n,e))},interfaces_:function(){return[]},getClass:function(){return cr}}),hr.HotPixelSnapAction=cr,e(fr.prototype,{processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&this.li.isInteriorIntersection()){for(var u=0;u<this.li.getIntersectionNum();u++)this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)}},isDone:function(){return!1},getInteriorIntersections:function(){return this.interiorIntersections},interfaces_:function(){return[on]},getClass:function(){return fr}}),e(gr.prototype,{checkCorrectness:function(t){var e=Ke.getNodedSubstrings(t),n=new ur(e);try{n.checkValid()}catch(t){if(!(t instanceof S))throw t;t.printStackTrace()}finally{}},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},snapRound:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},findInteriorIntersections:function(t,e){var n=new fr(e);return this.noder.setSegmentIntersector(n),this.noder.computeNodes(t),n.getInteriorIntersections()},computeVertexSnaps:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.computeVertexSnaps(n)}else if(arguments[0]instanceof Ke)for(var i=arguments[0],r=i.getCoordinates(),s=0;s<r.length;s++){var o=new lr(r[s],this.scaleFactor,this.li),a=this.pointSnapper.snap(o,i,s);a&&i.addIntersection(r[s],s)}},computeNodes:function(t){this.nodedSegStrings=t,this.noder=new nn,this.pointSnapper=new hr(this.noder.getIndex()),this.snapRound(t,this.li)},computeIntersectionSnaps:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new lr(n,this.scaleFactor,this.li);this.pointSnapper.snap(i)}},interfaces_:function(){return[tn]},getClass:function(){return gr}}),e(dr.prototype,{bufferFixedPrecision:function(t){var e=new Hi(new gr(new ee(1)),t.getScale()),n=new ar(this.bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this.resultGeometry=n.buffer(this.argGeom,this.distance)},bufferReducedPrecision:function(){if(0===arguments.length){for(var t=dr.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof sn))throw t;this.saveException=t}finally{}if(null!==this.resultGeometry)return null}throw this.saveException}if(1===arguments.length){var e=arguments[0],n=dr.precisionScaleFactor(this.argGeom,this.distance,e),i=new ee(n);this.bufferFixedPrecision(i)}},computeGeometry:function(){if(this.bufferOriginalPrecision(),null!==this.resultGeometry)return null;var t=this.argGeom.getFactory().getPrecisionModel();t.getType()===ee.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},setQuadrantSegments:function(t){this.bufParams.setQuadrantSegments(t)},bufferOriginalPrecision:function(){try{var t=new ar(this.bufParams);this.resultGeometry=t.buffer(this.argGeom,this.distance)}catch(t){if(!(t instanceof l))throw t;this.saveException=t}finally{}},getResultGeometry:function(t){return this.distance=t,this.computeGeometry(),this.resultGeometry},setEndCapStyle:function(t){this.bufParams.setEndCapStyle(t)},interfaces_:function(){return[]},getClass:function(){return dr}}),dr.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new dr(t),i=n.getResultGeometry(e);return i}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var r=arguments[0],s=arguments[1],o=arguments[2],a=new dr(r);a.setQuadrantSegments(o);var i=a.getResultGeometry(s);return i}if(arguments[2]instanceof Ki&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2],a=new dr(u,h),i=a.getResultGeometry(l);return i}}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3],a=new dr(c);a.setQuadrantSegments(g),a.setEndCapStyle(d);var i=a.getResultGeometry(f);return i}},dr.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=T.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY())),s=e>0?e:0,o=r+2*s,a=Math.trunc(Math.log(o)/Math.log(10)+1),u=n-a,l=Math.pow(10,u);return l},dr.CAP_ROUND=Ki.CAP_ROUND,dr.CAP_BUTT=Ki.CAP_FLAT,dr.CAP_FLAT=Ki.CAP_FLAT,dr.CAP_SQUARE=Ki.CAP_SQUARE,dr.MAX_PRECISION_DIGITS=12;var So=Object.freeze({BufferOp:dr,BufferParameters:Ki});e(pr.prototype,{filter:function(t){t instanceof Tt&&this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return pr}}),pr.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return pr.getPolygons(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Tt?n.add(e):e instanceof ft&&e.apply(new pr(n)),n}},e(vr.prototype,{isInsideArea:function(){return this.segIndex===vr.INSIDE_AREA},getCoordinate:function(){return this.pt},getGeometryComponent:function(){return this.component},getSegmentIndex:function(){return this.segIndex},interfaces_:function(){return[]},getClass:function(){return vr}}),vr.INSIDE_AREA=-1,e(mr.prototype,{filter:function(t){t instanceof Lt&&this.pts.add(t)},interfaces_:function(){return[ht]},getClass:function(){return mr}}),mr.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Lt?ho.singletonList(t):mr.getPoints(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Lt?n.add(e):e instanceof ft&&e.apply(new mr(n)),n}},e(yr.prototype,{filter:function(t){(t instanceof Lt||t instanceof St||t instanceof Tt)&&this.locations.add(new vr(t,0,t.getCoordinate()))},interfaces_:function(){return[ht]},getClass:function(){return yr}}),yr.getLocations=function(t){var e=new I;return t.apply(new yr(e)),e},e(xr.prototype,{computeContainmentDistance:function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this.minDistance<=this.terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=pr.getPolygons(this.geom[e]);if(r.size()>0){var s=yr.getLocations(this.geom[i]);if(this.computeContainmentDistance(s,r,n),this.minDistance<=this.terminateDistance)return this.minDistanceLocation[i]=n[0],this.minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&R(arguments[0],y)&&R(arguments[1],y)){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=0;l<o.size();l++)for(var h=o.get(l),c=0;c<a.size();c++)if(this.computeContainmentDistance(h,a.get(c),u),this.minDistance<=this.terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof vr&&arguments[1]instanceof Tt){var f=arguments[0],g=arguments[1],d=arguments[2],p=f.getCoordinate();if(L.EXTERIOR!==this.ptLocator.locate(p,g))return this.minDistance=0,d[0]=f,d[1]=new vr(g,p),null}},computeMinDistanceLinesPoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},computeFacetDistance:function(){var t=new Array(2).fill(null),e=kn.getLines(this.geom[0]),n=kn.getLines(this.geom[1]),i=mr.getPoints(this.geom[0]),r=mr.getPoints(this.geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},nearestLocations:function(){return this.computeMinDistance(),this.minDistanceLocation},updateMinDistance:function(t,e){return null===t[0]?null:void(e?(this.minDistanceLocation[0]=t[1],this.minDistanceLocation[1]=t[0]):(this.minDistanceLocation[0]=t[0],this.minDistanceLocation[1]=t[1]))},nearestPoints:function(){this.computeMinDistance();var t=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return t},computeMinDistance:function(){if(0===arguments.length){if(null!==this.minDistanceLocation)return null;if(this.minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this.minDistance<=this.terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof Lt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this.minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),s=0;s<i.length-1;s++){var o=he.distancePointLine(r,i[s],i[s+1]);if(o<this.minDistance){this.minDistance=o;var a=new ce(i[s],i[s+1]),u=a.closestPoint(r);n[0]=new vr(t,s,u),n[1]=new vr(e,0,r)}if(this.minDistance<=this.terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof St){var l=arguments[0],h=arguments[1],c=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this.minDistance)return null;for(var i=l.getCoordinates(),f=h.getCoordinates(),s=0;s<i.length-1;s++)for(var g=0;g<f.length-1;g++){var o=he.distanceLineLine(i[s],i[s+1],f[g],f[g+1]);if(o<this.minDistance){this.minDistance=o;var d=new ce(i[s],i[s+1]),p=new ce(f[g],f[g+1]),v=d.closestPoints(p);c[0]=new vr(l,s,v[0]),c[1]=new vr(h,g,v[1])}if(this.minDistance<=this.terminateDistance)return null}}},computeMinDistancePoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s),a=r.getCoordinate().distance(o.getCoordinate());if(a<this.minDistance&&(this.minDistance=a,n[0]=new vr(r,0,r.getCoordinate()),n[1]=new vr(o,0,o.getCoordinate())),this.minDistance<=this.terminateDistance)return null}},distance:function(){if(null===this.geom[0]||null===this.geom[1])throw new i("null geometries are not supported");return this.geom[0].isEmpty()||this.geom[1].isEmpty()?0:(this.computeMinDistance(),this.minDistance)},computeMinDistanceLines:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},interfaces_:function(){return[]},getClass:function(){return xr}}),xr.distance=function(t,e){var n=new xr(t,e);return n.distance()},xr.isWithinDistance=function(t,e,n){var i=new xr(t,e,n);return i.distance()<=n},xr.nearestPoints=function(t,e){var n=new xr(t,e);return n.nearestPoints()};var wo=Object.freeze({DistanceOp:xr});e(Er.prototype,{getCoordinates:function(){if(null===this.coordinates){for(var t=0,e=0,n=new N,i=this.directedEdges.iterator();i.hasNext();){var r=i.next();r.getEdgeDirection()?t++:e++,n.add(r.getEdge().getLine().getCoordinates(),!1,r.getEdgeDirection())}this.coordinates=n.toCoordinateArray(),e>t&&H.reverse(this.coordinates)}return this.coordinates},toLineString:function(){return this.factory.createLineString(this.getCoordinates())},add:function(t){this.directedEdges.add(t)},interfaces_:function(){return[]},getClass:function(){return Er}}),e(Ir.prototype,{setVisited:function(t){this._isVisited=t},isMarked:function(){return this._isMarked},setData:function(t){this.data=t},getData:function(){return this.data},setMarked:function(t){this._isMarked=t},getContext:function(){return this.data},isVisited:function(){return this._isVisited},setContext:function(t){this.data=t},interfaces_:function(){return[]},getClass:function(){return Ir}}),Ir.getComponentWithVisitedState=function(t,e){for(;t.hasNext();){var n=t.next();if(n.isVisited()===e)return n}return null},Ir.setVisited=function(t,e){for(;t.hasNext();){var n=t.next();n.setVisited(e)}},Ir.setMarked=function(t,e){for(;t.hasNext();){var n=t.next();n.setMarked(e)}},h(Nr,Ir),e(Nr.prototype,{isRemoved:function(){return null===this.parentEdge},compareDirection:function(t){return this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getCoordinate:function(){return this.from.getCoordinate()},print:function(t){var e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);t.print("  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+this.angle)},getDirectionPt:function(){return this.p1},getAngle:function(){return this.angle},compareTo:function(t){var e=t;return this.compareDirection(e)},getFromNode:function(){return this.from},getSym:function(){return this.sym;
},setEdge:function(t){this.parentEdge=t},remove:function(){this.sym=null,this.parentEdge=null},getEdge:function(){return this.parentEdge},getQuadrant:function(){return this.quadrant},setSym:function(t){this.sym=t},getToNode:function(){return this.to},getEdgeDirection:function(){return this.edgeDirection},interfaces_:function(){return[s]},getClass:function(){return Nr}}),Nr.toEdges=function(t){for(var e=new I,n=t.iterator();n.hasNext();)e.add(n.next().parentEdge);return e},h(Cr,Nr),e(Cr.prototype,{getNext:function(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(f.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))},interfaces_:function(){return[]},getClass:function(){return Cr}}),h(Sr,Ir),e(Sr.prototype,{isRemoved:function(){return null===this.dirEdge},setDirectedEdges:function(t,e){this.dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)},getDirEdge:function(){if(Number.isInteger(arguments[0])){var t=arguments[0];return this.dirEdge[t]}if(arguments[0]instanceof Lr){var e=arguments[0];return this.dirEdge[0].getFromNode()===e?this.dirEdge[0]:this.dirEdge[1].getFromNode()===e?this.dirEdge[1]:null}},remove:function(){this.dirEdge=null},getOppositeNode:function(t){return this.dirEdge[0].getFromNode()===t?this.dirEdge[0].getToNode():this.dirEdge[1].getFromNode()===t?this.dirEdge[1].getToNode():null},interfaces_:function(){return[]},getClass:function(){return Sr}}),e(wr.prototype,{getNextEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e+1))},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},iterator:function(){return this.sortEdges(),this.outEdges.iterator()},sortEdges:function(){this.sorted||(ho.sort(this.outEdges),this.sorted=!0)},remove:function(t){this.outEdges.remove(t)},getEdges:function(){return this.sortEdges(),this.outEdges},getNextCWEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e-1))},getIndex:function(){if(arguments[0]instanceof Sr){var t=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n.getEdge()===t)return e}return-1}if(arguments[0]instanceof Nr){var i=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n===i)return e}return-1}if(Number.isInteger(arguments[0])){var r=arguments[0],s=r%this.outEdges.size();return s<0&&(s+=this.outEdges.size()),s}},add:function(t){this.outEdges.add(t),this.sorted=!1},getDegree:function(){return this.outEdges.size()},interfaces_:function(){return[]},getClass:function(){return wr}}),h(Lr,Ir),e(Lr.prototype,{isRemoved:function(){return null===this.pt},addOutEdge:function(t){this.deStar.add(t)},getCoordinate:function(){return this.pt},getOutEdges:function(){return this.deStar},remove:function(){if(0===arguments.length)this.pt=null;else if(1===arguments.length){var t=arguments[0];this.deStar.remove(t)}},getIndex:function(t){return this.deStar.getIndex(t)},getDegree:function(){return this.deStar.getDegree()},interfaces_:function(){return[]},getClass:function(){return Lr}}),Lr.getEdgesBetween=function(t,e){var n=Nr.toEdges(t.getOutEdges().getEdges()),i=new J(n),r=Nr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r),i},h(Rr,Sr),e(Rr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Rr}}),e(Tr.prototype,{find:function(t){return this.nodeMap.get(t)},iterator:function(){return this.nodeMap.values().iterator()},remove:function(t){return this.nodeMap.remove(t)},values:function(){return this.nodeMap.values()},add:function(t){return this.nodeMap.put(t.getCoordinate(),t),t},interfaces_:function(){return[]},getClass:function(){return Tr}}),e(Pr.prototype,{findNodesOfDegree:function(t){for(var e=new I,n=this.nodeIterator();n.hasNext();){var i=n.next();i.getDegree()===t&&e.add(i)}return e},dirEdgeIterator:function(){return this.dirEdges.iterator()},edgeIterator:function(){return this.edges.iterator()},remove:function(){if(arguments[0]instanceof Sr){var t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this.edges.remove(t),t.remove()}else if(arguments[0]instanceof Nr){var e=arguments[0],n=e.getSym();null!==n&&n.setSym(null),e.getFromNode().remove(e),e.remove(),this.dirEdges.remove(e)}else if(arguments[0]instanceof Lr){for(var i=arguments[0],r=i.getOutEdges().getEdges(),s=r.iterator();s.hasNext();){var o=s.next(),n=o.getSym();null!==n&&this.remove(n),this.dirEdges.remove(o);var a=o.getEdge();null!==a&&this.edges.remove(a)}this.nodeMap.remove(i.getCoordinate()),i.remove()}},findNode:function(t){return this.nodeMap.find(t)},getEdges:function(){return this.edges},nodeIterator:function(){return this.nodeMap.iterator()},contains:function(){if(arguments[0]instanceof Sr){var t=arguments[0];return this.edges.contains(t)}if(arguments[0]instanceof Nr){var e=arguments[0];return this.dirEdges.contains(e)}},add:function(){if(arguments[0]instanceof Lr){var t=arguments[0];this.nodeMap.add(t)}else if(arguments[0]instanceof Sr){var e=arguments[0];this.edges.add(e),this.add(e.getDirEdge(0)),this.add(e.getDirEdge(1))}else if(arguments[0]instanceof Nr){var n=arguments[0];this.dirEdges.add(n)}},getNodes:function(){return this.nodeMap.values()},interfaces_:function(){return[]},getClass:function(){return Pr}}),h(br,Pr),e(br.prototype,{addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new Cr(r,s,e[1],(!0)),a=new Cr(s,r,e[e.length-2],(!1)),u=new Rr(t);u.setDirectedEdges(o,a),this.add(u)},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new Lr(t),this.add(e)),e},interfaces_:function(){return[]},getClass:function(){return br}}),e(Or.prototype,{buildEdgeStringsForUnprocessedNodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.isMarked()||(f.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForNonDegree2Nodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForObviousStartNodes:function(){this.buildEdgeStringsForNonDegree2Nodes()},getMergedLineStrings:function(){return this.merge(),this.mergedLineStrings},buildEdgeStringsStartingAt:function(t){for(var e=t.getOutEdges().iterator();e.hasNext();){var n=e.next();n.getEdge().isMarked()||this.edgeStrings.add(this.buildEdgeStringStartingWith(n))}},merge:function(){if(null!==this.mergedLineStrings)return null;Ir.setMarked(this.graph.nodeIterator(),!1),Ir.setMarked(this.graph.edgeIterator(),!1),this.edgeStrings=new I,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this.mergedLineStrings=new I;for(var t=this.edgeStrings.iterator();t.hasNext();){var e=t.next();this.mergedLineStrings.add(e.toLineString())}},buildEdgeStringStartingWith:function(t){var e=new Er(this.factory),n=t;do e.add(n),n.getEdge().setMarked(!0),n=n.getNext();while(null!==n&&n!==t);return e},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v)){var e=arguments[0];this.mergedLineStrings=null;for(var n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory()),this.graph.addEdge(r)}},buildEdgeStringsForIsolatedLoops:function(){this.buildEdgeStringsForUnprocessedNodes()},interfaces_:function(){return[]},getClass:function(){return Or}});var Lo=Object.freeze({LineMerger:Or}),Ro=Object.freeze({OverlayOp:ii});h(_r,Nr),e(_r.prototype,{getNext:function(){return this.next},isInRing:function(){return null!==this.edgeRing},setRing:function(t){this.edgeRing=t},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setNext:function(t){this.next=t},getRing:function(){return this.edgeRing},interfaces_:function(){return[]},getClass:function(){return _r}}),h(Mr,Sr),e(Mr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Mr}}),e(Dr.prototype,{visitInteriorRing:function(t,e){var n=t.getCoordinates(),i=n[0],r=Dr.findDifferentPoint(n,i),s=e.findEdgeInSameDirection(i,r),o=e.findEdgeEnd(s),a=null;o.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR?a=o:o.getSym().getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&(a=o.getSym()),f.isTrue(null!==a,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(a)},visitShellInteriors:function(t,e){if(t instanceof Tt){var n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof Ot)for(var i=t,r=0;r<i.getNumGeometries();r++){var n=i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(),e)}},getCoordinate:function(){return this.disconnectedRingcoord},setInteriorEdgesInResult:function(t){for(var e=t.getEdgeEnds().iterator();e.hasNext();){var n=e.next();n.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&n.setInResult(!0)}},visitLinkedDirectedEdges:function(t){var e=t,n=t;do f.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext();while(n!==e)},buildEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s=r.buildMinimalRings();e.addAll(s)}}return e},hasUnvisitedShellEdge:function(t){for(var e=0;e<t.size();e++){var n=t.get(e);if(!n.isHole()){var i=n.getEdges(),r=i.get(0);if(r.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR)for(var s=0;s<i.size();s++)if(r=i.get(s),!r.isVisited())return this.disconnectedRingcoord=r.getCoordinate(),!0}}return!1},isInteriorsConnected:function(){var t=new I;this.geomGraph.computeSplitEdges(t);var e=new Cn(new On);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();var n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)},interfaces_:function(){return[]},getClass:function(){return Dr}}),Dr.findDifferentPoint=function(t,e){for(var n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null},e(Ar.prototype,{createEdgeEndForNext:function(t,e,n,i){var r=n.segmentIndex+1;if(r>=t.getNumPoints()&&null===i)return null;var s=t.getCoordinate(r);null!==i&&i.segmentIndex===n.segmentIndex&&(s=i.coord);var o=new En(t,n.coord,s,new gn(t.getLabel()));e.add(o)},createEdgeEndForPrev:function(t,e,n,i){var r=n.segmentIndex;if(0===n.dist){if(0===r)return null;r--}var s=t.getCoordinate(r);null!==i&&i.segmentIndex>=r&&(s=i.coord);var o=new gn(t.getLabel());o.flip();var a=new En(t,n.coord,s,o);e.add(a)},computeEdgeEnds:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=t;n.hasNext();){var i=n.next();this.computeEdgeEnds(i,e)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1],o=r.getEdgeIntersectionList();o.addEndpoints();var a=o.iterator(),u=null,l=null;if(!a.hasNext())return null;var h=a.next();do u=l,l=h,h=null,a.hasNext()&&(h=a.next()),null!==l&&(this.createEdgeEndForPrev(r,s,l,u),this.createEdgeEndForNext(r,s,l,h));while(null!==l)}},interfaces_:function(){return[]},getClass:function(){return Ar}}),h(Fr,En),e(Fr.prototype,{insert:function(t){this.edgeEnds.add(t)},print:function(t){t.println("EdgeEndBundle--> Label: "+this.label);for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t),t.println()}},iterator:function(){return this.edgeEnds.iterator()},getEdgeEnds:function(){return this.edgeEnds},computeLabelOn:function(t,e){for(var n=0,i=!1,r=this.iterator();r.hasNext();){var s=r.next(),o=s.getLabel().getLocation(t);o===L.BOUNDARY&&n++,o===L.INTERIOR&&(i=!0)}var o=L.NONE;i&&(o=L.INTERIOR),n>0&&(o=$n.determineBoundary(e,n)),this.label.setLocation(t,o)},computeLabelSide:function(t,e){for(var n=this.iterator();n.hasNext();){var i=n.next();if(i.getLabel().isArea()){var r=i.getLabel().getLocation(t,e);if(r===L.INTERIOR)return this.label.setLocation(t,e,L.INTERIOR),null;r===L.EXTERIOR&&this.label.setLocation(t,e,L.EXTERIOR)}}},getLabel:function(){return this.label},computeLabelSides:function(t){this.computeLabelSide(t,cn.LEFT),this.computeLabelSide(t,cn.RIGHT)},updateIM:function(t){Jn.updateIM(this.label,t)},computeLabel:function(t){for(var e=!1,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().isArea()&&(e=!0)}e?this.label=new gn(L.NONE,L.NONE,L.NONE):this.label=new gn(L.NONE);for(var r=0;r<2;r++)this.computeLabelOn(r,t),e&&this.computeLabelSides(r)},interfaces_:function(){return[]},getClass:function(){return Fr}}),h(Gr,Pn),e(Gr.prototype,{updateIM:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}},insert:function(t){var e=this.edgeMap.get(t);null===e?(e=new Fr(t),this.insertEdgeEnd(t,e)):e.insert(t)},interfaces_:function(){return[]},getClass:function(){return Gr}}),h(qr,yn),e(qr.prototype,{updateIMFromEdges:function(t){this.edges.updateIM(t)},computeIM:function(t){t.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0)},interfaces_:function(){return[]},getClass:function(){return qr}}),h(Br,Nn),e(Br.prototype,{createNode:function(t){return new qr(t,new Gr)},interfaces_:function(){return[]},getClass:function(){return Br}}),e(zr.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},getNodeIterator:function(){return this.nodes.iterator()},copyNodesAndLabels:function(t,e){for(var n=t.getNodeIterator();n.hasNext();){var i=n.next(),r=this.nodes.addNode(i.getCoordinate());r.setLabel(e,i.getLabel().getLocation(e))}},build:function(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);var e=new Ar,n=e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n)},computeIntersectionNodes:function(t,e){for(var n=t.getEdgeIterator();n.hasNext();)for(var i=n.next(),r=i.getLabel().getLocation(e),s=i.getEdgeIntersectionList().iterator();s.hasNext();){var o=s.next(),a=this.nodes.addNode(o.coord);r===L.BOUNDARY?a.setLabelBoundary(e):a.getLabel().isNull(e)&&a.setLabel(e,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return zr}}),e(Vr.prototype,{isNodeEdgeAreaLabelsConsistent:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();){var e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this.geomGraph))return this.invalidPoint=e.getCoordinate().copy(),!1}return!0},getInvalidPoint:function(){return this.invalidPoint},hasDuplicateRings:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();)for(var e=t.next(),n=e.getEdges().iterator();n.hasNext();){var i=n.next();if(i.getEdgeEnds().size()>1)return this.invalidPoint=i.getEdge().getCoordinate(0),!0}return!1},isNodeConsistentArea:function(){var t=this.geomGraph.computeSelfNodes(this.li,!0,!0);return t.hasProperIntersection()?(this.invalidPoint=t.getProperIntersectionPoint(),!1):(this.nodeGraph.build(this.geomGraph),this.isNodeEdgeAreaLabelsConsistent())},interfaces_:function(){return[]},getClass:function(){return Vr}}),e(kr.prototype,{buildIndex:function(){this.index=new ke;for(var t=0;t<this.rings.size();t++){var e=this.rings.get(t),n=e.getEnvelopeInternal();this.index.insert(n,e)}},getNestedPoint:function(){return this.nestedPt},isNonNested:function(){this.buildIndex();for(var t=0;t<this.rings.size();t++)for(var e=this.rings.get(t),n=e.getCoordinates(),i=this.index.query(e.getEnvelopeInternal()),r=0;r<i.size();r++){var s=i.get(r),o=s.getCoordinates();if(e!==s&&e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())){var a=Ur.findPtNotNode(n,s,this.graph);if(null!==a){var u=he.isPointInRing(a,o);if(u)return this.nestedPt=a,!1}}}return!0},add:function(t){this.rings.add(t),this.totalEnv.expandToInclude(t.getEnvelopeInternal())},interfaces_:function(){return[]},getClass:function(){return kr}}),e(Yr.prototype,{getErrorType:function(){return this.errorType},getMessage:function(){return Yr.errMsg[this.errorType]},getCoordinate:function(){return this.pt},toString:function(){var t="";return null!==this.pt&&(t=" at or near point "+this.pt),this.getMessage()+t},interfaces_:function(){return[]},getClass:function(){return Yr}}),Yr.ERROR=0,Yr.REPEATED_POINT=1,Yr.HOLE_OUTSIDE_SHELL=2,Yr.NESTED_HOLES=3,Yr.DISCONNECTED_INTERIOR=4,Yr.SELF_INTERSECTION=5,Yr.RING_SELF_INTERSECTION=6,Yr.NESTED_SHELLS=7,Yr.DUPLICATE_RINGS=8,Yr.TOO_FEW_POINTS=9,Yr.INVALID_COORDINATE=10,Yr.RING_NOT_CLOSED=11,Yr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"],e(Ur.prototype,{checkInvalidCoordinates:function(){if(arguments[0]instanceof Array){for(var t=arguments[0],e=0;e<t.length;e++)if(!Ur.isValid(t[e]))return this.validErr=new Yr(Yr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof Tt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),null!==this.validErr)return null;for(var e=0;e<n.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),null!==this.validErr)return null}},checkHolesNotNested:function(t,e){for(var n=new kr(e),i=0;i<t.getNumInteriorRing();i++){var r=t.getInteriorRingN(i);n.add(r)}var s=n.isNonNested();s||(this.validErr=new Yr(Yr.NESTED_HOLES,n.getNestedPoint()))},checkConsistentArea:function(t){var e=new Vr(t),n=e.isNodeConsistentArea();return n?void(e.hasDuplicateRings()&&(this.validErr=new Yr(Yr.DUPLICATE_RINGS,e.getInvalidPoint()))):(this.validErr=new Yr(Yr.SELF_INTERSECTION,e.getInvalidPoint()),null)},isValid:function(){return this.checkValid(this.parentGeometry),null===this.validErr},checkShellInsideHole:function(t,e,n){var i=t.getCoordinates(),r=e.getCoordinates(),s=Ur.findPtNotNode(i,e,n);if(null!==s){var o=he.isPointInRing(s,r);if(!o)return s}var a=Ur.findPtNotNode(r,t,n);if(null!==a){var u=he.isPointInRing(a,i);return u?a:null}return f.shouldNeverReachHere("points in shell and hole appear to be equal"),null},checkNoSelfIntersectingRings:function(t){for(var e=t.getEdgeIterator();e.hasNext();){var n=e.next();if(this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),null!==this.validErr)return null}},checkConnectedInteriors:function(t){var e=new Dr(t);e.isInteriorsConnected()||(this.validErr=new Yr(Yr.DISCONNECTED_INTERIOR,e.getCoordinate()))},checkNoSelfIntersectingRing:function(t){for(var e=new at,n=!0,i=t.iterator();i.hasNext();){var r=i.next();if(n)n=!1;else{if(e.contains(r.coord))return this.validErr=new Yr(Yr.RING_SELF_INTERSECTION,r.coord),null;e.add(r.coord)}}},checkHolesInShell:function(t,e){for(var n=t.getExteriorRing(),i=new Ii(n),r=0;r<t.getNumInteriorRing();r++){var s=t.getInteriorRingN(r),o=Ur.findPtNotNode(s.getCoordinates(),n,e);if(null===o)return null;var a=!i.isInside(o);if(a)return this.validErr=new Yr(Yr.HOLE_OUTSIDE_SHELL,o),null}},checkTooFewPoints:function(t){if(t.hasTooFewPoints())return this.validErr=new Yr(Yr.TOO_FEW_POINTS,t.getInvalidPoint()),null},getValidationError:function(){return this.checkValid(this.parentGeometry),this.validErr},checkValid:function(){if(arguments[0]instanceof Lt){var t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Pt){var e=arguments[0];this.checkInvalidCoordinates(e.getCoordinates())}else if(arguments[0]instanceof bt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getCoordinates()),null!==this.validErr)return null;if(this.checkClosedRing(n),null!==this.validErr)return null;var i=new $n(0,n);if(this.checkTooFewPoints(i),null!==this.validErr)return null;var r=new ae;i.computeSelfNodes(r,!0,!0),this.checkNoSelfIntersectingRings(i)}else if(arguments[0]instanceof St){var s=arguments[0];if(this.checkInvalidCoordinates(s.getCoordinates()),null!==this.validErr)return null;var i=new $n(0,s);this.checkTooFewPoints(i)}else if(arguments[0]instanceof Tt){var o=arguments[0];if(this.checkInvalidCoordinates(o),null!==this.validErr)return null;if(this.checkClosedRings(o),null!==this.validErr)return null;var i=new $n(0,o);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;if(this.checkHolesInShell(o,i),null!==this.validErr)return null;if(this.checkHolesNotNested(o,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof Ot){for(var a=arguments[0],u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkInvalidCoordinates(l),null!==this.validErr)return null;if(this.checkClosedRings(l),null!==this.validErr)return null}var i=new $n(0,a);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesInShell(l,i),null!==this.validErr)return null}for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesNotNested(l,i),null!==this.validErr)return null}if(this.checkShellsNotNested(a,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof ft)for(var h=arguments[0],u=0;u<h.getNumGeometries();u++){var c=h.getGeometryN(u);if(this.checkValid(c),null!==this.validErr)return null}else if(arguments[0]instanceof B){var f=arguments[0];if(this.validErr=null,f.isEmpty())return null;if(f instanceof Lt)this.checkValid(f);else if(f instanceof Pt)this.checkValid(f);else if(f instanceof bt)this.checkValid(f);else if(f instanceof St)this.checkValid(f);else if(f instanceof Tt)this.checkValid(f);else if(f instanceof Ot)this.checkValid(f);else{if(!(f instanceof ft))throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f)}}},setSelfTouchingRingFormingHoleValid:function(t){this.isSelfTouchingRingFormingHoleValid=t},checkShellNotNested:function(t,e,n){var i=t.getCoordinates(),r=e.getExteriorRing(),s=r.getCoordinates(),o=Ur.findPtNotNode(i,r,n);if(null===o)return null;var a=he.isPointInRing(o,s);if(!a)return null;if(e.getNumInteriorRing()<=0)return this.validErr=new Yr(Yr.NESTED_SHELLS,o),null;for(var u=null,l=0;l<e.getNumInteriorRing();l++){var h=e.getInteriorRingN(l);if(u=this.checkShellInsideHole(t,h,n),null===u)return null}this.validErr=new Yr(Yr.NESTED_SHELLS,u)},checkClosedRings:function(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.validErr)return null;for(var e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this.validErr)return null},checkClosedRing:function(t){if(!t.isClosed()){var e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this.validErr=new Yr(Yr.RING_NOT_CLOSED,e)}},checkShellsNotNested:function(t,e){for(var n=0;n<t.getNumGeometries();n++)for(var i=t.getGeometryN(n),r=i.getExteriorRing(),s=0;s<t.getNumGeometries();s++)if(n!==s){var o=t.getGeometryN(s);if(this.checkShellNotNested(r,o,e),null!==this.validErr)return null}},interfaces_:function(){return[]},getClass:function(){return Ur}}),Ur.findPtNotNode=function(t,e,n){for(var i=n.findEdge(e),r=i.getEdgeIntersectionList(),s=0;s<t.length;s++){var o=t[s];if(!r.isIntersection(o))return o}return null},Ur.isValid=function(){if(arguments[0]instanceof B){var t=arguments[0],e=new Ur(t);return e.isValid()}if(arguments[0]instanceof g){var n=arguments[0];return!r.isNaN(n.x)&&(!r.isInfinite(n.x)&&(!r.isNaN(n.y)&&!r.isInfinite(n.y)))}},e(Xr.prototype,{isIncluded:function(){return this._isIncluded},getCoordinates:function(){if(null===this.ringPts){for(var t=new N,e=this.deList.iterator();e.hasNext();){var n=e.next(),i=n.getEdge();Xr.addEdge(i.getLine().getCoordinates(),n.getEdgeDirection(),t)}this.ringPts=t.toCoordinateArray()}return this.ringPts},isIncludedSet:function(){return this._isIncludedSet},isValid:function(){return this.getCoordinates(),!(this.ringPts.length<=3)&&(this.getRing(),Ur.isValid(this.ring))},build:function(t){var e=t;do this.add(e),e.setRing(this),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t)},isOuterHole:function(){return!!this._isHole&&!this.hasShell()},getPolygon:function(){var t=null;if(null!==this.holes){t=new Array(this.holes.size()).fill(null);for(var e=0;e<this.holes.size();e++)t[e]=this.holes.get(e)}var n=this.factory.createPolygon(this.ring,t);return n},isHole:function(){return this._isHole},isProcessed:function(){return this._isProcessed},addHole:function(){if(arguments[0]instanceof bt){var t=arguments[0];null===this.holes&&(this.holes=new I),this.holes.add(t)}else if(arguments[0]instanceof Xr){var e=arguments[0];e.setShell(this);var n=e.getRing();null===this.holes&&(this.holes=new I),this.holes.add(n)}},setIncluded:function(t){this._isIncluded=t,this._isIncludedSet=!0},getOuterHole:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing();if(n.isOuterHole())return n}return null},computeHole:function(){var t=this.getRing();this._isHole=he.isCCW(t.getCoordinates())},hasShell:function(){return null!==this.shell},isOuterShell:function(){return null!==this.getOuterHole()},getLineString:function(){return this.getCoordinates(),this.factory.createLineString(this.ringPts)},toString:function(){return se.toLineString(new Gt(this.getCoordinates()))},getShell:function(){return this.isHole()?this.shell:this},add:function(t){this.deList.add(t)},getRing:function(){if(null!==this.ring)return this.ring;this.getCoordinates(),this.ringPts.length<3&&A.out.println(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts)}catch(t){if(!(t instanceof S))throw t;A.out.println(this.ringPts)}finally{}return this.ring},updateIncluded:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing().getShell();if(null!==n&&n.isIncludedSet())return this.setIncluded(!n.isIncluded()),null}},setShell:function(t){this.shell=t},setProcessed:function(t){this._isProcessed=t},interfaces_:function(){return[]},getClass:function(){return Xr}}),Xr.findDirEdgesInRing=function(t){var e=t,n=new I;do n.add(e),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t);return n},Xr.addEdge=function(t,e,n){if(e)for(var i=0;i<t.length;i++)n.add(t[i],!1);else for(var i=t.length-1;i>=0;i--)n.add(t[i],!1)},Xr.findEdgeRingContaining=function(t,e){for(var n=t.getRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getRing(),h=l.getEnvelopeInternal();if(!h.equals(i)&&h.contains(i)){r=H.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u,o=s.getRing().getEnvelopeInternal())}}return s},e(Hr.prototype,{compare:function(t,e){var n=t,i=e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())},interfaces_:function(){return[a]},getClass:function(){return Hr}}),Xr.EnvelopeComparator=Hr,h(Wr,Pr),e(Wr.prototype,{findEdgeRing:function(t){var e=new Xr(this.factory);return e.build(t),e},computeDepthParity:function(){if(0===arguments.length)for(;;){var t=null;if(null===t)return null;this.computeDepthParity(t)}else if(1===arguments.length){arguments[0]}},computeNextCWEdges:function(){for(var t=this.nodeIterator();t.hasNext();){var e=t.next();Wr.computeNextCWEdges(e)}},addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new _r(r,s,e[1],(!0)),a=new _r(s,r,e[e.length-2],(!1)),u=new Mr(t);u.setDirectedEdges(o,a),this.add(u)},deleteCutEdges:function(){this.computeNextCWEdges(),Wr.findLabeledEdgeRings(this.dirEdges);for(var t=new I,e=this.dirEdges.iterator();e.hasNext();){var n=e.next();if(!n.isMarked()){var i=n.getSym();if(n.getLabel()===i.getLabel()){n.setMarked(!0),i.setMarked(!0);var r=n.getEdge();t.add(r.getLine())}}}return t},getEdgeRings:function(){this.computeNextCWEdges(),Wr.label(this.dirEdges,-1);var t=Wr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for(var e=new I,n=this.dirEdges.iterator();n.hasNext();){var i=n.next();if(!i.isMarked()&&!i.isInRing()){var r=this.findEdgeRing(i);e.add(r)}}return e},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new Lr(t),this.add(e)),e},convertMaximalToMinimalEdgeRings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel(),r=Wr.findIntersectionNodes(n,i);if(null!==r)for(var s=r.iterator();s.hasNext();){var o=s.next();Wr.computeNextCCWEdges(o,i)}}},deleteDangles:function(){for(var t=this.findNodesOfDegree(1),e=new J,n=new pe,i=t.iterator();i.hasNext();)n.push(i.next());for(;!n.isEmpty();){var r=n.pop();Wr.deleteAllEdges(r);for(var s=r.getOutEdges().getEdges(),i=s.iterator();i.hasNext();){var o=i.next();o.setMarked(!0);var a=o.getSym();null!==a&&a.setMarked(!0);var u=o.getEdge();e.add(u.getLine());var l=o.getToNode();1===Wr.getDegreeNonDeleted(l)&&n.push(l)}}return e},interfaces_:function(){return[]},getClass:function(){return Wr}}),Wr.findLabeledEdgeRings=function(t){for(var e=new I,n=1,i=t.iterator();i.hasNext();){var r=i.next();if(!(r.isMarked()||r.getLabel()>=0)){e.add(r);var s=Xr.findDirEdgesInRing(r);Wr.label(s,n),n++}}return e},Wr.getDegreeNonDeleted=function(t){for(var e=t.getOutEdges().getEdges(),n=0,i=e.iterator();i.hasNext();){var r=i.next();r.isMarked()||n++}return n},Wr.deleteAllEdges=function(t){for(var e=t.getOutEdges().getEdges(),n=e.iterator();n.hasNext();){var i=n.next();i.setMarked(!0);var r=i.getSym();null!==r&&r.setMarked(!0)}},Wr.label=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();i.setLabel(e)}},Wr.computeNextCWEdges=function(t){for(var e=t.getOutEdges(),n=null,i=null,r=e.getEdges().iterator();r.hasNext();){var s=r.next();if(!s.isMarked()){if(null===n&&(n=s),null!==i){var o=i.getSym();o.setNext(s)}i=s}}if(null!==i){var o=i.getSym();o.setNext(n)}},Wr.computeNextCCWEdges=function(t,e){for(var n=t.getOutEdges(),i=null,r=null,s=n.getEdges(),o=s.size()-1;o>=0;o--){var a=s.get(o),u=a.getSym(),l=null;a.getLabel()===e&&(l=a);var h=null;u.getLabel()===e&&(h=u),null===l&&null===h||(null!==h&&(r=h),null!==l&&(null!==r&&(r.setNext(l),r=null),null===i&&(i=l)))}null!==r&&(f.isTrue(null!==i),r.setNext(i))},Wr.getDegree=function(t,e){for(var n=t.getOutEdges().getEdges(),i=0,r=n.iterator();r.hasNext();){var s=r.next();s.getLabel()===e&&i++}return i},Wr.findIntersectionNodes=function(t,e){var n=t,i=null;do{var r=n.getFromNode();Wr.getDegree(r,e)>1&&(null===i&&(i=new I),i.add(r)),n=n.getNext(),f.isTrue(null!==n,"found null DE in ring"),f.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return i},e(jr.prototype,{getGeometry:function(){return null===this.geomFactory&&(this.geomFactory=new ie),this.polygonize(),this.extractOnlyPolygonal?this.geomFactory.buildGeometry(this.polyList):this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList))},getInvalidRingLines:function(){return this.polygonize(),this.invalidRingLines},findValidRings:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isValid()?e.add(r):n.add(r.getLineString())}},polygonize:function(){if(null!==this.polyList)return null;
if(this.polyList=new I,null===this.graph)return null;this.dangles=this.graph.deleteDangles(),this.cutEdges=this.graph.deleteCutEdges();var t=this.graph.getEdgeRings(),e=new I;this.invalidRingLines=new I,this.isCheckingRingsValid?this.findValidRings(t,e,this.invalidRingLines):e=t,this.findShellsAndHoles(e),jr.assignHolesToShells(this.holeList,this.shellList),ho.sort(this.shellList,new Xr.EnvelopeComparator);var n=!0;this.extractOnlyPolygonal&&(jr.findDisjointShells(this.shellList),n=!1),this.polyList=jr.extractPolygons(this.shellList,n)},getDangles:function(){return this.polygonize(),this.dangles},getCutEdges:function(){return this.polygonize(),this.cutEdges},getPolygons:function(){return this.polygonize(),this.polyList},add:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.add(n)}else if(arguments[0]instanceof St){var i=arguments[0];this.geomFactory=i.getFactory(),null===this.graph&&(this.graph=new Wr(this.geomFactory)),this.graph.addEdge(i)}else if(arguments[0]instanceof B){var r=arguments[0];r.apply(this.lineStringAdder)}},setCheckRingsValid:function(t){this.isCheckingRingsValid=t},findShellsAndHoles:function(t){this.holeList=new I,this.shellList=new I;for(var e=t.iterator();e.hasNext();){var n=e.next();n.computeHole(),n.isHole()?this.holeList.add(n):this.shellList.add(n)}},interfaces_:function(){return[]},getClass:function(){return jr}}),jr.findOuterShells=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getOuterHole();null===i||i.isProcessed()||(n.setIncluded(!0),i.setProcessed(!0))}},jr.extractPolygons=function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next();(e||r.isIncluded())&&n.add(r.getPolygon())}return n},jr.assignHolesToShells=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();jr.assignHoleToShell(i,e)}},jr.assignHoleToShell=function(t,e){var n=Xr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)},jr.findDisjointShells=function(t){jr.findOuterShells(t);var e=null;do{e=!1;for(var n=t.iterator();n.hasNext();){var i=n.next();i.isIncludedSet()||(i.updateIncluded(),i.isIncludedSet()||(e=!0))}}while(e)},e(Kr.prototype,{filter:function(t){t instanceof St&&this.p.add(t)},interfaces_:function(){return[q]},getClass:function(){return Kr}}),jr.LineStringAdder=Kr;var To=Object.freeze({Polygonizer:jr});e(Zr.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},computeProperIntersectionIM:function(t,e){var n=this.arg[0].getGeometry().getDimension(),i=this.arg[1].getGeometry().getDimension(),r=t.hasProperIntersection(),s=t.hasProperInteriorIntersection();2===n&&2===i?r&&e.setAtLeast("212101212"):2===n&&1===i?(r&&e.setAtLeast("FFF0FFFF2"),s&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(r&&e.setAtLeast("F0FFFFFF2"),s&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&s&&e.setAtLeast("0FFFFFFFF")},labelIsolatedEdges:function(t,e){for(var n=this.arg[t].getEdgeIterator();n.hasNext();){var i=n.next();i.isIsolated()&&(this.labelIsolatedEdge(i,e,this.arg[e].getGeometry()),this.isolatedEdges.add(i))}},labelIsolatedEdge:function(t,e,n){if(n.getDimension()>0){var i=this.ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,L.EXTERIOR)},computeIM:function(){var t=new fe;if(t.set(L.EXTERIOR,L.EXTERIOR,2),!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1);var e=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);var n=new Ar,i=n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r=n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t},labelNodeEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}},copyNodesAndLabels:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.nodes.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},labelIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.find(s.coord);o.getLabel().isNull(t)&&(i===L.BOUNDARY?o.setLabelBoundary(t):o.setLabel(t,L.INTERIOR))}},labelIsolatedNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setAllLocations(e,n)},computeIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.addNode(s.coord);i===L.BOUNDARY?o.setLabelBoundary(t):o.getLabel().isNull(t)&&o.setLabel(t,L.INTERIOR)}},labelIsolatedNodes:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();f.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}},updateIM:function(t){for(var e=this.isolatedEdges.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}for(var i=this.nodes.iterator();i.hasNext();){var r=i.next();r.updateIM(t),r.updateIMFromEdges(t)}},computeDisjointIM:function(t){var e=this.arg[0].getGeometry();e.isEmpty()||(t.set(L.INTERIOR,L.EXTERIOR,e.getDimension()),t.set(L.BOUNDARY,L.EXTERIOR,e.getBoundaryDimension()));var n=this.arg[1].getGeometry();n.isEmpty()||(t.set(L.EXTERIOR,L.INTERIOR,n.getDimension()),t.set(L.EXTERIOR,L.BOUNDARY,n.getBoundaryDimension()))},interfaces_:function(){return[]},getClass:function(){return Zr}}),e(Qr.prototype,{isContainedInBoundary:function(t){if(t instanceof Tt)return!1;if(t instanceof Lt)return this.isPointContainedInBoundary(t);if(t instanceof St)return this.isLineStringContainedInBoundary(t);for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0},isLineSegmentContainedInBoundary:function(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this.rectEnv.getMinX()||t.x===this.rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this.rectEnv.getMinY()||t.y===this.rectEnv.getMaxY()))return!0;return!1},isLineStringContainedInBoundary:function(t){for(var e=t.getCoordinateSequence(),n=new g,i=new g,r=0;r<e.size()-1;r++)if(e.getCoordinate(r,n),e.getCoordinate(r+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0},isPointContainedInBoundary:function(){if(arguments[0]instanceof Lt){var t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){var e=arguments[0];return e.x===this.rectEnv.getMinX()||e.x===this.rectEnv.getMaxX()||e.y===this.rectEnv.getMinY()||e.y===this.rectEnv.getMaxY()}},contains:function(t){return!!this.rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)},interfaces_:function(){return[]},getClass:function(){return Qr}}),Qr.contains=function(t,e){var n=new Qr(t);return n.contains(e)},e(Jr.prototype,{intersects:function(t,e){var n=new C(t,e);if(!this.rectEnv.intersects(n))return!1;if(this.rectEnv.intersects(t))return!0;if(this.rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){var i=t;t=e,e=i}var r=!1;return e.y>t.y&&(r=!0),r?this.li.computeIntersection(t,e,this.diagDown0,this.diagDown1):this.li.computeIntersection(t,e,this.diagUp0,this.diagUp1),!!this.li.hasIntersection()},interfaces_:function(){return[]},getClass:function(){return Jr}}),e($r.prototype,{applyTo:function(t){for(var e=0;e<t.getNumGeometries()&&!this._isDone;e++){var n=t.getGeometryN(e);if(n instanceof ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}},interfaces_:function(){return[]},getClass:function(){return $r}}),e(ts.prototype,{intersects:function(t){if(!this.rectEnv.intersects(t.getEnvelopeInternal()))return!1;var e=new es(this.rectEnv);if(e.applyTo(t),e.intersects())return!0;var n=new ns(this.rectangle);if(n.applyTo(t),n.containsPoint())return!0;var i=new is(this.rectangle);return i.applyTo(t),!!i.intersects()},interfaces_:function(){return[]},getClass:function(){return ts}}),ts.intersects=function(t,e){var n=new ts(t);return n.intersects(e)},h(es,$r),e(es.prototype,{isDone:function(){return this._intersects===!0},visit:function(t){var e=t.getEnvelopeInternal();return this.rectEnv.intersects(e)?this.rectEnv.contains(e)?(this._intersects=!0,null):e.getMinX()>=this.rectEnv.getMinX()&&e.getMaxX()<=this.rectEnv.getMaxX()?(this._intersects=!0,null):e.getMinY()>=this.rectEnv.getMinY()&&e.getMaxY()<=this.rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null},intersects:function(){return this._intersects},interfaces_:function(){return[]},getClass:function(){return es}}),h(ns,$r),e(ns.prototype,{isDone:function(){return this._containsPoint===!0},visit:function(t){if(!(t instanceof Tt))return null;var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;for(var n=new g,i=0;i<4;i++)if(this.rectSeq.getCoordinate(i,n),e.contains(n)&&Tn.containsPointInPolygon(n,t))return this._containsPoint=!0,null},containsPoint:function(){return this._containsPoint},interfaces_:function(){return[]},getClass:function(){return ns}}),h(is,$r),e(is.prototype,{intersects:function(){return this.hasIntersection},isDone:function(){return this.hasIntersection===!0},visit:function(t){var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;var n=kn.getLines(t);this.checkIntersectionWithLineStrings(n)},checkIntersectionWithLineStrings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();if(this.checkIntersectionWithSegments(n),this.hasIntersection)return null}},checkIntersectionWithSegments:function(t){for(var e=t.getCoordinateSequence(),n=1;n<e.size();n++)if(e.getCoordinate(n-1,this.p0),e.getCoordinate(n,this.p1),this.rectIntersector.intersects(this.p0,this.p1))return this.hasIntersection=!0,null},interfaces_:function(){return[]},getClass:function(){return is}}),h(rs,ti),e(rs.prototype,{getIntersectionMatrix:function(){return this._relate.computeIM()},interfaces_:function(){return[]},getClass:function(){return rs}}),rs.covers=function(t,e){return!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||rs.relate(t,e).isCovers())},rs.intersects=function(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&(t.isRectangle()?ts.intersects(t,e):e.isRectangle()?ts.intersects(e,t):rs.relate(t,e).isIntersects())},rs.touches=function(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&rs.relate(t,e).isTouches(t.getDimension(),e.getDimension())},rs.within=function(t,e){return e.contains(t)},rs.coveredBy=function(t,e){return rs.covers(e,t)},rs.relate=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new rs(t,e),i=n.getIntersectionMatrix();return i}if(3===arguments.length){if("string"==typeof arguments[2]&&arguments[0]instanceof B&&arguments[1]instanceof B){var r=arguments[0],s=arguments[1],o=arguments[2];return rs.relateWithCheck(r,s).matches(o)}if(R(arguments[2],V)&&arguments[0]instanceof B&&arguments[1]instanceof B){var a=arguments[0],u=arguments[1],l=arguments[2],n=new rs(a,u,l),i=n.getIntersectionMatrix();return i}}},rs.overlaps=function(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&rs.relate(t,e).isOverlaps(t.getDimension(),e.getDimension())},rs.disjoint=function(t,e){return!t.intersects(e)},rs.relateWithCheck=function(t,e){return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),rs.relate(t,e)},rs.crosses=function(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&rs.relate(t,e).isCrosses(t.getDimension(),e.getDimension())},rs.contains=function(t,e){return!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Qr.contains(t,e):rs.relate(t,e).isContains())};var Po=Object.freeze({RelateOp:rs});e(ss.prototype,{extractElements:function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this.skipEmpty&&i.isEmpty()||e.add(i)}},combine:function(){for(var t=new I,e=this.inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this.geomFactory?this.geomFactory.createGeometryCollection(null):null:this.geomFactory.buildGeometry(t)},interfaces_:function(){return[]},getClass:function(){return ss}}),ss.combine=function(){if(1===arguments.length){var t=arguments[0],e=new ss(t);return e.combine()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new ss(ss.createList(n,i));return e.combine()}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],e=new ss(ss.createList(r,s,o));return e.combine()}},ss.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},ss.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new I;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],n=new I;return n.add(i),n.add(r),n.add(s),n}},e(os.prototype,{union:function(){for(var t=new Te,e=new at,n=0;n<this.pointGeom.getNumGeometries();n++){var i=this.pointGeom.getGeometryN(n),r=i.getCoordinate(),s=t.locate(r,this.otherGeom);s===L.EXTERIOR&&e.add(r)}if(0===e.size())return this.otherGeom;var o=null,a=H.toCoordinateArray(e);return o=1===a.length?this.geomFact.createPoint(a[0]):this.geomFact.createMultiPointFromCoords(a),ss.combine(o,this.otherGeom)},interfaces_:function(){return[]},getClass:function(){return os}}),os.union=function(t,e){var n=new os(t,e);return n.union()},e(as.prototype,{filter:function(t){this.sortIndex!==-1&&t.getSortIndex()!==this.sortIndex||this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return as}}),as.extract=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return as.extract(t,e,new I)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];return n.getSortIndex()===i?r.add(n):n instanceof ft&&n.apply(new as(i,r)),r}},e(us.prototype,{reduceToGeometries:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=null;R(i,y)?r=this.unionTree(i):i instanceof B&&(r=i),e.add(r)}return e},extractByEnvelope:function(t,e,n){for(var i=new I,r=0;r<e.getNumGeometries();r++){var s=e.getGeometryN(r);s.getEnvelopeInternal().intersects(t)?i.add(s):n.add(s)}return this.geomFactory.buildGeometry(i)},unionOptimized:function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){var r=ss.combine(t,e);return r}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var s=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,s)},union:function(){if(null===this.inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this.inputPolys.isEmpty())return null;this.geomFactory=this.inputPolys.iterator().next().getFactory();for(var t=new ke(us.STRTREE_NODE_CAPACITY),e=this.inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this.inputPolys=null;var i=t.itemsTree(),r=this.unionTree(i);return r},binaryUnion:function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(i-n<=1){var r=us.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n===2)return this.unionSafe(us.getGeometry(e,n),us.getGeometry(e,n+1));var s=Math.trunc((i+n)/2),r=this.binaryUnion(e,n,s),o=this.binaryUnion(e,s,i);return this.unionSafe(r,o)}},repeatedUnion:function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},unionSafe:function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},unionActual:function(t,e){return us.restrictToPolygons(t.union(e))},unionTree:function(t){var e=this.reduceToGeometries(t),n=this.binaryUnion(e);return n},unionUsingEnvelopeIntersection:function(t,e,n){var i=new I,r=this.extractByEnvelope(n,t,i),s=this.extractByEnvelope(n,e,i),o=this.unionActual(r,s);i.add(o);var a=ss.combine(i);return a},bufferUnion:function(){if(1===arguments.length){var t=arguments[0],e=t.get(0).getFactory(),n=e.buildGeometry(t),i=n.buffer(0);return i}if(2===arguments.length){var r=arguments[0],s=arguments[1],e=r.getFactory(),n=e.createGeometryCollection([r,s]),i=n.buffer(0);return i}},interfaces_:function(){return[]},getClass:function(){return us}}),us.restrictToPolygons=function(t){if(R(t,Rt))return t;var e=pr.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(ie.toPolygonArray(e))},us.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},us.union=function(t){var e=new us(t);return e.union()},us.STRTREE_NODE_CAPACITY=4,e(ls.prototype,{unionNoOpt:function(t){var e=this.geomFact.createPoint();return si.overlayOp(t,e,ii.UNION)},unionWithNull:function(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)},extract:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.extract(n)}else if(arguments[0]instanceof B){var i=arguments[0];null===this.geomFact&&(this.geomFact=i.getFactory()),as.extract(i,B.SORTINDEX_POLYGON,this.polygons),as.extract(i,B.SORTINDEX_LINESTRING,this.lines),as.extract(i,B.SORTINDEX_POINT,this.points)}},union:function t(){if(null===this.geomFact)return null;var e=null;if(this.points.size()>0){var n=this.geomFact.buildGeometry(this.points);e=this.unionNoOpt(n)}var i=null;if(this.lines.size()>0){var r=this.geomFact.buildGeometry(this.lines);i=this.unionNoOpt(r)}var s=null;this.polygons.size()>0&&(s=us.union(this.polygons));var o=this.unionWithNull(i,s),t=null;return t=null===e?o:null===o?e:os.union(e,o),null===t?this.geomFact.createGeometryCollection():t},interfaces_:function(){return[]},getClass:function(){return ls}}),ls.union=function(){if(1===arguments.length){if(R(arguments[0],v)){var t=arguments[0],e=new ls(t);return e.union()}if(arguments[0]instanceof B){var n=arguments[0],e=new ls(n);return e.union()}}else if(2===arguments.length){var i=arguments[0],r=arguments[1],e=new ls(i,r);return e.union()}};var bo=Object.freeze({UnaryUnionOp:ls}),Oo=Object.freeze({IsValidOp:Ur,ConsistentAreaTester:Vr}),_o=Object.freeze({BoundaryOp:dt,IsSimpleOp:Wi,buffer:So,distance:wo,linemerge:Lo,overlay:Ro,polygonize:To,relate:Po,union:bo,valid:Oo});h(hs,_t.CoordinateOperation),e(hs.prototype,{editCoordinates:function(t,e){if(0===t.length)return null;for(var n=new Array(t.length).fill(null),i=0;i<t.length;i++){var r=new g(t[i]);this.targetPM.makePrecise(r),n[i]=r}var s=new N(n,(!1)),o=s.toCoordinateArray(),a=0;e instanceof St&&(a=2),e instanceof bt&&(a=4);var u=n;return this.removeCollapsed&&(u=null),o.length<a?u:o},interfaces_:function(){return[]},getClass:function(){return hs}}),e(cs.prototype,{fixPolygonalTopology:function(t){var e=t;this.changePrecisionModel||(e=this.changePM(t,this.targetPM));var n=e.buffer(0),i=n;return this.changePrecisionModel||(i=this.changePM(n,t.getPrecisionModel())),i},reducePointwise:function(t){var e=null;if(this.changePrecisionModel){var n=this.createFactory(t.getFactory(),this.targetPM);e=new _t(n)}else e=new _t;var i=this.removeCollapsed;t.getDimension()>=2&&(i=!0);var r=e.edit(t,new hs(this.targetPM,i));return r},changePM:function(t,e){var n=this.createEditor(t.getFactory(),e);return n.edit(t,new _t.NoOpGeometryOperation)},setRemoveCollapsedComponents:function(t){this.removeCollapsed=t},createFactory:function(t,e){var n=new ie(e,t.getSRID(),t.getCoordinateSequenceFactory());return n},setChangePrecisionModel:function(t){this.changePrecisionModel=t},reduce:function(t){var e=this.reducePointwise(t);return this.isPointwise?e:R(e,Rt)?e.isValid()?e:this.fixPolygonalTopology(e):e},setPointwise:function(t){this.isPointwise=t},createEditor:function(t,e){if(t.getPrecisionModel()===e)return new _t;var n=this.createFactory(t,e),i=new _t(n);return i},interfaces_:function(){return[]},getClass:function(){return cs}}),cs.reduce=function(t,e){var n=new cs(e);return n.reduce(t)},cs.reducePointwise=function(t,e){var n=new cs(e);return n.setPointwise(!0),n.reduce(t)};var Mo=Object.freeze({GeometryPrecisionReducer:cs});e(fs.prototype,{simplifySection:function(t,e){if(t+1===e)return null;this.seg.p0=this.pts[t],this.seg.p1=this.pts[e];for(var n=-1,i=t,r=t+1;r<e;r++){var s=this.seg.distance(this.pts[r]);s>n&&(n=s,i=r)}if(n<=this.distanceTolerance)for(var r=t+1;r<e;r++)this.usePt[r]=!1;else this.simplifySection(t,i),this.simplifySection(i,e)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(){this.usePt=new Array(this.pts.length).fill(null);for(var t=0;t<this.pts.length;t++)this.usePt[t]=!0;this.simplifySection(0,this.pts.length-1);for(var e=new N,t=0;t<this.pts.length;t++)this.usePt[t]&&e.add(new g(this.pts[t]));return e.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return fs}}),fs.simplify=function(t,e){var n=new fs(t);return n.setDistanceTolerance(e),n.simplify()},e(gs.prototype,{setEnsureValid:function(t){this.isEnsureValidTopology=t},getResultGeometry:function(){return this.inputGeom.isEmpty()?this.inputGeom.copy():new ds(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(t<0)throw new i("Tolerance must be non-negative");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return gs}}),gs.simplify=function(t,e){var n=new gs(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(ds,xe),e(ds.prototype,{transformPolygon:function(t,e){if(t.isEmpty())return null;var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},createValidArea:function(t){return this.isEnsureValidTopology?t.buffer(0):t},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=null;return i=0===n.length?new Array(0).fill(null):fs.simplify(n,this.distanceTolerance),this.factory.getCoordinateSequenceFactory().create(i)},transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformLinearRing:function(t,e){var n=e instanceof Tt,i=xe.prototype.transformLinearRing.call(this,t,e);return!n||i instanceof bt?i:null},interfaces_:function(){return[]},getClass:function(){return ds}}),gs.DPTransformer=ds,h(ps,ce),e(ps.prototype,{getIndex:function(){return this.index},getParent:function(){return this.parent},interfaces_:function(){return[]},getClass:function(){return ps}}),e(vs.prototype,{addToResult:function(t){this.resultSegs.add(t)},asLineString:function(){return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs))},getResultSize:function(){var t=this.resultSegs.size();return 0===t?0:t+1},getParent:function(){return this.parentLine},getSegment:function(t){return this.segs[t]},getParentCoordinates:function(){return this.parentLine.getCoordinates()},getMinimumSize:function(){return this.minimumSize},asLinearRing:function(){return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs))},getSegments:function(){return this.segs},init:function(){var t=this.parentLine.getCoordinates();this.segs=new Array(t.length-1).fill(null);for(var e=0;e<t.length-1;e++){var n=new ps(t[e],t[e+1],this.parentLine,e);this.segs[e]=n}},getResultCoordinates:function(){return vs.extractCoordinates(this.resultSegs)},interfaces_:function(){return[]},getClass:function(){return vs}}),vs.extractCoordinates=function(t){for(var e=new Array(t.size()+1).fill(null),n=null,i=0;i<t.size();i++)n=t.get(i),e[i]=n.p0;return e[e.length-1]=n.p1,e},e(ms.prototype,{remove:function(t){this.index.remove(new C(t.p0,t.p1),t)},add:function(){if(arguments[0]instanceof vs)for(var t=arguments[0],e=t.getSegments(),n=0;n<e.length;n++){var i=e[n];this.add(i)}else if(arguments[0]instanceof ce){var r=arguments[0];this.index.insert(new C(r.p0,r.p1),r)}},query:function(t){var e=new C(t.p0,t.p1),n=new ys(t);this.index.query(e,n);var i=n.getItems();return i},interfaces_:function(){return[]},getClass:function(){return ms}}),e(ys.prototype,{visitItem:function(t){var e=t;C.intersects(e.p0,e.p1,this.querySeg.p0,this.querySeg.p1)&&this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return ys}}),e(xs.prototype,{flatten:function(t,e){var n=this.linePts[t],i=this.linePts[e],r=new ce(n,i);return this.remove(this.line,t,e),this.outputIndex.add(r),r},hasBadIntersection:function(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplifySection:function(t,e,n){n+=1;var i=new Array(2).fill(null);if(t+1===e){var r=this.line.getSegment(t);return this.line.addToResult(r),null}var s=!0;if(this.line.getResultSize()<this.line.getMinimumSize()){var o=n+1;o<this.line.getMinimumSize()&&(s=!1)}var a=new Array(1).fill(null),u=this.findFurthestPoint(this.linePts,t,e,a);a[0]>this.distanceTolerance&&(s=!1);var l=new ce;if(l.p0=this.linePts[t],l.p1=this.linePts[e],i[0]=t,i[1]=e,this.hasBadIntersection(this.line,i,l)&&(s=!1),s){var r=this.flatten(t,e);return this.line.addToResult(r),null}this.simplifySection(t,u,n),this.simplifySection(u,e,n)},hasBadOutputIntersection:function(t){for(var e=this.outputIndex.query(t),n=e.iterator();n.hasNext();){var i=n.next();if(this.hasInteriorIntersection(i,t))return!0}return!1},findFurthestPoint:function(t,e,n,i){var r=new ce;r.p0=t[e],r.p1=t[n];for(var s=-1,o=e,a=e+1;a<n;a++){var u=t[a],l=r.distance(u);l>s&&(s=l,o=a)}return i[0]=s,o},simplify:function(t){this.line=t,this.linePts=t.getParentCoordinates(),this.simplifySection(0,this.linePts.length-1,0)},remove:function(t,e,n){for(var i=e;i<n;i++){var r=t.getSegment(i);this.inputIndex.remove(r)}},hasInteriorIntersection:function(t,e){return this.li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this.li.isInteriorIntersection()},hasBadInputIntersection:function(t,e,n){for(var i=this.inputIndex.query(n),r=i.iterator();r.hasNext();){var s=r.next();if(this.hasInteriorIntersection(s,n)){if(xs.isInLineSection(t,e,s))continue;return!0}}return!1},interfaces_:function(){return[]},getClass:function(){return xs}}),xs.isInLineSection=function(t,e,n){if(n.getParent()!==t.getParent())return!1;var i=n.getIndex();return i>=e[0]&&i<e[1]},e(Es.prototype,{setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(t){for(var e=t.iterator();e.hasNext();)this.inputIndex.add(e.next());for(var e=t.iterator();e.hasNext();){var n=new xs(this.inputIndex,this.outputIndex);n.setDistanceTolerance(this.distanceTolerance),n.simplify(e.next())}},interfaces_:function(){return[]},getClass:function(){return Es}}),e(Is.prototype,{getResultGeometry:function(){if(this.inputGeom.isEmpty())return this.inputGeom.copy();this.linestringMap=new te,this.inputGeom.apply(new Cs(this)),this.lineSimplifier.simplify(this.linestringMap.values());var t=new Ns(this.linestringMap).transform(this.inputGeom);return t},setDistanceTolerance:function(t){if(t<0)throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t)},interfaces_:function(){return[]},getClass:function(){return Is}}),Is.simplify=function(t,e){var n=new Is(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ns,xe),e(Ns.prototype,{transformCoordinates:function(t,e){if(0===t.size())return null;if(e instanceof St){var n=this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates())}return xe.prototype.transformCoordinates.call(this,t,e)},interfaces_:function(){return[]},getClass:function(){return Ns}}),e(Cs.prototype,{filter:function(t){if(t instanceof St){var e=t;if(e.isEmpty())return null;var n=e.isClosed()?4:2,i=new vs(e,n);this.tps.linestringMap.put(e,i)}},interfaces_:function(){return[q]},getClass:function(){return Cs}}),Is.LineStringTransformer=Ns,Is.LineStringMapBuilderFilter=Cs;var Do=Object.freeze({DouglasPeuckerSimplifier:gs,TopologyPreservingSimplifier:Is});e(Ss.prototype,{splitAt:function(){if(1===arguments.length){var t=arguments[0],e=this.minimumLen/this.segLen;if(t.distance(this.seg.p0)<this.minimumLen)return this.splitPt=this.seg.pointAlong(e),null;if(t.distance(this.seg.p1)<this.minimumLen)return this.splitPt=Ss.pointAlongReverse(this.seg,e),null;this.splitPt=t}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.getConstrainedLength(n),s=r/this.segLen;i.equals2D(this.seg.p0)?this.splitPt=this.seg.pointAlong(s):this.splitPt=Ss.pointAlongReverse(this.seg,s)}},setMinimumLength:function(t){this.minimumLen=t},getConstrainedLength:function(t){return t<this.minimumLen?this.minimumLen:t},getSplitPoint:function(){return this.splitPt},interfaces_:function(){return[]},getClass:function(){return Ss}}),Ss.pointAlongReverse=function(t,e){var n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n},e(ws.prototype,{findSplitPoint:function(t,e){},interfaces_:function(){return[]},getClass:function(){return ws}}),e(Ls.prototype,{findSplitPoint:function(t,e){var n=t.getLineSegment(),i=n.getLength(),r=i/2,s=new Ss(n),o=Ls.projectedSplitPoint(t,e),a=2*o.distance(e)*.8,u=a;return u>r&&(u=r),s.setMinimumLength(u),s.splitAt(o),s.getSplitPoint()},interfaces_:function(){return[ws]},getClass:function(){return Ls}}),Ls.projectedSplitPoint=function(t,e){var n=t.getLineSegment(),i=n.project(e);return i},e(Rs.prototype,{interfaces_:function(){return[]},getClass:function(){return Rs}}),Rs.triArea=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)},Rs.isInCircleDDNormalized=function(t,e,n,i){var r=_.valueOf(t.x).selfSubtract(i.x),s=_.valueOf(t.y).selfSubtract(i.y),o=_.valueOf(e.x).selfSubtract(i.x),a=_.valueOf(e.y).selfSubtract(i.y),u=_.valueOf(n.x).selfSubtract(i.x),l=_.valueOf(n.y).selfSubtract(i.y),h=r.multiply(a).selfSubtract(o.multiply(s)),c=o.multiply(l).selfSubtract(u.multiply(a)),f=u.multiply(s).selfSubtract(r.multiply(l)),g=r.multiply(r).selfAdd(s.multiply(s)),d=o.multiply(o).selfAdd(a.multiply(a)),p=u.multiply(u).selfAdd(l.multiply(l)),v=g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),m=v.doubleValue()>0;return m},Rs.checkRobustInCircle=function(t,e,n,i){var r=Rs.isInCircleNonRobust(t,e,n,i),s=Rs.isInCircleDDSlow(t,e,n,i),o=Rs.isInCircleCC(t,e,n,i),a=Si.circumcentre(t,e,n);A.out.println("p radius diff a = "+Math.abs(i.distance(a)-t.distance(a))/t.distance(a)),r===s&&r===o||(A.out.println("inCircle robustness failure (double result = "+r+", DD result = "+s+", CC result = "+o+")"),A.out.println(se.toLineString(new Gt([t,e,n,i]))),A.out.println("Circumcentre = "+se.toPoint(a)+" radius = "+t.distance(a)),A.out.println("p radius diff a = "+Math.abs(i.distance(a)/t.distance(a)-1)),A.out.println("p radius diff b = "+Math.abs(i.distance(a)/e.distance(a)-1)),A.out.println("p radius diff c = "+Math.abs(i.distance(a)/n.distance(a)-1)),A.out.println())},Rs.isInCircleDDFast=function(t,e,n,i){var r=_.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e,n,i)),s=_.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t,n,i)),o=_.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t,e,i)),a=_.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t,e,n)),u=r.selfSubtract(s).selfAdd(o).selfSubtract(a),l=u.doubleValue()>0;return l},Rs.isInCircleCC=function(t,e,n,i){var r=Si.circumcentre(t,e,n),s=t.distance(r),o=i.distance(r)-s;return o<=0},Rs.isInCircleNormalized=function(t,e,n,i){var r=t.x-i.x,s=t.y-i.y,o=e.x-i.x,a=e.y-i.y,u=n.x-i.x,l=n.y-i.y,h=r*a-o*s,c=o*l-u*a,f=u*s-r*l,g=r*r+s*s,d=o*o+a*a,p=u*u+l*l,v=g*c+d*f+p*h;
return v>0},Rs.isInCircleDDSlow=function(t,e,n,i){var r=_.valueOf(i.x),s=_.valueOf(i.y),o=_.valueOf(t.x),a=_.valueOf(t.y),u=_.valueOf(e.x),l=_.valueOf(e.y),h=_.valueOf(n.x),c=_.valueOf(n.y),f=o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u,l,h,c,r,s)),g=u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o,a,h,c,r,s)),d=h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o,a,u,l,r,s)),p=r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o,a,u,l,h,c)),v=f.subtract(g).add(d).subtract(p),m=v.doubleValue()>0;return m},Rs.isInCircleNonRobust=function(t,e,n,i){var r=(t.x*t.x+t.y*t.y)*Rs.triArea(e,n,i)-(e.x*e.x+e.y*e.y)*Rs.triArea(t,n,i)+(n.x*n.x+n.y*n.y)*Rs.triArea(t,e,i)-(i.x*i.x+i.y*i.y)*Rs.triArea(t,e,n)>0;return r},Rs.isInCircleRobust=function(t,e,n,i){return Rs.isInCircleNormalized(t,e,n,i)},Rs.triAreaDDSlow=function(t,e,n,i,r,s){return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))},Rs.triAreaDDFast=function(t,e,n){var i=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),r=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r)},e(Ts.prototype,{circleCenter:function(t,e){var n=new Ts(this.getX(),this.getY()),i=this.bisector(n,t),r=this.bisector(t,e),s=new F(i,r),o=null;try{o=new Ts(s.getX(),s.getY())}catch(i){if(!(i instanceof w))throw i;A.err.println("a: "+n+"  b: "+t+"  c: "+e),A.err.println(i)}finally{}return o},dot:function(t){return this.p.x*t.getX()+this.p.y*t.getY()},magn:function(){return Math.sqrt(this.p.x*this.p.x+this.p.y*this.p.y)},getZ:function(){return this.p.z},bisector:function(t,e){var n=e.getX()-t.getX(),i=e.getY()-t.getY(),r=new F(t.getX()+n/2,t.getY()+i/2,1),s=new F(t.getX()-i+n/2,t.getY()+n+i/2,1);return new F(r,s)},equals:function(){if(1===arguments.length){var t=arguments[0];return this.p.x===t.getX()&&this.p.y===t.getY()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.p.distance(e.getCoordinate())<n}},getCoordinate:function(){return this.p},isInCircle:function(t,e,n){return Rs.isInCircleRobust(t.p,e.p,n.p,this.p)},interpolateZValue:function(t,e,n){var i=t.getX(),r=t.getY(),s=e.getX()-i,o=n.getX()-i,a=e.getY()-r,u=n.getY()-r,l=s*u-o*a,h=this.getX()-i,c=this.getY()-r,f=(u*h-o*c)/l,g=(-a*h+s*c)/l,d=t.getZ()+f*(e.getZ()-t.getZ())+g*(n.getZ()-t.getZ());return d},midPoint:function(t){var e=(this.p.x+t.getX())/2,n=(this.p.y+t.getY())/2,i=(this.p.z+t.getZ())/2;return new Ts(e,n,i)},rightOf:function(t){return this.isCCW(t.dest(),t.orig())},isCCW:function(t,e){return(t.p.x-this.p.x)*(e.p.y-this.p.y)-(t.p.y-this.p.y)*(e.p.x-this.p.x)>0},getX:function(){return this.p.x},crossProduct:function(t){return this.p.x*t.getY()-this.p.y*t.getX()},setZ:function(t){this.p.z=t},times:function(t){return new Ts(t*this.p.x,t*this.p.y)},cross:function(){return new Ts(this.p.y,(-this.p.x))},leftOf:function(t){return this.isCCW(t.orig(),t.dest())},toString:function(){return"POINT ("+this.p.x+" "+this.p.y+")"},sub:function(t){return new Ts(this.p.x-t.getX(),this.p.y-t.getY())},getY:function(){return this.p.y},classify:function(t,e){var n=this,i=e.sub(t),r=n.sub(t),s=i.crossProduct(r);return s>0?Ts.LEFT:s<0?Ts.RIGHT:i.getX()*r.getX()<0||i.getY()*r.getY()<0?Ts.BEHIND:i.magn()<r.magn()?Ts.BEYOND:t.equals(n)?Ts.ORIGIN:e.equals(n)?Ts.DESTINATION:Ts.BETWEEN},sum:function(t){return new Ts(this.p.x+t.getX(),this.p.y+t.getY())},distance:function(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))},circumRadiusRatio:function(t,e){var n=this.circleCenter(t,e),i=this.distance(n,t),r=this.distance(this,t),s=this.distance(t,e);return s<r&&(r=s),s=this.distance(e,this),s<r&&(r=s),i/r},interfaces_:function(){return[]},getClass:function(){return Ts}}),Ts.interpolateZ=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=e.distance(n),r=t.distance(e),s=n.z-e.z,o=e.z+s*(r/i);return o}if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3],c=u.x,f=u.y,g=l.x-c,d=h.x-c,p=l.y-f,v=h.y-f,m=g*v-d*p,y=a.x-c,x=a.y-f,E=(v*y-d*x)/m,I=(-p*y+g*x)/m,N=u.z+E*(l.z-u.z)+I*(h.z-u.z);return N}},Ts.LEFT=0,Ts.RIGHT=1,Ts.BEYOND=2,Ts.BEHIND=3,Ts.BETWEEN=4,Ts.ORIGIN=5,Ts.DESTINATION=6,h(Ps,Ts),e(Ps.prototype,{getConstraint:function(){return this.constraint},setOnConstraint:function(t){this._isOnConstraint=t},merge:function(t){t._isOnConstraint&&(this._isOnConstraint=!0,this.constraint=t.constraint)},isOnConstraint:function(){return this._isOnConstraint},setConstraint:function(t){this._isOnConstraint=!0,this.constraint=t},interfaces_:function(){return[]},getClass:function(){return Ps}}),e(bs.prototype,{equalsNonOriented:function(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())},toLineSegment:function(){return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())},dest:function(){return this.sym().orig()},oNext:function(){return this.next},equalsOriented:function(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))},dNext:function(){return this.sym().oNext().sym()},lPrev:function(){return this.next.sym()},rPrev:function(){return this.sym().oNext()},rot:function(){return this._rot},oPrev:function(){return this._rot.next._rot},sym:function(){return this._rot._rot},setOrig:function(t){this.vertex=t},lNext:function(){return this.invRot().oNext().rot()},getLength:function(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())},invRot:function(){return this._rot.sym()},setDest:function(t){this.sym().setOrig(t)},setData:function(t){this.data=t},getData:function(){return this.data},delete:function(){this._rot=null},orig:function(){return this.vertex},rNext:function(){return this._rot.next.invRot()},toString:function(){var t=this.vertex.getCoordinate(),e=this.dest().getCoordinate();return se.toLineString(t,e)},isLive:function(){return null!==this._rot},getPrimary:function(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()},dPrev:function(){return this.invRot().oNext().invRot()},setNext:function(t){this.next=t},interfaces_:function(){return[]},getClass:function(){return bs}}),bs.makeEdge=function(t,e){var n=new bs,i=new bs,r=new bs,s=new bs;n._rot=i,i._rot=r,r._rot=s,s._rot=n,n.setNext(n),i.setNext(s),r.setNext(r),s.setNext(i);var o=n;return o.setOrig(t),o.setDest(e),o},bs.swap=function(t){var e=t.oPrev(),n=t.sym().oPrev();bs.splice(t,e),bs.splice(t.sym(),n),bs.splice(t,e.lNext()),bs.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())},bs.splice=function(t,e){var n=t.oNext().rot(),i=e.oNext().rot(),r=e.oNext(),s=t.oNext(),o=i.oNext(),a=n.oNext();t.setNext(r),e.setNext(s),n.setNext(o),i.setNext(a)},bs.connect=function(t,e){var n=bs.makeEdge(t.dest(),e.orig());return bs.splice(n,t.lNext()),bs.splice(n.sym(),e),n},e(Os.prototype,{insertSite:function(t){var e=this.subdiv.locate(t);if(this.subdiv.isVertexOfEdge(e,t))return e;this.subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this.subdiv.delete(e.oNext()));var n=this.subdiv.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.subdiv.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);for(;;){var r=e.oPrev();if(r.dest().rightOf(e)&&t.isInCircle(e.orig(),r.dest(),e.dest()))bs.swap(e),e=e.oPrev();else{if(e.oNext()===i)return n;e=e.oNext().lPrev()}}},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},interfaces_:function(){return[]},getClass:function(){return Os}}),e(_s.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return _s}}),e(Ms.prototype,{init:function(){this.lastEdge=this.findEdge()},locate:function(t){this.lastEdge.isLive()||this.init();var e=this.subdiv.locateFromEdge(t,this.lastEdge);return this.lastEdge=e,e},findEdge:function(){var t=this.subdiv.getEdges();return t.iterator().next()},interfaces_:function(){return[_s]},getClass:function(){return Ms}}),h(Ds,l),e(Ds.prototype,{getSegment:function(){return this.seg},interfaces_:function(){return[]},getClass:function(){return Ds}}),Ds.msgWithSpatial=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(As.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return As}}),e(Fs.prototype,{getTriangleVertices:function(t){var e=new Bs;return this.visitTriangles(e,t),e.getTriangleVertices()},isFrameVertex:function(t){return!!t.equals(this.frameVertex[0])||(!!t.equals(this.frameVertex[1])||!!t.equals(this.frameVertex[2]))},isVertexOfEdge:function(t,e){return!(!e.equals(t.orig(),this.tolerance)&&!e.equals(t.dest(),this.tolerance))},connect:function(t,e){var n=bs.connect(t,e);return this.quadEdges.add(n),n},getVoronoiCellPolygon:function(t,e){var n=new I,i=t;do{var r=t.rot().orig().getCoordinate();n.add(r),t=t.oPrev()}while(t!==i);var s=new N;s.addAll(n,!1),s.closeRing(),s.size()<4&&(A.out.println(s),s.add(s.get(s.size()-1),!0));var o=s.toCoordinateArray(),a=e.createPolygon(e.createLinearRing(o),null),u=i.orig();return a.setUserData(u.getCoordinate()),a},setLocator:function(t){this.locator=t},initSubdiv:function(){var t=this.makeEdge(this.frameVertex[0],this.frameVertex[1]),e=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);bs.splice(t.sym(),e);var n=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);return bs.splice(e.sym(),n),bs.splice(n.sym(),t),t},isFrameBorderEdge:function(t){var e=new Array(3).fill(null);Fs.getTriangleEdges(t,e);var n=new Array(3).fill(null);Fs.getTriangleEdges(t.sym(),n);var i=t.lNext().dest();if(this.isFrameVertex(i))return!0;var r=t.sym().lNext().dest();return!!this.isFrameVertex(r)},makeEdge:function(t,e){var n=bs.makeEdge(t,e);return this.quadEdges.add(n),n},visitTriangles:function(t,e){this.visitedKey++;var n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=this.fetchTriangleToVisit(r,n,e,i);null!==s&&t.visit(s)}}},isFrameEdge:function(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))},isOnEdge:function(t,e){this.seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());var n=this.seg.distance(e);return n<this.edgeCoincidenceTolerance},getEnvelope:function(){return new C(this.frameEnv)},createFrame:function(t){var e=t.getWidth(),n=t.getHeight(),i=0;i=e>n?10*e:10*n,this.frameVertex[0]=new Ts((t.getMaxX()+t.getMinX())/2,t.getMaxY()+i),this.frameVertex[1]=new Ts(t.getMinX()-i,t.getMinY()-i),this.frameVertex[2]=new Ts(t.getMaxX()+i,t.getMinY()-i),this.frameEnv=new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())},getTriangleCoordinates:function(t){var e=new zs;return this.visitTriangles(e,t),e.getTriangles()},getVertices:function(t){for(var e=new J,n=this.quadEdges.iterator();n.hasNext();){var i=n.next(),r=i.orig();!t&&this.isFrameVertex(r)||e.add(r);var s=i.dest();!t&&this.isFrameVertex(s)||e.add(s)}return e},fetchTriangleToVisit:function(t,e,n,i){var r=t,s=0,o=!1;do{this.triEdges[s]=r,this.isFrameEdge(r)&&(o=!0);var a=r.sym();i.contains(a)||e.push(a),i.add(r),s++,r=r.lNext()}while(r!==t);return o&&!n?null:this.triEdges},getEdges:function(){if(0===arguments.length)return this.quadEdges;if(1===arguments.length){for(var t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createLineString([s.orig().getCoordinate(),s.dest().getCoordinate()])}return t.createMultiLineString(n)}},getVertexUniqueEdges:function(t){for(var e=new I,n=new J,i=this.quadEdges.iterator();i.hasNext();){var r=i.next(),s=r.orig();n.contains(s)||(n.add(s),!t&&this.isFrameVertex(s)||e.add(r));var o=r.sym(),a=o.orig();n.contains(a)||(n.add(a),!t&&this.isFrameVertex(a)||e.add(o))}return e},getTriangleEdges:function(t){var e=new qs;return this.visitTriangles(e,t),e.getTriangleEdges()},getPrimaryEdges:function(t){this.visitedKey++;var e=new I,n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=r.getPrimary();!t&&this.isFrameEdge(s)||e.add(s),n.push(r.oNext()),n.push(r.sym().oNext()),i.add(r),i.add(r.sym())}}return e},delete:function(t){bs.splice(t,t.oPrev()),bs.splice(t.sym(),t.sym().oPrev());var e=t.sym(),n=t.rot(),i=t.rot().sym();this.quadEdges.remove(t),this.quadEdges.remove(e),this.quadEdges.remove(n),this.quadEdges.remove(i),t.delete(),e.delete(),n.delete(),i.delete()},locateFromEdge:function(t,e){for(var n=0,i=this.quadEdges.size(),r=e;;){if(n++,n>i)throw new Ds(r.toLineSegment());if(t.equals(r.orig())||t.equals(r.dest()))break;if(t.rightOf(r))r=r.sym();else if(t.rightOf(r.oNext())){if(t.rightOf(r.dPrev()))break;r=r.dPrev()}else r=r.oNext()}return r},getTolerance:function(){return this.tolerance},getVoronoiCellPolygons:function(t){this.visitTriangles(new Gs,!0);for(var e=new I,n=this.getVertexUniqueEdges(!1),i=n.iterator();i.hasNext();){var r=i.next();e.add(this.getVoronoiCellPolygon(r,t))}return e},getVoronoiDiagram:function(t){var e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e))},getTriangles:function(t){for(var e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createPolygon(t.createLinearRing(s),null)}return t.createGeometryCollection(n)},insertSite:function(t){var e=this.locate(t);if(t.equals(e.orig(),this.tolerance)||t.equals(e.dest(),this.tolerance))return e;var n=this.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);return i},locate:function(){if(1===arguments.length){if(arguments[0]instanceof Ts){var t=arguments[0];return this.locator.locate(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.locator.locate(new Ts(e))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.locator.locate(new Ts(n));if(null===r)return null;var s=r;r.dest().getCoordinate().equals2D(n)&&(s=r.sym());var o=s;do{if(o.dest().getCoordinate().equals2D(i))return o;o=o.oNext()}while(o!==s);return null}},interfaces_:function(){return[]},getClass:function(){return Fs}}),Fs.getTriangleEdges=function(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new i("Edges do not form a triangle")},e(Gs.prototype,{visit:function(t){for(var e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),i=t[2].orig().getCoordinate(),r=Si.circumcentre(e,n,i),s=new Ts(r),o=0;o<3;o++)t[o].rot().setOrig(s)},interfaces_:function(){return[As]},getClass:function(){return Gs}}),e(qs.prototype,{getTriangleEdges:function(){return this.triList},visit:function(t){this.triList.add(t.clone())},interfaces_:function(){return[As]},getClass:function(){return qs}}),e(Bs.prototype,{visit:function(t){this.triList.add([t[0].orig(),t[1].orig(),t[2].orig()])},getTriangleVertices:function(){return this.triList},interfaces_:function(){return[As]},getClass:function(){return Bs}}),e(zs.prototype,{checkTriangleSize:function(t){var e="";t.length>=2?e=se.toLineString(t[0],t[1]):t.length>=1&&(e=se.toPoint(t[0]))},visit:function(t){this.coordList.clear();for(var e=0;e<3;e++){var n=t[e].orig();this.coordList.add(n.getCoordinate())}if(this.coordList.size()>0){this.coordList.closeRing();var i=this.coordList.toCoordinateArray();if(4!==i.length)return null;this.triCoords.add(i)}},getTriangles:function(){return this.triCoords},interfaces_:function(){return[As]},getClass:function(){return zs}}),Fs.TriangleCircumcentreVisitor=Gs,Fs.TriangleEdgesListVisitor=qs,Fs.TriangleVertexListVisitor=Bs,Fs.TriangleCoordinatesVisitor=zs,Fs.EDGE_COINCIDENCE_TOL_FACTOR=1e3,e(Vs.prototype,{getLineSegment:function(){return this.ls},getEndZ:function(){var t=this.ls.getCoordinate(1);return t.z},getStartZ:function(){var t=this.ls.getCoordinate(0);return t.z},intersection:function(t){return this.ls.intersection(t.getLineSegment())},getStart:function(){return this.ls.getCoordinate(0)},getEnd:function(){return this.ls.getCoordinate(1)},getEndY:function(){var t=this.ls.getCoordinate(1);return t.y},getStartX:function(){var t=this.ls.getCoordinate(0);return t.x},equalsTopo:function(t){return this.ls.equalsTopo(t.getLineSegment())},getStartY:function(){var t=this.ls.getCoordinate(0);return t.y},setData:function(t){this.data=t},getData:function(){return this.data},getEndX:function(){var t=this.ls.getCoordinate(1);return t.x},toString:function(){return this.ls.toString()},interfaces_:function(){return[]},getClass:function(){return Vs}}),e(ks.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return ks}}),e(Ys.prototype,{isRepeated:function(){return this.count>1},getRight:function(){return this.right},getCoordinate:function(){return this.p},setLeft:function(t){this.left=t},getX:function(){return this.p.x},getData:function(){return this.data},getCount:function(){return this.count},getLeft:function(){return this.left},getY:function(){return this.p.y},increment:function(){this.count=this.count+1},setRight:function(t){this.right=t},interfaces_:function(){return[]},getClass:function(){return Ys}}),e(Us.prototype,{insert:function(){if(1===arguments.length){var t=arguments[0];return this.insert(t,null)}if(2===arguments.length){var e=arguments[0],n=arguments[1];if(null===this.root)return this.root=new Ys(e,n),this.root;if(this.tolerance>0){var i=this.findBestMatchNode(e);if(null!==i)return i.increment(),i}return this.insertExact(e,n)}},query:function(){var t=arguments,e=this;if(1===arguments.length){var n=arguments[0],i=new I;return this.query(n,i),i}if(2===arguments.length)if(arguments[0]instanceof C&&R(arguments[1],y))!function(){var n=t[0],i=t[1];e.queryNode(e.root,n,!0,{interfaces_:function(){return[ks]},visit:function(t){i.add(t)}})}();else if(arguments[0]instanceof C&&R(arguments[1],ks)){var r=arguments[0],s=arguments[1];this.queryNode(this.root,r,!0,s)}},queryNode:function(t,e,n,i){if(null===t)return null;var r=null,s=null,o=null;n?(r=e.getMinX(),s=e.getMaxX(),o=t.getX()):(r=e.getMinY(),s=e.getMaxY(),o=t.getY());var a=r<o,u=o<=s;a&&this.queryNode(t.getLeft(),e,!n,i),e.contains(t.getCoordinate())&&i.visit(t),u&&this.queryNode(t.getRight(),e,!n,i)},findBestMatchNode:function(t){var e=new Xs(t,this.tolerance);return this.query(e.queryEnvelope(),e),e.getNode()},isEmpty:function(){return null===this.root},insertExact:function(t,e){for(var n=this.root,i=this.root,r=!0,s=!0;null!==n;){if(null!==n){var o=t.distance(n.getCoordinate())<=this.tolerance;if(o)return n.increment(),n}s=r?t.x<n.getX():t.y<n.getY(),i=n,n=s?n.getLeft():n.getRight(),r=!r}this.numberOfNodes=this.numberOfNodes+1;var a=new Ys(t,e);return s?i.setLeft(a):i.setRight(a),a},interfaces_:function(){return[]},getClass:function(){return Us}}),Us.toCoordinates=function(){if(1===arguments.length){var t=arguments[0];return Us.toCoordinates(t,!1)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new N,r=e.iterator();r.hasNext();)for(var s=r.next(),o=n?s.getCount():1,a=0;a<o;a++)i.add(s.getCoordinate(),!0);return i.toCoordinateArray()}},e(Xs.prototype,{visit:function(t){var e=this.p.distance(t.getCoordinate()),n=e<=this.tolerance;if(!n)return null;var i=!1;(null===this.matchNode||e<this.matchDist||null!==this.matchNode&&e===this.matchDist&&t.getCoordinate().compareTo(this.matchNode.getCoordinate())<1)&&(i=!0),i&&(this.matchNode=t,this.matchDist=e)},queryEnvelope:function(){var t=new C(this.p);return t.expandBy(this.tolerance),t},getNode:function(){return this.matchNode},interfaces_:function(){return[ks]},getClass:function(){return Xs}}),Us.BestMatchVisitor=Xs,e(Hs.prototype,{getInitialVertices:function(){return this.initialVertices},getKDT:function(){return this.kdt},enforceConstraints:function(){this.addConstraintVertices();var t=0,e=0;do e=this.enforceGabriel(this.segments),t++;while(e>0&&t<Hs.MAX_SPLIT_ITER)},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},getVertexFactory:function(){return this.vertexFactory},getPointArray:function(){for(var t=new Array(this.initialVertices.size()+this.segVertices.size()).fill(null),e=0,n=this.initialVertices.iterator();n.hasNext();){var i=n.next();t[e++]=i.getCoordinate()}for(var r=this.segVertices.iterator();r.hasNext();){var i=r.next();t[e++]=i.getCoordinate()}return t},setConstraints:function(t,e){this.segments=t,this.segVertices=e},computeConvexHull:function(){var t=new ie,e=this.getPointArray(),n=new me(e,t);this.convexHull=n.getConvexHull()},addConstraintVertices:function(){this.computeConvexHull(),this.insertSites(this.segVertices)},findNonGabrielPoint:function(t){var e=t.getStart(),n=t.getEnd(),i=new g((e.x+n.x)/2,(e.y+n.y)/2),s=e.distance(i),o=new C(i);o.expandBy(s);for(var a=this.kdt.query(o),u=null,l=r.MAX_VALUE,h=a.iterator();h.hasNext();){var c=h.next(),f=c.getCoordinate();if(!f.equals2D(e)&&!f.equals2D(n)){var d=i.distance(f);if(d<s){var p=d;(null===u||p<l)&&(u=f,l=p)}}}return u},getConstraintSegments:function(){return this.segments},setSplitPointFinder:function(t){this.splitFinder=t},getConvexHull:function(){return this.convexHull},getTolerance:function(){return this.tolerance},enforceGabriel:function(t){for(var e=new I,n=0,i=new I,r=t.iterator();r.hasNext();){var s=r.next(),o=this.findNonGabrielPoint(s);if(null!==o){this.splitPt=this.splitFinder.findSplitPoint(s,o);var a=this.createVertex(this.splitPt,s),u=(this.insertSite(a),new Vs(s.getStartX(),s.getStartY(),s.getStartZ(),a.getX(),a.getY(),a.getZ(),s.getData())),l=new Vs(a.getX(),a.getY(),a.getZ(),s.getEndX(),s.getEndY(),s.getEndZ(),s.getData());e.add(u),e.add(l),i.add(s),n+=1}}return t.removeAll(i),t.addAll(e),n},createVertex:function(){if(1===arguments.length){var t=arguments[0],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(t,null):new Ps(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(n,i):new Ps(n),e.setOnConstraint(!0),e}},getSubdivision:function(){return this.subdiv},computeBoundingBox:function(){var t=Hs.computeVertexEnvelope(this.initialVertices),e=Hs.computeVertexEnvelope(this.segVertices),n=new C(t);n.expandToInclude(e);var i=.2*n.getWidth(),r=.2*n.getHeight(),s=Math.max(i,r);this.computeAreaEnv=new C(n),this.computeAreaEnv.expandBy(s)},setVertexFactory:function(t){this.vertexFactory=t},formInitialDelaunay:function(){this.computeBoundingBox(),this.subdiv=new Fs(this.computeAreaEnv,this.tolerance),this.subdiv.setLocator(new Ms(this.subdiv)),this.incDel=new Os(this.subdiv),this.insertSites(this.initialVertices)},insertSite:function(){if(arguments[0]instanceof Ps){var t=arguments[0],e=this.kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){var n=e.getData();return n.merge(t),n}return this.incDel.insertSite(t),t}if(arguments[0]instanceof g){var i=arguments[0];this.insertSite(this.createVertex(i))}},interfaces_:function(){return[]},getClass:function(){return Hs}}),Hs.computeVertexEnvelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i.getCoordinate())}return e},Hs.MAX_SPLIT_ITER=99,e(Ws.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var n=new Os(this.subdiv);n.insertSites(e)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},interfaces_:function(){return[]},getClass:function(){return Ws}}),Ws.extractUniqueCoordinates=function(t){if(null===t)return new N;var e=t.getCoordinates();return Ws.unique(e)},Ws.envelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i)}return e},Ws.unique=function(t){var e=H.copyDeep(t);ut.sort(e);var n=new N(e,(!1));return n},Ws.toVertices=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ts(i))}return e},e(js.prototype,{createSiteVertices:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();this.constraintVertexMap.containsKey(i)||e.add(new Ps(i))}return e},create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=new I;null!==this.constraintLines&&(t.expandToInclude(this.constraintLines.getEnvelopeInternal()),this.createVertices(this.constraintLines),e=js.createConstraintSegments(this.constraintLines));var n=this.createSiteVertices(this.siteCoords),i=new Hs(n,this.tolerance);i.setConstraints(e,new I(this.constraintVertexMap.values())),i.formInitialDelaunay(),i.enforceConstraints(),this.subdiv=i.getSubdivision()},setTolerance:function(t){this.tolerance=t},setConstraints:function(t){this.constraintLines=t},setSites:function(t){this.siteCoords=Ws.extractUniqueCoordinates(t)},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},createVertices:function(t){for(var e=t.getCoordinates(),n=0;n<e.length;n++){var i=new Ps(e[n]);this.constraintVertexMap.put(e[n],i)}},interfaces_:function(){return[]},getClass:function(){return js}}),js.createConstraintSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=kn.getLines(t),n=new I,i=e.iterator();i.hasNext();){var r=i.next();js.createConstraintSegments(r,n)}return n}if(2===arguments.length)for(var s=arguments[0],o=arguments[1],a=s.getCoordinates(),i=1;i<a.length;i++)o.add(new Vs(a[i-1],a[i]))},e(Ks.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords);this.diagramEnv=t;var e=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(e),null!==this.clipEnv&&this.diagramEnv.expandToInclude(this.clipEnv);var n=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var i=new Os(this.subdiv);i.insertSites(n)},getDiagram:function(t){this.create();var e=this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e,this.diagramEnv)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},setClipEnvelope:function(t){this.clipEnv=t},getSubdivision:function(){return this.create(),this.subdiv},interfaces_:function(){return[]},getClass:function(){return Ks}}),Ks.clipGeometryCollection=function(t,e){for(var n=t.getFactory().toGeometry(e),i=new I,r=0;r<t.getNumGeometries();r++){var s=t.getGeometryN(r),o=null;e.contains(s.getEnvelopeInternal())?o=s:e.intersects(s.getEnvelopeInternal())&&(o=n.intersection(s),o.setUserData(s.getUserData())),null===o||o.isEmpty()||i.add(o)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(i))};var Ao=Object.freeze({Vertex:Ts}),Fo=Object.freeze({ConformingDelaunayTriangulationBuilder:js,DelaunayTriangulationBuilder:Ws,VoronoiDiagramBuilder:Ks,quadedge:Ao});e(Zs.prototype,{interfaces_:function(){return[]},getClass:function(){return Zs}}),Zs.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.UNION)},e(B.prototype,{equalsTopo:function(t){return!!this.getEnvelopeInternal().equals(t.getEnvelopeInternal())&&rs.relate(this,t).isEquals(this.getDimension(),t.getDimension())},union:function(){if(0===arguments.length)return ls.union(this);if(1===arguments.length){var t=arguments[0];return Zs.union(this,t)}},isValid:function(){return Ur.isValid(this)},intersection:function(t){if(this.isEmpty()||t.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,this,t,this.factory);if(this.isGeometryCollection()){var e=t;return hn.map(this,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(e)}})}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.INTERSECTION)},covers:function(t){return rs.covers(this,t)},coveredBy:function(t){return rs.coveredBy(this,t)},touches:function(t){return rs.touches(this,t)},intersects:function(t){return rs.intersects(this,t)},within:function(t){return rs.within(this,t)},overlaps:function(t){return rs.overlaps(this,t)},disjoint:function(t){return rs.disjoint(this,t)},crosses:function(t){return rs.crosses(this,t)},buffer:function(){if(1===arguments.length){var t=arguments[0];return dr.bufferOp(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return dr.bufferOp(this,e,n)}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];return dr.bufferOp(this,i,r,s)}},convexHull:function(){return new me(this).getConvexHull()},relate:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return rs.relate.apply(rs,[this].concat(e))},getCentroid:function(){if(this.isEmpty())return this.factory.createPoint();var t=ge.getCentroid(this);return this.createPointFromInternalCoord(t,this)},getInteriorPoint:function(){if(this.isEmpty())return this.factory.createPoint();var t=null,e=this.getDimension();if(0===e){var n=new li(this);t=n.getInteriorPoint()}else if(1===e){var n=new ui(this);t=n.getInteriorPoint()}else{var n=new oi(this);t=n.getInteriorPoint()}return this.createPointFromInternalCoord(t,this)},symDifference:function(t){if(this.isEmpty()||t.isEmpty()){if(this.isEmpty()&&t.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,this,t,this.factory);if(this.isEmpty())return t.copy();if(t.isEmpty())return this.copy()}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.SYMDIFFERENCE)},createPointFromInternalCoord:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},toText:function(){var t=new se;return t.write(this)},toString:function(){this.toText()},contains:function(t){return rs.contains(this,t)},difference:function(t){return this.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,this,t,this.factory):t.isEmpty()?this.copy():(this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.DIFFERENCE))},isSimple:function(){var t=new Wi(this);return t.isSimple()},isWithinDistance:function(t,e){var n=this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return!(n>e)&&xr.isWithinDistance(this,t,e)},distance:function(t){return xr.distance(this,t)},isEquivalentClass:function(t){return this.getClass()===t.getClass()}});var Go="1.3.0 (6e65adb)";t.version=Go,t.algorithm=co,t.densify=fo,t.dissolve=go,t.geom=lo,t.geomgraph=po,t.index=yo,t.io=No,t.noding=Co,t.operation=_o,t.precision=Mo,t.simplify=Do,t.triangulate=Fo,Object.defineProperty(t,"__esModule",{value:!0})});

},{}],166:[function(require,module,exports){
'use strict';

module.exports = lineclip;

lineclip.polyline = lineclip;
lineclip.polygon = polygonclip;


// Cohen-Sutherland line clippign algorithm, adapted to efficiently
// handle polylines rather than just segments

function lineclip(points, bbox, result) {

    var len = points.length,
        codeA = bitCode(points[0], bbox),
        part = [],
        i, a, b, codeB, lastCode;

    if (!result) result = [];

    for (i = 1; i < len; i++) {
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);

        while (true) {

            if (!(codeA | codeB)) { // accept
                part.push(a);

                if (codeB !== lastCode) { // segment went outside
                    part.push(b);

                    if (i < len - 1) { // start a new line
                        result.push(part);
                        part = [];
                    }
                } else if (i === len - 1) {
                    part.push(b);
                }
                break;

            } else if (codeA & codeB) { // trivial reject
                break;

            } else if (codeA) { // a outside, intersect with clip edge
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);

            } else { // b outside
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }

        codeA = lastCode;
    }

    if (part.length) result.push(part);

    return result;
}

// Sutherland-Hodgeman polygon clipping algorithm

function polygonclip(points, bbox) {

    var result, edge, prev, prevInside, i, p, inside;

    // clip against each side of the clip rectangle
    for (edge = 1; edge <= 8; edge *= 2) {
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);

        for (i = 0; i < points.length; i++) {
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);

            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

            if (inside) result.push(p); // add a point if it's inside

            prev = p;
            prevInside = inside;
        }

        points = result;

        if (!points.length) break;
    }

    return result;
}

// intersect a segment against one of the 4 lines that make up the bbox

function intersect(a, b, edge, bbox) {
    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
           null;
}

// bit code reflects the point position relative to the bbox:

//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110

function bitCode(p, bbox) {
    var code = 0;

    if (p[0] < bbox[0]) code |= 1; // left
    else if (p[0] > bbox[2]) code |= 2; // right

    if (p[1] < bbox[1]) code |= 4; // bottom
    else if (p[1] > bbox[3]) code |= 8; // top

    return code;
}

},{}],167:[function(require,module,exports){
(function (global){
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],168:[function(require,module,exports){
'use strict'

module.exports = monotoneConvexHull2D

var orient = require('robust-orientation')[3]

function monotoneConvexHull2D(points) {
  var n = points.length

  if(n < 3) {
    var result = new Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = i
    }

    if(n === 2 &&
       points[0][0] === points[1][0] &&
       points[0][1] === points[1][1]) {
      return [0]
    }

    return result
  }

  //Sort point indices along x-axis
  var sorted = new Array(n)
  for(var i=0; i<n; ++i) {
    sorted[i] = i
  }
  sorted.sort(function(a,b) {
    var d = points[a][0]-points[b][0]
    if(d) {
      return d
    }
    return points[a][1] - points[b][1]
  })

  //Construct upper and lower hulls
  var lower = [sorted[0], sorted[1]]
  var upper = [sorted[0], sorted[1]]

  for(var i=2; i<n; ++i) {
    var idx = sorted[i]
    var p   = points[idx]

    //Insert into lower list
    var m = lower.length
    while(m > 1 && orient(
        points[lower[m-2]], 
        points[lower[m-1]], 
        p) <= 0) {
      m -= 1
      lower.pop()
    }
    lower.push(idx)

    //Insert into upper list
    m = upper.length
    while(m > 1 && orient(
        points[upper[m-2]], 
        points[upper[m-1]], 
        p) >= 0) {
      m -= 1
      upper.pop()
    }
    upper.push(idx)
  }

  //Merge lists together
  var result = new Array(upper.length + lower.length - 2)
  var ptr    = 0
  for(var i=0, nl=lower.length; i<nl; ++i) {
    result[ptr++] = lower[i]
  }
  for(var j=upper.length-2; j>0; --j) {
    result[ptr++] = upper[j]
  }

  //Return result
  return result
}
},{"robust-orientation":175}],169:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],170:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":172}],171:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin() for .
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],172:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],173:[function(require,module,exports){
'use strict';

module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],174:[function(require,module,exports){
'use strict';

module.exports = rbush;

var quickselect = require('quickselect');

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

},{"quickselect":173}],175:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var robustSubtract = require("robust-subtract")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function cofactor(m, c) {
  var result = new Array(m.length-1)
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1)
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j]
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n)
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("")
    }
  }
  return result
}

function sign(n) {
  if(n & 1) {
    return "-"
  }
  return ""
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function determinant(m) {
  if(m.length === 2) {
    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
  } else {
    var expr = []
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
    }
    return expr
  }
}

function orientation(n) {
  var pos = []
  var neg = []
  var m = matrix(n)
  var args = []
  for(var i=0; i<n; ++i) {
    if((i&1)===0) {
      pos.push.apply(pos, determinant(cofactor(m, i)))
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)))
    }
    args.push("m" + i)
  }
  var posExpr = generateSum(pos)
  var negExpr = generateSum(neg)
  var funcName = "orientation" + n + "Exact"
  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("")
  var proc = new Function("sum", "prod", "scale", "sub", code)
  return proc(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) { 
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy) 
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  var args = []
  var procArgs = ["slow"]
  for(var i=0; i<=NUM_EXPAND; ++i) {
    args.push("a" + i)
    procArgs.push("o" + i)
  }
  var code = [
    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
  ]
  for(var i=2; i<=NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
  procArgs.push(code.join(""))

  var proc = Function.apply(undefined, procArgs)
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()
},{"robust-scale":176,"robust-subtract":177,"robust-sum":178,"two-product":189}],176:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var twoSum = require("two-sum")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}
},{"two-product":189,"two-sum":190}],177:[function(require,module,exports){
"use strict"

module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],178:[function(require,module,exports){
"use strict"

module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],179:[function(require,module,exports){
var isects = require('geojson-polygon-self-intersections');
var helpers = require('@turf/helpers');
var within = require('@turf/within');
var area = require('@turf/area');
var rbush = require('rbush');
var debug = require('debug')('simplepolygon');
var debugAll = require('debug')('simplepolygon:all');

/**
* Takes a complex (i.e. self-intersecting) geojson polygon, and breaks it down into its composite simple, non-self-intersecting one-ring polygons.
*
* @module simplepolygon
* @param {Feature} feature Input polygon. This polygon may be unconform the {@link https://en.wikipedia.org/wiki/Simple_Features|Simple Features standard} in the sense that it's inner and outer rings may cross-intersect or self-intersect, that the outer ring must not contain the optional inner rings and that the winding number must not be positive for the outer and negative for the inner rings.
* @return {FeatureCollection} Feature collection containing the simple, non-self-intersecting one-ring polygon features that the complex polygon is composed of. These simple polygons have properties such as their parent polygon, winding number and net winding number.
*
* @example
* var poly = {
*   "type": "Feature",
*   "geometry": {
*     "type": "Polygon",
*     "coordinates": [[[0,0],[2,0],[0,2],[2,2],[0,0]]]
*   }
* };
*
* var result = simplepolygon(poly);
*
* // =result
* // which will be a featureCollection of two polygons, one with coordinates [[[0,0],[2,0],[1,1],[0,0]]], parent -1, winding 1 and net winding 1, and one with coordinates [[[1,1],[0,2],[2,2],[1,1]]], parent -1, winding -1 and net winding -1
*/

module.exports = function(feature) {
  // Check input
  if (feature.type != "Feature") throw new Error("The input must a geojson object of type Feature");
  if ((feature.geometry === undefined) || (feature.geometry == null)) throw new Error("The input must a geojson object with a non-empty geometry");
  if (feature.geometry.type != "Polygon") throw new Error("The input must be a geojson Polygon");

  // Process input
  var numRings = feature.geometry.coordinates.length;
  var vertices = [];
  for (var i = 0; i < numRings; i++) {
    var ring = feature.geometry.coordinates[i];
    if (!equalArrays(ring[0],ring[ring.length-1])) {
      ring.push(ring[0]) // Close input ring if it is not
    }
    vertices.push.apply(vertices,ring.slice(0,ring.length-1));
  }
  if (!isUnique(vertices)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
  var numvertices = vertices.length; // number of input ring vertices, with the last closing vertices not counted
  debug("Processing input");

  // Compute self-intersections
  var selfIsectsData = isects(feature, function filterFn(isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique){
    return [isect, ring0, edge0, start0, end0, frac0, ring1, edge1, start1, end1, frac1, unique];
  });
  var numSelfIsect = selfIsectsData.length;
  debug("Computing self-intersections");

  // If no self-intersections are found, the input rings are the output rings. Hence, we must only compute their winding numbers, net winding numbers and (since ohers rings could lie outside the first ring) parents.
  if (numSelfIsect == 0) {
    var outputFeatureArray = [];
    for(var i = 0; i < numRings; i++) {
      outputFeatureArray.push(helpers.polygon([feature.geometry.coordinates[i]],{parent: -1, winding: windingOfRing(feature.geometry.coordinates[i])}));
    }
    var output = helpers.featureCollection(outputFeatureArray)
    determineParents();
    setNetWinding();
    debugAll("No self-intersections found. Input rings are output rings. Computed winding numbers, net winding numbers and parents");
    debug("Finishing without self-intersections");
    return output;
  }

  // If self-intersections are found, we will compute the output rings with the help of two intermediate variables
  // First, we build the pseudo vertex list and intersection list
  // The Pseudo vertex list is an array with for each ring an array with for each edge an array containing the pseudo-vertices (as made by their constructor) that have this ring and edge as ringAndEdgeIn, sorted for each edge by their fractional distance on this edge. It's length hence equals numRings.
  var pseudoVtxListByRingAndEdge = [];
  // The intersection list is an array containing intersections (as made by their constructor). First all numvertices ring-vertex-intersections, then all self-intersections (intra- and inter-ring). The order of the latter is not important but is permanent once given.
  var isectList = [];
  // Adding ring-pseudo-vertices to pseudoVtxListByRingAndEdge and ring-vertex-intersections to isectList
  for (var i = 0; i < numRings; i++) {
    pseudoVtxListByRingAndEdge.push([]);
    for (var j = 0; j < feature.geometry.coordinates[i].length-1; j++) {
      // Each edge will feature one ring-pseudo-vertex in its array, on the last position. i.e. edge j features the ring-pseudo-vertex of the ring vertex j+1, which has ringAndEdgeIn = [i,j], on the last position.
      pseudoVtxListByRingAndEdge[i].push([new PseudoVtx(feature.geometry.coordinates[i][(j+1).modulo(feature.geometry.coordinates[i].length-1)], 1, [i, j], [i, (j+1).modulo(feature.geometry.coordinates[i].length-1)], undefined)]);
      // The first numvertices elements in isectList correspond to the ring-vertex-intersections
      isectList.push(new Isect(feature.geometry.coordinates[i][j], [i, (j-1).modulo(feature.geometry.coordinates[i].length-1)], [i, j], undefined, undefined, false, true));
    }
  }
  // Adding intersection-pseudo-vertices to pseudoVtxListByRingAndEdge and self-intersections to isectList
  for (var i = 0; i < numSelfIsect; i++) {
    // Adding intersection-pseudo-vertices made using selfIsectsData to pseudoVtxListByRingAndEdge's array corresponding to the incomming ring and edge
    pseudoVtxListByRingAndEdge[selfIsectsData[i][1]][selfIsectsData[i][2]].push(new PseudoVtx(selfIsectsData[i][0], selfIsectsData[i][5], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined));
    // selfIsectsData contains double mentions of each intersection, but we only want to add them once to isectList
    if (selfIsectsData[i][11]) isectList.push(new Isect(selfIsectsData[i][0], [selfIsectsData[i][1], selfIsectsData[i][2]], [selfIsectsData[i][6], selfIsectsData[i][7]], undefined, undefined, true, true));
  }
  var numIsect = isectList.length;
  // Sort edge arrays of pseudoVtxListByRingAndEdge by the fractional distance 'param'
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++) {
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++) {
      pseudoVtxListByRingAndEdge[i][j].sort(function(a, b){ return (a.param < b.param) ? -1 : 1 ; } );
    }
  }
  debug("Setting up pseudoVtxListByRingAndEdge and isectList");

  // Make a spatial index of intersections, in preperation for the following two steps
  allIsectsAsIsectRbushTreeItem = [];
  for (var i = 0; i < numIsect; i++) {
    allIsectsAsIsectRbushTreeItem.push({minX: isectList[i].coord[0], minY: isectList[i].coord[1], maxX: isectList[i].coord[0], maxY: isectList[i].coord[1], index: i}); // could pass isect: isectList[i], but not necessary
  }
  var isectRbushTree = rbush();
  isectRbushTree.load(allIsectsAsIsectRbushTreeItem);

  // Now we will teach each intersection in isectList which is the next intersection along both it's [ring, edge]'s, in two steps.
  // First, we find the next intersection for each pseudo-vertex in pseudoVtxListByRingAndEdge:
  // For each pseudovertex in pseudoVtxListByRingAndEdge (3 loops) look at the next pseudovertex on that edge and find the corresponding intersection by comparing coordinates
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++){
        var coordToFind;
        if (k == pseudoVtxListByRingAndEdge[i][j].length-1) { // If it's the last pseudoVertex on that edge, then the next pseudoVertex is the first one on the next edge of that ring.
          coordToFind = pseudoVtxListByRingAndEdge[i][(j+1).modulo(feature.geometry.coordinates[i].length-1)][0].coord;
        } else {
          coordToFind = pseudoVtxListByRingAndEdge[i][j][k+1].coord;
        }
        var IsectRbushTreeItemFound = isectRbushTree.search({minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1]})[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
        pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn = IsectRbushTreeItemFound.index;
      }
    }
  }
  debug("Computing nextIsect for pseudoVtxListByRingAndEdge");

  // Second, we port this knowledge of the next intersection over to the intersections in isectList, by finding the intersection corresponding to each pseudo-vertex and copying the pseudo-vertex' knownledge of the next-intersection over to the intersection
  for (var i = 0; i < pseudoVtxListByRingAndEdge.length; i++){
    for (var j = 0; j < pseudoVtxListByRingAndEdge[i].length; j++){
      for (var k = 0; k < pseudoVtxListByRingAndEdge[i][j].length; k++){
        var coordToFind = pseudoVtxListByRingAndEdge[i][j][k].coord;
        var IsectRbushTreeItemFound = isectRbushTree.search({minX: coordToFind[0], minY: coordToFind[1], maxX: coordToFind[0], maxY: coordToFind[1]})[0]; // We can take [0] of the result, because there is only one isect correponding to a pseudo-vertex
        var l = IsectRbushTreeItemFound.index;
        if (l < numvertices) { // Special treatment at ring-vertices: we correct the misnaming that happened in the previous block, since ringAndEdgeOut = ringAndEdge2 for ring vertices.
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
        } else { // Port the knowledge of the next intersection from the pseudo-vertices to the intersections, depending on how the edges are labeled in the pseudo-vertex and intersection.
          if (equalArrays(isectList[l].ringAndEdge1, pseudoVtxListByRingAndEdge[i][j][k].ringAndEdgeIn)) {
            isectList[l].nxtIsectAlongRingAndEdge1 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          } else {
            isectList[l].nxtIsectAlongRingAndEdge2 = pseudoVtxListByRingAndEdge[i][j][k].nxtIsectAlongEdgeIn;
          }
        }
      }
    }
  }
  // This explains why, eventhough when we will walk away from an intersection, we will walk way from the corresponding pseudo-vertex along edgeOut, pseudo-vertices have the property 'nxtIsectAlongEdgeIn' in stead of some propery 'nxtPseudoVtxAlongEdgeOut'. This is because this property (which is easy to find out) is used in the above for nxtIsectAlongRingAndEdge1 and nxtIsectAlongRingAndEdge2!
  debug("Porting nextIsect to isectList");

  // Before we start walking over the intersections to build the output rings, we prepare a queue that stores information on intersections we still have to deal with, and put at least one intersection in it.
  // This queue will contain information on intersections where we can start walking from once the current walk is finished, and its parent output ring (the smallest output ring it lies within, -1 if no parent or parent unknown yet) and its winding number (which we can already determine).
  var queue = []
  // For each output ring, add the ring-vertex-intersection with the smalles x-value (i.e. the left-most) as a start intersection. By choosing such an extremal intersections, we are sure to start at an intersection that is a convex vertex of its output ring. By adding them all to the queue, we are sure that no rings will be forgotten. If due to ring-intersections such an intersection will be encountered while walking, it will be removed from the queue.
  var i = 0;
  for (var j = 0; j < numRings; j++) {
    var leftIsect = i;
    for (var k = 0; k < feature.geometry.coordinates[j].length-1; k++) {
      if (isectList[i].coord[0] < isectList[leftIsect].coord[0]) {
        leftIsect = i;
      }
      i++;
    }
    // Compute winding at this left-most ring-vertex-intersection. We thus this by using our knowledge that this extremal vertex must be a convex vertex.
    // We first find the intersection before and after it, and then use them to determine the winding number of the corresponding output ring, since we know that an extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it would not be is because the winding number we use to compute it is wrong
    var isectAfterLeftIsect = isectList[leftIsect].nxtIsectAlongRingAndEdge2;
    for (var k = 0; k < isectList.length; k++) {
      if ((isectList[k].nxtIsectAlongRingAndEdge1 == leftIsect) || (isectList[k].nxtIsectAlongRingAndEdge2 == leftIsect)) {
        var isectBeforeLeftIsect = k;
        break
      }
    }
    var windingAtIsect = isConvex([isectList[isectBeforeLeftIsect].coord,isectList[leftIsect].coord,isectList[isectAfterLeftIsect].coord],true) ? 1 : -1;

    queue.push({isect: leftIsect, parent: -1, winding: windingAtIsect})
  }
  // Sort the queue by the same criterion used to find the leftIsect: the left-most leftIsect must be last in the queue, such that it will be popped first, such that we will work from out to in regarding input rings. This assumtion is used when predicting the winding number and parent of a new queue member.
  queue.sort(function(a, b){ return (isectList[a.isect].coord > isectList[b.isect].coord) ? -1 : 1 });
  debugAll("Initial state of the queue: " + JSON.stringify(queue));
  debug("Setting up queue");

  // Initialise output
  var outputFeatureArray = [];

  // While the queue is not empty, take the last object (i.e. its intersection) out and start making an output ring by walking in the direction that has not been walked away over yet.
  while (queue.length>0) {
    // Get the last object out of the queue
    var popped = queue.pop();
    var startIsect = popped.isect;
    var currentOutputRingParent = popped.parent;
    var currentOutputRingWinding = popped.winding;
    // Make new output ring and add vertex from starting intersection
    var currentOutputRing = outputFeatureArray.length;
    var currentOutputRingCoords = [isectList[startIsect].coord];
    debugAll("# Starting output ring number " + outputFeatureArray.length + " with winding " + currentOutputRingWinding + " from intersection " + startIsect);
    if (startIsect < numvertices) debugAll("This is a ring-vertex-intersections, which means this output ring does not touch existing output rings");
    // Set up the variables used while walking over intersections: 'currentIsect', 'nxtIsect' and 'walkingRingAndEdge'
    var currentIsect = startIsect;
    if (isectList[startIsect].ringAndEdge1Walkable) {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge1;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge1;
    } else {
      var walkingRingAndEdge = isectList[startIsect].ringAndEdge2;
      var nxtIsect = isectList[startIsect].nxtIsectAlongRingAndEdge2;
    }
    // While we have not arrived back at the same intersection, keep walking
    while (!equalArrays(isectList[startIsect].coord,isectList[nxtIsect].coord)){
      debugAll("Walking from intersection " + currentIsect + " to " + nxtIsect + " over ring " + walkingRingAndEdge[0] + " and edge " + walkingRingAndEdge[1]);
      currentOutputRingCoords.push(isectList[nxtIsect].coord);
      debugAll("Adding intersection " + nxtIsect + " to current output ring");
      // If the next intersection is queued, we can remove it, because we will go there now.
      var nxtIsectInQueue = undefined;
      for(var i = 0; i < queue.length; i++) { if (queue[i].isect == nxtIsect) {nxtIsectInQueue = i; break; } }
      if (nxtIsectInQueue != undefined) {
        debugAll("Removing intersection " + nxtIsect + " from queue");
        queue.splice(nxtIsectInQueue,1);
      }
      // Arriving at this new intersection, we know which will be our next walking ring and edge (if we came from 1 we will walk away from 2 and vice versa),
      // So we can set it as our new walking ring and intersection and remember that we (will) have walked over it
      // If we have never walked away from this new intersection along the other ring and edge then we will soon do, add the intersection (and the parent wand winding number) to the queue
      // (We can predict the winding number and parent as follows: if the edge is convex, the other output ring started from there will have the alternate winding and lie outside of the current one, and thus have the same parent ring as the current ring. Otherwise, it will have the same winding number and lie inside of the current ring. We are, however, only sure of this of an output ring started from there does not enclose the current ring. This is why the initial queue's intersections must be sorted such that outer ones come out first.)
      // We then update the other two walking variables.
      if (equalArrays(walkingRingAndEdge,isectList[nxtIsect].ringAndEdge1)) {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge2;
        isectList[nxtIsect].ringAndEdge2Walkable = false;
        if (isectList[nxtIsect].ringAndEdge1Walkable) {
          debugAll("Adding intersection " + nxtIsect + " to queue");
          var pushing = {isect: nxtIsect};
          if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge2].coord],currentOutputRingWinding == 1)) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge2;
      } else {
        walkingRingAndEdge = isectList[nxtIsect].ringAndEdge1;
        isectList[nxtIsect].ringAndEdge1Walkable = false;
        if (isectList[nxtIsect].ringAndEdge2Walkable) {
          debugAll("Adding intersection " + nxtIsect + " to queue");
          var pushing = {isect: nxtIsect};
          if (isConvex([isectList[currentIsect].coord, isectList[nxtIsect].coord, isectList[isectList[nxtIsect].nxtIsectAlongRingAndEdge1].coord],currentOutputRingWinding == 1)) {
            pushing.parent = currentOutputRingParent;
            pushing.winding = -currentOutputRingWinding;
          } else {
            pushing.parent = currentOutputRing;
            pushing.winding = currentOutputRingWinding;
          }
          queue.push(pushing);
        }
        currentIsect = nxtIsect;
        nxtIsect = isectList[nxtIsect].nxtIsectAlongRingAndEdge1;
      }
      debugAll("Current state of the queue: " + JSON.stringify(queue));
    }
    debugAll("Walking from intersection " + currentIsect + " to " + nxtIsect + " over ring " + walkingRingAndEdge[0] + " and edge " + walkingRingAndEdge[1] + " and closing ring");
    // Close output ring
    currentOutputRingCoords.push(isectList[nxtIsect].coord);
    // Push output ring to output
    outputFeatureArray.push(helpers.polygon([currentOutputRingCoords],{index: currentOutputRing, parent: currentOutputRingParent, winding: currentOutputRingWinding, netWinding: undefined}));
  }

  var output = helpers.featureCollection(outputFeatureArray);
  debug("Walking");

  determineParents();
  debug("Determining parents");

  setNetWinding();
  debug("Setting winding number");

  // These functions are also used if no intersections are found
  function determineParents() {
    var featuresWithoutParent = [];
    for (var i = 0; i < output.features.length; i++) {
      debugAll("Output ring " + i + " has parent " + output.features[i].properties.parent);
      if (output.features[i].properties.parent == -1) featuresWithoutParent.push(i);
    }
    debugAll("The following output ring(s) have no parent: " + featuresWithoutParent);
    if (featuresWithoutParent.length > 1) {
      for (var i = 0; i < featuresWithoutParent.length; i++) {
        var parent = -1;
        var parentArea = Infinity;
        for (var j = 0; j < output.features.length; j++) {
          if (featuresWithoutParent[i] == j) continue
          if (within(helpers.featureCollection([helpers.point(output.features[featuresWithoutParent[i]].geometry.coordinates[0][0])]),helpers.featureCollection([output.features[j]])).features.length == 1) {
            if (area(output.features[j]) < parentArea) {
              parent = j;
              debugAll("Ring "+featuresWithoutParent[i]+" lies within output ring "+j);
            }
          }
        }
        output.features[featuresWithoutParent[i]].properties.parent = parent;
        debugAll("Ring "+featuresWithoutParent[i]+" is assigned parent "+parent);
      }
    }
  }

  function setNetWinding() {
    for (var i = 0; i < output.features.length; i++) {
      if (output.features[i].properties.parent == -1) {
        var netWinding = output.features[i].properties.winding
        output.features[i].properties.netWinding = netWinding;
        setNetWindingOfChildren(i,netWinding)
      }
    }
  }

  function setNetWindingOfChildren(parent,ParentNetWinding){
    for (var i = 0; i < output.features.length; i++) {
      if (output.features[i].properties.parent == parent){
        var netWinding = ParentNetWinding + output.features[i].properties.winding
        output.features[i].properties.netWinding = netWinding;
        setNetWindingOfChildren(i,netWinding)
      }
    }
  }

  debugAll("# Total of " + output.features.length + " rings");

  return output;
}



// Constructor for (ring- or intersection-) pseudo-vertices.
var PseudoVtx = function (coord, param, ringAndEdgeIn, ringAndEdgeOut, nxtIsectAlongEdgeIn) {
  this.coord = coord; // [x,y] of this pseudo-vertex
  this.param = param; // fractional distance of this intersection on incomming edge
  this.ringAndEdgeIn = ringAndEdgeIn; // [ring index, edge index] of incomming edge
  this.ringAndEdgeOut = ringAndEdgeOut; // [ring index, edge index] of outgoing edge
  this.nxtIsectAlongEdgeIn = nxtIsectAlongEdgeIn; // The next intersection when following the incomming edge (so not when following ringAndEdgeOut!)
}

// Constructor for an intersection. There are two intersection-pseudo-vertices per self-intersection and one ring-pseudo-vertex per ring-vertex-intersection. Their labels 1 and 2 are not assigned a particular meaning but are permanent once given.
var Isect = function (coord, ringAndEdge1, ringAndEdge2, nxtIsectAlongRingAndEdge1, nxtIsectAlongRingAndEdge2, ringAndEdge1Walkable, ringAndEdge2Walkable) {
  this.coord = coord; // [x,y] of this intersection
  this.ringAndEdge1 = ringAndEdge1; // first edge of this intersection
  this.ringAndEdge2 = ringAndEdge2; // second edge of this intersection
  this.nxtIsectAlongRingAndEdge1 = nxtIsectAlongRingAndEdge1; // the next intersection when following ringAndEdge1
  this.nxtIsectAlongRingAndEdge2 = nxtIsectAlongRingAndEdge2; // the next intersection when following ringAndEdge2
  this.ringAndEdge1Walkable = ringAndEdge1Walkable; // May we (still) walk away from this intersection over ringAndEdge1?
  this.ringAndEdge2Walkable = ringAndEdge2Walkable; // May we (still) walk away from this intersection over ringAndEdge2?
}

// Function to determine if three consecutive points of a simple, non-self-intersecting ring make up a convex vertex, assuming the ring is right- or lefthanded
function isConvex(pts, righthanded){
  // 'pts' is an [x,y] pair
  // 'righthanded' is a boolean
  if (typeof(righthanded) === 'undefined') righthanded = true;
  if (pts.length != 3) throw new Error("This function requires an array of three points [x,y]");
  var d = (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[1][1] - pts[0][1]) * (pts[2][0] - pts[0][0]);
  return (d >= 0) == righthanded;
}

// Function to compute winding of simple, non-self-intersecting ring
function windingOfRing(ring){
  // 'ring' is an array of [x,y] pairs with the last equal to the first
  // Compute the winding number based on the vertex with the smallest x-value, it precessor and successor. An extremal vertex of a simple, non-self-intersecting ring is always convex, so the only reason it is not is because the winding number we use to compute it is wrong
  var leftVtx = 0;
  for (var i = 0; i < ring.length-1; i++) { if (ring[i][0] < ring[leftVtx][0]) leftVtx = i; }
  if (isConvex([ring[(leftVtx-1).modulo(ring.length-1)],ring[leftVtx],ring[(leftVtx+1).modulo(ring.length-1)]],true)) {
    var winding = 1;
  } else {
    var winding = -1;
  }
  return winding
}

// Function to compare Arrays of numbers. From http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
function equalArrays(array1, array2) {
  // if the other array is a falsy value, return
  if (!array1 || !array2)
      return false;

  // compare lengths - can save a lot of time
  if (array1.length != array2.length)
      return false;

  for (var i = 0, l=array1.length; i < l; i++) {
      // Check if we have nested arrays
      if (array1[i] instanceof Array && array2[i] instanceof Array) {
          // recurse into the nested arrays
          if (!equalArrays(array1[i],array2[i]))
              return false;
      }
      else if (array1[i] != array2[i]) {
          // Warning - two different object instances will never be equal: {x:20} != {x:20}
          return false;
      }
  }
  return true;
}

// Fix Javascript modulo for negative number. From http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving
Number.prototype.modulo = function(n) {
  return ((this % n) + n) % n;
}

// Function to get array with only unique elements. From http://stackoverflow.com/questions/1960473/unique-values-in-an-array
function getUnique(array) {
 var u = {}, a = [];
 for(var i = 0, l = array.length; i < l; ++i){
    if(u.hasOwnProperty(array[i])) {
       continue;
    }
    a.push(array[i]);
    u[array[i]] = 1;
 }
 return a;
}

// Function to check if array is unique (i.e. all unique elements, i.e. no duplicate elements)
function isUnique(array) {
 var u = {}, a = [];
 var isUnique = 1;
 for(var i = 0, l = array.length; i < l; ++i){
    if(u.hasOwnProperty(array[i])) {
      isUnique = 0;
      break;
    }
    u[array[i]] = 1;
 }
 return isUnique;
}

},{"@turf/area":180,"@turf/helpers":53,"@turf/within":183,"debug":144,"geojson-polygon-self-intersections":156,"rbush":174}],180:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"@mapbox/geojson-area":2,"@turf/meta":96,"dup":9}],181:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"@turf/invariant":182,"dup":60}],182:[function(require,module,exports){
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @param {Array<any>|Geometry|Feature<Point>} obj any value
 * @returns {Array<number>} coordinates
 */
function getCoord(obj) {
    if (!obj) throw new Error('No obj passed');

    var coordinates = getCoords(obj);

    // getCoord() must contain at least two numbers (Point)
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return coordinates;
    } else {
        throw new Error('Coordinate is not a valid Point');
    }
}

/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers
 *
 * @param {Array<any>|Geometry|Feature<any>} obj any value
 * @returns {Array<any>} coordinates
 */
function getCoords(obj) {
    if (!obj) throw new Error('No obj passed');
    var coordinates;

    // Array of numbers
    if (obj.length) {
        coordinates = obj;

    // Geometry Object
    } else if (obj.coordinates) {
        coordinates = obj.coordinates;

    // Feature
    } else if (obj.geometry && obj.geometry.coordinates) {
        coordinates = obj.geometry.coordinates;
    }
    // Checks if coordinates contains a number
    if (coordinates) {
        containsNumber(coordinates);
        return coordinates;
    }
    throw new Error('No valid coordinates');
}

/**
 * Checks if coordinates contains a number
 *
 * @private
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        typeof coordinates[0] === 'number' &&
        typeof coordinates[1] === 'number') {
        return true;
    }
    if (coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error('coordinates must only contain numbers');
}

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @alias geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) throw new Error('No feature passed');
    if (!name) throw new Error('.featureOf() requires a name');
    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) throw new Error('No featureCollection passed');
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < featureCollection.features.length; i++) {
        var feature = featureCollection.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

module.exports.geojsonType = geojsonType;
module.exports.collectionOf = collectionOf;
module.exports.featureOf = featureOf;
module.exports.getCoord = getCoord;
module.exports.getCoords = getCoords;

},{}],183:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"@turf/helpers":53,"@turf/inside":181,"dup":134}],184:[function(require,module,exports){
"use strict"; "use restrict";

var bits      = require("bit-twiddle")
  , UnionFind = require("union-find")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents

},{"bit-twiddle":137,"union-find":191}],185:[function(require,module,exports){
/*
 (c) 2013, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
function simplifyDouglasPeucker(points, sqTolerance) {

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) newPoints.push(points[i]);
    }

    return newPoints;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') module.exports = simplify;
else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],186:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],187:[function(require,module,exports){
module.exports = function(ring){
  var sum = 0;
  var i = 1;
  var len = ring.length;
  var prev,cur;
  while(i<len){
    prev = cur||ring[0];
    cur = ring[i];
    sum += ((cur[0]-prev[0])*(cur[1]+prev[1]));
    i++;
  }
  return sum > 0;
}
},{}],188:[function(require,module,exports){
var clockwise = require('turf-is-clockwise');

function doLinesIntersect(line1, line2) {
  var p1 = line1[0],
    p2 = line1[1],
    p3 = line2[0],
    p4 = line2[1];

  return (clockwise([p1, p3, p4, p1]) != clockwise([p2, p3, p4, p2]))
    && (clockwise([p1, p2, p3, p1]) != clockwise([p1, p2, p4, p1]));
}

function testLines(ring1, ring2) {
  for (var p1_ind = 0; p1_ind < (ring1.length - 1); p1_ind++) {
    var p1_line = [ring1[p1_ind], ring1[p1_ind + 1]];
    for (var p2_ind = 0; p2_ind < (ring2.length - 1); p2_ind++) {
      var p2_line = [ring2[p2_ind], ring2[p2_ind + 1]];

      if (doLinesIntersect(p1_line, p2_line)) {
        return true;
      }
    }
  }
  return false;
}

function getCoordinates(polygon) {
  var coords = [[[]]];

  switch (polygon.geometry.type) {
    case 'LineString':
      coords = [[polygon.geometry.coordinates]];
      break;
    case 'Polygon':
      coords = [polygon.geometry.coordinates];
      break;
    case 'MultiPolygon':
      coords = polygon.geometry.coordinates;
      break;
  }
  return coords;
}

/**
 * Since we don't care about the overlap amount,
 * or it's geometry, but rather just whether overlap
 * occurs, polygon overlap can most simply be expressed
 * by testing whether any pair of edges on the two polygons
 * intersect. If there are any edge intersections, the
 * polygons overlap.
 *
 * @param  {[type]} poly1 [description]
 * @param  {[type]} poly2 [description]
 * @return {[type]}       [description]
 */
module.exports = function (poly1, poly2) {
  var coords1 = getCoordinates(poly1),
    coords2 = getCoordinates(poly2);

  // This looks completely stupid ridiculous to
  // have so many nested loops, but it supports
  // multipolygons nicely. In the case of polygons
  // or linestrings, the outer loops are only one
  // iteration.
  return coords1.some(function (rings1) {
    return coords2.some(function (rings2) {
      return rings1.some(function(ring1) {
        return rings2.some(function(ring2) {
          return testLines(ring1, ring2);
        });
      });
    });
  });
};

},{"turf-is-clockwise":187}],189:[function(require,module,exports){
"use strict"

module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}
},{}],190:[function(require,module,exports){
"use strict"

module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}
},{}],191:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}
},{}],192:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],193:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],194:[function(require,module,exports){
'use strict';

var isEqual = require('lodash.isequal');
var normalize = require('@mapbox/geojson-normalize');
var hat = require('hat');
var featuresAt = require('./lib/features_at');
var stringSetsAreEqual = require('./lib/string_sets_are_equal');
var geojsonhint = require('@mapbox/geojsonhint');
var Constants = require('./constants');
var StringSet = require('./lib/string_set');

var featureTypes = {
  Polygon: require('./feature_types/polygon'),
  LineString: require('./feature_types/line_string'),
  Point: require('./feature_types/point'),
  MultiPolygon: require('./feature_types/multi_feature'),
  MultiLineString: require('./feature_types/multi_feature'),
  MultiPoint: require('./feature_types/multi_feature')
};

module.exports = function (ctx, api) {

  api.modes = Constants.modes;

  api.getFeatureIdsAt = function (point) {
    var features = featuresAt.click({ point: point }, null, ctx);
    return features.map(function (feature) {
      return feature.properties.id;
    });
  };

  api.getSelectedIds = function () {
    return ctx.store.getSelectedIds();
  };

  api.getSelected = function () {
    return {
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: ctx.store.getSelectedIds().map(function (id) {
        return ctx.store.get(id);
      }).map(function (feature) {
        return feature.toGeoJSON();
      })
    };
  };

  api.getSelectedPoints = function () {
    return {
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: ctx.store.getSelectedCoordinates().map(function (coordinate) {
        return {
          type: Constants.geojsonTypes.FEATURE,
          properties: {},
          geometry: {
            type: Constants.geojsonTypes.POINT,
            coordinates: coordinate.coordinates
          }
        };
      })
    };
  };

  api.set = function (featureCollection) {
    if (featureCollection.type === undefined || featureCollection.type !== Constants.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {
      throw new Error('Invalid FeatureCollection');
    }
    var renderBatch = ctx.store.createRenderBatch();
    var toDelete = ctx.store.getAllIds().slice();
    var newIds = api.add(featureCollection);
    var newIdsLookup = new StringSet(newIds);

    toDelete = toDelete.filter(function (id) {
      return !newIdsLookup.has(id);
    });
    if (toDelete.length) {
      api.delete(toDelete);
    }

    renderBatch();
    return newIds;
  };

  api.add = function (geojson) {
    var errors = geojsonhint.hint(geojson, { precisionWarning: false }).filter(function (e) {
      return e.level !== 'message';
    });
    if (errors.length) {
      throw new Error(errors[0].message);
    }
    var featureCollection = JSON.parse(JSON.stringify(normalize(geojson)));

    var ids = featureCollection.features.map(function (feature) {
      feature.id = feature.id || hat();

      if (feature.geometry === null) {
        throw new Error('Invalid geometry: null');
      }

      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {
        // If the feature has not yet been created ...
        var Model = featureTypes[feature.geometry.type];
        if (Model === undefined) {
          throw new Error('Invalid geometry type: ' + feature.geometry.type + '.');
        }
        var internalFeature = new Model(ctx, feature);
        ctx.store.add(internalFeature);
      } else {
        // If a feature of that id has already been created, and we are swapping it out ...
        var _internalFeature = ctx.store.get(feature.id);
        _internalFeature.properties = feature.properties;
        if (!isEqual(_internalFeature.getCoordinates(), feature.geometry.coordinates)) {
          _internalFeature.incomingCoords(feature.geometry.coordinates);
        }
      }
      return feature.id;
    });

    ctx.store.render();
    return ids;
  };

  api.get = function (id) {
    var feature = ctx.store.get(id);
    if (feature) {
      return feature.toGeoJSON();
    }
  };

  api.getAll = function () {
    return {
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: ctx.store.getAll().map(function (feature) {
        return feature.toGeoJSON();
      })
    };
  };

  api.delete = function (featureIds) {
    ctx.store.delete(featureIds, { silent: true });
    // If we were in direct select mode and our selected feature no longer exists
    // (because it was deleted), we need to get out of that mode.
    if (api.getMode() === Constants.modes.DIRECT_SELECT && !ctx.store.getSelectedIds().length) {
      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent: true });
    } else {
      ctx.store.render();
    }

    return api;
  };

  api.deleteAll = function () {
    ctx.store.delete(ctx.store.getAllIds(), { silent: true });
    // If we were in direct select mode, now our selected feature no longer exists,
    // so escape that mode.
    if (api.getMode() === Constants.modes.DIRECT_SELECT) {
      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent: true });
    } else {
      ctx.store.render();
    }

    return api;
  };

  api.changeMode = function (mode) {
    var modeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // Avoid changing modes just to re-select what's already selected
    if (mode === Constants.modes.SIMPLE_SELECT && api.getMode() === Constants.modes.SIMPLE_SELECT) {
      if (stringSetsAreEqual(modeOptions.featureIds || [], ctx.store.getSelectedIds())) return api;
      // And if we are changing the selection within simple_select mode, just change the selection,
      // instead of stopping and re-starting the mode
      ctx.store.setSelected(modeOptions.featureIds, { silent: true });
      ctx.store.render();
      return api;
    }

    if (mode === Constants.modes.DIRECT_SELECT && api.getMode() === Constants.modes.DIRECT_SELECT && modeOptions.featureId === ctx.store.getSelectedIds()[0]) {
      return api;
    }

    ctx.events.changeMode(mode, modeOptions, { silent: true });
    return api;
  };

  api.getMode = function () {
    return ctx.events.getMode();
  };

  api.trash = function () {
    ctx.events.trash({ silent: true });
    return api;
  };

  api.combineFeatures = function () {
    ctx.events.combineFeatures({ silent: true });
    return api;
  };

  api.uncombineFeatures = function () {
    ctx.events.uncombineFeatures({ silent: true });
    return api;
  };

  api.setFeatureProperty = function (featureId, property, value) {
    ctx.store.setFeatureProperty(featureId, property, value);
    return api;
  };

  return api;
};

},{"./constants":195,"./feature_types/line_string":198,"./feature_types/multi_feature":199,"./feature_types/point":200,"./feature_types/polygon":201,"./lib/features_at":209,"./lib/string_set":220,"./lib/string_sets_are_equal":221,"@mapbox/geojson-normalize":3,"@mapbox/geojsonhint":4,"hat":162,"lodash.isequal":167}],195:[function(require,module,exports){
'use strict';

module.exports = {
  classes: {
    CONTROL_BASE: 'mapboxgl-ctrl',
    CONTROL_PREFIX: 'mapboxgl-ctrl-',
    CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',
    CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',
    CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',
    CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',
    CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',
    CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',
    CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',
    CONTROL_GROUP: 'mapboxgl-ctrl-group',
    ATTRIBUTION: 'mapboxgl-ctrl-attrib',
    ACTIVE_BUTTON: 'active',
    BOX_SELECT: 'mapbox-gl-draw_boxselect'
  },
  sources: {
    HOT: 'mapbox-gl-draw-hot',
    COLD: 'mapbox-gl-draw-cold'
  },
  cursors: {
    ADD: 'add',
    MOVE: 'move',
    DRAG: 'drag',
    POINTER: 'pointer',
    NONE: 'none'
  },
  types: {
    POLYGON: 'polygon',
    LINE: 'line_string',
    POINT: 'point'
  },
  geojsonTypes: {
    FEATURE: 'Feature',
    POLYGON: 'Polygon',
    LINE_STRING: 'LineString',
    POINT: 'Point',
    FEATURE_COLLECTION: 'FeatureCollection',
    MULTI_PREFIX: 'Multi',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon'
  },
  modes: {
    DRAW_LINE_STRING: 'draw_line_string',
    DRAW_POLYGON: 'draw_polygon',
    DRAW_POINT: 'draw_point',
    SIMPLE_SELECT: 'simple_select',
    DIRECT_SELECT: 'direct_select',
    STATIC: 'static'
  },
  events: {
    CREATE: 'draw.create',
    DELETE: 'draw.delete',
    UPDATE: 'draw.update',
    SELECTION_CHANGE: 'draw.selectionchange',
    MODE_CHANGE: 'draw.modechange',
    ACTIONABLE: 'draw.actionable',
    RENDER: 'draw.render',
    COMBINE_FEATURES: 'draw.combine',
    UNCOMBINE_FEATURES: 'draw.uncombine'
  },
  updateActions: {
    MOVE: 'move',
    CHANGE_COORDINATES: 'change_coordinates'
  },
  meta: {
    FEATURE: 'feature',
    MIDPOINT: 'midpoint',
    VERTEX: 'vertex'
  },
  activeStates: {
    ACTIVE: 'true',
    INACTIVE: 'false'
  },
  LAT_MIN: -90,
  LAT_RENDERED_MIN: -85,
  LAT_MAX: 90,
  LAT_RENDERED_MAX: 85,
  LNG_MIN: -270,
  LNG_MAX: 270
};

},{}],196:[function(require,module,exports){
'use strict';

var _modes;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var setupModeHandler = require('./lib/mode_handler');
var getFeaturesAndSetCursor = require('./lib/get_features_and_set_cursor');
var featuresAt = require('./lib/features_at');
var isClick = require('./lib/is_click');
var isTap = require('./lib/is_tap');
var Constants = require('./constants');

var modes = (_modes = {}, _defineProperty(_modes, Constants.modes.SIMPLE_SELECT, require('./modes/simple_select')), _defineProperty(_modes, Constants.modes.DIRECT_SELECT, require('./modes/direct_select')), _defineProperty(_modes, Constants.modes.DRAW_POINT, require('./modes/draw_point')), _defineProperty(_modes, Constants.modes.DRAW_LINE_STRING, require('./modes/draw_line_string')), _defineProperty(_modes, Constants.modes.DRAW_POLYGON, require('./modes/draw_polygon')), _defineProperty(_modes, Constants.modes.STATIC, require('./modes/static')), _modes);

module.exports = function (ctx) {

  var mouseDownInfo = {};
  var touchStartInfo = {};
  var events = {};
  var _currentModeName = Constants.modes.SIMPLE_SELECT;
  var currentMode = setupModeHandler(modes.simple_select(ctx), ctx);

  events.drag = function (event, isDrag) {
    if (isDrag({
      point: event.point,
      time: new Date().getTime()
    })) {
      ctx.ui.queueMapClasses({ mouse: Constants.cursors.DRAG });
      currentMode.drag(event);
    } else {
      event.originalEvent.stopPropagation();
    }
  };

  events.mousedrag = function (event) {
    events.drag(event, function (endInfo) {
      return !isClick(mouseDownInfo, endInfo);
    });
  };

  events.touchdrag = function (event) {
    events.drag(event, function (endInfo) {
      return !isTap(touchStartInfo, endInfo);
    });
  };

  events.mousemove = function (event) {
    var button = event.originalEvent.buttons !== undefined ? event.originalEvent.buttons : event.originalEvent.which;
    if (button === 1) {
      return events.mousedrag(event);
    }
    var target = getFeaturesAndSetCursor(event, ctx);
    event.featureTarget = target;
    currentMode.mousemove(event);
  };

  events.mousedown = function (event) {
    mouseDownInfo = {
      time: new Date().getTime(),
      point: event.point
    };
    var target = getFeaturesAndSetCursor(event, ctx);
    event.featureTarget = target;
    currentMode.mousedown(event);
  };

  events.mouseup = function (event) {
    var target = getFeaturesAndSetCursor(event, ctx);
    event.featureTarget = target;

    if (isClick(mouseDownInfo, {
      point: event.point,
      time: new Date().getTime()
    })) {
      currentMode.click(event);
    } else {
      currentMode.mouseup(event);
    }
  };

  events.mouseout = function (event) {
    currentMode.mouseout(event);
  };

  events.touchstart = function (event) {
    // Prevent emulated mouse events because we will fully handle the touch here.
    // This does not stop the touch events from propogating to mapbox though.
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    touchStartInfo = {
      time: new Date().getTime(),
      point: event.point
    };
    var target = featuresAt.touch(event, null, ctx)[0];
    event.featureTarget = target;
    currentMode.touchstart(event);
  };

  events.touchmove = function (event) {
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    currentMode.touchmove(event);
    return events.touchdrag(event);
  };

  events.touchend = function (event) {
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    var target = featuresAt.touch(event, null, ctx)[0];
    event.featureTarget = target;
    if (isTap(touchStartInfo, {
      time: new Date().getTime(),
      point: event.point
    })) {
      currentMode.tap(event);
    } else {
      currentMode.touchend(event);
    }
  };

  // 8 - Backspace
  // 46 - Delete
  var isKeyModeValid = function isKeyModeValid(code) {
    return !(code === 8 || code === 46 || code >= 48 && code <= 57);
  };

  events.keydown = function (event) {

    if ((event.keyCode === 8 || event.keyCode === 46) && ctx.options.controls.trash) {
      event.preventDefault();
      currentMode.trash();
    } else if (isKeyModeValid(event.keyCode)) {
      currentMode.keydown(event);
    } else if (event.keyCode === 49 && ctx.options.controls.point) {
      changeMode(Constants.modes.DRAW_POINT);
    } else if (event.keyCode === 50 && ctx.options.controls.line_string) {
      changeMode(Constants.modes.DRAW_LINE_STRING);
    } else if (event.keyCode === 51 && ctx.options.controls.polygon) {
      changeMode(Constants.modes.DRAW_POLYGON);
    }

    if (event.keyCode === 17) {
      ctx.snapToOverride = true;
    }
  };

  events.keyup = function (event) {
    if (isKeyModeValid(event.keyCode)) {
      currentMode.keyup(event);
    }

    if (event.keyCode === 17) {
      ctx.snapToOverride = false;
    }
  };

  events.zoomend = function () {
    ctx.store.changeZoom();
  };

  events.data = function (event) {
    if (event.dataType === 'style') {
      var setup = ctx.setup,
          map = ctx.map,
          options = ctx.options,
          store = ctx.store;

      var hasLayers = options.styles.some(function (style) {
        return map.getLayer(style.id);
      });
      if (!hasLayers) {
        setup.addLayers();
        store.setDirty();
        store.render();
      }
    }
  };

  function changeMode(modename, nextModeOptions) {
    var eventOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    currentMode.stop();

    var modebuilder = modes[modename];
    if (modebuilder === undefined) {
      throw new Error(modename + ' is not valid');
    }
    _currentModeName = modename;
    var mode = modebuilder(ctx, nextModeOptions);
    currentMode = setupModeHandler(mode, ctx);

    if (!eventOptions.silent) {
      ctx.map.fire(Constants.events.MODE_CHANGE, { mode: modename });
    }

    ctx.store.setDirty();
    ctx.store.render();
  }

  var actionState = {
    trash: false,
    combineFeatures: false,
    uncombineFeatures: false
  };

  function actionable(actions) {
    var changed = false;
    Object.keys(actions).forEach(function (action) {
      if (actionState[action] === undefined) throw new Error('Invalid action type');
      if (actionState[action] !== actions[action]) changed = true;
      actionState[action] = actions[action];
    });
    if (changed) ctx.map.fire(Constants.events.ACTIONABLE, { actions: actionState });
  }

  var api = {
    changeMode: changeMode,
    actionable: actionable,
    currentModeName: function currentModeName() {
      return _currentModeName;
    },
    currentModeRender: function currentModeRender(geojson, push) {
      return currentMode.render(geojson, push);
    },
    fire: function fire(name, event) {
      if (events[name]) {
        events[name](event);
      }
    },
    addEventListeners: function addEventListeners() {
      ctx.map.on('mousemove', events.mousemove);
      ctx.map.on('mousedown', events.mousedown);
      ctx.map.on('mouseup', events.mouseup);
      ctx.map.on('data', events.data);

      ctx.map.on('touchmove', events.touchmove);
      ctx.map.on('touchstart', events.touchstart);
      ctx.map.on('touchend', events.touchend);

      ctx.container.addEventListener('mouseout', events.mouseout);

      if (ctx.options.keybindings) {
        ctx.container.addEventListener('keydown', events.keydown);
        ctx.container.addEventListener('keyup', events.keyup);
      }
    },
    removeEventListeners: function removeEventListeners() {
      ctx.map.off('mousemove', events.mousemove);
      ctx.map.off('mousedown', events.mousedown);
      ctx.map.off('mouseup', events.mouseup);
      ctx.map.off('data', events.data);

      ctx.map.off('touchmove', events.touchmove);
      ctx.map.off('touchstart', events.touchstart);
      ctx.map.off('touchend', events.touchend);

      ctx.container.removeEventListener('mouseout', events.mouseout);

      if (ctx.options.keybindings) {
        ctx.container.removeEventListener('keydown', events.keydown);
        ctx.container.removeEventListener('keyup', events.keyup);
      }
    },
    trash: function trash(options) {
      currentMode.trash(options);
    },
    combineFeatures: function combineFeatures() {
      currentMode.combineFeatures();
    },
    uncombineFeatures: function uncombineFeatures() {
      currentMode.uncombineFeatures();
    },
    getMode: function getMode() {
      return _currentModeName;
    }
  };

  return api;
};

},{"./constants":195,"./lib/features_at":209,"./lib/get_features_and_set_cursor":210,"./lib/is_click":211,"./lib/is_tap":213,"./lib/mode_handler":215,"./modes/direct_select":225,"./modes/draw_line_string":226,"./modes/draw_point":227,"./modes/draw_polygon":228,"./modes/simple_select":229,"./modes/static":230}],197:[function(require,module,exports){
'use strict';

var hat = require('hat');
var Constants = require('../constants');

var Feature = function Feature(ctx, geojson) {
  this.ctx = ctx;
  this.properties = geojson.properties || {};
  this.coordinates = geojson.geometry.coordinates;
  this.id = geojson.id || hat();
  this.type = geojson.geometry.type;
};

Feature.prototype.changed = function () {
  this.ctx.store.featureChanged(this.id);
};

Feature.prototype.incomingCoords = function (coords) {
  this.setCoordinates(coords);
};

Feature.prototype.setCoordinates = function (coords) {
  this.coordinates = coords;
  this.changed();
};

Feature.prototype.getCoordinates = function () {
  return JSON.parse(JSON.stringify(this.coordinates));
};

Feature.prototype.setProperty = function (property, value) {
  this.properties[property] = value;
};

Feature.prototype.toGeoJSON = function () {
  return JSON.parse(JSON.stringify({
    id: this.id,
    type: Constants.geojsonTypes.FEATURE,
    properties: this.properties,
    geometry: {
      coordinates: this.getCoordinates(),
      type: this.type
    }
  }));
};

Feature.prototype.internal = function (mode) {
  var properties = {
    id: this.id,
    meta: Constants.meta.FEATURE,
    'meta:type': this.type,
    active: Constants.activeStates.INACTIVE,
    mode: mode
  };

  if (this.ctx.options.userProperties) {
    for (var name in this.properties) {
      properties['user_' + name] = this.properties[name];
    }
  }

  return {
    type: Constants.geojsonTypes.FEATURE,
    properties: properties,
    geometry: {
      coordinates: this.getCoordinates(),
      type: this.type
    }
  };
};

module.exports = Feature;

},{"../constants":195,"hat":162}],198:[function(require,module,exports){
'use strict';

var Feature = require('./feature');

var LineString = function LineString(ctx, geojson) {
  Feature.call(this, ctx, geojson);
};

LineString.prototype = Object.create(Feature.prototype);

LineString.prototype.isValid = function () {
  return this.coordinates.length > 1;
};

LineString.prototype.addCoordinate = function (path, lng, lat) {
  this.changed();
  var id = parseInt(path, 10);
  this.coordinates.splice(id, 0, [lng, lat]);
};

LineString.prototype.getCoordinate = function (path) {
  var id = parseInt(path, 10);
  var coords = this.coordinates[id];
  if (coords === undefined) {
    return undefined;
  }
  return JSON.parse(JSON.stringify(coords));
};

LineString.prototype.removeCoordinate = function (path) {
  this.changed();
  this.coordinates.splice(parseInt(path, 10), 1);
};

LineString.prototype.updateCoordinate = function (path, lng, lat) {
  var id = parseInt(path, 10);
  this.coordinates[id] = [lng, lat];
  this.changed();
};

module.exports = LineString;

},{"./feature":197}],199:[function(require,module,exports){
'use strict';

var Feature = require('./feature');
var Constants = require('../constants');
var hat = require('hat');

var models = {
  MultiPoint: require('./point'),
  MultiLineString: require('./line_string'),
  MultiPolygon: require('./polygon')
};

var takeAction = function takeAction(features, action, path, lng, lat) {
  var parts = path.split('.');
  var idx = parseInt(parts[0], 10);
  var tail = !parts[1] ? null : parts.slice(1).join('.');
  return features[idx][action](tail, lng, lat);
};

var MultiFeature = function MultiFeature(ctx, geojson) {
  Feature.call(this, ctx, geojson);

  delete this.coordinates;
  this.model = models[geojson.geometry.type];
  if (this.model === undefined) throw new TypeError(geojson.geometry.type + ' is not a valid type');
  this.features = this._coordinatesToFeatures(geojson.geometry.coordinates);
};

MultiFeature.prototype = Object.create(Feature.prototype);

MultiFeature.prototype._coordinatesToFeatures = function (coordinates) {
  var _this = this;

  var Model = this.model.bind(this);
  return coordinates.map(function (coords) {
    return new Model(_this.ctx, {
      id: hat(),
      type: Constants.geojsonTypes.FEATURE,
      properties: {},
      geometry: {
        coordinates: coords,
        type: _this.type.replace('Multi', '')
      }
    });
  });
};

MultiFeature.prototype.isValid = function () {
  return this.features.every(function (f) {
    return f.isValid();
  });
};

MultiFeature.prototype.setCoordinates = function (coords) {
  this.features = this._coordinatesToFeatures(coords);
  this.changed();
};

MultiFeature.prototype.getCoordinate = function (path) {
  return takeAction(this.features, 'getCoordinate', path);
};

MultiFeature.prototype.getCoordinates = function () {
  return JSON.parse(JSON.stringify(this.features.map(function (f) {
    if (f.type === Constants.geojsonTypes.POLYGON) return f.getCoordinates();
    return f.coordinates;
  })));
};

MultiFeature.prototype.updateCoordinate = function (path, lng, lat) {
  takeAction(this.features, 'updateCoordinate', path, lng, lat);
  this.changed();
};

MultiFeature.prototype.addCoordinate = function (path, lng, lat) {
  takeAction(this.features, 'addCoordinate', path, lng, lat);
  this.changed();
};

MultiFeature.prototype.removeCoordinate = function (path) {
  takeAction(this.features, 'removeCoordinate', path);
  this.changed();
};

MultiFeature.prototype.getFeatures = function () {
  return this.features;
};

module.exports = MultiFeature;

},{"../constants":195,"./feature":197,"./line_string":198,"./point":200,"./polygon":201,"hat":162}],200:[function(require,module,exports){
'use strict';

var Feature = require('./feature');

var Point = function Point(ctx, geojson) {
  Feature.call(this, ctx, geojson);
};

Point.prototype = Object.create(Feature.prototype);

Point.prototype.isValid = function () {
  return typeof this.coordinates[0] === 'number' && typeof this.coordinates[1] === 'number';
};

Point.prototype.updateCoordinate = function (pathOrLng, lngOrLat, lat) {
  if (arguments.length === 3) {
    this.coordinates = [lngOrLat, lat];
  } else {
    this.coordinates = [pathOrLng, lngOrLat];
  }
  this.changed();
};

Point.prototype.getCoordinate = function () {
  return this.getCoordinates();
};

module.exports = Point;

},{"./feature":197}],201:[function(require,module,exports){
'use strict';

var Feature = require('./feature');

var Polygon = function Polygon(ctx, geojson) {
  Feature.call(this, ctx, geojson);
  this.coordinates = this.coordinates.map(function (ring) {
    return ring.slice(0, -1);
  });
};

Polygon.prototype = Object.create(Feature.prototype);

Polygon.prototype.isValid = function () {
  if (this.coordinates.length === 0) return false;
  return this.coordinates.every(function (ring) {
    return ring.length > 2;
  });
};

// Expects valid geoJSON polygon geometry: first and last positions must be equivalent.
Polygon.prototype.incomingCoords = function (coords) {
  this.coordinates = coords.map(function (ring) {
    return ring.slice(0, -1);
  });
  this.changed();
};

// Does NOT expect valid geoJSON polygon geometry: first and last positions should not be equivalent.
Polygon.prototype.setCoordinates = function (coords) {
  this.coordinates = coords;
  this.changed();
};

Polygon.prototype.addCoordinate = function (path, lng, lat) {
  this.changed();
  var ids = path.split('.').map(function (x) {
    return parseInt(x, 10);
  });

  var ring = this.coordinates[ids[0]];

  ring.splice(ids[1], 0, [lng, lat]);
};

Polygon.prototype.removeCoordinate = function (path) {
  this.changed();
  var ids = path.split('.').map(function (x) {
    return parseInt(x, 10);
  });
  var ring = this.coordinates[ids[0]];
  if (ring) {
    ring.splice(ids[1], 1);
    if (ring.length < 3) {
      this.coordinates.splice(ids[1], 0);
    }
  }
};

Polygon.prototype.getCoordinate = function (path) {
  var ids = path.split('.').map(function (x) {
    return parseInt(x, 10);
  });
  var ring = this.coordinates[ids[0]];
  var coords = ring[ids[1]];
  if (coords === undefined) {
    return undefined;
  }
  return JSON.parse(JSON.stringify(coords));
};

Polygon.prototype.getCoordinates = function () {
  return this.coordinates.map(function (coords) {
    return coords.concat([coords[0]]);
  });
};

Polygon.prototype.updateCoordinate = function (path, lng, lat) {
  this.changed();
  var parts = path.split('.');
  var ringId = parseInt(parts[0], 10);
  var coordId = parseInt(parts[1], 10);

  if (this.coordinates[ringId] === undefined) {
    this.coordinates[ringId] = [];
  }

  this.coordinates[ringId][coordId] = [lng, lat];
};

module.exports = Polygon;

},{"./feature":197}],202:[function(require,module,exports){
'use strict';

var Constants = require('../constants');

module.exports = {
  isOfMetaType: function isOfMetaType(type) {
    return function (e) {
      var featureTarget = e.featureTarget;
      if (!featureTarget) return false;
      if (!featureTarget.properties) return false;
      return featureTarget.properties.meta === type;
    };
  },
  isShiftMousedown: function isShiftMousedown(e) {
    if (!e.originalEvent) return false;
    if (!e.originalEvent.shiftKey) return false;
    return e.originalEvent.button === 0;
  },
  isActiveFeature: function isActiveFeature(e) {
    if (!e.featureTarget) return false;
    if (!e.featureTarget.properties) return false;
    return e.featureTarget.properties.active === Constants.activeStates.ACTIVE && e.featureTarget.properties.meta === Constants.meta.FEATURE;
  },
  isInactiveFeature: function isInactiveFeature(e) {
    if (!e.featureTarget) return false;
    if (!e.featureTarget.properties) return false;
    return e.featureTarget.properties.active === Constants.activeStates.INACTIVE && e.featureTarget.properties.meta === Constants.meta.FEATURE;
  },
  noTarget: function noTarget(e) {
    return e.featureTarget === undefined;
  },
  isFeature: function isFeature(e) {
    if (!e.featureTarget) return false;
    if (!e.featureTarget.properties) return false;
    return e.featureTarget.properties.meta === Constants.meta.FEATURE;
  },
  isVertex: function isVertex(e) {
    var featureTarget = e.featureTarget;
    if (!featureTarget) return false;
    if (!featureTarget.properties) return false;
    return featureTarget.properties.meta === Constants.meta.VERTEX;
  },
  isShiftDown: function isShiftDown(e) {
    if (!e.originalEvent) return false;
    return e.originalEvent.shiftKey === true;
  },
  isEscapeKey: function isEscapeKey(e) {
    return e.keyCode === 27;
  },
  isEnterKey: function isEnterKey(e) {
    return e.keyCode === 13;
  },
  true: function _true() {
    return true;
  }
};

},{"../constants":195}],203:[function(require,module,exports){
'use strict';

var extent = require('geojson-extent');
var Constants = require('../constants');

var LAT_MIN = Constants.LAT_MIN,
    LAT_MAX = Constants.LAT_MAX,
    LAT_RENDERED_MIN = Constants.LAT_RENDERED_MIN,
    LAT_RENDERED_MAX = Constants.LAT_RENDERED_MAX,
    LNG_MIN = Constants.LNG_MIN,
    LNG_MAX = Constants.LNG_MAX;

// Ensure that we do not drag north-south far enough for
// - any part of any feature to exceed the poles
// - any feature to be completely lost in the space between the projection's
//   edge and the poles, such that it couldn't be re-selected and moved back

module.exports = function (geojsonFeatures, delta) {
  // "inner edge" = a feature's latitude closest to the equator
  var northInnerEdge = LAT_MIN;
  var southInnerEdge = LAT_MAX;
  // "outer edge" = a feature's latitude furthest from the equator
  var northOuterEdge = LAT_MIN;
  var southOuterEdge = LAT_MAX;

  var westEdge = LNG_MAX;
  var eastEdge = LNG_MIN;

  geojsonFeatures.forEach(function (feature) {
    var bounds = extent(feature);
    var featureSouthEdge = bounds[1];
    var featureNorthEdge = bounds[3];
    var featureWestEdge = bounds[0];
    var featureEastEdge = bounds[2];
    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;
    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;
    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;
    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;
    if (featureWestEdge < westEdge) westEdge = featureWestEdge;
    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;
  });

  // These changes are not mutually exclusive: we might hit the inner
  // edge but also have hit the outer edge and therefore need
  // another readjustment
  var constrainedDelta = delta;
  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {
    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;
  }
  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {
    constrainedDelta.lat = LAT_MAX - northOuterEdge;
  }
  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {
    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;
  }
  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {
    constrainedDelta.lat = LAT_MIN - southOuterEdge;
  }
  if (westEdge + constrainedDelta.lng <= LNG_MIN) {
    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
  }
  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {
    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
  }

  return constrainedDelta;
};

},{"../constants":195,"geojson-extent":153}],204:[function(require,module,exports){
'use strict';

var Constants = require('../constants');

module.exports = function (parent, startVertex, endVertex, map) {
  var startCoord = startVertex.geometry.coordinates;
  var endCoord = endVertex.geometry.coordinates;

  // If a coordinate exceeds the projection, we can't calculate a midpoint,
  // so run away
  if (startCoord[1] > Constants.LAT_RENDERED_MAX || startCoord[1] < Constants.LAT_RENDERED_MIN || endCoord[1] > Constants.LAT_RENDERED_MAX || endCoord[1] < Constants.LAT_RENDERED_MIN) {
    return null;
  }

  var ptA = map.project([startCoord[0], startCoord[1]]);
  var ptB = map.project([endCoord[0], endCoord[1]]);
  var mid = map.unproject([(ptA.x + ptB.x) / 2, (ptA.y + ptB.y) / 2]);

  return {
    type: Constants.geojsonTypes.FEATURE,
    properties: {
      meta: Constants.meta.MIDPOINT,
      parent: parent,
      lng: mid.lng,
      lat: mid.lat,
      coord_path: endVertex.properties.coord_path
    },
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: [mid.lng, mid.lat]
    }
  };
};

},{"../constants":195}],205:[function(require,module,exports){
'use strict';

var createVertex = require('./create_vertex');
var createMidpoint = require('./create_midpoint');
var Constants = require('../constants');

function createSupplementaryPoints(geojson) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var basePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var _geojson$geometry = geojson.geometry,
      type = _geojson$geometry.type,
      coordinates = _geojson$geometry.coordinates;

  var featureId = geojson.properties && geojson.properties.id;

  var supplementaryPoints = [];

  if (type === Constants.geojsonTypes.POINT) {
    // For points, just create a vertex
    supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));
  } else if (type === Constants.geojsonTypes.POLYGON) {
    // Cycle through a Polygon's rings and
    // process each line
    coordinates.forEach(function (line, lineIndex) {
      processLine(line, basePath !== null ? basePath + '.' + lineIndex : String(lineIndex));
    });
  } else if (type === Constants.geojsonTypes.LINE_STRING) {
    processLine(coordinates, basePath);
  } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {
    processMultiGeometry();
  }

  function processLine(line, lineBasePath) {
    var firstPointString = '';
    var lastVertex = null;
    line.forEach(function (point, pointIndex) {
      var pointPath = lineBasePath !== undefined && lineBasePath !== null ? lineBasePath + '.' + pointIndex : String(pointIndex);
      var vertex = createVertex(featureId, point, pointPath, isSelectedPath(pointPath));

      // If we're creating midpoints, check if there was a
      // vertex before this one. If so, add a midpoint
      // between that vertex and this one.
      if (options.midpoints && lastVertex) {
        var midpoint = createMidpoint(featureId, lastVertex, vertex, options.map);
        if (midpoint) {
          supplementaryPoints.push(midpoint);
        }
      }
      lastVertex = vertex;

      // A Polygon line's last point is the same as the first point. If we're on the last
      // point, we want to draw a midpoint before it but not another vertex on it
      // (since we already a vertex there, from the first point).
      var stringifiedPoint = JSON.stringify(point);
      if (firstPointString !== stringifiedPoint) {
        supplementaryPoints.push(vertex);
      }
      if (pointIndex === 0) {
        firstPointString = stringifiedPoint;
      }
    });
  }

  function isSelectedPath(path) {
    if (!options.selectedPaths) return false;
    return options.selectedPaths.indexOf(path) !== -1;
  }

  // Split a multi-geometry into constituent
  // geometries, and accumulate the supplementary points
  // for each of those constituents
  function processMultiGeometry() {
    var subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');
    coordinates.forEach(function (subCoordinates, index) {
      var subFeature = {
        type: Constants.geojsonTypes.FEATURE,
        properties: geojson.properties,
        geometry: {
          type: subType,
          coordinates: subCoordinates
        }
      };
      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));
    });
  }

  return supplementaryPoints;
}

module.exports = createSupplementaryPoints;

},{"../constants":195,"./create_midpoint":204,"./create_vertex":206}],206:[function(require,module,exports){
'use strict';

var Constants = require('../constants');

/**
 * Returns GeoJSON for a Point representing the
 * vertex of another feature.
 *
 * @param {string} parentId
 * @param {Array<number>} coordinates
 * @param {string} path - Dot-separated numbers indicating exactly
 *   where the point exists within its parent feature's coordinates.
 * @param {boolean} selected
 * @return {GeoJSON} Point
 */
module.exports = function (parentId, coordinates, path, selected) {
  return {
    type: Constants.geojsonTypes.FEATURE,
    properties: {
      meta: Constants.meta.VERTEX,
      parent: parentId,
      coord_path: path,
      active: selected ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE
    },
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: coordinates
    }
  };
};

},{"../constants":195}],207:[function(require,module,exports){
"use strict";

module.exports = {
  enable: function enable(ctx) {
    setTimeout(function () {
      if (!ctx.map || !ctx.map.doubleClickZoom) return;
      ctx.map.doubleClickZoom.enable();
    }, 0);
  },
  disable: function disable(ctx) {
    setTimeout(function () {
      if (!ctx.map || !ctx.map.doubleClickZoom) return;
      ctx.map.doubleClickZoom.disable();
    }, 0);
  }
};

},{}],208:[function(require,module,exports){
"use strict";

module.exports = function (a, b) {
  var x = a.x - b.x;
  var y = a.y - b.y;
  return Math.sqrt(x * x + y * y);
};

},{}],209:[function(require,module,exports){
'use strict';

var sortFeatures = require('./sort_features');
var mapEventToBoundingBox = require('./map_event_to_bounding_box');
var Constants = require('../constants');
var StringSet = require('./string_set');

var META_TYPES = [Constants.meta.FEATURE, Constants.meta.MIDPOINT, Constants.meta.VERTEX];

// Requires either event or bbox
module.exports = {
  click: featuresAtClick,
  touch: featuresAtTouch
};

function featuresAtClick(event, bbox, ctx) {
  return featuresAt(event, bbox, ctx, ctx.options.clickBuffer);
}

function featuresAtTouch(event, bbox, ctx) {
  return featuresAt(event, bbox, ctx, ctx.options.touchBuffer);
}

function featuresAt(event, bbox, ctx, buffer) {
  if (ctx.map === null) return [];

  var box = event ? mapEventToBoundingBox(event, buffer) : bbox;

  var queryParams = {};
  if (ctx.options.styles) queryParams.layers = ctx.options.styles.map(function (s) {
    return s.id;
  });

  var features = ctx.map.queryRenderedFeatures(box, queryParams).filter(function (feature) {
    return META_TYPES.indexOf(feature.properties.meta) !== -1;
  });

  var featureIds = new StringSet();
  var uniqueFeatures = [];
  features.forEach(function (feature) {
    var featureId = feature.properties.id;
    if (featureIds.has(featureId)) return;
    featureIds.add(featureId);
    uniqueFeatures.push(feature);
  });

  return sortFeatures(uniqueFeatures);
}

},{"../constants":195,"./map_event_to_bounding_box":214,"./sort_features":219,"./string_set":220}],210:[function(require,module,exports){
'use strict';

var featuresAt = require('./features_at');
var Constants = require('../constants');

module.exports = function getFeatureAtAndSetCursors(event, ctx) {
  var features = featuresAt.click(event, null, ctx);
  var classes = { mouse: Constants.cursors.NONE };

  if (features[0]) {
    classes.mouse = features[0].properties.active === Constants.activeStates.ACTIVE ? Constants.cursors.MOVE : Constants.cursors.POINTER;
    classes.feature = features[0].properties.meta;
  }

  if (ctx.events.currentModeName().indexOf('draw') !== -1) {
    classes.mouse = Constants.cursors.ADD;
  }

  ctx.ui.queueMapClasses(classes);
  ctx.ui.updateMapClasses();

  return features[0];
};

},{"../constants":195,"./features_at":209}],211:[function(require,module,exports){
'use strict';

var euclideanDistance = require('./euclidean_distance');

var FINE_TOLERANCE = 4;
var GROSS_TOLERANCE = 12;
var INTERVAL = 500;

module.exports = function isClick(start, end) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var fineTolerance = options.fineTolerance != null ? options.fineTolerance : FINE_TOLERANCE;
  var grossTolerance = options.grossTolerance != null ? options.grossTolerance : GROSS_TOLERANCE;
  var interval = options.interval != null ? options.interval : INTERVAL;

  start.point = start.point || end.point;
  start.time = start.time || end.time;
  var moveDistance = euclideanDistance(start.point, end.point);

  return moveDistance < fineTolerance || moveDistance < grossTolerance && end.time - start.time < interval;
};

},{"./euclidean_distance":208}],212:[function(require,module,exports){
"use strict";

function isEventAtCoordinates(event, coordinates) {
  if (!event.lngLat) return false;
  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];
}

module.exports = isEventAtCoordinates;

},{}],213:[function(require,module,exports){
'use strict';

var euclideanDistance = require('./euclidean_distance');

var TOLERANCE = 25;
var INTERVAL = 250;

module.exports = function isTap(start, end) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var tolerance = options.tolerance != null ? options.tolerance : TOLERANCE;
  var interval = options.interval != null ? options.interval : INTERVAL;

  start.point = start.point || end.point;
  start.time = start.time || end.time;
  var moveDistance = euclideanDistance(start.point, end.point);

  return moveDistance < tolerance && end.time - start.time < interval;
};

},{"./euclidean_distance":208}],214:[function(require,module,exports){
"use strict";

/**
 * Returns a bounding box representing the event's location.
 *
 * @param {Event} mapEvent - Mapbox GL JS map event, with a point properties.
 * @return {Array<Array<number>>} Bounding box.
 */
function mapEventToBoundingBox(mapEvent) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return [[mapEvent.point.x - buffer, mapEvent.point.y - buffer], [mapEvent.point.x + buffer, mapEvent.point.y + buffer]];
}

module.exports = mapEventToBoundingBox;

},{}],215:[function(require,module,exports){
'use strict';

var ModeHandler = function ModeHandler(mode, DrawContext) {

  var handlers = {
    drag: [],
    click: [],
    mousemove: [],
    mousedown: [],
    mouseup: [],
    mouseout: [],
    keydown: [],
    keyup: [],
    touchstart: [],
    touchmove: [],
    touchend: [],
    tap: []
  };

  var ctx = {
    on: function on(event, selector, fn) {
      if (handlers[event] === undefined) {
        throw new Error('Invalid event type: ' + event);
      }
      handlers[event].push({
        selector: selector,
        fn: fn
      });
    },
    render: function render(id) {
      DrawContext.store.featureChanged(id);
    }
  };

  var delegate = function delegate(eventName, event) {
    var handles = handlers[eventName];
    var iHandle = handles.length;
    while (iHandle--) {
      var handle = handles[iHandle];
      if (handle.selector(event)) {
        handle.fn.call(ctx, event);
        DrawContext.store.render();
        DrawContext.ui.updateMapClasses();

        // ensure an event is only handled once
        // we do this to let modes have multiple overlapping selectors
        // and relay on order of oppertations to filter
        break;
      }
    }
  };

  mode.start.call(ctx);

  return {
    render: mode.render,
    stop: function stop() {
      if (mode.stop) mode.stop();
    },
    trash: function trash() {
      if (mode.trash) {
        mode.trash();
        DrawContext.store.render();
      }
    },
    combineFeatures: function combineFeatures() {
      if (mode.combineFeatures) {
        mode.combineFeatures();
      }
    },
    uncombineFeatures: function uncombineFeatures() {
      if (mode.uncombineFeatures) {
        mode.uncombineFeatures();
      }
    },
    drag: function drag(event) {
      delegate('drag', event);
    },
    click: function click(event) {
      delegate('click', event);
    },
    mousemove: function mousemove(event) {
      delegate('mousemove', event);
    },
    mousedown: function mousedown(event) {
      delegate('mousedown', event);
    },
    mouseup: function mouseup(event) {
      delegate('mouseup', event);
    },
    mouseout: function mouseout(event) {
      delegate('mouseout', event);
    },
    keydown: function keydown(event) {
      delegate('keydown', event);
    },
    keyup: function keyup(event) {
      delegate('keyup', event);
    },
    touchstart: function touchstart(event) {
      delegate('touchstart', event);
    },
    touchmove: function touchmove(event) {
      delegate('touchmove', event);
    },
    touchend: function touchend(event) {
      delegate('touchend', event);
    },
    tap: function tap(event) {
      delegate('tap', event);
    }
  };
};

module.exports = ModeHandler;

},{}],216:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

/**
 * Returns a Point representing a mouse event's position
 * relative to a containing element.
 *
 * @param {MouseEvent} mouseEvent
 * @param {Node} container
 * @returns {Point}
 */
function mouseEventPoint(mouseEvent, container) {
  var rect = container.getBoundingClientRect();
  return new Point(mouseEvent.clientX - rect.left - (container.clientLeft || 0), mouseEvent.clientY - rect.top - (container.clientTop || 0));
}

module.exports = mouseEventPoint;

},{"point-geometry":171}],217:[function(require,module,exports){
'use strict';

var constrainFeatureMovement = require('./constrain_feature_movement');
var Constants = require('../constants');

module.exports = function (features, delta) {
  var constrainedDelta = constrainFeatureMovement(features.map(function (feature) {
    return feature.toGeoJSON();
  }), delta);

  features.forEach(function (feature) {
    var currentCoordinates = feature.getCoordinates();

    var moveCoordinate = function moveCoordinate(coord) {
      var point = {
        lng: coord[0] + constrainedDelta.lng,
        lat: coord[1] + constrainedDelta.lat
      };
      return [point.lng, point.lat];
    };
    var moveRing = function moveRing(ring) {
      return ring.map(function (coord) {
        return moveCoordinate(coord);
      });
    };
    var moveMultiPolygon = function moveMultiPolygon(multi) {
      return multi.map(function (ring) {
        return moveRing(ring);
      });
    };

    var nextCoordinates = void 0;
    if (feature.type === Constants.geojsonTypes.POINT) {
      nextCoordinates = moveCoordinate(currentCoordinates);
    } else if (feature.type === Constants.geojsonTypes.LINE_STRING || feature.type === Constants.geojsonTypes.MULTI_POINT) {
      nextCoordinates = currentCoordinates.map(moveCoordinate);
    } else if (feature.type === Constants.geojsonTypes.POLYGON || feature.type === Constants.geojsonTypes.MULTI_LINE_STRING) {
      nextCoordinates = currentCoordinates.map(moveRing);
    } else if (feature.type === Constants.geojsonTypes.MULTI_POLYGON) {
      nextCoordinates = currentCoordinates.map(moveMultiPolygon);
    }

    feature.incomingCoords(nextCoordinates);
  });
};

},{"../constants":195,"./constrain_feature_movement":203}],218:[function(require,module,exports){
'use strict';

var StringSet = require('../lib/string_set');
var coordEach = require('@turf/meta').coordEach;
var turf = require('@turf/turf');
var cheapRuler = require('cheap-ruler');

var DEBUG_SNAP = false;

function toPointArray(feature) {
  var result = [];
  turf.coordAll(feature).forEach(function (coords) {
    result.push(turf.point(coords));
  });
  return result;
}

// All are required
module.exports = function snapTo(evt, ctx, id) {
  if (ctx.map === null) return [];

  //console.log("---");
  var buffer = 20; // ctx.options.snapBuffer;
  var box = [[evt.point.x - buffer, evt.point.y - buffer], [evt.point.x + buffer, evt.point.y + buffer]];

  //console.log("Box: ", box);

  //const snapFilter = {layers: ["road-street", "road-service-link-track", "road-path", "road-secondary-tertiary", "road-motorway"]};
  var snapFilter = { layers: ['demodata', 'gl-draw-polygon-stroke-inactive.cold', 'gl-draw-line-inactive.cold', 'gl-draw-point-inactive.cold'] };
  //const snapFilter = {filter: ["any", ["has", "geohub"], ["in", "class", "street_major", "street_minor", "street_limited", "service", "link", "track", "street", "path", "secondary", "primary", "tertiary", "motorway"]]};
  var featureIds = new StringSet();
  var uniqueFeatures = [];
  var evtCoords = evt.lngLat.toArray !== undefined ? evt.lngLat.toArray() : undefined;
  //console.log("evtCoors: ", evtCoords);

  var closestDistance = null;
  var closestCoord = void 0;
  var closestFeature = void 0;

  var eventPoint = {
    "type": "Feature",
    "properties": {},
    "geometry": {
      "type": "Point",
      "coordinates": [0, 0]
    }
  };

  var selectedElements = {
    "type": "FeatureCollection",
    "features": []
  };

  if (ctx.map.getSource("snap-source") === undefined) {
    console.log("adding snap-source");
    ctx.map.addSource('snap-source', {
      type: 'geojson',
      data: eventPoint
    });
  }
  if (ctx.map.getLayer("snap-layer") === undefined) {
    console.log("adding snap-layer");
    ctx.map.addLayer({
      id: "snap-layer",
      source: "snap-source",
      type: "circle",
      paint: {
        "circle-color": "#ff0000",
        "circle-radius": 7
      }
    });
  }
  if (DEBUG_SNAP) {
    if (ctx.map.getSource("snap-elements") === undefined) {
      console.log("adding snap-elements");
      ctx.map.addSource('snap-elements', {
        type: 'geojson',
        data: selectedElements
      });
    }
    if (ctx.map.getLayer("snap-elements") === undefined) {
      console.log("adding snap-elements");
      ctx.map.addLayer({
        id: "snap-elements",
        source: "snap-elements",
        type: "circle",
        paint: {
          "circle-color": "#0000ff",
          "circle-radius": 4
        }
      });
    }
  }

  var renderedFeatures = ctx.map.queryRenderedFeatures(box, snapFilter);
  //console.log("renderedFeatures: ", renderedFeatures);
  renderedFeatures.forEach(function (feature) {
    var featureId = feature.properties.id;
    //console.log("checking featureId: ", featureId, " currentId: ", id);

    if (featureId !== undefined) {
      if (featureIds.has(featureId) || String(featureId) === id) {
        return;
      }
      featureIds.add(featureId);
    }
    var points = toPointArray(feature);
    points.forEach(function (point) {
      selectedElements.features.push(point);
    });
    return uniqueFeatures.push(feature);
  });

  if (evtCoords === undefined || uniqueFeatures.length < 1) {
    //remove point
    ctx.map.getSource("snap-source").setData({
      "type": "FeatureCollection",
      "features": []
    });
    if (DEBUG_SNAP) {
      ctx.map.getSource("snap-elements").setData({
        "type": "FeatureCollection",
        "features": []
      });
    }
    return evt;
  } else {
    if (DEBUG_SNAP) {
      ctx.map.getSource("snap-elements").setData(selectedElements);
    }
  }

  var closestPoints = function closestPoints(ruler, coordinates, evtCoords) {
    var result = [];
    var pointIndex = ruler.pointOnLine(coordinates, evtCoords);
    result.push({ type: "linepoint", coords: pointIndex.point });
    var vertex = null;
    if (pointIndex.index === coordinates.length) {
      vertex = coordinates[pointIndex.index];
    } else {
      var p1 = coordinates[pointIndex.index];
      var p2 = coordinates[pointIndex.index + 1];
      var distance1 = ruler.distance(p1, evtCoords);
      var distance2 = ruler.distance(p2, evtCoords);
      vertex = distance1 < distance2 ? p1 : p2;
    }
    result.push({ type: "vertex", coords: vertex });
    return result;
  };

  //console.log("Unique features: ", uniqueFeatures);
  //snapto line
  uniqueFeatures.forEach(function (feature) {
    var type = feature.geometry.type;
    var coords = [];
    var ruler = cheapRuler.fromTile(feature._vectorTileFeature._y, feature._vectorTileFeature._z); //z is max map zoom of 20

    if (type === "LineString") {
      closestPoints(ruler, feature.geometry.coordinates, evtCoords).forEach(function (pointType) {
        coords.push(pointType);
      });
    } else if (type === "Point") {
      coords.push({ type: "vertex", coords: feature.geometry.coordinates });
    } else if (type === "MultiLineString" || type === "Polygon") {
      feature.geometry.coordinates.forEach(function (coordinates) {
        closestPoints(ruler, coordinates, evtCoords).forEach(function (pointType) {
          coords.push(pointType);
        });
      });
    }

    if (coords.length === 0) {
      console.log("coords empty for feature: ", feature);
    } else {
      coords.forEach(function (pointType) {
        var singleCoords = pointType.coords;
        var dist = ruler.distance(singleCoords, evtCoords);
        //console.log("type: ", pointType.type, " dist: ", dist);
        if (dist !== null) {
          if (closestDistance === null || pointType.type === "vertex" && dist < 0.004 || dist < closestDistance) {
            feature.distance = dist;
            closestFeature = feature;
            closestCoord = singleCoords;
            closestDistance = dist;
            //console.log("clostest type: ", pointType.type, " dist: ", dist);
          }
        }
      });
    }
  });

  if (closestDistance !== null) {
    evt.lngLat.lng = closestCoord[0];
    evt.lngLat.lat = closestCoord[1];
    evt.point = ctx.map.project(closestCoord);
    evt.snap = true;
    eventPoint.geometry.coordinates = closestCoord;
    ctx.map.getSource("snap-source").setData(eventPoint);
  }
  return evt;
};

},{"../lib/string_set":220,"@turf/meta":96,"@turf/turf":123,"cheap-ruler":139}],219:[function(require,module,exports){
'use strict';

var area = require('@mapbox/geojson-area');
var Constants = require('../constants');

var FEATURE_SORT_RANKS = {
  Point: 0,
  LineString: 1,
  Polygon: 2
};

function comparator(a, b) {
  var score = FEATURE_SORT_RANKS[a.geometry.type] - FEATURE_SORT_RANKS[b.geometry.type];

  if (score === 0 && a.geometry.type === Constants.geojsonTypes.POLYGON) {
    return a.area - b.area;
  }

  return score;
}

// Sort in the order above, then sort polygons by area ascending.
function sortFeatures(features) {
  return features.map(function (feature) {
    if (feature.geometry.type === Constants.geojsonTypes.POLYGON) {
      feature.area = area.geometry({
        type: Constants.geojsonTypes.FEATURE,
        property: {},
        geometry: feature.geometry
      });
    }
    return feature;
  }).sort(comparator).map(function (feature) {
    delete feature.area;
    return feature;
  });
}

module.exports = sortFeatures;

},{"../constants":195,"@mapbox/geojson-area":2}],220:[function(require,module,exports){
"use strict";

function StringSet(items) {
  this._items = {};
  this._length = items ? items.length : 0;
  if (!items) return;
  for (var i = 0, l = items.length; i < l; i++) {
    if (items[i] === undefined) continue;
    this._items[items[i]] = i;
  }
}

StringSet.prototype.add = function (x) {
  this._length = this._items[x] ? this._length : this._length + 1;
  this._items[x] = this._items[x] ? this._items[x] : this._length;
  return this;
};

StringSet.prototype.delete = function (x) {
  this._length = this._items[x] ? this._length - 1 : this._length;
  delete this._items[x];
  return this;
};

StringSet.prototype.has = function (x) {
  return this._items[x] !== undefined;
};

StringSet.prototype.values = function () {
  var _this = this;

  var orderedKeys = Object.keys(this._items).sort(function (a, b) {
    return _this._items[a] - _this._items[b];
  });
  return orderedKeys;
};

StringSet.prototype.clear = function () {
  this._length = 0;
  this._items = {};
  return this;
};

module.exports = StringSet;

},{}],221:[function(require,module,exports){
"use strict";

module.exports = function (a, b) {
  if (a.length !== b.length) return false;
  return JSON.stringify(a.map(function (id) {
    return id;
  }).sort()) === JSON.stringify(b.map(function (id) {
    return id;
  }).sort());
};

},{}],222:[function(require,module,exports){
'use strict';

module.exports = [{
  'id': 'gl-draw-polygon-fill-inactive',
  'type': 'fill',
  'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon'], ['!=', 'mode', 'static']],
  'paint': {
    'fill-color': '#3bb2d0',
    'fill-outline-color': '#3bb2d0',
    'fill-opacity': 0.1
  }
}, {
  'id': 'gl-draw-polygon-fill-active',
  'type': 'fill',
  'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
  'paint': {
    'fill-color': '#fbb03b',
    'fill-outline-color': '#fbb03b',
    'fill-opacity': 0.1
  }
}, {
  'id': 'gl-draw-polygon-midpoint',
  'type': 'circle',
  'filter': ['all', ['==', '$type', 'Point'], ['==', 'meta', 'midpoint']],
  'paint': {
    'circle-radius': 3,
    'circle-color': '#fbb03b'
  }
}, {
  'id': 'gl-draw-polygon-stroke-inactive',
  'type': 'line',
  'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon'], ['!=', 'mode', 'static']],
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#3bb2d0',
    'line-width': 2
  }
}, {
  'id': 'gl-draw-polygon-stroke-active',
  'type': 'line',
  'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#fbb03b',
    'line-dasharray': [0.2, 2],
    'line-width': 2
  }
}, {
  'id': 'gl-draw-line-inactive',
  'type': 'line',
  'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'LineString'], ['!=', 'mode', 'static']],
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#3bb2d0',
    'line-width': 2
  }
}, {
  'id': 'gl-draw-line-active',
  'type': 'line',
  'filter': ['all', ['==', '$type', 'LineString'], ['==', 'active', 'true']],
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#fbb03b',
    'line-dasharray': [0.2, 2],
    'line-width': 2
  }
}, {
  'id': 'gl-draw-polygon-and-line-vertex-stroke-inactive',
  'type': 'circle',
  'filter': ['all', ['==', 'meta', 'vertex'], ['==', '$type', 'Point'], ['!=', 'mode', 'static']],
  'paint': {
    'circle-radius': 5,
    'circle-color': '#fff'
  }
}, {
  'id': 'gl-draw-polygon-and-line-vertex-inactive',
  'type': 'circle',
  'filter': ['all', ['==', 'meta', 'vertex'], ['==', '$type', 'Point'], ['!=', 'mode', 'static']],
  'paint': {
    'circle-radius': 3,
    'circle-color': '#fbb03b'
  }
}, {
  'id': 'gl-draw-point-point-stroke-inactive',
  'type': 'circle',
  'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Point'], ['==', 'meta', 'feature'], ['!=', 'mode', 'static']],
  'paint': {
    'circle-radius': 5,
    'circle-opacity': 1,
    'circle-color': '#fff'
  }
}, {
  'id': 'gl-draw-point-inactive',
  'type': 'circle',
  'filter': ['all', ['==', 'active', 'false'], ['==', '$type', 'Point'], ['==', 'meta', 'feature'], ['!=', 'mode', 'static']],
  'paint': {
    'circle-radius': 3,
    'circle-color': '#3bb2d0'
  }
}, {
  'id': 'gl-draw-point-stroke-active',
  'type': 'circle',
  'filter': ['all', ['==', '$type', 'Point'], ['==', 'active', 'true'], ['!=', 'meta', 'midpoint']],
  'paint': {
    'circle-radius': 7,
    'circle-color': '#fff'
  }
}, {
  'id': 'gl-draw-point-active',
  'type': 'circle',
  'filter': ['all', ['==', '$type', 'Point'], ['!=', 'meta', 'midpoint'], ['==', 'active', 'true']],
  'paint': {
    'circle-radius': 5,
    'circle-color': '#fbb03b'
  }
}, {
  'id': 'gl-draw-polygon-fill-static',
  'type': 'fill',
  'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],
  'paint': {
    'fill-color': '#404040',
    'fill-outline-color': '#404040',
    'fill-opacity': 0.1
  }
}, {
  'id': 'gl-draw-polygon-stroke-static',
  'type': 'line',
  'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#404040',
    'line-width': 2
  }
}, {
  'id': 'gl-draw-line-static',
  'type': 'line',
  'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'LineString']],
  'layout': {
    'line-cap': 'round',
    'line-join': 'round'
  },
  'paint': {
    'line-color': '#404040',
    'line-width': 2
  }
}, {
  'id': 'gl-draw-point-static',
  'type': 'circle',
  'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Point']],
  'paint': {
    'circle-radius': 5,
    'circle-color': '#404040'
  }
}];

},{}],223:[function(require,module,exports){
"use strict";

function throttle(fn, time, context) {
  var lock = void 0,
      args = void 0;

  function later() {
    // reset lock and call if queued
    lock = false;
    if (args) {
      wrapperFn.apply(context, args);
      args = false;
    }
  }

  function wrapperFn() {
    if (lock) {
      // called too soon, queue to call later
      args = arguments;
    } else {
      // lock until later then call
      lock = true;
      fn.apply(context, arguments);
      setTimeout(later, time);
    }
  }

  return wrapperFn;
}

module.exports = throttle;

},{}],224:[function(require,module,exports){
"use strict";

/**
 * Derive a dense array (no `undefined`s) from a single value or array.
 *
 * @param {any} x
 * @return {Array<any>}
 */
function toDenseArray(x) {
  return [].concat(x).filter(function (y) {
    return y !== undefined;
  });
}

module.exports = toDenseArray;

},{}],225:[function(require,module,exports){
'use strict';

var _require = require('../lib/common_selectors'),
    noTarget = _require.noTarget,
    isOfMetaType = _require.isOfMetaType,
    isInactiveFeature = _require.isInactiveFeature,
    isShiftDown = _require.isShiftDown;

var createSupplementaryPoints = require('../lib/create_supplementary_points');
var constrainFeatureMovement = require('../lib/constrain_feature_movement');
var doubleClickZoom = require('../lib/double_click_zoom');
var Constants = require('../constants');
var CommonSelectors = require('../lib/common_selectors');
var moveFeatures = require('../lib/move_features');
var snapTo = require('../lib/snap_to');

var isVertex = isOfMetaType(Constants.meta.VERTEX);
var isMidpoint = isOfMetaType(Constants.meta.MIDPOINT);

module.exports = function (ctx, opts) {
  var featureId = opts.featureId;
  var feature = ctx.store.get(featureId);

  if (!feature) {
    throw new Error('You must provide a featureId to enter direct_select mode');
  }

  if (feature.type === Constants.geojsonTypes.POINT) {
    throw new TypeError('direct_select mode doesn\'t handle point features');
  }

  var dragMoveLocation = opts.startPos || null;
  var dragMoving = false;
  var canDragMove = false;

  var selectedCoordPaths = opts.coordPath ? [opts.coordPath] : [];
  var selectedCoordinates = pathsToCoordinates(featureId, selectedCoordPaths);
  ctx.store.setSelectedCoordinates(selectedCoordinates);

  var fireUpdate = function fireUpdate() {
    ctx.map.fire(Constants.events.UPDATE, {
      action: Constants.updateActions.CHANGE_COORDINATES,
      features: ctx.store.getSelected().map(function (f) {
        return f.toGeoJSON();
      })
    });
  };

  var fireActionable = function fireActionable() {
    return ctx.events.actionable({
      combineFeatures: false,
      uncombineFeatures: false,
      trash: selectedCoordPaths.length > 0
    });
  };

  var startDragging = function startDragging(e) {
    ctx.map.dragPan.disable();
    canDragMove = true;
    dragMoveLocation = e.lngLat;
  };

  var stopDragging = function stopDragging() {
    ctx.map.dragPan.enable();
    dragMoving = false;
    canDragMove = false;
    dragMoveLocation = null;
  };

  var onVertex = function onVertex(e) {
    startDragging(e);
    var about = e.featureTarget.properties;
    var selectedIndex = selectedCoordPaths.indexOf(about.coord_path);
    if (!isShiftDown(e) && selectedIndex === -1) {
      selectedCoordPaths = [about.coord_path];
    } else if (isShiftDown(e) && selectedIndex === -1) {
      selectedCoordPaths.push(about.coord_path);
    }
    var selectedCoordinates = pathsToCoordinates(featureId, selectedCoordPaths);
    ctx.store.setSelectedCoordinates(selectedCoordinates);
    feature.changed();
  };

  var onMidpoint = function onMidpoint(e) {
    startDragging(e);
    var about = e.featureTarget.properties;
    feature.addCoordinate(about.coord_path, about.lng, about.lat);
    fireUpdate();
    selectedCoordPaths = [about.coord_path];
  };

  function pathsToCoordinates(featureId, paths) {
    return paths.map(function (coord_path) {
      return { feature_id: featureId, coord_path: coord_path, coordinates: feature.getCoordinate(coord_path) };
    });
  }

  var onFeature = function onFeature(e) {
    if (selectedCoordPaths.length === 0) startDragging(e);else stopDragging();
  };

  var dragFeature = function dragFeature(e, delta) {
    moveFeatures(ctx.store.getSelected(), delta);
    dragMoveLocation = e.lngLat;
  };

  var dragVertex = function dragVertex(e, delta) {
    var selectedCoords = selectedCoordPaths.map(function (coord_path) {
      return feature.getCoordinate(coord_path);
    });
    var selectedCoordPoints = selectedCoords.map(function (coords) {
      return {
        type: Constants.geojsonTypes.FEATURE,
        properties: {},
        geometry: {
          type: Constants.geojsonTypes.POINT,
          coordinates: coords
        }
      };
    });

    var constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);
    for (var i = 0; i < selectedCoords.length; i++) {
      var coord = selectedCoords[i];
      var lng = coord[0] + constrainedDelta.lng;
      var lat = coord[1] + constrainedDelta.lat;
      if (e.snap !== undefined) {
        lng = e.lngLat.lng;
        lat = e.lngLat.lat;
      }
      feature.updateCoordinate(selectedCoordPaths[i], lng, lat);
    }
  };

  return {
    start: function start() {
      ctx.store.setSelected(featureId);
      doubleClickZoom.disable(ctx);

      // On mousemove that is not a drag, stop vertex movement.
      this.on('mousemove', CommonSelectors.true, function (e) {
        var isFeature = CommonSelectors.isActiveFeature(e);
        var onVertex = isVertex(e);
        var noCoords = selectedCoordPaths.length === 0;
        if (isFeature && noCoords) ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });else if (onVertex && !noCoords) ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });else ctx.ui.queueMapClasses({ mouse: Constants.cursors.NONE });
        stopDragging(e);
      });

      // As soon as you mouse leaves the canvas, update the feature
      this.on('mouseout', function () {
        return dragMoving;
      }, fireUpdate);
      this.on('mousedown', isVertex, onVertex);
      this.on('touchstart', isVertex, onVertex);
      this.on('mousedown', CommonSelectors.isActiveFeature, onFeature);
      this.on('touchstart', CommonSelectors.isActiveFeature, onFeature);
      this.on('mousedown', isMidpoint, onMidpoint);
      this.on('touchstart', isMidpoint, onMidpoint);
      this.on('drag', function () {
        return canDragMove;
      }, function (e) {
        dragMoving = true;
        e.originalEvent.stopPropagation();

        var evt = e;

        if (!ctx.snapToOverride && evt.point && ctx.options.snapTo) {
          evt = snapTo(evt, ctx, featureId);
        }

        var delta = {
          lng: evt.lngLat.lng - dragMoveLocation.lng,
          lat: evt.lngLat.lat - dragMoveLocation.lat
        };
        if (selectedCoordPaths.length > 0) dragVertex(evt, delta);else dragFeature(evt, delta);

        dragMoveLocation = evt.lngLat;
      });
      this.on('click', CommonSelectors.true, stopDragging);
      this.on('mouseup', CommonSelectors.true, function () {
        if (dragMoving) {
          fireUpdate();
        }
        stopDragging();
      });
      this.on('touchend', CommonSelectors.true, function () {
        if (dragMoving) {
          fireUpdate();
        }
        stopDragging();
      });
      this.on('click', noTarget, clickNoTarget);
      this.on('tap', noTarget, clickNoTarget);
      this.on('click', isInactiveFeature, clickInactive);
      this.on('tap', isInactiveFeature, clickInactive);
      this.on('click', CommonSelectors.isActiveFeature, clickActiveFeature);
      this.on('tap', CommonSelectors.isActiveFeature, clickActiveFeature);

      function clickNoTarget() {
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
      }
      function clickInactive() {
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
      }
      function clickActiveFeature() {
        selectedCoordPaths = [];
        ctx.store.clearSelectedCoordinates();
        feature.changed();
      }
    },
    stop: function stop() {
      doubleClickZoom.enable(ctx);
      ctx.store.clearSelectedCoordinates();
    },
    render: function render(geojson, push) {
      if (featureId === geojson.properties.id) {
        geojson.properties.active = Constants.activeStates.ACTIVE;
        push(geojson);
        createSupplementaryPoints(geojson, {
          map: ctx.map,
          midpoints: true,
          selectedPaths: selectedCoordPaths
        }).forEach(push);
      } else {
        geojson.properties.active = Constants.activeStates.INACTIVE;
        push(geojson);
      }
      fireActionable();
    },
    trash: function trash() {
      selectedCoordPaths.sort().reverse().forEach(function (id) {
        return feature.removeCoordinate(id);
      });
      ctx.map.fire(Constants.events.UPDATE, {
        action: Constants.updateActions.CHANGE_COORDINATES,
        features: ctx.store.getSelected().map(function (f) {
          return f.toGeoJSON();
        })
      });
      selectedCoordPaths = [];
      ctx.store.clearSelectedCoordinates();
      fireActionable();
      if (feature.isValid() === false) {
        ctx.store.delete([featureId]);
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, {});
      }
    }
  };
};

},{"../constants":195,"../lib/common_selectors":202,"../lib/constrain_feature_movement":203,"../lib/create_supplementary_points":205,"../lib/double_click_zoom":207,"../lib/move_features":217,"../lib/snap_to":218}],226:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var CommonSelectors = require('../lib/common_selectors');
var LineString = require('../feature_types/line_string');
var isEventAtCoordinates = require('../lib/is_event_at_coordinates');
var doubleClickZoom = require('../lib/double_click_zoom');
var Constants = require('../constants');
var createVertex = require('../lib/create_vertex');
var snapTo = require('../lib/snap_to');

module.exports = function (ctx, opts) {
  opts = opts || {};
  var featureId = opts.featureId;

  var line = void 0,
      currentVertexPosition = void 0;
  var direction = 'forward';
  if (featureId) {
    line = ctx.store.get(featureId);
    if (!line) {
      throw new Error('Could not find a feature with the provided featureId');
    }
    var from = opts.from;
    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {
      from = from.geometry;
    }
    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {
      from = from.coordinates;
    }
    if (!from || !Array.isArray(from)) {
      throw new Error('Please use the `from` property to indicate which point to continue the line from');
    }
    var lastCoord = line.coordinates.length - 1;
    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {
      var _line;

      currentVertexPosition = lastCoord + 1;
      // add one new coordinate to continue from
      (_line = line).addCoordinate.apply(_line, [currentVertexPosition].concat(_toConsumableArray(line.coordinates[lastCoord])));
    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {
      var _line2;

      direction = 'backwards';
      currentVertexPosition = 0;
      // add one new coordinate to continue from
      (_line2 = line).addCoordinate.apply(_line2, [currentVertexPosition].concat(_toConsumableArray(line.coordinates[0])));
    } else {
      throw new Error('`from` should match the point at either the start or the end of the provided LineString');
    }
  } else {
    line = new LineString(ctx, {
      type: Constants.geojsonTypes.FEATURE,
      properties: {},
      geometry: {
        type: Constants.geojsonTypes.LINE_STRING,
        coordinates: []
      }
    });
    currentVertexPosition = 0;
    ctx.store.add(line);
  }

  if (ctx._test) ctx._test.line = line;
  var heardMouseMove = false;
  var snapClickPoint = void 0;

  return {
    start: function start() {
      ctx.store.clearSelected();
      doubleClickZoom.disable(ctx);
      ctx.ui.queueMapClasses({ mouse: Constants.cursors.ADD });
      ctx.ui.setActiveButton(Constants.types.LINE);

      this.on('mousemove', CommonSelectors.true, function (e) {
        var evt = e;

        if (!ctx.snapToOverride && evt.point && ctx.options.snapTo) {
          evt = snapTo(evt, ctx, line.id);
        }
        snapClickPoint = evt;
        line.updateCoordinate(currentVertexPosition, evt.lngLat.lng, evt.lngLat.lat);
        if (CommonSelectors.isVertex(evt)) {
          ctx.ui.queueMapClasses({ mouse: Constants.cursors.POINTER });
        }
        heardMouseMove = true;
      });

      this.on('click', CommonSelectors.true, clickAnywhere);
      this.on('tap', CommonSelectors.true, clickAnywhere);
      this.on('click', CommonSelectors.isVertex, clickOnVertex);
      this.on('tap', CommonSelectors.isVertex, clickOnVertex);

      function clickAnywhere(e) {
        var evt = snapClickPoint || e;
        if (currentVertexPosition > 0 && isEventAtCoordinates(evt, line.coordinates[currentVertexPosition - 1]) || direction === 'backwards' && isEventAtCoordinates(evt, line.coordinates[currentVertexPosition + 1])) {
          return ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [line.id] });
        }
        ctx.ui.queueMapClasses({ mouse: Constants.cursors.ADD });
        line.updateCoordinate(currentVertexPosition, evt.lngLat.lng, evt.lngLat.lat);
        if (direction === 'forward') {
          currentVertexPosition++;
        } else {
          line.addCoordinate(0, evt.lngLat.lng, evt.lngLat.lat);
        }
      }
      function clickOnVertex() {
        return ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [line.id] });
      }

      this.on('keyup', CommonSelectors.isEscapeKey, function () {
        ctx.store.delete([line.id], { silent: true });
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
      });
      this.on('keyup', CommonSelectors.isEnterKey, function () {
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [line.id] });
      });
      ctx.events.actionable({
        combineFeatures: false,
        uncombineFeatures: false,
        trash: true
      });
    },

    stop: function stop() {
      doubleClickZoom.enable(ctx);
      ctx.ui.setActiveButton();

      // check to see if we've deleted this feature
      if (ctx.store.get(line.id) === undefined) return;

      //remove last added coordinate
      line.removeCoordinate('' + currentVertexPosition);
      if (line.isValid()) {
        ctx.map.fire(Constants.events.CREATE, {
          features: [line.toGeoJSON()]
        });
      } else {
        ctx.store.delete([line.id], { silent: true });
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });
      }
    },
    render: function render(geojson, callback) {
      var isActiveLine = geojson.properties.id === line.id;
      geojson.properties.active = isActiveLine ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      if (!isActiveLine) return callback(geojson);

      // Only render the line if it has at least one real coordinate
      if (geojson.geometry.coordinates.length < 2) return;
      geojson.properties.meta = Constants.meta.FEATURE;

      if (geojson.geometry.coordinates.length >= 3) {
        callback(createVertex(line.id, geojson.geometry.coordinates[direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1], '' + (direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1), false));
      }

      callback(geojson);
    },
    trash: function trash() {
      if (currentVertexPosition > 1) {
        var cursorPosition = line.getCoordinate('' + currentVertexPosition);

        if (cursorPosition === undefined && heardMouseMove === true) {
          //a mousemove event has not recently happened so mimic one
          cursorPosition = line.getCoordinate('' + (currentVertexPosition - 1));
          line.updateCoordinate('' + currentVertexPosition, cursorPosition[0], cursorPosition[1]);
        }
        if (cursorPosition !== undefined && heardMouseMove === false) {
          //should be a touch with no mousemove
          line.removeCoordinate('' + currentVertexPosition);
          currentVertexPosition--;
        }
        //remove the last point
        currentVertexPosition--;
        line.removeCoordinate('' + currentVertexPosition);
      } else {
        ctx.store.delete([line.id], { silent: true });
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
      }
    }
  };
};

},{"../constants":195,"../feature_types/line_string":198,"../lib/common_selectors":202,"../lib/create_vertex":206,"../lib/double_click_zoom":207,"../lib/is_event_at_coordinates":212,"../lib/snap_to":218}],227:[function(require,module,exports){
'use strict';

var CommonSelectors = require('../lib/common_selectors');
var Point = require('../feature_types/point');
var Constants = require('../constants');

module.exports = function (ctx) {

  var point = new Point(ctx, {
    type: Constants.geojsonTypes.FEATURE,
    properties: {},
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: []
    }
  });

  if (ctx._test) ctx._test.point = point;

  ctx.store.add(point);

  function stopDrawingAndRemove() {
    ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
    ctx.store.delete([point.id], { silent: true });
  }

  function handleClick(e) {
    ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });
    point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);
    ctx.map.fire(Constants.events.CREATE, {
      features: [point.toGeoJSON()]
    });
    ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [point.id] });
  }

  return {
    start: function start() {
      ctx.store.clearSelected();
      ctx.ui.queueMapClasses({ mouse: Constants.cursors.ADD });
      ctx.ui.setActiveButton(Constants.types.POINT);
      this.on('click', CommonSelectors.true, handleClick);
      this.on('tap', CommonSelectors.true, handleClick);
      this.on('keyup', CommonSelectors.isEscapeKey, stopDrawingAndRemove);
      this.on('keyup', CommonSelectors.isEnterKey, stopDrawingAndRemove);
      ctx.events.actionable({
        combineFeatures: false,
        uncombineFeatures: false,
        trash: true
      });
    },
    stop: function stop() {
      ctx.ui.setActiveButton();
      if (!point.getCoordinate().length) {
        ctx.store.delete([point.id], { silent: true });
      }
    },
    render: function render(geojson, callback) {
      var isActivePoint = geojson.properties.id === point.id;
      geojson.properties.active = isActivePoint ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      if (!isActivePoint) return callback(geojson);
      // Never render the point we're drawing
    },
    trash: function trash() {
      stopDrawingAndRemove();
    }
  };
};

},{"../constants":195,"../feature_types/point":200,"../lib/common_selectors":202}],228:[function(require,module,exports){
'use strict';

var CommonSelectors = require('../lib/common_selectors');
var Polygon = require('../feature_types/polygon');
var doubleClickZoom = require('../lib/double_click_zoom');
var Constants = require('../constants');
var isEventAtCoordinates = require('../lib/is_event_at_coordinates');
var createVertex = require('../lib/create_vertex');
var snapTo = require('../lib/snap_to');

module.exports = function (ctx) {

  var polygon = new Polygon(ctx, {
    type: Constants.geojsonTypes.FEATURE,
    properties: {},
    geometry: {
      type: Constants.geojsonTypes.POLYGON,
      coordinates: [[]]
    }
  });
  var currentVertexPosition = 0;
  var heardMouseMove = false;

  if (ctx._test) ctx._test.polygon = polygon;

  ctx.store.add(polygon);

  var snapClickPoint = void 0;

  return {
    start: function start() {
      ctx.store.clearSelected();
      doubleClickZoom.disable(ctx);
      ctx.ui.queueMapClasses({ mouse: Constants.cursors.ADD });
      ctx.ui.setActiveButton(Constants.types.POLYGON);
      this.on('mousemove', CommonSelectors.true, function (e) {
        var evt = e;

        if (!ctx.snapToOverride && evt.point && ctx.options.snapTo) {
          evt = snapTo(evt, ctx, polygon.id);
        }
        snapClickPoint = evt;
        polygon.updateCoordinate('0.' + currentVertexPosition, evt.lngLat.lng, evt.lngLat.lat);
        if (CommonSelectors.isVertex(evt)) {
          ctx.ui.queueMapClasses({ mouse: Constants.cursors.POINTER });
        }
        heardMouseMove = true;
      });
      this.on('click', CommonSelectors.true, clickAnywhere);
      this.on('click', CommonSelectors.isVertex, clickOnVertex);
      this.on('tap', CommonSelectors.true, clickAnywhere);
      this.on('tap', CommonSelectors.isVertex, clickOnVertex);

      function clickAnywhere(e) {
        var evt = snapClickPoint || e;
        if (currentVertexPosition > 0 && isEventAtCoordinates(evt, polygon.coordinates[0][currentVertexPosition - 1])) {
          return ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [polygon.id] });
        }
        ctx.ui.queueMapClasses({ mouse: Constants.cursors.ADD });
        polygon.updateCoordinate('0.' + currentVertexPosition, evt.lngLat.lng, evt.lngLat.lat);
        currentVertexPosition++;
      }
      function clickOnVertex() {
        return ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [polygon.id] });
      }
      this.on('keyup', CommonSelectors.isEscapeKey, function () {
        ctx.store.delete([polygon.id], { silent: true });
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
      });
      this.on('keyup', CommonSelectors.isEnterKey, function () {
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [polygon.id] });
      });
      ctx.events.actionable({
        combineFeatures: false,
        uncombineFeatures: false,
        trash: true
      });
    },


    stop: function stop() {
      ctx.ui.queueMapClasses({ mouse: Constants.cursors.NONE });
      doubleClickZoom.enable(ctx);
      ctx.ui.setActiveButton();

      // check to see if we've deleted this feature
      if (ctx.store.get(polygon.id) === undefined) return;

      //remove last added coordinate
      polygon.removeCoordinate('0.' + currentVertexPosition);
      if (polygon.isValid()) {
        ctx.map.fire(Constants.events.CREATE, {
          features: [polygon.toGeoJSON()]
        });
      } else {
        ctx.store.delete([polygon.id], { silent: true });
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });
      }
    },

    render: function render(geojson, callback) {
      var isActivePolygon = geojson.properties.id === polygon.id;
      geojson.properties.active = isActivePolygon ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      if (!isActivePolygon) return callback(geojson);

      // Don't render a polygon until it has two positions
      // (and a 3rd which is just the first repeated)
      if (geojson.geometry.coordinates.length === 0) return;

      var coordinateCount = geojson.geometry.coordinates[0].length;

      // If we have fewer than two positions (plus the closer),
      // it's not yet a shape to render
      if (coordinateCount < 3) return;

      geojson.properties.meta = Constants.meta.FEATURE;

      if (coordinateCount > 4) {
        // Add a start position marker to the map, clicking on this will finish the feature
        // This should only be shown when we're in a valid spot
        callback(createVertex(polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));
        var endPos = geojson.geometry.coordinates[0].length - 3;
        callback(createVertex(polygon.id, geojson.geometry.coordinates[0][endPos], '0.' + endPos, false));
      }

      // If we have more than two positions (plus the closer),
      // render the Polygon
      if (coordinateCount > 3) {
        return callback(geojson);
      }

      // If we've only drawn two positions (plus the closer),
      // make a LineString instead of a Polygon
      var lineCoordinates = [[geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]];
      return callback({
        type: Constants.geojsonTypes.FEATURE,
        properties: geojson.properties,
        geometry: {
          coordinates: lineCoordinates,
          type: Constants.geojsonTypes.LINE_STRING
        }
      });
    },
    trash: function trash() {
      if (currentVertexPosition > 1) {
        var cursorPosition = polygon.getCoordinate('0.' + currentVertexPosition);

        if (cursorPosition === undefined && heardMouseMove === true) {
          //a mousemove event has not recently happened so mimic one
          cursorPosition = polygon.getCoordinate('0.' + (currentVertexPosition - 1));
          polygon.updateCoordinate('0.' + currentVertexPosition, cursorPosition[0], cursorPosition[1]);
        }
        if (cursorPosition !== undefined && heardMouseMove === false) {
          //should be a touch which has no mousemove
          polygon.removeCoordinate('0.' + currentVertexPosition);
          currentVertexPosition--;
        }
        //remove last added coordinate
        currentVertexPosition--;
        polygon.removeCoordinate('0.' + currentVertexPosition);
      } else {
        ctx.store.delete([polygon.id], { silent: true });
        ctx.events.changeMode(Constants.modes.SIMPLE_SELECT);
      }
    }
  };
};

},{"../constants":195,"../feature_types/polygon":201,"../lib/common_selectors":202,"../lib/create_vertex":206,"../lib/double_click_zoom":207,"../lib/is_event_at_coordinates":212,"../lib/snap_to":218}],229:[function(require,module,exports){
'use strict';

var CommonSelectors = require('../lib/common_selectors');
var mouseEventPoint = require('../lib/mouse_event_point');
var featuresAt = require('../lib/features_at');
var createSupplementaryPoints = require('../lib/create_supplementary_points');
var StringSet = require('../lib/string_set');
var doubleClickZoom = require('../lib/double_click_zoom');
var moveFeatures = require('../lib/move_features');
var Constants = require('../constants');
var MultiFeature = require('../feature_types/multi_feature');

module.exports = function (ctx) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var dragMoveLocation = null;
  var boxSelectStartLocation = null;
  var boxSelectElement = void 0;
  var boxSelecting = false;
  var canBoxSelect = false;
  var dragMoving = false;
  var canDragMove = false;

  var initiallySelectedFeatureIds = options.featureIds || [];

  var fireUpdate = function fireUpdate() {
    ctx.map.fire(Constants.events.UPDATE, {
      action: Constants.updateActions.MOVE,
      features: ctx.store.getSelected().map(function (f) {
        return f.toGeoJSON();
      })
    });
  };

  var fireActionable = function fireActionable() {
    var selectedFeatures = ctx.store.getSelected();

    var multiFeatures = selectedFeatures.filter(function (feature) {
      return feature instanceof MultiFeature;
    });

    var combineFeatures = false;

    if (selectedFeatures.length > 1) {
      combineFeatures = true;
      var featureType = selectedFeatures[0].type.replace('Multi', '');
      selectedFeatures.forEach(function (feature) {
        if (feature.type.replace('Multi', '') !== featureType) {
          combineFeatures = false;
        }
      });
    }

    var uncombineFeatures = multiFeatures.length > 0;
    var trash = selectedFeatures.length > 0;

    ctx.events.actionable({
      combineFeatures: combineFeatures, uncombineFeatures: uncombineFeatures, trash: trash
    });
  };

  var getUniqueIds = function getUniqueIds(allFeatures) {
    if (!allFeatures.length) return [];
    var ids = allFeatures.map(function (s) {
      return s.properties.id;
    }).filter(function (id) {
      return id !== undefined;
    }).reduce(function (memo, id) {
      memo.add(id);
      return memo;
    }, new StringSet());

    return ids.values();
  };

  var stopExtendedInteractions = function stopExtendedInteractions() {
    if (boxSelectElement) {
      if (boxSelectElement.parentNode) boxSelectElement.parentNode.removeChild(boxSelectElement);
      boxSelectElement = null;
    }

    ctx.map.dragPan.enable();

    boxSelecting = false;
    canBoxSelect = false;
    dragMoving = false;
    canDragMove = false;
  };

  return {
    stop: function stop() {
      doubleClickZoom.enable(ctx);
    },
    start: function start() {
      // Select features that should start selected,
      // probably passed in from a `draw_*` mode
      if (ctx.store) {
        ctx.store.setSelected(initiallySelectedFeatureIds.filter(function (id) {
          return ctx.store.get(id) !== undefined;
        }));
        fireActionable();
      }

      // Any mouseup should stop box selecting and dragMoving
      this.on('mouseup', CommonSelectors.true, stopExtendedInteractions);

      // On mousemove that is not a drag, stop extended interactions.
      // This is useful if you drag off the canvas, release the button,
      // then move the mouse back over the canvas --- we don't allow the
      // interaction to continue then, but we do let it continue if you held
      // the mouse button that whole time
      this.on('mousemove', CommonSelectors.true, stopExtendedInteractions);

      // As soon as you mouse leaves the canvas, update the feature
      this.on('mouseout', function () {
        return dragMoving;
      }, fireUpdate);

      // Click (with or without shift) on no feature
      this.on('click', CommonSelectors.noTarget, clickAnywhere);
      this.on('tap', CommonSelectors.noTarget, clickAnywhere);

      // Click (with or without shift) on a vertex
      this.on('click', CommonSelectors.isOfMetaType(Constants.meta.VERTEX), clickOnVertex);
      this.on('tap', CommonSelectors.isOfMetaType(Constants.meta.VERTEX), clickOnVertex);

      function clickAnywhere() {
        var _this = this;

        // Clear the re-render selection
        var wasSelected = ctx.store.getSelectedIds();
        if (wasSelected.length) {
          ctx.store.clearSelected();
          wasSelected.forEach(function (id) {
            return _this.render(id);
          });
        }
        doubleClickZoom.enable(ctx);
        stopExtendedInteractions();
      }

      function clickOnVertex(e) {
        // Enter direct select mode
        ctx.events.changeMode(Constants.modes.DIRECT_SELECT, {
          featureId: e.featureTarget.properties.parent,
          coordPath: e.featureTarget.properties.coord_path,
          startPos: e.lngLat
        });
        ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });
      }

      // Mousedown on a selected feature
      this.on('mousedown', CommonSelectors.isActiveFeature, startOnActiveFeature);
      this.on('touchstart', CommonSelectors.isActiveFeature, startOnActiveFeature);

      function startOnActiveFeature(e) {
        // Stop any already-underway extended interactions
        stopExtendedInteractions();

        // Disable map.dragPan immediately so it can't start
        ctx.map.dragPan.disable();

        // Re-render it and enable drag move
        this.render(e.featureTarget.properties.id);

        // Set up the state for drag moving
        canDragMove = true;
        dragMoveLocation = e.lngLat;
      }

      // Click (with or without shift) on any feature
      this.on('click', CommonSelectors.isFeature, clickOnFeature);
      this.on('tap', CommonSelectors.isFeature, clickOnFeature);

      function clickOnFeature(e) {
        // Stop everything
        doubleClickZoom.disable(ctx);
        stopExtendedInteractions();

        var isShiftClick = CommonSelectors.isShiftDown(e);
        var selectedFeatureIds = ctx.store.getSelectedIds();
        var featureId = e.featureTarget.properties.id;
        var isFeatureSelected = ctx.store.isSelected(featureId);

        // Click (without shift) on any selected feature but a point
        if (!isShiftClick && isFeatureSelected && ctx.store.get(featureId).type !== Constants.geojsonTypes.POINT) {
          // Enter direct select mode
          return ctx.events.changeMode(Constants.modes.DIRECT_SELECT, {
            featureId: featureId
          });
        }

        // Shift-click on a selected feature
        if (isFeatureSelected && isShiftClick) {
          // Deselect it
          ctx.store.deselect(featureId);
          ctx.ui.queueMapClasses({ mouse: Constants.cursors.POINTER });
          if (selectedFeatureIds.length === 1) {
            doubleClickZoom.enable(ctx);
          }
          // Shift-click on an unselected feature
        } else if (!isFeatureSelected && isShiftClick) {
          // Add it to the selection
          ctx.store.select(featureId);
          ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });
          // Click (without shift) on an unselected feature
        } else if (!isFeatureSelected && !isShiftClick) {
          // Make it the only selected feature
          selectedFeatureIds.forEach(this.render);
          ctx.store.setSelected(featureId);
          ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });
        }

        // No matter what, re-render the clicked feature
        this.render(featureId);
      }

      // Dragging when drag move is enabled
      this.on('drag', function () {
        return canDragMove;
      }, function (e) {
        dragMoving = true;
        e.originalEvent.stopPropagation();

        var delta = {
          lng: e.lngLat.lng - dragMoveLocation.lng,
          lat: e.lngLat.lat - dragMoveLocation.lat
        };

        moveFeatures(ctx.store.getSelected(), delta);

        dragMoveLocation = e.lngLat;
      });

      // Mouseup, always
      this.on('mouseup', CommonSelectors.true, function (e) {
        // End any extended interactions
        if (dragMoving) {
          fireUpdate();
        } else if (boxSelecting) {
          var bbox = [boxSelectStartLocation, mouseEventPoint(e.originalEvent, ctx.container)];
          var featuresInBox = featuresAt.click(null, bbox, ctx);
          var idsToSelect = getUniqueIds(featuresInBox).filter(function (id) {
            return !ctx.store.isSelected(id);
          });

          if (idsToSelect.length) {
            ctx.store.select(idsToSelect);
            idsToSelect.forEach(this.render);
            ctx.ui.queueMapClasses({ mouse: Constants.cursors.MOVE });
          }
        }
        stopExtendedInteractions();
      });

      if (ctx.options.boxSelect) {
        // Shift-mousedown anywhere
        this.on('mousedown', CommonSelectors.isShiftMousedown, function (e) {
          stopExtendedInteractions();
          ctx.map.dragPan.disable();
          // Enable box select
          boxSelectStartLocation = mouseEventPoint(e.originalEvent, ctx.container);
          canBoxSelect = true;
        });

        // Drag when box select is enabled
        this.on('drag', function () {
          return canBoxSelect;
        }, function (e) {
          boxSelecting = true;
          ctx.ui.queueMapClasses({ mouse: Constants.cursors.ADD });

          // Create the box node if it doesn't exist
          if (!boxSelectElement) {
            boxSelectElement = document.createElement('div');
            boxSelectElement.classList.add(Constants.classes.BOX_SELECT);
            ctx.container.appendChild(boxSelectElement);
          }

          // Adjust the box node's width and xy position
          var current = mouseEventPoint(e.originalEvent, ctx.container);
          var minX = Math.min(boxSelectStartLocation.x, current.x);
          var maxX = Math.max(boxSelectStartLocation.x, current.x);
          var minY = Math.min(boxSelectStartLocation.y, current.y);
          var maxY = Math.max(boxSelectStartLocation.y, current.y);
          var translateValue = 'translate(' + minX + 'px, ' + minY + 'px)';
          boxSelectElement.style.transform = translateValue;
          boxSelectElement.style.WebkitTransform = translateValue;
          boxSelectElement.style.width = maxX - minX + 'px';
          boxSelectElement.style.height = maxY - minY + 'px';
        });
      }
    },
    render: function render(geojson, push) {
      geojson.properties.active = ctx.store.isSelected(geojson.properties.id) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      push(geojson);
      fireActionable();
      if (geojson.properties.active !== Constants.activeStates.ACTIVE || geojson.geometry.type === Constants.geojsonTypes.POINT) return;
      createSupplementaryPoints(geojson).forEach(push);
    },
    trash: function trash() {
      ctx.store.delete(ctx.store.getSelectedIds());
      fireActionable();
    },
    combineFeatures: function combineFeatures() {
      var selectedFeatures = ctx.store.getSelected();

      if (selectedFeatures.length === 0 || selectedFeatures.length < 2) return;

      var coordinates = [],
          featuresCombined = [];
      var featureType = selectedFeatures[0].type.replace('Multi', '');

      for (var i = 0; i < selectedFeatures.length; i++) {
        var feature = selectedFeatures[i];

        if (feature.type.replace('Multi', '') !== featureType) {
          return;
        }
        if (feature.type.includes('Multi')) {
          feature.getCoordinates().forEach(function (subcoords) {
            coordinates.push(subcoords);
          });
        } else {
          coordinates.push(feature.getCoordinates());
        }

        featuresCombined.push(feature.toGeoJSON());
      }

      if (featuresCombined.length > 1) {

        var multiFeature = new MultiFeature(ctx, {
          type: Constants.geojsonTypes.FEATURE,
          properties: featuresCombined[0].properties,
          geometry: {
            type: 'Multi' + featureType,
            coordinates: coordinates
          }
        });

        ctx.store.add(multiFeature);
        ctx.store.delete(ctx.store.getSelectedIds(), { silent: true });
        ctx.store.setSelected([multiFeature.id]);

        ctx.map.fire(Constants.events.COMBINE_FEATURES, {
          createdFeatures: [multiFeature.toGeoJSON()],
          deletedFeatures: featuresCombined
        });
      }
      fireActionable();
    },
    uncombineFeatures: function uncombineFeatures() {
      var selectedFeatures = ctx.store.getSelected();
      if (selectedFeatures.length === 0) return;

      var createdFeatures = [];
      var featuresUncombined = [];

      var _loop = function _loop(i) {
        var feature = selectedFeatures[i];

        if (feature instanceof MultiFeature) {
          feature.getFeatures().forEach(function (subFeature) {
            ctx.store.add(subFeature);
            subFeature.properties = feature.properties;
            createdFeatures.push(subFeature.toGeoJSON());
            ctx.store.select([subFeature.id]);
          });
          ctx.store.delete(feature.id, { silent: true });
          featuresUncombined.push(feature.toGeoJSON());
        }
      };

      for (var i = 0; i < selectedFeatures.length; i++) {
        _loop(i);
      }

      if (createdFeatures.length > 1) {
        ctx.map.fire(Constants.events.UNCOMBINE_FEATURES, {
          createdFeatures: createdFeatures,
          deletedFeatures: featuresUncombined
        });
      }
      fireActionable();
    }
  };
};

},{"../constants":195,"../feature_types/multi_feature":199,"../lib/common_selectors":202,"../lib/create_supplementary_points":205,"../lib/double_click_zoom":207,"../lib/features_at":209,"../lib/mouse_event_point":216,"../lib/move_features":217,"../lib/string_set":220}],230:[function(require,module,exports){
"use strict";

module.exports = function (ctx) {
  return {
    stop: function stop() {},
    start: function start() {
      ctx.events.actionable({
        combineFeatures: false,
        uncombineFeatures: false,
        trash: false
      });
    },
    render: function render(geojson, push) {
      push(geojson);
    }
  };
};

},{}],231:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var Constants = require('./constants');

var defaultOptions = {
  defaultMode: Constants.modes.SIMPLE_SELECT,
  keybindings: true,
  touchEnabled: true,
  clickBuffer: 2,
  snapBuffer: 15,
  touchBuffer: 25,
  boxSelect: true,
  snapTo: true,
  displayControlsDefault: true,
  styles: require('./lib/theme'),
  controls: {},
  userProperties: false,
  snapStyles: ['gl-draw-polygon-stroke-inactive.cold', 'gl-draw-line-inactive.cold', 'gl-draw-point-inactive.cold'],
  snapOverCircleStyle: {
    'id': 'gl-draw-circle-snap',
    'type': 'circle',
    'paint': {
      'circle-radius': 3,
      'circle-color': '#FF0',
      'circle-stroke-width': 1,
      'circle-stroke-color': '#000'
    },
    'filter': ['all', ["==", "id", ""]],
    'source': 'mapbox-gl-draw-cold'
  },
  snapOverLineStyle: {
    'id': 'gl-draw-line-snap',
    'type': 'line',
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#00F',
      'line-width': 1
    },
    'filter': ['all', ["==", "id", ""]],
    'source': 'mapbox-gl-draw-cold'
  }
};

var showControls = {
  point: true,
  line_string: true,
  polygon: true,
  trash: true,
  combine_features: true,
  uncombine_features: true
};

var hideControls = {
  point: false,
  line_string: false,
  polygon: false,
  trash: false,
  combine_features: false,
  uncombine_features: false
};

function addSources(styles, sourceBucket) {
  return styles.map(function (style) {
    if (style.source) return style;
    return xtend(style, {
      id: style.id + '.' + sourceBucket,
      source: sourceBucket === 'hot' ? Constants.sources.HOT : Constants.sources.COLD
    });
  });
}

module.exports = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var withDefaults = xtend(options);

  if (!options.controls) {
    withDefaults.controls = {};
  }

  if (options.displayControlsDefault === false) {
    withDefaults.controls = xtend(hideControls, options.controls);
  } else {
    withDefaults.controls = xtend(showControls, options.controls);
  }

  withDefaults = xtend(defaultOptions, withDefaults);

  // Layers with a shared source should be adjacent for performance reasons
  withDefaults.styles = addSources(withDefaults.styles, 'cold').concat(addSources(withDefaults.styles, 'hot'));

  return withDefaults;
};

},{"./constants":195,"./lib/theme":222,"xtend":193}],232:[function(require,module,exports){
'use strict';

var Constants = require('./constants');

module.exports = function render() {
  var store = this;
  var mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;
  if (!mapExists) return cleanup();

  var mode = store.ctx.events.currentModeName();

  store.ctx.ui.queueMapClasses({ mode: mode });

  var newHotIds = [];
  var newColdIds = [];

  if (store.isDirty) {
    newColdIds = store.getAllIds();
  } else {
    newHotIds = store.getChangedIds().filter(function (id) {
      return store.get(id) !== undefined;
    });
    newColdIds = store.sources.hot.filter(function (geojson) {
      return geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined;
    }).map(function (geojson) {
      return geojson.properties.id;
    });
  }

  store.sources.hot = [];
  var lastColdCount = store.sources.cold.length;
  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter(function (geojson) {
    var id = geojson.properties.id || geojson.properties.parent;
    return newHotIds.indexOf(id) === -1;
  });

  var coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;

  newHotIds.forEach(function (id) {
    return renderFeature(id, 'hot');
  });
  newColdIds.forEach(function (id) {
    return renderFeature(id, 'cold');
  });

  function renderFeature(id, source) {
    var feature = store.get(id);
    var featureInternal = feature.internal(mode);
    store.ctx.events.currentModeRender(featureInternal, function (geojson) {
      store.sources[source].push(geojson);
    });
  }

  if (coldChanged) {
    store.ctx.map.getSource(Constants.sources.COLD).setData({
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: store.sources.cold
    });
  }

  store.ctx.map.getSource(Constants.sources.HOT).setData({
    type: Constants.geojsonTypes.FEATURE_COLLECTION,
    features: store.sources.hot
  });

  if (store._emitSelectionChange) {
    store.ctx.map.fire(Constants.events.SELECTION_CHANGE, {
      features: store.getSelected().map(function (feature) {
        return feature.toGeoJSON();
      }),
      points: store.getSelectedCoordinates().map(function (coordinate) {
        return {
          type: Constants.geojsonTypes.FEATURE,
          properties: {},
          geometry: {
            type: Constants.geojsonTypes.POINT,
            coordinates: coordinate.coordinates
          }
        };
      })
    });
    store._emitSelectionChange = false;
  }

  if (store._deletedFeaturesToEmit.length) {
    var geojsonToEmit = store._deletedFeaturesToEmit.map(function (feature) {
      return feature.toGeoJSON();
    });

    store._deletedFeaturesToEmit = [];

    store.ctx.map.fire(Constants.events.DELETE, {
      features: geojsonToEmit
    });
  }

  store.ctx.map.fire(Constants.events.RENDER, {});
  cleanup();

  function cleanup() {
    store.isDirty = false;
    store.clearChangedIds();
  }
};

},{"./constants":195}],233:[function(require,module,exports){
'use strict';

var events = require('./events');
var Store = require('./store');
var ui = require('./ui');
var Constants = require('./constants');

module.exports = function (ctx) {

  ctx.events = events(ctx);

  ctx.map = null;
  ctx.container = null;
  ctx.store = null;
  ctx.ui = ui(ctx);
  ctx.snapToOverride = false;

  var controlContainer = null;

  var setup = {
    onRemove: function onRemove() {
      setup.removeLayers();
      ctx.ui.removeButtons();
      ctx.events.removeEventListeners();
      ctx.map = null;
      ctx.container = null;
      ctx.store = null;

      if (controlContainer && controlContainer.parentNode) controlContainer.parentNode.removeChild(controlContainer);
      controlContainer = null;

      return this;
    },
    onAdd: function onAdd(map) {
      ctx.map = map;
      ctx.container = map.getContainer();
      ctx.store = new Store(ctx);

      controlContainer = ctx.ui.addButtons();

      if (ctx.options.boxSelect) {
        map.boxZoom.disable();
        // Need to toggle dragPan on and off or else first
        // dragPan disable attempt in simple_select doesn't work
        map.dragPan.disable();
        map.dragPan.enable();
      }

      var intervalId = null;

      var connect = function connect() {
        map.off('load', connect);
        clearInterval(intervalId);
        setup.addLayers();
        ctx.events.addEventListeners();
      };

      if (map.loaded()) {
        connect();
      } else {
        map.on('load', connect);
        intervalId = setInterval(function () {
          if (map.loaded()) connect();
        }, 16);
      }

      return controlContainer;
    },
    addLayers: function addLayers() {
      // drawn features style
      ctx.map.addSource(Constants.sources.COLD, {
        data: {
          type: Constants.geojsonTypes.FEATURE_COLLECTION,
          features: []
        },
        type: 'geojson'
      });

      // hot features style
      ctx.map.addSource(Constants.sources.HOT, {
        data: {
          type: Constants.geojsonTypes.FEATURE_COLLECTION,
          features: []
        },
        type: 'geojson'
      });

      ctx.options.styles.forEach(function (style) {
        ctx.map.addLayer(style);
      });

      ctx.store.render();
    },
    removeLayers: function removeLayers() {
      ctx.options.styles.forEach(function (style) {
        ctx.map.removeLayer(style.id);
      });
      //remove snap layers
      if (ctx.map.getLayer(ctx.options.snapOverCircleStyle.id) !== undefined) {
        ctx.map.removeLayer(ctx.options.snapOverCircleStyle.id);
      }
      if (ctx.map.getLayer(ctx.options.snapOverLineStyle.id) !== undefined) {
        ctx.map.removeLayer(ctx.options.snapOverLineStyle.id);
      }

      ctx.map.removeSource(Constants.sources.COLD);
      ctx.map.removeSource(Constants.sources.HOT);
    }
  };

  ctx.setup = setup;

  return setup;
};

},{"./constants":195,"./events":196,"./store":234,"./ui":235}],234:[function(require,module,exports){
'use strict';

var throttle = require('./lib/throttle');
var toDenseArray = require('./lib/to_dense_array');
var StringSet = require('./lib/string_set');
var render = require('./render');

var Store = module.exports = function (ctx) {
  this._features = {};
  this._featureIds = new StringSet();
  this._selectedFeatureIds = new StringSet();
  this._selectedCoordinates = [];
  this._changedFeatureIds = new StringSet();
  this._deletedFeaturesToEmit = [];
  this._emitSelectionChange = false;
  this.ctx = ctx;
  this.sources = {
    hot: [],
    cold: []
  };
  this.render = throttle(render, 16, this);
  this.isDirty = false;
};

/**
 * Delays all rendering until the returned function is invoked
 * @return {Function} renderBatch
 */
Store.prototype.createRenderBatch = function () {
  var _this = this;

  var holdRender = this.render;
  var numRenders = 0;
  this.render = function () {
    numRenders++;
  };

  return function () {
    _this.render = holdRender;
    if (numRenders > 0) {
      _this.render();
    }
  };
};

/**
 * Sets the store's state to dirty.
 * @return {Store} this
 */
Store.prototype.setDirty = function () {
  this.isDirty = true;
  return this;
};

/**
 * Sets a feature's state to changed.
 * @param {string} featureId
 * @return {Store} this
 */
Store.prototype.featureChanged = function (featureId) {
  this._changedFeatureIds.add(featureId);
  return this;
};

/**
 * Gets the ids of all features currently in changed state.
 * @return {Store} this
 */
Store.prototype.getChangedIds = function () {
  return this._changedFeatureIds.values();
};

/**
 * Sets all features to unchanged state.
 * @return {Store} this
 */
Store.prototype.clearChangedIds = function () {
  this._changedFeatureIds.clear();
  return this;
};

/**
 * Gets the ids of all features in the store.
 * @return {Store} this
 */
Store.prototype.getAllIds = function () {
  return this._featureIds.values();
};

/**
 * Adds a feature to the store.
 * @param {Object} feature
 *
 * @return {Store} this
 */
Store.prototype.add = function (feature) {
  this.featureChanged(feature.id);
  this._features[feature.id] = feature;
  this._featureIds.add(feature.id);
  return this;
};

/**
 * Deletes a feature or array of features from the store.
 * Cleans up after the deletion by deselecting the features.
 * If changes were made, sets the state to the dirty
 * and fires an event.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.delete = function (featureIds) {
  var _this2 = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  toDenseArray(featureIds).forEach(function (id) {
    if (!_this2._featureIds.has(id)) return;
    _this2._featureIds.delete(id);
    _this2._selectedFeatureIds.delete(id);
    if (!options.silent) {
      if (_this2._deletedFeaturesToEmit.indexOf(_this2._features[id]) === -1) {
        _this2._deletedFeaturesToEmit.push(_this2._features[id]);
      }
    }
    delete _this2._features[id];
    _this2.isDirty = true;
  });
  refreshSelectedCoordinates.call(this, options);
  return this;
};

/**
 * Returns a feature in the store matching the specified value.
 * @return {Object | undefined} feature
 */
Store.prototype.get = function (id) {
  return this._features[id];
};

/**
 * Returns all features in the store.
 * @return {Array<Object>}
 */
Store.prototype.getAll = function () {
  var _this3 = this;

  return Object.keys(this._features).map(function (id) {
    return _this3._features[id];
  });
};

/**
 * Adds features to the current selection.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.select = function (featureIds) {
  var _this4 = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  toDenseArray(featureIds).forEach(function (id) {
    if (_this4._selectedFeatureIds.has(id)) return;
    _this4._selectedFeatureIds.add(id);
    _this4._changedFeatureIds.add(id);
    if (!options.silent) {
      _this4._emitSelectionChange = true;
    }
  });
  return this;
};

/**
 * Deletes features from the current selection.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.deselect = function (featureIds) {
  var _this5 = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  toDenseArray(featureIds).forEach(function (id) {
    if (!_this5._selectedFeatureIds.has(id)) return;
    _this5._selectedFeatureIds.delete(id);
    _this5._changedFeatureIds.add(id);
    if (!options.silent) {
      _this5._emitSelectionChange = true;
    }
  });
  refreshSelectedCoordinates.call(this, options);
  return this;
};

/**
 * Clears the current selection.
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.clearSelected = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.deselect(this._selectedFeatureIds.values(), { silent: options.silent });
  return this;
};

/**
 * Sets the store's selection, clearing any prior values.
 * If no feature ids are passed, the store is just cleared.
 * @param {string | Array<string> | undefined} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.setSelected = function (featureIds) {
  var _this6 = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  featureIds = toDenseArray(featureIds);

  // Deselect any features not in the new selection
  this.deselect(this._selectedFeatureIds.values().filter(function (id) {
    return featureIds.indexOf(id) === -1;
  }), { silent: options.silent });

  // Select any features in the new selection that were not already selected
  this.select(featureIds.filter(function (id) {
    return !_this6._selectedFeatureIds.has(id);
  }), { silent: options.silent });

  return this;
};

/**
 * Sets the store's coordinates selection, clearing any prior values.
 * @param {Array<Array<string>>} coordinates
 * @return {Store} this
 */
Store.prototype.setSelectedCoordinates = function (coordinates) {
  this._selectedCoordinates = coordinates;
  this._emitSelectionChange = true;
  return this;
};

/**
 * Clears the current coordinates selection.
 * @param {Object} [options]
 * @return {Store} this
 */
Store.prototype.clearSelectedCoordinates = function () {
  this._selectedCoordinates = [];
  this._emitSelectionChange = true;
  return this;
};

/**
 * Returns the ids of features in the current selection.
 * @return {Array<string>} Selected feature ids.
 */
Store.prototype.getSelectedIds = function () {
  return this._selectedFeatureIds.values();
};

/**
 * Returns features in the current selection.
 * @return {Array<Object>} Selected features.
 */
Store.prototype.getSelected = function () {
  var _this7 = this;

  return this._selectedFeatureIds.values().map(function (id) {
    return _this7.get(id);
  });
};

/**
 * Returns selected coordinates in the currently selected feature.
 * @return {Array<Object>} Selected coordinates.
 */
Store.prototype.getSelectedCoordinates = function () {
  return this._selectedCoordinates;
};

/**
 * Indicates whether a feature is selected.
 * @param {string} featureId
 * @return {boolean} `true` if the feature is selected, `false` if not.
 */
Store.prototype.isSelected = function (featureId) {
  return this._selectedFeatureIds.has(featureId);
};

/**
 * Sets a property on the given feature
 * @param {string} featureId
 * @param {string} property property
 * @param {string} property value
*/
Store.prototype.setFeatureProperty = function (featureId, property, value) {
  this.get(featureId).setProperty(property, value);
  this.featureChanged(featureId);
};

function refreshSelectedCoordinates(options) {
  var _this8 = this;

  var newSelectedCoordinates = this._selectedCoordinates.filter(function (point) {
    return _this8._selectedFeatureIds.has(point.feature_id);
  });
  if (this._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {
    this._emitSelectionChange = true;
  }
  this._selectedCoordinates = newSelectedCoordinates;
}

},{"./lib/string_set":220,"./lib/throttle":223,"./lib/to_dense_array":224,"./render":232}],235:[function(require,module,exports){
'use strict';

var xtend = require('xtend');
var Constants = require('./constants');

var classTypes = ['mode', 'feature', 'mouse'];

module.exports = function (ctx) {

  var buttonElements = {};
  var activeButton = null;

  var currentMapClasses = {
    mode: null, // e.g. mode-direct_select
    feature: null, // e.g. feature-vertex
    mouse: null // e.g. mouse-move
  };

  var nextMapClasses = {
    mode: null,
    feature: null,
    mouse: null
  };

  function queueMapClasses(options) {
    nextMapClasses = xtend(nextMapClasses, options);
  }

  function updateMapClasses() {
    if (!ctx.container) return;

    var classesToRemove = [];
    var classesToAdd = [];

    classTypes.forEach(function (type) {
      if (nextMapClasses[type] === currentMapClasses[type]) return;

      classesToRemove.push(type + '-' + currentMapClasses[type]);
      if (nextMapClasses[type] !== null) {
        classesToAdd.push(type + '-' + nextMapClasses[type]);
      }
    });

    if (classesToRemove.length > 0) {
      ctx.container.classList.remove.apply(ctx.container.classList, classesToRemove);
    }

    if (classesToAdd.length > 0) {
      ctx.container.classList.add.apply(ctx.container.classList, classesToAdd);
    }

    currentMapClasses = xtend(currentMapClasses, nextMapClasses);
  }

  function createControlButton(id) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var button = document.createElement('button');
    button.className = Constants.classes.CONTROL_BUTTON + ' ' + options.className;
    button.setAttribute('title', options.title);
    options.container.appendChild(button);

    button.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();

      var clickedButton = e.target;
      if (clickedButton === activeButton) {
        deactivateButtons();
        return;
      }

      setActiveButton(id);
      options.onActivate();
    }, true);

    return button;
  }

  function deactivateButtons() {
    if (!activeButton) return;
    activeButton.classList.remove(Constants.classes.ACTIVE_BUTTON);
    activeButton = null;
  }

  function setActiveButton(id) {
    deactivateButtons();

    var button = buttonElements[id];
    if (!button) return;

    if (button && id !== 'trash') {
      button.classList.add(Constants.classes.ACTIVE_BUTTON);
      activeButton = button;
    }
  }

  function addButtons() {
    var controls = ctx.options.controls;
    var controlGroup = document.createElement('div');
    controlGroup.className = Constants.classes.CONTROL_GROUP + ' ' + Constants.classes.CONTROL_BASE;

    if (!controls) return controlGroup;

    if (controls[Constants.types.LINE]) {
      buttonElements[Constants.types.LINE] = createControlButton(Constants.types.LINE, {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_LINE,
        title: 'LineString tool ' + (ctx.options.keybindings && '(l)'),
        onActivate: function onActivate() {
          return ctx.events.changeMode(Constants.modes.DRAW_LINE_STRING);
        }
      });
    }

    if (controls[Constants.types.POLYGON]) {
      buttonElements[Constants.types.POLYGON] = createControlButton(Constants.types.POLYGON, {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_POLYGON,
        title: 'Polygon tool ' + (ctx.options.keybindings && '(p)'),
        onActivate: function onActivate() {
          return ctx.events.changeMode(Constants.modes.DRAW_POLYGON);
        }
      });
    }

    if (controls[Constants.types.POINT]) {
      buttonElements[Constants.types.POINT] = createControlButton(Constants.types.POINT, {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_POINT,
        title: 'Marker tool ' + (ctx.options.keybindings && '(m)'),
        onActivate: function onActivate() {
          return ctx.events.changeMode(Constants.modes.DRAW_POINT);
        }
      });
    }

    if (controls.trash) {
      buttonElements.trash = createControlButton('trash', {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_TRASH,
        title: 'Delete',
        onActivate: function onActivate() {
          ctx.events.trash();
        }
      });
    }

    if (controls.combine_features) {
      buttonElements.combine_features = createControlButton('combineFeatures', {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_COMBINE_FEATURES,
        title: 'Combine',
        onActivate: function onActivate() {
          ctx.events.combineFeatures();
        }
      });
    }

    if (controls.uncombine_features) {
      buttonElements.uncombine_features = createControlButton('uncombineFeatures', {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_UNCOMBINE_FEATURES,
        title: 'Uncombine',
        onActivate: function onActivate() {
          ctx.events.uncombineFeatures();
        }
      });
    }

    return controlGroup;
  }

  function removeButtons() {
    Object.keys(buttonElements).forEach(function (buttonId) {
      var button = buttonElements[buttonId];
      if (button.parentNode) {
        button.parentNode.removeChild(button);
      }
      delete buttonElements[buttonId];
    });
  }

  return {
    setActiveButton: setActiveButton,
    queueMapClasses: queueMapClasses,
    updateMapClasses: updateMapClasses,
    addButtons: addButtons,
    removeButtons: removeButtons
  };
};

},{"./constants":195,"xtend":193}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWFwYm94L2dlb2pzb24tYXJlYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWFwYm94L2dlb2pzb24tbm9ybWFsaXplL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtYXBib3gvZ2VvanNvbmhpbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtYXBib3gvZ2VvanNvbmhpbnQvbGliL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AbWFwYm94L2dlb2pzb25oaW50L2xpYi9yaHIuanMiLCJub2RlX21vZHVsZXMvQHR1cmYvYWxvbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvYWxvbmcvbm9kZV9tb2R1bGVzL0B0dXJmL2hlbHBlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvYXJlYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9hcmVhL25vZGVfbW9kdWxlcy9AdHVyZi9tZXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2Jib3gtY2xpcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9iYm94L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2JlYXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvYmV6aWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2Jlemllci9zcGxpbmUuanMiLCJub2RlX21vZHVsZXMvQHR1cmYvY2VudGVyLW9mLW1hc3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvY2VudGVyLW9mLW1hc3Mvbm9kZV9tb2R1bGVzL0B0dXJmL2NlbnRyb2lkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2NlbnRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9jaXJjbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvY29sbGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9jb25jYXZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2NvbmNhdmUvbm9kZV9tb2R1bGVzL0B0dXJmL3VuaW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2NvbnZleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9kZXN0aW5hdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9kaWZmZXJlbmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2Rpc3NvbHZlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2Rpc3RhbmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2VudmVsb3BlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2VudmVsb3BlL25vZGVfbW9kdWxlcy9AdHVyZi9iYm94LXBvbHlnb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvZXhwbG9kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9mbGF0dGVuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2ZsaXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvZ3JlYXQtY2lyY2xlL2FyYy5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9ncmVhdC1jaXJjbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvaGVscGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9oZXgtZ3JpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9pZHcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvaW5zaWRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2ludGVyc2VjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9pbnZhcmlhbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvaXNvbGluZXMvY29ucmVjLmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2lzb2xpbmVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2tpbmtzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2xpbmUtYXJjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2xpbmUtY2h1bmsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvbGluZS1kaXN0YW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9saW5lLWludGVyc2VjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9saW5lLW92ZXJsYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvbGluZS1zZWdtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL2xpbmUtc2xpY2UtYWxvbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvbGluZS1zbGljZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9saW5lLXNwbGl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL21hc2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvbWV0YS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9taWRwb2ludC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9uZWFyZXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL3BsYW5lcG9pbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvcG9pbnQtZ3JpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9wb2ludC1vbi1saW5lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL3BvaW50LW9uLXN1cmZhY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbi10by1saW5lc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL3JhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi9zYW1wbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvc2ltcGxpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvc3F1YXJlLWdyaWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvc3F1YXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL3RhZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi90ZXNzZWxhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvdGluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B0dXJmL3RyaWFuZ2xlLWdyaWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvdHJ1bmNhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvdHVyZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi90dXJmL25vZGVfbW9kdWxlcy9AdHVyZi9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHR1cmYvdHVyZi9ub2RlX21vZHVsZXMvQHR1cmYvY29tYmluZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi91bmtpbmstcG9seWdvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AdHVyZi93aXRoaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvYWZmaW5lLWh1bGwvYWZmLmpzIiwibm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2NoZWFwLXJ1bGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC1odWxsL2NoLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC1odWxsL2xpYi9jaDFkLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC1odWxsL2xpYi9jaDJkLmpzIiwibm9kZV9tb2R1bGVzL2NvbnZleC1odWxsL2xpYi9jaG5kLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwibm9kZV9tb2R1bGVzL2V4dGVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLWNvb3Jkcy9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tY29vcmRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tZXh0ZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tZmxhdHRlbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXBvbHlnb24tc2VsZi1pbnRlcnNlY3Rpb25zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tcmFuZG9tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tcmJ1c2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi11dGlscy9nZW9qc29uLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2dldC1jbG9zZXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1jb252ZXgtaHVsbC9pY2guanMiLCJub2RlX21vZHVsZXMvanNvbmxpbnQtbGluZXMvbGliL2pzb25saW50LmpzIiwibm9kZV9tb2R1bGVzL2pzdHMvZGlzdC9qc3RzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9saW5lY2xpcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guaXNlcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb25vdG9uZS1jb252ZXgtaHVsbC0yZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9pbnQtZ2VvbWV0cnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3Qtc2NhbGUvcm9idXN0LXNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1zdWJ0cmFjdC9yb2J1c3QtZGlmZi5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3Qtc3VtL3JvYnVzdC1zdW0uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlcG9seWdvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGVwb2x5Z29uL25vZGVfbW9kdWxlcy9AdHVyZi9pbnZhcmlhbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxpY2lhbC1jb21wbGV4L3RvcG9sb2d5LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LWpzL3NpbXBsaWZ5LmpzIiwibm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R1cmYtaXMtY2xvY2t3aXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R1cmYtb3ZlcmxhcHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHdvLXByb2R1Y3QvdHdvLXByb2R1Y3QuanMiLCJub2RlX21vZHVsZXMvdHdvLXN1bS90d28tc3VtLmpzIiwibm9kZV9tb2R1bGVzL3VuaW9uLWZpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2dzODQvaW5kZXguanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwic3JjL2FwaS5qcyIsInNyYy9jb25zdGFudHMuanMiLCJzcmMvZXZlbnRzLmpzIiwic3JjL2ZlYXR1cmVfdHlwZXMvZmVhdHVyZS5qcyIsInNyYy9mZWF0dXJlX3R5cGVzL2xpbmVfc3RyaW5nLmpzIiwic3JjL2ZlYXR1cmVfdHlwZXMvbXVsdGlfZmVhdHVyZS5qcyIsInNyYy9mZWF0dXJlX3R5cGVzL3BvaW50LmpzIiwic3JjL2ZlYXR1cmVfdHlwZXMvcG9seWdvbi5qcyIsInNyYy9saWIvY29tbW9uX3NlbGVjdG9ycy5qcyIsInNyYy9saWIvY29uc3RyYWluX2ZlYXR1cmVfbW92ZW1lbnQuanMiLCJzcmMvbGliL2NyZWF0ZV9taWRwb2ludC5qcyIsInNyYy9saWIvY3JlYXRlX3N1cHBsZW1lbnRhcnlfcG9pbnRzLmpzIiwic3JjL2xpYi9jcmVhdGVfdmVydGV4LmpzIiwic3JjL2xpYi9kb3VibGVfY2xpY2tfem9vbS5qcyIsInNyYy9saWIvZXVjbGlkZWFuX2Rpc3RhbmNlLmpzIiwic3JjL2xpYi9mZWF0dXJlc19hdC5qcyIsInNyYy9saWIvZ2V0X2ZlYXR1cmVzX2FuZF9zZXRfY3Vyc29yLmpzIiwic3JjL2xpYi9pc19jbGljay5qcyIsInNyYy9saWIvaXNfZXZlbnRfYXRfY29vcmRpbmF0ZXMuanMiLCJzcmMvbGliL2lzX3RhcC5qcyIsInNyYy9saWIvbWFwX2V2ZW50X3RvX2JvdW5kaW5nX2JveC5qcyIsInNyYy9saWIvbW9kZV9oYW5kbGVyLmpzIiwic3JjL2xpYi9tb3VzZV9ldmVudF9wb2ludC5qcyIsInNyYy9saWIvbW92ZV9mZWF0dXJlcy5qcyIsInNyYy9saWIvc25hcF90by5qcyIsInNyYy9saWIvc29ydF9mZWF0dXJlcy5qcyIsInNyYy9saWIvc3RyaW5nX3NldC5qcyIsInNyYy9saWIvc3RyaW5nX3NldHNfYXJlX2VxdWFsLmpzIiwic3JjL2xpYi90aGVtZS5qcyIsInNyYy9saWIvdGhyb3R0bGUuanMiLCJzcmMvbGliL3RvX2RlbnNlX2FycmF5LmpzIiwic3JjL21vZGVzL2RpcmVjdF9zZWxlY3QuanMiLCJzcmMvbW9kZXMvZHJhd19saW5lX3N0cmluZy5qcyIsInNyYy9tb2Rlcy9kcmF3X3BvaW50LmpzIiwic3JjL21vZGVzL2RyYXdfcG9seWdvbi5qcyIsInNyYy9tb2Rlcy9zaW1wbGVfc2VsZWN0LmpzIiwic3JjL21vZGVzL3N0YXRpYy5qcyIsInNyYy9vcHRpb25zLmpzIiwic3JjL3JlbmRlci5qcyIsInNyYy9zZXR1cC5qcyIsInNyYy9zdG9yZS5qcyIsInNyYy91aS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsSUFBTSxXQUFXLFFBQVEsYUFBUixDQUFqQjtBQUNBLElBQU0sZUFBZSxRQUFRLGVBQVIsQ0FBckI7QUFDQSxJQUFNLFdBQVcsUUFBUSxXQUFSLENBQWpCO0FBQ0EsSUFBTSxZQUFZLFFBQVEsaUJBQVIsQ0FBbEI7O0FBRUEsSUFBTSxZQUFZLFNBQVosU0FBWSxDQUFTLE9BQVQsRUFBa0IsR0FBbEIsRUFBdUI7QUFDdkMsWUFBVSxhQUFhLE9BQWIsQ0FBVjs7QUFFQSxNQUFNLE1BQU07QUFDVixhQUFTO0FBREMsR0FBWjs7QUFJQSxRQUFNLFNBQVMsR0FBVCxFQUFjLEdBQWQsQ0FBTjtBQUNBLE1BQUksR0FBSixHQUFVLEdBQVY7O0FBRUEsTUFBTSxRQUFRLFNBQVMsR0FBVCxDQUFkOztBQUVBLE1BQUksS0FBSixHQUFZLE1BQU0sS0FBbEI7QUFDQSxNQUFJLFFBQUosR0FBZSxNQUFNLFFBQXJCO0FBQ0EsTUFBSSxLQUFKLEdBQVksVUFBVSxLQUF0QjtBQUNBLE1BQUksT0FBSixHQUFjLE9BQWQ7O0FBRUEsU0FBTyxHQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBLE9BQU8sT0FBUCxHQUFpQixVQUFTLE9BQVQsRUFBa0I7QUFDakMsWUFBVSxPQUFWLEVBQW1CLElBQW5CO0FBQ0QsQ0FGRDs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RCxPQUE3QixDQUF2QjtBQVFEOztBQUVELFFBQUksU0FBUyxnQkFBYixFQUErQjtBQUM3QixxQkFBZSxnQkFBZixHQUFrQyxvQkFBb0IsaUJBQXBCLEVBQXVDO0FBQ3ZFLG1CQUFXLFlBRDREO0FBRXZFLG1CQUFXLFVBQVUsT0FBVixDQUFrQiwrQkFGMEM7QUFHdkUsZUFBTyxTQUhnRTtBQUl2RSxvQkFBWSxzQkFBTTtBQUNoQixjQUFJLE1BQUosQ0FBVyxlQUFYO0FBQ0Q7QUFOc0UsT0FBdkMsQ0FBbEM7QUFRRDs7QUFFRCxRQUFJLFNBQVMsa0JBQWIsRUFBaUM7QUFDL0IscUJBQWUsa0JBQWYsR0FBb0Msb0JBQW9CLG1CQUFwQixFQUF5QztBQUMzRSxtQkFBVyxZQURnRTtBQUUzRSxtQkFBVyxVQUFVLE9BQVYsQ0FBa0IsaUNBRjhDO0FBRzNFLGVBQU8sV0FIb0U7QUFJM0Usb0JBQVksc0JBQU07QUFDaEIsY0FBSSxNQUFKLENBQVcsaUJBQVg7QUFDRDtBQU4wRSxPQUF6QyxDQUFwQztBQVFEOztBQUVELFdBQU8sWUFBUDtBQUNEOztBQUVELFdBQVMsYUFBVCxHQUF5QjtBQUN2QixXQUFPLElBQVAsQ0FBWSxjQUFaLEVBQTRCLE9BQTVCLENBQW9DLG9CQUFZO0FBQzlDLFVBQU0sU0FBUyxlQUFlLFFBQWYsQ0FBZjtBQUNBLFVBQUksT0FBTyxVQUFYLEVBQXVCO0FBQ3JCLGVBQU8sVUFBUCxDQUFrQixXQUFsQixDQUE4QixNQUE5QjtBQUNEO0FBQ0QsYUFBTyxlQUFlLFFBQWYsQ0FBUDtBQUNELEtBTkQ7QUFPRDs7QUFFRCxTQUFPO0FBQ0wsb0NBREs7QUFFTCxvQ0FGSztBQUdMLHNDQUhLO0FBSUwsMEJBSks7QUFLTDtBQUxLLEdBQVA7QUFPRCxDQWhMRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJjb25zdCBydW5TZXR1cCA9IHJlcXVpcmUoJy4vc3JjL3NldHVwJyk7XG5jb25zdCBzZXR1cE9wdGlvbnMgPSByZXF1aXJlKCcuL3NyYy9vcHRpb25zJyk7XG5jb25zdCBzZXR1cEFQSSA9IHJlcXVpcmUoJy4vc3JjL2FwaScpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9zcmMvY29uc3RhbnRzJyk7XG5cbmNvbnN0IHNldHVwRHJhdyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGFwaSkge1xuICBvcHRpb25zID0gc2V0dXBPcHRpb25zKG9wdGlvbnMpO1xuXG4gIGNvbnN0IGN0eCA9IHtcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG5cbiAgYXBpID0gc2V0dXBBUEkoY3R4LCBhcGkpO1xuICBjdHguYXBpID0gYXBpO1xuXG4gIGNvbnN0IHNldHVwID0gcnVuU2V0dXAoY3R4KTtcblxuICBhcGkub25BZGQgPSBzZXR1cC5vbkFkZDtcbiAgYXBpLm9uUmVtb3ZlID0gc2V0dXAub25SZW1vdmU7XG4gIGFwaS50eXBlcyA9IENvbnN0YW50cy50eXBlcztcbiAgYXBpLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIHJldHVybiBhcGk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgc2V0dXBEcmF3KG9wdGlvbnMsIHRoaXMpO1xufTtcbiIsInZhciB3Z3M4NCA9IHJlcXVpcmUoJ3dnczg0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5tb2R1bGUuZXhwb3J0cy5yaW5nID0gcmluZ0FyZWE7XG5cbmZ1bmN0aW9uIGdlb21ldHJ5KF8pIHtcbiAgICB2YXIgYXJlYSA9IDAsIGk7XG4gICAgc3dpdGNoIChfLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlcyk7XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgXy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZWEgKz0gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcbiAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmVhICs9IGdlb21ldHJ5KF8uZ2VvbWV0cmllc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcbiAgICBpZiAoY29vcmRzICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzWzBdKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcG9seWdvbiB3ZXJlIGl0IHByb2plY3RlZCBvbnRvXG4gKiAgICAgdGhlIGVhcnRoLiAgTm90ZSB0aGF0IHRoaXMgYXJlYSB3aWxsIGJlIHBvc2l0aXZlIGlmIHJpbmcgaXMgb3JpZW50ZWRcbiAqICAgICBjbG9ja3dpc2UsIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICpcbiAqIFJlZmVyZW5jZTpcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogICAgIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqICAgICBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwNyBodHRwOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvZHNwYWNlL2hhbmRsZS8yMDE0LzQwNDA5XG4gKlxuICogUmV0dXJuczpcbiAqIHtmbG9hdH0gVGhlIGFwcHJveGltYXRlIHNpZ25lZCBnZW9kZXNpYyBhcmVhIG9mIHRoZSBwb2x5Z29uIGluIHNxdWFyZVxuICogICAgIG1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiByaW5nQXJlYShjb29yZHMpIHtcbiAgICB2YXIgcDEsIHAyLCBwMywgbG93ZXJJbmRleCwgbWlkZGxlSW5kZXgsIHVwcGVySW5kZXgsIGksXG4gICAgYXJlYSA9IDAsXG4gICAgY29vcmRzTGVuZ3RoID0gY29vcmRzLmxlbmd0aDtcblxuICAgIGlmIChjb29yZHNMZW5ndGggPiAyKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGNvb3Jkc0xlbmd0aCAtIDIpIHsvLyBpID0gTi0yXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGNvb3Jkc0xlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSBjb29yZHNMZW5ndGggLTE7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGNvb3Jkc0xlbmd0aCAtIDEpIHsvLyBpID0gTi0xXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGNvb3Jkc0xlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaSA9IDAgdG8gTi0zXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSBpKzE7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGkrMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAxID0gY29vcmRzW2xvd2VySW5kZXhdO1xuICAgICAgICAgICAgcDIgPSBjb29yZHNbbWlkZGxlSW5kZXhdO1xuICAgICAgICAgICAgcDMgPSBjb29yZHNbdXBwZXJJbmRleF07XG4gICAgICAgICAgICBhcmVhICs9ICggcmFkKHAzWzBdKSAtIHJhZChwMVswXSkgKSAqIE1hdGguc2luKCByYWQocDJbMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWEgPSBhcmVhICogd2dzODQuUkFESVVTICogd2dzODQuUkFESVVTIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gcmFkKF8pIHtcbiAgICByZXR1cm4gXyAqIE1hdGguUEkgLyAxODA7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemU7XG5cbnZhciB0eXBlcyA9IHtcbiAgICBQb2ludDogJ2dlb21ldHJ5JyxcbiAgICBNdWx0aVBvaW50OiAnZ2VvbWV0cnknLFxuICAgIExpbmVTdHJpbmc6ICdnZW9tZXRyeScsXG4gICAgTXVsdGlMaW5lU3RyaW5nOiAnZ2VvbWV0cnknLFxuICAgIFBvbHlnb246ICdnZW9tZXRyeScsXG4gICAgTXVsdGlQb2x5Z29uOiAnZ2VvbWV0cnknLFxuICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogJ2dlb21ldHJ5JyxcbiAgICBGZWF0dXJlOiAnZmVhdHVyZScsXG4gICAgRmVhdHVyZUNvbGxlY3Rpb246ICdmZWF0dXJlY29sbGVjdGlvbidcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgR2VvSlNPTiBmZWF0dXJlIGludG8gYSBGZWF0dXJlQ29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ2ogZ2VvanNvbiBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBub3JtYWxpemVkIGdlb2pzb24gZGF0YVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZ2opIHtcbiAgICBpZiAoIWdqIHx8ICFnai50eXBlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdHlwZSA9IHR5cGVzW2dqLnR5cGVdO1xuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2dlb21ldHJ5Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2pcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZmVhdHVyZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICBmZWF0dXJlczogW2dqXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ZlYXR1cmVjb2xsZWN0aW9uJykge1xuICAgICAgICByZXR1cm4gZ2o7XG4gICAgfVxufVxuIiwidmFyIGpzb25saW50ID0gcmVxdWlyZSgnanNvbmxpbnQtbGluZXMnKSxcbiAgZ2VvanNvbkhpbnRPYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuXG4vKipcbiAqIEBhbGlhcyBnZW9qc29uaGludFxuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IEdlb0pTT04gZ2l2ZW4gYXMgYSBzdHJpbmcgb3IgYXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub0R1cGxpY2F0ZU1lbWJlcnM9dHJ1ZV0gZm9yYmlkIHJlcGVhdGVkXG4gKiBwcm9wZXJ0aWVzLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgaW5wdXQsIGJlY2F1c2VkIHBhcnNlZFxuICogT2JqZWN0cyBjYW5ub3QgaGF2ZSBkdXBsaWNhdGUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJlY2lzaW9uV2FybmluZz10cnVlXSB3YXJuIGlmIEdlb0pTT04gY29udGFpbnNcbiAqIHVubmVjZXNzYXJ5IGNvb3JkaW5hdGUgcHJlY2lzaW9uLlxuICogQHJldHVybnMge0FycmF5PE9iamVjdD59IGFuIGFycmF5IG9mIGVycm9yc1xuICovXG5mdW5jdGlvbiBoaW50KHN0ciwgb3B0aW9ucykge1xuXG4gICAgdmFyIGdqLCBlcnJvcnMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBnaiA9IHN0cjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnaiA9IGpzb25saW50LnBhcnNlKHN0cik7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gZS5tZXNzYWdlLm1hdGNoKC9saW5lIChcXGQrKS8pO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlciAtIDEsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIHN0cmluZyBvciBvYmplY3QgYXMgaW5wdXQnLFxuICAgICAgICAgICAgbGluZTogMFxuICAgICAgICB9XTtcbiAgICB9XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGdlb2pzb25IaW50T2JqZWN0LmhpbnQoZ2osIG9wdGlvbnMpKTtcblxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbm1vZHVsZS5leHBvcnRzLmhpbnQgPSBoaW50O1xuIiwidmFyIHJpZ2h0SGFuZFJ1bGUgPSByZXF1aXJlKCcuL3JocicpO1xuXG4vKipcbiAqIEBhbGlhcyBnZW9qc29uaGludFxuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IEdlb0pTT04gZ2l2ZW4gYXMgYSBzdHJpbmcgb3IgYXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub0R1cGxpY2F0ZU1lbWJlcnM9dHJ1ZV0gZm9yYmlkIHJlcGVhdGVkXG4gKiBwcm9wZXJ0aWVzLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgaW5wdXQsIGJlY2F1c2VkIHBhcnNlZFxuICogT2JqZWN0cyBjYW5ub3QgaGF2ZSBkdXBsaWNhdGUgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJlY2lzaW9uV2FybmluZz10cnVlXSB3YXJuIGlmIEdlb0pTT04gY29udGFpbnNcbiAqIHVubmVjZXNzYXJ5IGNvb3JkaW5hdGUgcHJlY2lzaW9uLlxuICogQHJldHVybnMge0FycmF5PE9iamVjdD59IGFuIGFycmF5IG9mIGVycm9yc1xuICovXG5mdW5jdGlvbiBoaW50KGdqLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHByZWNpc2lvbldhcm5pbmdDb3VudCA9IDA7XG4gICAgdmFyIG1heFByZWNpc2lvbldhcm5pbmdzID0gMTA7XG4gICAgdmFyIG1heFByZWNpc2lvbiA9IDY7XG5cbiAgICBmdW5jdGlvbiByb290KF8pIHtcblxuICAgICAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMubm9EdXBsaWNhdGVNZW1iZXJzICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgXy5fX2R1cGxpY2F0ZVByb3BlcnRpZXNfXykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBbiBvYmplY3QgY29udGFpbmVkIGR1cGxpY2F0ZSBtZW1iZXJzLCBtYWtpbmcgcGFyc2luZyBhbWJpZ291czogJyArIF8uX19kdXBsaWNhdGVQcm9wZXJ0aWVzX18uam9pbignLCAnKSxcbiAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1aXJlZFByb3BlcnR5KF8sICd0eXBlJywgJ3N0cmluZycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR5cGVzW18udHlwZV0pIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZFR5cGUgPSB0eXBlc0xvd2VyW18udHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkICcgKyBleHBlY3RlZFR5cGUgKyAnIGJ1dCBnb3QgJyArIF8udHlwZSArICcgKGNhc2Ugc2Vuc2l0aXZlKScsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IF8uX19saW5lX19cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhlIHR5cGUgJyArIF8udHlwZSArICcgaXMgdW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IF8uX19saW5lX19cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfKSB7XG4gICAgICAgICAgICB0eXBlc1tfLnR5cGVdKF8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXZlcnlJcyhfLCB0eXBlKSB7XG4gICAgICAgIC8vIG1ha2UgYSBzaW5nbGUgZXhjZXB0aW9uIGJlY2F1c2UgdHlwZW9mIG51bGwgPT09ICdvYmplY3QnXG4gICAgICAgIHJldHVybiBfLmV2ZXJ5KGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSB0eXBlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXF1aXJlZFByb3BlcnR5KF8sIG5hbWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnXCInICsgbmFtZSArICdcIiBtZW1iZXIgcmVxdWlyZWQnLFxuICAgICAgICAgICAgICAgIGxpbmU6IF8uX19saW5lX19cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShfW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdcIicgKyBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIiBtZW1iZXIgc2hvdWxkIGJlIGFuIGFycmF5LCBidXQgaXMgYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIF9bbmFtZV0pICsgJyBpbnN0ZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogXy5fX2xpbmVfX1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIF9bbmFtZV0gJiYgX1tuYW1lXS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnXCInICsgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICdcIiBtZW1iZXIgc2hvdWxkIGJlICcgKyAodHlwZSkgK1xuICAgICAgICAgICAgICAgICAgICAnLCBidXQgaXMgYW4gJyArIChfW25hbWVdLmNvbnN0cnVjdG9yLm5hbWUpICsgJyBpbnN0ZWFkJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICYmIHR5cGVvZiBfW25hbWVdICE9PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdcIicgKyBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIG1lbWJlciBzaG91bGQgYmUgJyArICh0eXBlKSArXG4gICAgICAgICAgICAgICAgICAgICcsIGJ1dCBpcyBhbiAnICsgKHR5cGVvZiBfW25hbWVdKSArICcgaW5zdGVhZCcsXG4gICAgICAgICAgICAgICAgbGluZTogXy5fX2xpbmVfX1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NiNzZWN0aW9uLTMuM1xuICAgIGZ1bmN0aW9uIEZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVDb2xsZWN0aW9uKSB7XG4gICAgICAgIGNycyhmZWF0dXJlQ29sbGVjdGlvbik7XG4gICAgICAgIGJib3goZmVhdHVyZUNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoZmVhdHVyZUNvbGxlY3Rpb24ucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZlYXR1cmVDb2xsZWN0aW9uIG9iamVjdCBjYW5ub3QgY29udGFpbiBhIFwicHJvcGVydGllc1wiIG1lbWJlcicsXG4gICAgICAgICAgICAgICAgbGluZTogZmVhdHVyZUNvbGxlY3Rpb24uX19saW5lX19cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWF0dXJlQ29sbGVjdGlvbi5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZlYXR1cmVDb2xsZWN0aW9uIG9iamVjdCBjYW5ub3QgY29udGFpbiBhIFwiY29vcmRpbmF0ZXNcIiBtZW1iZXInLFxuICAgICAgICAgICAgICAgIGxpbmU6IGZlYXR1cmVDb2xsZWN0aW9uLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcXVpcmVkUHJvcGVydHkoZmVhdHVyZUNvbGxlY3Rpb24sICdmZWF0dXJlcycsICdhcnJheScpKSB7XG4gICAgICAgICAgICBpZiAoIWV2ZXJ5SXMoZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMsICdvYmplY3QnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdFdmVyeSBmZWF0dXJlIG11c3QgYmUgYW4gb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZmVhdHVyZUNvbGxlY3Rpb24uX19saW5lX19cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmZvckVhY2goRmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NiNzZWN0aW9uLTMuMS4xXG4gICAgZnVuY3Rpb24gcG9zaXRpb24oXywgbGluZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoXykpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ3Bvc2l0aW9uIHNob3VsZCBiZSBhbiBhcnJheSwgaXMgYSAnICsgKHR5cGVvZiBfKSArXG4gICAgICAgICAgICAgICAgICAgICcgaW5zdGVhZCcsXG4gICAgICAgICAgICAgICAgbGluZTogXy5fX2xpbmVfXyB8fCBsaW5lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdwb3NpdGlvbiBtdXN0IGhhdmUgMiBvciBtb3JlIGVsZW1lbnRzJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fIHx8IGxpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ3Bvc2l0aW9uIHNob3VsZCBub3QgaGF2ZSBtb3JlIHRoYW4gMyBlbGVtZW50cycsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fIHx8IGxpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXZlcnlJcyhfLCAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2VhY2ggZWxlbWVudCBpbiBhIHBvc2l0aW9uIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgICAgICAgICAgIGxpbmU6IF8uX19saW5lX18gfHwgbGluZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByZWNpc2lvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb25XYXJuaW5nQ291bnQgPT09IG1heFByZWNpc2lvbldhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uV2FybmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3RydW5jYXRlZCB3YXJuaW5nczogd2VcXCd2ZSBlbmNvdW50ZXJlZCBjb29yZGluYXRlIHByZWNpc2lvbiB3YXJuaW5nICcgKyBtYXhQcmVjaXNpb25XYXJuaW5ncyArICcgdGltZXMsIG5vIG1vcmUgd2FybmluZ3Mgd2lsbCBiZSByZXBvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IF8uX19saW5lX18gfHwgbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVjaXNpb25XYXJuaW5nQ291bnQgPCBtYXhQcmVjaXNpb25XYXJuaW5ncykge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChmdW5jdGlvbihudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsU3RyID0gU3RyaW5nKG51bSkuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxTdHIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IGRlY2ltYWxTdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uID4gbWF4UHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb25XYXJuaW5nQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3ByZWNpc2lvbiBvZiBjb29yZGluYXRlcyBzaG91bGQgYmUgcmVkdWNlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fIHx8IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbkFycmF5KGNvb3JkcywgdHlwZSwgZGVwdGgsIGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCAmJiBjb29yZHMuX19saW5lX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGluZSA9IGNvb3Jkcy5fX2xpbmVfXztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbihjb29yZHMsIGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMSAmJiB0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0xpbmVhclJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdhIG51bWJlciB3YXMgZm91bmQgd2hlcmUgYSBjb29yZGluYXRlIGFycmF5IHNob3VsZCBoYXZlIGJlZW4gZm91bmQ6IHRoaXMgbmVlZHMgdG8gYmUgbmVzdGVkIG1vcmUgZGVlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2EgTGluZWFyUmluZyBvZiBjb29yZGluYXRlcyBuZWVkcyB0byBoYXZlIGZvdXIgb3IgbW9yZSBwb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0ubGVuZ3RoICE9PSBjb29yZHNbMF0ubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgICFjb29yZHNbY29vcmRzLmxlbmd0aCAtIDFdLmV2ZXJ5KGZ1bmN0aW9uKHBvcywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb29yZHNbMF1baW5kZXhdID09PSBwb3M7XG4gICAgICAgICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICd0aGUgZmlyc3QgYW5kIGxhc3QgcG9zaXRpb25zIGluIGEgTGluZWFyUmluZyBvZiBjb29yZGluYXRlcyBtdXN0IGJlIHRoZSBzYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmUnICYmIGNvb3Jkcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2EgbGluZSBuZWVkcyB0byBoYXZlIHR3byBvciBtb3JlIGNvb3JkaW5hdGVzIHRvIGJlIHZhbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb29yZHMpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2EgbnVtYmVyIHdhcyBmb3VuZCB3aGVyZSBhIGNvb3JkaW5hdGUgYXJyYXkgc2hvdWxkIGhhdmUgYmVlbiBmb3VuZDogdGhpcyBuZWVkcyB0byBiZSBuZXN0ZWQgbW9yZSBkZWVwbHknLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBjb29yZHMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb25BcnJheShjLCB0eXBlLCBkZXB0aCAtIDEsIGMuX19saW5lX18gfHwgbGluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLnNvbWUoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcnMoXykge1xuICAgICAgICBpZiAoIV8uY3JzKSByZXR1cm47XG4gICAgICAgIHZhciBkZWZhdWx0Q1JTTmFtZSA9ICd1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCc7XG4gICAgICAgIGlmICh0eXBlb2YgXy5jcnMgPT09ICdvYmplY3QnICYmIF8uY3JzLnByb3BlcnRpZXMgJiYgXy5jcnMucHJvcGVydGllcy5uYW1lID09PSBkZWZhdWx0Q1JTTmFtZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdvbGQtc3R5bGUgY3JzIG1lbWJlciBpcyBub3QgcmVjb21tZW5kZWQsIHRoaXMgb2JqZWN0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGRlZmF1bHQgYW5kIHNob3VsZCBiZSByZW1vdmVkJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnb2xkLXN0eWxlIGNycyBtZW1iZXIgaXMgbm90IHJlY29tbWVuZGVkJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJib3goXykge1xuICAgICAgICBpZiAoIV8uYmJveCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KF8uYmJveCkpIHtcbiAgICAgICAgICAgIGlmICghZXZlcnlJcyhfLmJib3gsICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2VhY2ggZWxlbWVudCBpbiBhIGJib3ggbWVtYmVyIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBfLmJib3guX19saW5lX19cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKF8uYmJveC5sZW5ndGggPT09IDQgfHwgXy5iYm94Lmxlbmd0aCA9PT0gNikpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdiYm94IG11c3QgY29udGFpbiA0IGVsZW1lbnRzIChmb3IgMkQpIG9yIDYgZWxlbWVudHMgKGZvciAzRCknLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBfLmJib3guX19saW5lX19cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdiYm94IG1lbWJlciBtdXN0IGJlIGFuIGFycmF5IG9mIG51bWJlcnMsIGJ1dCBpcyBhICcgKyAodHlwZW9mIF8uYmJveCksXG4gICAgICAgICAgICBsaW5lOiBfLl9fbGluZV9fXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5U2VtYW50aWNzKGdlb20pIHtcbiAgICAgICAgaWYgKGdlb20ucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2dlb21ldHJ5IG9iamVjdCBjYW5ub3QgY29udGFpbiBhIFwicHJvcGVydGllc1wiIG1lbWJlcicsXG4gICAgICAgICAgICAgICAgbGluZTogZ2VvbS5fX2xpbmVfX1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb20uZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdnZW9tZXRyeSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYSBcImdlb21ldHJ5XCIgbWVtYmVyJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW9tLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2VvbS5mZWF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ2dlb21ldHJ5IG9iamVjdCBjYW5ub3QgY29udGFpbiBhIFwiZmVhdHVyZXNcIiBtZW1iZXInLFxuICAgICAgICAgICAgICAgIGxpbmU6IGdlb20uX19saW5lX19cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYjc2VjdGlvbi0zLjEuMlxuICAgIGZ1bmN0aW9uIFBvaW50KHBvaW50KSB7XG4gICAgICAgIGNycyhwb2ludCk7XG4gICAgICAgIGJib3gocG9pbnQpO1xuICAgICAgICBnZW9tZXRyeVNlbWFudGljcyhwb2ludCk7XG4gICAgICAgIGlmICghcmVxdWlyZWRQcm9wZXJ0eShwb2ludCwgJ2Nvb3JkaW5hdGVzJywgJ2FycmF5JykpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uKHBvaW50LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2I3NlY3Rpb24tMy4xLjZcbiAgICBmdW5jdGlvbiBQb2x5Z29uKHBvbHlnb24pIHtcbiAgICAgICAgY3JzKHBvbHlnb24pO1xuICAgICAgICBiYm94KHBvbHlnb24pO1xuICAgICAgICBpZiAoIXJlcXVpcmVkUHJvcGVydHkocG9seWdvbiwgJ2Nvb3JkaW5hdGVzJywgJ2FycmF5JykpIHtcbiAgICAgICAgICAgIGlmICghcG9zaXRpb25BcnJheShwb2x5Z29uLmNvb3JkaW5hdGVzLCAnTGluZWFyUmluZycsIDIpKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRIYW5kUnVsZShwb2x5Z29uLCBlcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYjc2VjdGlvbi0zLjEuN1xuICAgIGZ1bmN0aW9uIE11bHRpUG9seWdvbihtdWx0aVBvbHlnb24pIHtcbiAgICAgICAgY3JzKG11bHRpUG9seWdvbik7XG4gICAgICAgIGJib3gobXVsdGlQb2x5Z29uKTtcbiAgICAgICAgaWYgKCFyZXF1aXJlZFByb3BlcnR5KG11bHRpUG9seWdvbiwgJ2Nvb3JkaW5hdGVzJywgJ2FycmF5JykpIHtcbiAgICAgICAgICAgIGlmICghcG9zaXRpb25BcnJheShtdWx0aVBvbHlnb24uY29vcmRpbmF0ZXMsICdMaW5lYXJSaW5nJywgMykpIHtcbiAgICAgICAgICAgICAgICByaWdodEhhbmRSdWxlKG11bHRpUG9seWdvbiwgZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2I3NlY3Rpb24tMy4xLjRcbiAgICBmdW5jdGlvbiBMaW5lU3RyaW5nKGxpbmVTdHJpbmcpIHtcbiAgICAgICAgY3JzKGxpbmVTdHJpbmcpO1xuICAgICAgICBiYm94KGxpbmVTdHJpbmcpO1xuICAgICAgICBpZiAoIXJlcXVpcmVkUHJvcGVydHkobGluZVN0cmluZywgJ2Nvb3JkaW5hdGVzJywgJ2FycmF5JykpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uQXJyYXkobGluZVN0cmluZy5jb29yZGluYXRlcywgJ0xpbmUnLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2I3NlY3Rpb24tMy4xLjVcbiAgICBmdW5jdGlvbiBNdWx0aUxpbmVTdHJpbmcobXVsdGlMaW5lU3RyaW5nKSB7XG4gICAgICAgIGNycyhtdWx0aUxpbmVTdHJpbmcpO1xuICAgICAgICBiYm94KG11bHRpTGluZVN0cmluZyk7XG4gICAgICAgIGlmICghcmVxdWlyZWRQcm9wZXJ0eShtdWx0aUxpbmVTdHJpbmcsICdjb29yZGluYXRlcycsICdhcnJheScpKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkFycmF5KG11bHRpTGluZVN0cmluZy5jb29yZGluYXRlcywgJ0xpbmUnLCAyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2I3NlY3Rpb24tMy4xLjNcbiAgICBmdW5jdGlvbiBNdWx0aVBvaW50KG11bHRpUG9pbnQpIHtcbiAgICAgICAgY3JzKG11bHRpUG9pbnQpO1xuICAgICAgICBiYm94KG11bHRpUG9pbnQpO1xuICAgICAgICBpZiAoIXJlcXVpcmVkUHJvcGVydHkobXVsdGlQb2ludCwgJ2Nvb3JkaW5hdGVzJywgJ2FycmF5JykpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uQXJyYXkobXVsdGlQb2ludC5jb29yZGluYXRlcywgJycsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYjc2VjdGlvbi0zLjEuOFxuICAgIGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgICAgY3JzKGdlb21ldHJ5Q29sbGVjdGlvbik7XG4gICAgICAgIGJib3goZ2VvbWV0cnlDb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFyZXF1aXJlZFByb3BlcnR5KGdlb21ldHJ5Q29sbGVjdGlvbiwgJ2dlb21ldHJpZXMnLCAnYXJyYXknKSkge1xuICAgICAgICAgICAgaWYgKCFldmVyeUlzKGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLCAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgZ2VvbWV0cmllcyBhcnJheSBpbiBhIEdlb21ldHJ5Q29sbGVjdGlvbiBtdXN0IGNvbnRhaW4gb25seSBnZW9tZXRyeSBvYmplY3RzJyxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZ2VvbWV0cnlDb2xsZWN0aW9uLl9fbGluZV9fXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnR2VvbWV0cnlDb2xsZWN0aW9uIHdpdGggYSBzaW5nbGUgZ2VvbWV0cnkgc2hvdWxkIGJlIGF2b2lkZWQgaW4gZmF2b3Igb2Ygc2luZ2xlIHBhcnQgb3IgYSBzaW5nbGUgb2JqZWN0IG9mIG11bHRpLXBhcnQgdHlwZScsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLl9fbGluZV9fXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW9tZXRyeUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdHZW9tZXRyeUNvbGxlY3Rpb24gc2hvdWxkIGF2b2lkIG5lc3RlZCBnZW9tZXRyeSBjb2xsZWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXMuX19saW5lX19cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvb3QoZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYjc2VjdGlvbi0zLjJcbiAgICBmdW5jdGlvbiBGZWF0dXJlKGZlYXR1cmUpIHtcbiAgICAgICAgY3JzKGZlYXR1cmUpO1xuICAgICAgICBiYm94KGZlYXR1cmUpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2VvanNvbi9kcmFmdC1nZW9qc29uL2Jsb2IvbWFzdGVyL21pZGRsZS5ta2QjZmVhdHVyZS1vYmplY3RcbiAgICAgICAgaWYgKGZlYXR1cmUuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZlYXR1cmUuaWQgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2YgZmVhdHVyZS5pZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmVhdHVyZSBcImlkXCIgbWVtYmVyIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUnLFxuICAgICAgICAgICAgICAgIGxpbmU6IGZlYXR1cmUuX19saW5lX19cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWF0dXJlLmZlYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmVhdHVyZSBvYmplY3QgY2Fubm90IGNvbnRhaW4gYSBcImZlYXR1cmVzXCIgbWVtYmVyJyxcbiAgICAgICAgICAgICAgICBsaW5lOiBmZWF0dXJlLl9fbGluZV9fXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVhdHVyZS5jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZlYXR1cmUgb2JqZWN0IGNhbm5vdCBjb250YWluIGEgXCJjb29yZGluYXRlc1wiIG1lbWJlcicsXG4gICAgICAgICAgICAgICAgbGluZTogZmVhdHVyZS5fX2xpbmVfX1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlYXR1cmUudHlwZSAhPT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0dlb0pTT04gZmVhdHVyZXMgbXVzdCBoYXZlIGEgdHlwZT1mZWF0dXJlIG1lbWJlcicsXG4gICAgICAgICAgICAgICAgbGluZTogZmVhdHVyZS5fX2xpbmVfX1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZWRQcm9wZXJ0eShmZWF0dXJlLCAncHJvcGVydGllcycsICdvYmplY3QnKTtcbiAgICAgICAgaWYgKCFyZXF1aXJlZFByb3BlcnR5KGZlYXR1cmUsICdnZW9tZXRyeScsICdvYmplY3QnKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc5NDYjc2VjdGlvbi0zLjJcbiAgICAgICAgICAgIC8vIHRvbGVyYXRlIG51bGwgZ2VvbWV0cnlcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5KSByb290KGZlYXR1cmUuZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHR5cGVzID0ge1xuICAgICAgICBQb2ludDogUG9pbnQsXG4gICAgICAgIEZlYXR1cmU6IEZlYXR1cmUsXG4gICAgICAgIE11bHRpUG9pbnQ6IE11bHRpUG9pbnQsXG4gICAgICAgIExpbmVTdHJpbmc6IExpbmVTdHJpbmcsXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogTXVsdGlMaW5lU3RyaW5nLFxuICAgICAgICBGZWF0dXJlQ29sbGVjdGlvbjogRmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgICAgICBQb2x5Z29uOiBQb2x5Z29uLFxuICAgICAgICBNdWx0aVBvbHlnb246IE11bHRpUG9seWdvblxuICAgIH07XG5cbiAgICB2YXIgdHlwZXNMb3dlciA9IE9iamVjdC5rZXlzKHR5cGVzKS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICBwcmV2W2N1cnIudG9Mb3dlckNhc2UoKV0gPSBjdXJyO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG5cbiAgICBpZiAodHlwZW9mIGdqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBnaiA9PT0gbnVsbCB8fFxuICAgICAgICBnaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgcm9vdCBvZiBhIEdlb0pTT04gb2JqZWN0IG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIHJvb3QoZ2opO1xuXG4gICAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ2xpbmUnKSAmJiBlcnIubGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgZXJyLmxpbmU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlcnJvcnM7XG59XG5cbm1vZHVsZS5leHBvcnRzLmhpbnQgPSBoaW50O1xuIiwiZnVuY3Rpb24gcmFkKHgpIHtcbiAgICByZXR1cm4geCAqIE1hdGguUEkgLyAxODA7XG59XG5cbmZ1bmN0aW9uIGlzUmluZ0Nsb2Nrd2lzZSAoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIGlmIChjb29yZHMubGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgcDEsIHAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHAxID0gY29vcmRzW2ldO1xuICAgICAgICAgICAgcDIgPSBjb29yZHNbaSArIDFdO1xuICAgICAgICAgICAgYXJlYSArPSByYWQocDJbMF0gLSBwMVswXSkgKiAoMiArIE1hdGguc2luKHJhZChwMVsxXSkpICsgTWF0aC5zaW4ocmFkKHAyWzFdKSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWEgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNQb2x5UkhSIChjb29yZHMpIHtcbiAgICBpZiAoY29vcmRzICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpc1JpbmdDbG9ja3dpc2UoY29vcmRzWzBdKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGludGVyaW9yQ29vcmRzID0gY29vcmRzLnNsaWNlKDEsIGNvb3Jkcy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWludGVyaW9yQ29vcmRzLmV2ZXJ5KGlzUmluZ0Nsb2Nrd2lzZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByaWdodEhhbmRSdWxlIChnZW9tZXRyeSkge1xuICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcmV0dXJuIGlzUG9seVJIUihnZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZXZlcnkoaXNQb2x5UkhSKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVSaWdodEhhbmRSdWxlKGdlb21ldHJ5LCBlcnJvcnMpIHtcbiAgICBpZiAoIXJpZ2h0SGFuZFJ1bGUoZ2VvbWV0cnkpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQb2x5Z29ucyBhbmQgTXVsdGlQb2x5Z29ucyBzaG91bGQgZm9sbG93IHRoZSByaWdodC1oYW5kIHJ1bGUnLFxuICAgICAgICAgICAgbGV2ZWw6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgIGxpbmU6IGdlb21ldHJ5Ll9fbGluZV9fXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4iLCJ2YXIgbWVhc3VyZURpc3RhbmNlID0gcmVxdWlyZSgnQHR1cmYvZGlzdGFuY2UnKTtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2ludDtcbnZhciBiZWFyaW5nID0gcmVxdWlyZSgnQHR1cmYvYmVhcmluZycpO1xudmFyIGRlc3RpbmF0aW9uID0gcmVxdWlyZSgnQHR1cmYvZGVzdGluYXRpb24nKTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfGxpbmV9IGFuZCByZXR1cm5zIGEge0BsaW5rIFBvaW50fHBvaW50fSBhdCBhIHNwZWNpZmllZCBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZS5cbiAqXG4gKiBAbmFtZSBhbG9uZ1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIGlucHV0IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZVxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gUG9pbnQgYGRpc3RhbmNlYCBgdW5pdHNgIGFsb25nIHRoZSBsaW5lXG4gKiBAYWRkVG9NYXAgYWxvbmcsIGxpbmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgIFstNzcuMDMxNjY5LCAzOC44Nzg2MDVdLFxuICogICAgICAgWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl0sXG4gKiAgICAgICBbLTc3LjAyMDMzOSwgMzguODg0MDg0XSxcbiAqICAgICAgIFstNzcuMDI1NjYxLCAzOC44ODU4MjFdLFxuICogICAgICAgWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M10sXG4gKiAgICAgICBbLTc3LjAxOTgyNCwgMzguODkyMzY4XVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgYWxvbmcgPSB0dXJmLmFsb25nKGxpbmUsIDEsICdtaWxlcycpO1xuICogLy89YWxvbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGluZSwgZGlzdGFuY2UsIHVuaXRzKSB7XG4gICAgdmFyIGNvb3JkcztcbiAgICBpZiAobGluZS50eXBlID09PSAnRmVhdHVyZScpIGNvb3JkcyA9IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgZWxzZSBpZiAobGluZS50eXBlID09PSAnTGluZVN0cmluZycpIGNvb3JkcyA9IGxpbmUuY29vcmRpbmF0ZXM7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBMaW5lU3RyaW5nIEZlYXR1cmUgb3IgR2VvbWV0cnknKTtcblxuICAgIHZhciB0cmF2ZWxsZWQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA+PSB0cmF2ZWxsZWQgJiYgaSA9PT0gY29vcmRzLmxlbmd0aCAtIDEpIGJyZWFrO1xuICAgICAgICBlbHNlIGlmICh0cmF2ZWxsZWQgPj0gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBvdmVyc2hvdCA9IGRpc3RhbmNlIC0gdHJhdmVsbGVkO1xuICAgICAgICAgICAgaWYgKCFvdmVyc2hvdCkgcmV0dXJuIHBvaW50KGNvb3Jkc1tpXSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gYmVhcmluZyhjb29yZHNbaV0sIGNvb3Jkc1tpIC0gMV0pIC0gMTgwO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZWQgPSBkZXN0aW5hdGlvbihjb29yZHNbaV0sIG92ZXJzaG90LCBkaXJlY3Rpb24sIHVuaXRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhdmVsbGVkICs9IG1lYXN1cmVEaXN0YW5jZShjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0sIHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnQoY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXSk7XG59O1xuIiwiLyoqXG4gKiBXcmFwcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBpbiBhIEdlb0pTT04ge0BsaW5rIEZlYXR1cmV9LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGlucHV0IGdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgaW5wdXQgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvbWV0cnkgPSB7XG4gKiAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgIDY3LjUsXG4gKiAgICAgICAgMzIuODQyNjczNjMxOTU0MzFcbiAqICAgICAgXVxuICogICAgfVxuICpcbiAqIHZhciBmZWF0dXJlID0gdHVyZi5mZWF0dXJlKGdlb21ldHJ5KTtcbiAqXG4gKiAvLz1mZWF0dXJlXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmUoZ2VvbWV0cnksIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWdlb21ldHJ5KSB0aHJvdyBuZXcgRXJyb3IoJ05vIGdlb21ldHJ5IHBhc3NlZCcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICB9O1xufVxuXG4vKipcbiAqIFRha2VzIGNvb3JkaW5hdGVzIGFuZCBwcm9wZXJ0aWVzIChvcHRpb25hbCkgYW5kIHJldHVybnMgYSBuZXcge0BsaW5rIFBvaW50fSBmZWF0dXJlLlxuICpcbiAqIEBuYW1lIHBvaW50XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcG9zaXRpb24gKGVhY2ggaW4gZGVjaW1hbCBkZWdyZWVzKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCB0aGF0IGlzIHVzZWQgYXMgdGhlIHtAbGluayBGZWF0dXJlfSdzXG4gKiBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wdDFcbiAqL1xuZnVuY3Rpb24gcG9pbnQoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBiZSBhdCBsZWFzdCAyIG51bWJlcnMgbG9uZycpO1xuICAgIGlmICh0eXBlb2YgY29vcmRpbmF0ZXNbMF0gIT09ICdudW1iZXInIHx8IHR5cGVvZiBjb29yZGluYXRlc1sxXSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBudW1iZXJzJyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufVxuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzIGFuZCBvcHRpb25hbGx5IGFuIHtAbGluayBPYmplY3R9IHdpdGggcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIHtAbGluayBQb2x5Z29ufSBmZWF0dXJlLlxuICpcbiAqIEBuYW1lIHBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGEgcHJvcGVydGllcyBvYmplY3RcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBhIFBvbHlnb24gZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIGEgTGluZWFyUmluZyBvZiB0aGUgcG9seWdvbiBoYXMgdG9vIGZldyBwb3NpdGlvbnNcbiAqIG9yIGlmIGEgTGluZWFyUmluZyBvZiB0aGUgUG9seWdvbiBkb2VzIG5vdCBoYXZlIG1hdGNoaW5nIFBvc2l0aW9ucyBhdCB0aGVcbiAqIGJlZ2lubmluZyAmIGVuZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1xuICogIFstMi4yNzU1NDMsIDUzLjQ2NDU0N10sXG4gKiAgWy0yLjI3NTU0MywgNTMuNDg5MjcxXSxcbiAqICBbLTIuMjE1MTE4LCA1My40ODkyNzFdLFxuICogIFstMi4yMTUxMTgsIDUzLjQ2NDU0N10sXG4gKiAgWy0yLjI3NTU0MywgNTMuNDY0NTQ3XVxuICogXV0sIHsgbmFtZTogJ3BvbHkxJywgcG9wdWxhdGlvbjogNDAwfSk7XG4gKlxuICogLy89cG9seWdvblxuICovXG5mdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZ1tyaW5nLmxlbmd0aCAtIDFdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocmluZ1tyaW5nLmxlbmd0aCAtIDFdW2pdICE9PSByaW5nWzBdW2pdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhbmQgbGFzdCBQb3NpdGlvbiBhcmUgbm90IGVxdWl2YWxlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIGxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBhIExpbmVTdHJpbmcgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZXN0cmluZzEgPSB0dXJmLmxpbmVTdHJpbmcoW1xuICogICBbLTIxLjk2NDQxNiwgNjQuMTQ4MjAzXSxcbiAqICAgWy0yMS45NTYxNzYsIDY0LjE0MTMxNl0sXG4gKiAgIFstMjEuOTM5MDEsIDY0LjEzNTkyNF0sXG4gKiAgIFstMjEuOTI3MzM3LCA2NC4xMzY2NzNdXG4gKiBdKTtcbiAqIHZhciBsaW5lc3RyaW5nMiA9IHR1cmYubGluZVN0cmluZyhbXG4gKiAgIFstMjEuOTI5MDU0LCA2NC4xMjc5ODVdLFxuICogICBbLTIxLjkxMjkxOCwgNjQuMTM0NzI2XSxcbiAqICAgWy0yMS45MTYwMDcsIDY0LjE0MTAxNl0sXG4gKiAgIFstMjEuOTMwMDg0LCA2NC4xNDQ0Nl1cbiAqIF0sIHtuYW1lOiAnbGluZSAxJywgZGlzdGFuY2U6IDE0NX0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKlxuICogLy89bGluZXN0cmluZzJcbiAqL1xuZnVuY3Rpb24gbGluZVN0cmluZyhjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59XG5cbi8qKlxuICogVGFrZXMgb25lIG9yIG1vcmUge0BsaW5rIEZlYXR1cmV8RmVhdHVyZXN9IGFuZCBjcmVhdGVzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtGZWF0dXJlW119IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgaW5wdXQgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSBbXG4gKiAgdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSwge25hbWU6ICdMb2NhdGlvbiBBJ30pLFxuICogIHR1cmYucG9pbnQoWy03NS44MzMsIDM5LjI4NF0sIHtuYW1lOiAnTG9jYXRpb24gQid9KSxcbiAqICB0dXJmLnBvaW50KFstNzUuNTM0LCAzOS4xMjNdLCB7bmFtZTogJ0xvY2F0aW9uIEMnfSlcbiAqIF07XG4gKlxuICogdmFyIGZjID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcyk7XG4gKlxuICogLy89ZmNcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpIHtcbiAgICBpZiAoIWZlYXR1cmVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZlYXR1cmVzIHBhc3NlZCcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aUxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lU3RyaW5nc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGEgTXVsdGlMaW5lU3RyaW5nIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtbWzAsMF0sWzEwLDEwXV1dKTtcbiAqXG4gKiAvLz1tdWx0aUxpbmVcbiAqXG4gKi9cbmZ1bmN0aW9uIG11bHRpTGluZVN0cmluZyhjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2ludD59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlQb2ludFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2ludD59IGEgTXVsdGlQb2ludCBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVB0ID0gdHVyZi5tdWx0aVBvaW50KFtbMCwwXSxbMTAsMTBdXSk7XG4gKlxuICogLy89bXVsdGlQdFxuICpcbiAqL1xuZnVuY3Rpb24gbXVsdGlQb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvbHlnb24+fSBhIG11bHRpcG9seWdvbiBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbW1tbMCwwXSxbMCwxMF0sWzEwLDEwXSxbMTAsMF0sWzAsMF1dXV0pO1xuICpcbiAqIC8vPW11bHRpUG9seVxuICpcbiAqL1xuZnVuY3Rpb24gbXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIGdlb21ldHJ5Q29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheTx7R2VvbWV0cnl9Pn0gZ2VvbWV0cmllcyBhbiBhcnJheSBvZiBHZW9KU09OIEdlb21ldHJpZXNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBhIEdlb0pTT04gR2VvbWV0cnlDb2xsZWN0aW9uIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQgPSB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwMCwgMF1cbiAqICAgICB9O1xuICogdmFyIGxpbmUgPSB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWyBbMTAxLCAwXSwgWzEwMiwgMV0gXVxuICogICB9O1xuICogdmFyIGNvbGxlY3Rpb24gPSB0dXJmLmdlb21ldHJ5Q29sbGVjdGlvbihbcHQsIGxpbmVdKTtcbiAqXG4gKiAvLz1jb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFnZW9tZXRyaWVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGdlb21ldHJpZXMgcGFzc2VkJyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgICAgICBnZW9tZXRyaWVzOiBnZW9tZXRyaWVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59XG5cbnZhciBmYWN0b3JzID0ge1xuICAgIG1pbGVzOiAzOTYwLFxuICAgIG5hdXRpY2FsbWlsZXM6IDM0NDEuMTQ1LFxuICAgIGRlZ3JlZXM6IDU3LjI5NTc3OTUsXG4gICAgcmFkaWFuczogMSxcbiAgICBpbmNoZXM6IDI1MDkwNTYwMCxcbiAgICB5YXJkczogNjk2OTYwMCxcbiAgICBtZXRlcnM6IDYzNzMwMDAsXG4gICAgbWV0cmVzOiA2MzczMDAwLFxuICAgIGtpbG9tZXRlcnM6IDYzNzMsXG4gICAga2lsb21ldHJlczogNjM3MyxcbiAgICBmZWV0OiAyMDkwODc5Mi42NVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgZnJvbSByYWRpYW5zIHRvIGEgbW9yZSBmcmllbmRseSB1bml0LlxuICpcbiAqIEBuYW1lIHJhZGlhbnNUb0Rpc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyBpbiByYWRpYW5zIGFjcm9zcyB0aGUgc3BoZXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVycyBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJhZGlhbnNUb0Rpc3RhbmNlKHJhZGlhbnMsIHVuaXRzKSB7XG4gICAgdmFyIGZhY3RvciA9IGZhY3RvcnNbdW5pdHMgfHwgJ2tpbG9tZXRlcnMnXTtcbiAgICBpZiAoZmFjdG9yID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG5cbiAgICByZXR1cm4gcmFkaWFucyAqIGZhY3Rvcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIHJhZGlhbnNcbiAqXG4gKiBAbmFtZSBkaXN0YW5jZVRvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzIGluY2hlcywgeWFyZHMsIG1ldHJlcywgbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZVRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpIHtcbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0cyB8fCAna2lsb21ldGVycyddO1xuICAgIGlmIChmYWN0b3IgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVuaXQnKTtcblxuICAgIHJldHVybiBkaXN0YW5jZSAvIGZhY3Rvcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIGRlZ3JlZXNcbiAqXG4gKiBAbmFtZSBkaXN0YW5jZVRvRGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzIGluY2hlcywgeWFyZHMsIG1ldHJlcywgbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gZGVncmVlc1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZVRvRGVncmVlcyhkaXN0YW5jZSwgdW5pdHMpIHtcbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0cyB8fCAna2lsb21ldGVycyddO1xuICAgIGlmIChmYWN0b3IgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVuaXQnKTtcblxuICAgIHJldHVybiAoZGlzdGFuY2UgLyBmYWN0b3IpICogNTcuMjk1ODtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICBmZWF0dXJlQ29sbGVjdGlvbjogZmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uOiBnZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgcG9pbnQ6IHBvaW50LFxuICAgIG11bHRpUG9pbnQ6IG11bHRpUG9pbnQsXG4gICAgbGluZVN0cmluZzogbGluZVN0cmluZyxcbiAgICBtdWx0aUxpbmVTdHJpbmc6IG11bHRpTGluZVN0cmluZyxcbiAgICBwb2x5Z29uOiBwb2x5Z29uLFxuICAgIG11bHRpUG9seWdvbjogbXVsdGlQb2x5Z29uLFxuICAgIHJhZGlhbnNUb0Rpc3RhbmNlOiByYWRpYW5zVG9EaXN0YW5jZSxcbiAgICBkaXN0YW5jZVRvUmFkaWFuczogZGlzdGFuY2VUb1JhZGlhbnMsXG4gICAgZGlzdGFuY2VUb0RlZ3JlZXM6IGRpc3RhbmNlVG9EZWdyZWVzXG59O1xuIiwidmFyIGFyZWEgPSByZXF1aXJlKCdAbWFwYm94L2dlb2pzb24tYXJlYScpLmdlb21ldHJ5O1xudmFyIGdlb21SZWR1Y2UgPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuZ2VvbVJlZHVjZTtcblxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSBmZWF0dXJlcyBhbmQgcmV0dXJucyB0aGVpciBhcmVhIGluIHNxdWFyZSBtZXRlcnMuXG4gKlxuICogQG5hbWUgYXJlYVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPGFueT59IGdlb2pzb24gaW5wdXQgR2VvSlNPTiBmZWF0dXJlKHMpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhcmVhIGluIHNxdWFyZSBtZXRlcnNcbiAqIEBhZGRUb01hcCBwb2x5Z29uXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbXG4gKiAgICAgICAgIFsxMjUsIC0xNV0sXG4gKiAgICAgICAgIFsxMTMsIC0yMl0sXG4gKiAgICAgICAgIFsxMTcsIC0zN10sXG4gKiAgICAgICAgIFsxMzAsIC0zM10sXG4gKiAgICAgICAgIFsxNDgsIC0zOV0sXG4gKiAgICAgICAgIFsxNTQsIC0yN10sXG4gKiAgICAgICAgIFsxNDQsIC0xNV0sXG4gKiAgICAgICAgIFsxMjUsIC0xNV1cbiAqICAgICAgIF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH1cbiAqIHZhciBhcmVhID0gdHVyZi5hcmVhKHBvbHlnb24pO1xuICogLy89YXJlYSA9PiBzcXVhcmUgbWV0ZXJzXG4gKiAvLz1wb2x5Z29uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGdlb2pzb24pIHtcbiAgICByZXR1cm4gZ2VvbVJlZHVjZShnZW9qc29uLCBmdW5jdGlvbiAodmFsdWUsIGdlb21ldHJ5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGFyZWEoZ2VvbWV0cnkpO1xuICAgIH0sIDApO1xufTtcbiIsIi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkRWFjaFxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2FsbGJhY2sgY29vcmRFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gY3VycmVudENvb3JkcyBUaGUgY3VycmVudCBjb29yZGluYXRlcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGVcbiAqIGFycmF5LlN0YXJ0cyBhdCBpbmRleCAwLCBpZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQsIGFuZCBhdCBpbmRleCAxIG90aGVyd2lzZS5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgY29vcmRFYWNoXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50Q29vcmRzLCBjdXJyZW50SW5kZXgpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmNvb3JkRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRDb29yZHMsIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1jdXJyZW50Q29vcmRzXG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChsYXllciwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICB2YXIgaSwgaiwgaywgZywgbCwgZ2VvbWV0cnksIHN0b3BHLCBjb29yZHMsXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgICB3cmFwU2hyaW5rID0gMCxcbiAgICAgICAgY3VycmVudEluZGV4ID0gMCxcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSBsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBpc0ZlYXR1cmUgPSBsYXllci50eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gbGF5ZXIuZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gICAgZm9yIChpID0gMDsgaSA8IHN0b3A7IGkrKykge1xuXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6XG4gICAgICAgIChpc0ZlYXR1cmUgPyBsYXllci5nZW9tZXRyeSA6IGxheWVyKSk7XG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XG4gICAgICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICAgICAgZm9yIChnID0gMDsgZyA8IHN0b3BHOyBnKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gP1xuICAgICAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuICAgICAgICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIHdyYXBTaHJpbmsgPSAoZXhjbHVkZVdyYXBDb29yZCAmJlxuICAgICAgICAgICAgICAgIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpKSA/XG4gICAgICAgICAgICAgICAgMSA6IDA7XG5cbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjb29yZHNbal0sIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvb3Jkc1tqXVtrXSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBjb29yZHNbal1ba10ubGVuZ3RoIC0gd3JhcFNocmluazsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdW2xdLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICBjb29yZEVhY2goZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvbWV0cnkgVHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBjb29yZFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBjb29yZFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBjdXJyZW50Q29vcmRzIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlXG4gKiBhcnJheS5TdGFydHMgYXQgaW5kZXggMCwgaWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkLCBhbmQgYXQgaW5kZXggMSBvdGhlcndpc2UuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpXG4gKlxuICogQG5hbWUgY29vcmRSZWR1Y2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZHMsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmNvb3JkUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkcywgY3VycmVudEluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudENvb3Jkc1xuICogICAvLz1jdXJyZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRDb29yZHM7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRSZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUsIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBjb29yZEVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmRzLCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRDb29yZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkcywgY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBwcm9wRWFjaFxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2FsbGJhY2sgcHJvcEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHsqfSBjdXJyZW50UHJvcGVydGllcyBUaGUgY3VycmVudCBwcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZVxuICogYXJyYXkuU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICpcbiAqIEBuYW1lIHByb3BFYWNoXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50UHJvcGVydGllcywgY3VycmVudEluZGV4KVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcImZvb1wiOiBcImJhclwifSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyNiwgMzddXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1wiaGVsbG9cIjogXCJ3b3JsZFwifSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFszNiwgNTNdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICogdHVyZi5wcm9wRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRQcm9wZXJ0aWVzLCBjdXJyZW50SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudFByb3BlcnRpZXNcbiAqICAgLy89Y3VycmVudEluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcHJvcEVhY2gobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChsYXllci50eXBlKSB7XG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXIuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICBjYWxsYmFjayhsYXllci5wcm9wZXJ0aWVzLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHByb3BSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2FsbGJhY2sgcHJvcFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHsqfSBjdXJyZW50UHJvcGVydGllcyBUaGUgY3VycmVudCBwcm9wZXJ0aWVzIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZVxuICogYXJyYXkuU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICovXG5cbi8qKlxuICogUmVkdWNlIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyBpcyB1bm5lY2Vzc2FyeS5cbiAqXG4gKiBAbmFtZSBwcm9wUmVkdWNlXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgY3VycmVudEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XCJmb29cIjogXCJiYXJcIn0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcImhlbGxvXCI6IFwid29ybGRcIn0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMzYsIDUzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqIHR1cmYucHJvcFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBjdXJyZW50SW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50UHJvcGVydGllc1xuICogICAvLz1jdXJyZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0aWVzXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcHJvcFJlZHVjZShsYXllciwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHByb3BFYWNoKGxheWVyLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY3VycmVudFByb3BlcnRpZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmVhdHVyZUVhY2hcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhbGxiYWNrIGZlYXR1cmVFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxhbnk+fSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBmZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZVxuICogYXJyYXkuU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xuICogQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlRWFjaFxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEZlYXR1cmUsIGN1cnJlbnRJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyNiwgMzddXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMzYsIDUzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqIHR1cmYuZmVhdHVyZUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgY3VycmVudEluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVFYWNoKGxheWVyLCBjYWxsYmFjaykge1xuICAgIGlmIChsYXllci50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIsIDApO1xuICAgIH0gZWxzZSBpZiAobGF5ZXIudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXllci5mZWF0dXJlc1tpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2FsbGJhY2sgZmVhdHVyZVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlPGFueT59IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlXG4gKiBhcnJheS5TdGFydHMgYXQgaW5kZXggMCwgaWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkLCBhbmQgYXQgaW5kZXggMSBvdGhlcndpc2UuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVSZWR1Y2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBjdXJyZW50SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcImZvb1wiOiBcImJhclwifSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyNiwgMzddXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1wiaGVsbG9cIjogXCJ3b3JsZFwifSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFszNiwgNTNdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICogdHVyZi5mZWF0dXJlUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogICByZXR1cm4gY3VycmVudEZlYXR1cmVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlUmVkdWNlKGxheWVyLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgZmVhdHVyZUVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgY3VycmVudEluZGV4KSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50RmVhdHVyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBhbGwgY29vcmRpbmF0ZXMgZnJvbSBhbnkgR2VvSlNPTiBvYmplY3QuXG4gKlxuICogQG5hbWUgY29vcmRBbGxcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZSBwb3NpdGlvbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI2LCAzN11cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFszNiwgNTNdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICogdmFyIGNvb3JkcyA9IHR1cmYuY29vcmRBbGwoZmVhdHVyZXMpO1xuICogLy89Y29vcmRzXG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGxheWVyKSB7XG4gICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgIGNvb3JkRWFjaChsYXllciwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGNvb3Jkcy5wdXNoKGNvb3JkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBnZW9tRWFjaFxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEdlb21ldHJ5LCBjdXJyZW50SW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmdlb21FYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEdlb21ldHJ5LCBjdXJyZW50SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudEdlb21ldHJ5XG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21FYWNoKGxheWVyLCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBqLCBnLCBnZW9tZXRyeSwgc3RvcEcsXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbixcbiAgICAgICAgY3VycmVudEluZGV4ID0gMCxcbiAgICAgICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IGxheWVyLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGlzRmVhdHVyZSA9IGxheWVyLnR5cGUgPT09ICdGZWF0dXJlJyxcbiAgICAgICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gIC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xuICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcbiAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcbiAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RvcDsgaSsrKSB7XG5cbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSAoaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGxheWVyLmZlYXR1cmVzW2ldLmdlb21ldHJ5IDpcbiAgICAgICAgKGlzRmVhdHVyZSA/IGxheWVyLmdlb21ldHJ5IDogbGF5ZXIpKTtcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJztcbiAgICAgICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcblxuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgc3RvcEc7IGcrKykge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/XG4gICAgICAgICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2ddIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247XG5cbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnIHx8XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnIHx8XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycgfHxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGdlb21ldHJ5LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb21ldHJ5IFR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBnZW9tUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0geyp9IGN1cnJlbnRHZW9tZXRyeSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZVxuICogYXJyYXkuU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBnZW9tUmVkdWNlXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1wiZm9vXCI6IFwiYmFyXCJ9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI2LCAzN11cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmdlb21SZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRHZW9tZXRyeVxuICogICAvLz1jdXJyZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRHZW9tZXRyeVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21SZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBnZW9tRWFjaChsYXllciwgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgY3VycmVudEluZGV4KSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50R2VvbWV0cnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvb3JkRWFjaDogY29vcmRFYWNoLFxuICAgIGNvb3JkUmVkdWNlOiBjb29yZFJlZHVjZSxcbiAgICBwcm9wRWFjaDogcHJvcEVhY2gsXG4gICAgcHJvcFJlZHVjZTogcHJvcFJlZHVjZSxcbiAgICBmZWF0dXJlRWFjaDogZmVhdHVyZUVhY2gsXG4gICAgZmVhdHVyZVJlZHVjZTogZmVhdHVyZVJlZHVjZSxcbiAgICBjb29yZEFsbDogY29vcmRBbGwsXG4gICAgZ2VvbUVhY2g6IGdlb21FYWNoLFxuICAgIGdlb21SZWR1Y2U6IGdlb21SZWR1Y2Vcbn07XG4iLCJ2YXIgaGVscGVycyA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKTtcbnZhciBsaW5lY2xpcCA9IHJlcXVpcmUoJ2xpbmVjbGlwJyk7XG52YXIgZ2V0Q29vcmRzID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50JykuZ2V0Q29vcmRzO1xudmFyIGxpbmVTdHJpbmcgPSBoZWxwZXJzLmxpbmVTdHJpbmc7XG52YXIgbXVsdGlMaW5lU3RyaW5nID0gaGVscGVycy5tdWx0aUxpbmVTdHJpbmc7XG52YXIgcG9seWdvbiA9IGhlbHBlcnMucG9seWdvbjtcbnZhciBtdWx0aVBvbHlnb24gPSBoZWxwZXJzLm11bHRpUG9seWdvbjtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBGZWF0dXJlfSBhbmQgYSBiYm94IGFuZCBjbGlwcyB0aGUgZmVhdHVyZSB0byB0aGUgYmJveCB1c2luZyBbbGluZWNsaXBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbGluZWNsaXApLlxuICogTWF5IHJlc3VsdCBpbiBkZWdlbmVyYXRlIGVkZ2VzIHdoZW4gY2xpcHBpbmcgUG9seWdvbnMuXG4gKlxuICogQG5hbWUgYmJveC1jbGlwXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZ3xNdWx0aUxpbmVTdHJpbmd8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBmZWF0dXJlIGZlYXR1cmUgdG8gY2xpcCB0byB0aGUgYmJveFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmd8TXVsdGlMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlQb2x5Z29uPn0gY2xpcHBlZCBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBbMCwgMCwgMTAsIDEwXTtcbiAqIHZhciBwb2x5ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tbMiwgMl0sIFs4LCA0XSwgWzEyLCA4XSwgWzMsIDddLCBbMiwgMl1dXVxuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGNsaXBwZWQgPSB0dXJmLmJib3hDbGlwKHBvbHksIGJib3gpO1xuICpcbiAqIC8vPWNsaXBwZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgYmJveCkge1xuICAgIHZhciBnZW9tID0gZ2V0R2VvbShmZWF0dXJlKTtcbiAgICB2YXIgY29vcmRzID0gZ2V0Q29vcmRzKGZlYXR1cmUpO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xuXG4gICAgc3dpdGNoIChnZW9tKSB7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIGlmIChnZW9tID09PSAnTGluZVN0cmluZycpIGNvb3JkcyA9IFtjb29yZHNdO1xuICAgICAgICBjb29yZHMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgbGluZWNsaXAobGluZSwgYmJveCwgbGluZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpbmVTdHJpbmcobGluZXNbMF0sIHByb3BlcnRpZXMpO1xuICAgICAgICByZXR1cm4gbXVsdGlMaW5lU3RyaW5nKGxpbmVzLCBwcm9wZXJ0aWVzKTtcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgcmV0dXJuIHBvbHlnb24oY2xpcFBvbHlnb24oY29vcmRzLCBiYm94KSwgcHJvcGVydGllcyk7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgcmV0dXJuIG11bHRpUG9seWdvbihjb29yZHMubWFwKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpcFBvbHlnb24ocG9seWdvbiwgYmJveCk7XG4gICAgICAgIH0pLCBwcm9wZXJ0aWVzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb21ldHJ5ICcgKyBnZW9tICsgJyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2xpcFBvbHlnb24ocmluZ3MsIGJib3gpIHtcbiAgICB2YXIgb3V0UmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbGlwcGVkID0gbGluZWNsaXAucG9seWdvbihyaW5nc1tpXSwgYmJveCk7XG4gICAgICAgIGlmIChjbGlwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjbGlwcGVkWzBdWzBdICE9PSBjbGlwcGVkW2NsaXBwZWQubGVuZ3RoIC0gMV1bMF0gfHwgY2xpcHBlZFswXVsxXSAhPT0gY2xpcHBlZFtjbGlwcGVkLmxlbmd0aCAtIDFdWzFdKSB7XG4gICAgICAgICAgICAgICAgY2xpcHBlZC5wdXNoKGNsaXBwZWRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0UmluZ3MucHVzaChjbGlwcGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0UmluZ3M7XG59XG5cbmZ1bmN0aW9uIGdldEdlb20oZmVhdHVyZSkge1xuICAgIHJldHVybiAoZmVhdHVyZS5nZW9tZXRyeSkgPyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgOiBmZWF0dXJlLnR5cGU7XG59XG4iLCJ2YXIgZWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5jb29yZEVhY2g7XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2YgZmVhdHVyZXMsIGNhbGN1bGF0ZXMgdGhlIGJib3ggb2YgYWxsIGlucHV0IGZlYXR1cmVzLCBhbmQgcmV0dXJucyBhIGJvdW5kaW5nIGJveC5cbiAqXG4gKiBAbmFtZSBiYm94XG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gZ2VvanNvbiBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQGFkZFRvTWFwIGZlYXR1cmVzLCBiYm94UG9seWdvblxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB0dXJmLnBvaW50KFsxMTQuMTc1MzI5LCAyMi4yNTI0XSlcbiAqIHZhciBwdDIgPSB0dXJmLnBvaW50KFsxMTQuMTcwMDA3LCAyMi4yNjc5NjldKVxuICogdmFyIHB0MyA9IHR1cmYucG9pbnQoWzExNC4yMDA2NDksIDIyLjI3NDY0MV0pXG4gKiB2YXIgcHQ0ID0gdHVyZi5wb2ludChbMTE0LjIwMDY0OSwgMjIuMjc0NjQxXSlcbiAqIHZhciBwdDUgPSB0dXJmLnBvaW50KFsxMTQuMTg2NzQ0LCAyMi4yNjU3NDVdKVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbcHQxLCBwdDIsIHB0MywgcHQ0LCBwdDVdKVxuICpcbiAqIHZhciBiYm94ID0gdHVyZi5iYm94KGZlYXR1cmVzKTtcbiAqXG4gKiB2YXIgYmJveFBvbHlnb24gPSB0dXJmLmJib3hQb2x5Z29uKGJib3gpO1xuICpcbiAqIC8vPWJib3hcbiAqXG4gKiAvLz1iYm94UG9seWdvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgdmFyIGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgZWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgaWYgKGJib3hbMF0gPiBjb29yZFswXSkgYmJveFswXSA9IGNvb3JkWzBdO1xuICAgICAgICBpZiAoYmJveFsxXSA+IGNvb3JkWzFdKSBiYm94WzFdID0gY29vcmRbMV07XG4gICAgICAgIGlmIChiYm94WzJdIDwgY29vcmRbMF0pIGJib3hbMl0gPSBjb29yZFswXTtcbiAgICAgICAgaWYgKGJib3hbM10gPCBjb29yZFsxXSkgYmJveFszXSA9IGNvb3JkWzFdO1xuICAgIH0pO1xuICAgIHJldHVybiBiYm94O1xufTtcbiIsInZhciBnZXRDb29yZCA9IHJlcXVpcmUoJ0B0dXJmL2ludmFyaWFudCcpLmdldENvb3JkO1xuLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vL2h0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG5cbi8qKlxuICogVGFrZXMgdHdvIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBmaW5kcyB0aGUgZ2VvZ3JhcGhpYyBiZWFyaW5nIGJldHdlZW4gdGhlbS5cbiAqXG4gKiBAbmFtZSBiZWFyaW5nXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBzdGFydCBzdGFydGluZyBQb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gZW5kIGVuZGluZyBQb2ludFxuICogQHBhcmFtIHtib29sZWFufSBbZmluYWw9ZmFsc2VdIGNhbGN1bGF0ZXMgdGhlIGZpbmFsIGJlYXJpbmcgaWYgdHJ1ZVxuICogQHJldHVybnMge251bWJlcn0gYmVhcmluZyBpbiBkZWNpbWFsIGRlZ3JlZXNcbiAqIEBhZGRUb01hcCBwb2ludDEsIHBvaW50MlxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludDEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcIm1hcmtlci1jb2xvclwiOiAnI2YwMCdcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuMzQzLCAzOS45ODRdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcG9pbnQyID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJtYXJrZXItY29sb3JcIjogJyMwZjAnXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjUzNCwgMzkuMTIzXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBiZWFyaW5nID0gdHVyZi5iZWFyaW5nKHBvaW50MSwgcG9pbnQyKTtcbiAqIHBvaW50MS5wcm9wZXJ0aWVzLmJlYXJpbmcgPSBiZWFyaW5nXG4gKiAvLz1iZWFyaW5nXG4gKi9cbmZ1bmN0aW9uIGJlYXJpbmcoc3RhcnQsIGVuZCwgZmluYWwpIHtcbiAgICBpZiAoZmluYWwgPT09IHRydWUpIHJldHVybiBjYWxjdWxhdGVGaW5hbEJlYXJpbmcoc3RhcnQsIGVuZCk7XG5cbiAgICB2YXIgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcmFkaWFuczJkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiAgICB2YXIgY29vcmRpbmF0ZXMxID0gZ2V0Q29vcmQoc3RhcnQpO1xuICAgIHZhciBjb29yZGluYXRlczIgPSBnZXRDb29yZChlbmQpO1xuXG4gICAgdmFyIGxvbjEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMF07XG4gICAgdmFyIGxvbjIgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczJbMF07XG4gICAgdmFyIGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMV07XG4gICAgdmFyIGxhdDIgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczJbMV07XG4gICAgdmFyIGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgICB2YXIgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgICAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuXG4gICAgdmFyIGJlYXIgPSByYWRpYW5zMmRlZ3JlZXMgKiBNYXRoLmF0YW4yKGEsIGIpO1xuXG4gICAgcmV0dXJuIGJlYXI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBGaW5hbCBCZWFyaW5nXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gc3RhcnQgc3RhcnRpbmcgUG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IGVuZCBlbmRpbmcgUG9pbnRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGJlYXJpbmdcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRmluYWxCZWFyaW5nKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBTd2FwIHN0YXJ0ICYgZW5kXG4gICAgdmFyIGJlYXIgPSBiZWFyaW5nKGVuZCwgc3RhcnQpO1xuICAgIGJlYXIgPSAoYmVhciArIDE4MCkgJSAzNjA7XG4gICAgcmV0dXJuIGJlYXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmVhcmluZztcbiIsInZhciBsaW5lc3RyaW5nID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmxpbmVTdHJpbmc7XG52YXIgU3BsaW5lID0gcmVxdWlyZSgnLi9zcGxpbmUuanMnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfGxpbmV9IGFuZCByZXR1cm5zIGEgY3VydmVkIHZlcnNpb25cbiAqIGJ5IGFwcGx5aW5nIGEgW0JlemllciBzcGxpbmVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfc3BsaW5lKVxuICogYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBiZXppZXIgc3BsaW5lIGltcGxlbWVudGF0aW9uIGlzIGJ5IFtMZXN6ZWsgUnliaWNraV0oaHR0cDovL2xlc3play5yeWJpY2tpLmNjLykuXG4gKlxuICogQG5hbWUgYmV6aWVyXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgaW5wdXQgTGluZVN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTEwMDAwXSB0aW1lIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtzaGFycG5lc3M9MC44NV0gYSBtZWFzdXJlIG9mIGhvdyBjdXJ2eSB0aGUgcGF0aCBzaG91bGQgYmUgYmV0d2VlbiBzcGxpbmVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VydmVkIGxpbmVcbiAqIEBhZGRUb01hcCBsaW5lLCBjdXJ2ZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwic3Ryb2tlXCI6IFwiI2YwMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgIFstNzYuMDkxMzA4LCAxOC40Mjc1MDFdLFxuICogICAgICAgWy03Ni42OTU1NTYsIDE4LjcyOTUwMV0sXG4gKiAgICAgICBbLTc2LjU1MjczNCwgMTkuNDA0NDNdLFxuICogICAgICAgWy03NC42MTkxNCwgMTkuMTM0Nzg5XSxcbiAqICAgICAgIFstNzMuNjUyMzQzLCAyMC4wNzY1N10sXG4gKiAgICAgICBbLTczLjE1Nzk1OCwgMjAuMjEwNjU2XVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgY3VydmVkID0gdHVyZi5iZXppZXIobGluZSk7XG4gKiBjdXJ2ZWQucHJvcGVydGllcyA9IHsgc3Ryb2tlOiAnIzBmMCcgfTtcbiAqXG4gKiAvLz1jdXJ2ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGluZSwgcmVzb2x1dGlvbiwgc2hhcnBuZXNzKSB7XG4gICAgdmFyIGxpbmVPdXQgPSBsaW5lc3RyaW5nKFtdKTtcblxuICAgIGxpbmVPdXQucHJvcGVydGllcyA9IGxpbmUucHJvcGVydGllcztcblxuICAgIHZhciBzcGxpbmUgPSBuZXcgU3BsaW5lKHtcbiAgICAgICAgcG9pbnRzOiBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7eDogcHRbMF0sIHk6IHB0WzFdfTtcbiAgICAgICAgfSksXG4gICAgICAgIGR1cmF0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICBzaGFycG5lc3M6IHNoYXJwbmVzc1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpbmUuZHVyYXRpb247IGkgKz0gMTApIHtcbiAgICAgICAgdmFyIHBvcyA9IHNwbGluZS5wb3MoaSk7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKGkgLyAxMDApICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbGluZU91dC5nZW9tZXRyeS5jb29yZGluYXRlcy5wdXNoKFtwb3MueCwgcG9zLnldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaW5lT3V0O1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbiAvKipcbiAgICogQmV6aWVyU3BsaW5lXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sZXN6ZWtyL2Jlemllci1zcGxpbmUtanNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvcHlyaWdodFxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTMgTGVzemVrIFJ5Ymlja2lcbiAgICpcbiAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAgKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICpcbiAgICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAqXG4gICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gICAqIFNPRlRXQVJFLlxuICAgKi9cbnZhciBTcGxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMucG9pbnRzID0gb3B0aW9ucy5wb2ludHMgfHwgW107XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgMTAwMDA7XG4gICAgdGhpcy5zaGFycG5lc3MgPSBvcHRpb25zLnNoYXJwbmVzcyB8fCAwLjg1O1xuICAgIHRoaXMuY2VudGVycyA9IFtdO1xuICAgIHRoaXMuY29udHJvbHMgPSBbXTtcbiAgICB0aGlzLnN0ZXBMZW5ndGggPSBvcHRpb25zLnN0ZXBMZW5ndGggfHwgNjA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7XG4gICAgdGhpcy5kZWxheSA9IDA7XG4gICAgLy8gdGhpcyBpcyB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSAyZCB2ZXJzaW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB0aGlzLnBvaW50c1tpXS56ID0gdGhpcy5wb2ludHNbaV0ueiB8fCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIHZhciBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXTtcbiAgICAgICAgdGhpcy5jZW50ZXJzLnB1c2goe1xuICAgICAgICAgICAgeDogKHAxLnggKyBwMi54KSAvIDIsXG4gICAgICAgICAgICB5OiAocDEueSArIHAyLnkpIC8gMixcbiAgICAgICAgICAgIHo6IChwMS56ICsgcDIueikgLyAyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xzLnB1c2goW3RoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1swXV0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jZW50ZXJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLmNlbnRlcnNbaV07XG4gICAgICAgIHZhciBwMiA9IHRoaXMuY2VudGVyc1tpICsgMV07XG4gICAgICAgIHZhciBkeCA9IHRoaXMucG9pbnRzW2kgKyAxXS54IC0gKHRoaXMuY2VudGVyc1tpXS54ICsgdGhpcy5jZW50ZXJzW2kgKyAxXS54KSAvIDI7XG4gICAgICAgIHZhciBkeSA9IHRoaXMucG9pbnRzW2kgKyAxXS55IC0gKHRoaXMuY2VudGVyc1tpXS55ICsgdGhpcy5jZW50ZXJzW2kgKyAxXS55KSAvIDI7XG4gICAgICAgIHZhciBkeiA9IHRoaXMucG9pbnRzW2kgKyAxXS56IC0gKHRoaXMuY2VudGVyc1tpXS55ICsgdGhpcy5jZW50ZXJzW2kgKyAxXS56KSAvIDI7XG4gICAgICAgIHRoaXMuY29udHJvbHMucHVzaChbe1xuICAgICAgICAgICAgeDogKDEuMCAtIHRoaXMuc2hhcnBuZXNzKSAqIHRoaXMucG9pbnRzW2kgKyAxXS54ICsgdGhpcy5zaGFycG5lc3MgKiAodGhpcy5jZW50ZXJzW2ldLnggKyBkeCksXG4gICAgICAgICAgICB5OiAoMS4wIC0gdGhpcy5zaGFycG5lc3MpICogdGhpcy5wb2ludHNbaSArIDFdLnkgKyB0aGlzLnNoYXJwbmVzcyAqICh0aGlzLmNlbnRlcnNbaV0ueSArIGR5KSxcbiAgICAgICAgICAgIHo6ICgxLjAgLSB0aGlzLnNoYXJwbmVzcykgKiB0aGlzLnBvaW50c1tpICsgMV0ueiArIHRoaXMuc2hhcnBuZXNzICogKHRoaXMuY2VudGVyc1tpXS56ICsgZHopfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiAoMS4wIC0gdGhpcy5zaGFycG5lc3MpICogdGhpcy5wb2ludHNbaSArIDFdLnggKyB0aGlzLnNoYXJwbmVzcyAqICh0aGlzLmNlbnRlcnNbaSArIDFdLnggKyBkeCksXG4gICAgICAgICAgICAgICAgeTogKDEuMCAtIHRoaXMuc2hhcnBuZXNzKSAqIHRoaXMucG9pbnRzW2kgKyAxXS55ICsgdGhpcy5zaGFycG5lc3MgKiAodGhpcy5jZW50ZXJzW2kgKyAxXS55ICsgZHkpLFxuICAgICAgICAgICAgICAgIHo6ICgxLjAgLSB0aGlzLnNoYXJwbmVzcykgKiB0aGlzLnBvaW50c1tpICsgMV0ueiArIHRoaXMuc2hhcnBuZXNzICogKHRoaXMuY2VudGVyc1tpICsgMV0ueiArIGR6KX1dKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9scy5wdXNoKFt0aGlzLnBvaW50c1t0aGlzLmxlbmd0aCAtIDFdLCB0aGlzLnBvaW50c1t0aGlzLmxlbmd0aCAtIDFdXSk7XG4gICAgdGhpcy5zdGVwcyA9IHRoaXMuY2FjaGVTdGVwcyh0aGlzLnN0ZXBMZW5ndGgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuICAvKlxuICAgIENhY2hlcyBhbiBhcnJheSBvZiBlcXVpZGlzdGFudCAobW9yZSBvciBsZXNzKSBwb2ludHMgb24gdGhlIGN1cnZlLlxuICAqL1xuU3BsaW5lLnByb3RvdHlwZS5jYWNoZVN0ZXBzID0gZnVuY3Rpb24gKG1pbmRpc3QpIHtcbiAgICB2YXIgc3RlcHMgPSBbXTtcbiAgICB2YXIgbGFzdHN0ZXAgPSB0aGlzLnBvcygwKTtcbiAgICBzdGVwcy5wdXNoKDApO1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy5kdXJhdGlvbjsgdCArPSAxMCkge1xuICAgICAgICB2YXIgc3RlcCA9IHRoaXMucG9zKHQpO1xuICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCgoc3RlcC54IC0gbGFzdHN0ZXAueCkgKiAoc3RlcC54IC0gbGFzdHN0ZXAueCkgKyAoc3RlcC55IC0gbGFzdHN0ZXAueSkgKiAoc3RlcC55IC0gbGFzdHN0ZXAueSkgKyAoc3RlcC56IC0gbGFzdHN0ZXAueikgKiAoc3RlcC56IC0gbGFzdHN0ZXAueikpO1xuICAgICAgICBpZiAoZGlzdCA+IG1pbmRpc3QpIHtcbiAgICAgICAgICAgIHN0ZXBzLnB1c2godCk7XG4gICAgICAgICAgICBsYXN0c3RlcCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ZXBzO1xufTtcblxuICAvKlxuICAgIHJldHVybnMgYW5nbGUgYW5kIHNwZWVkIGluIHRoZSBnaXZlbiBwb2ludCBpbiB0aGUgY3VydmVcbiAgKi9cblNwbGluZS5wcm90b3R5cGUudmVjdG9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgcDEgPSB0aGlzLnBvcyh0ICsgMTApO1xuICAgIHZhciBwMiA9IHRoaXMucG9zKHQgLSAxMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGU6MTgwICogTWF0aC5hdGFuMihwMS55IC0gcDIueSwgcDEueCAtIHAyLngpIC8gMy4xNCxcbiAgICAgICAgc3BlZWQ6TWF0aC5zcXJ0KChwMi54IC0gcDEueCkgKiAocDIueCAtIHAxLngpICsgKHAyLnkgLSBwMS55KSAqIChwMi55IC0gcDEueSkgKyAocDIueiAtIHAxLnopICogKHAyLnogLSBwMS56KSlcbiAgICB9O1xufTtcblxuICAvKlxuICAgIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCwgZ2l2ZW4gdGltZS5cblxuICAgIFdBUk5JTkc6IFRoZSBzcGVlZCBpcyBub3QgY29uc3RhbnQuIFRoZSB0aW1lIGl0IHRha2VzIGJldHdlZW4gY29udHJvbCBwb2ludHMgaXMgY29uc3RhbnQuXG5cbiAgICBGb3IgY29uc3RhbnQgc3BlZWQsIHVzZSBTcGxpbmUuc3RlcHNbaV07XG4gICovXG5TcGxpbmUucHJvdG90eXBlLnBvcyA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cbiAgICBmdW5jdGlvbiBiZXppZXIodCwgcDEsIGMxLCBjMiwgcDIpIHtcbiAgICAgICAgdmFyIEIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHQyID0gdCAqIHQsIHQzID0gdDIgKiB0O1xuICAgICAgICAgICAgcmV0dXJuIFsodDMpLCAoMyAqIHQyICogKDEgLSB0KSksICgzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpKSwgKCgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KSldO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYiA9IEIodCk7XG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICB4IDogcDIueCAqIGJbMF0gKyBjMi54ICogYlsxXSArIGMxLnggKiBiWzJdICsgcDEueCAqIGJbM10sXG4gICAgICAgICAgICB5IDogcDIueSAqIGJbMF0gKyBjMi55ICogYlsxXSArIGMxLnkgKiBiWzJdICsgcDEueSAqIGJbM10sXG4gICAgICAgICAgICB6IDogcDIueiAqIGJbMF0gKyBjMi56ICogYlsxXSArIGMxLnogKiBiWzJdICsgcDEueiAqIGJbM11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgdmFyIHQgPSB0aW1lIC0gdGhpcy5kZWxheTtcbiAgICBpZiAodCA8IDApIHQgPSAwO1xuICAgIGlmICh0ID4gdGhpcy5kdXJhdGlvbikgdCA9IHRoaXMuZHVyYXRpb24gLSAxO1xuICAgIC8vdCA9IHQtdGhpcy5kZWxheTtcbiAgICB2YXIgdDIgPSAodCkgLyB0aGlzLmR1cmF0aW9uO1xuICAgIGlmICh0MiA+PSAxKSByZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5sZW5ndGggLSAxXTtcblxuICAgIHZhciBuID0gTWF0aC5mbG9vcigodGhpcy5wb2ludHMubGVuZ3RoIC0gMSkgKiB0Mik7XG4gICAgdmFyIHQxID0gKHRoaXMubGVuZ3RoIC0gMSkgKiB0MiAtIG47XG4gICAgcmV0dXJuIGJlemllcih0MSwgdGhpcy5wb2ludHNbbl0sIHRoaXMuY29udHJvbHNbbl1bMV0sIHRoaXMuY29udHJvbHNbbiArIDFdWzBdLCB0aGlzLnBvaW50c1tuICsgMV0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGxpbmU7XG4iLCJ2YXIgZWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5jb29yZEVhY2gsXG4gICAgY2VudHJvaWQgPSByZXF1aXJlKCdAdHVyZi9jZW50cm9pZCcpLFxuICAgIGNvbnZleCA9IHJlcXVpcmUoJ0B0dXJmL2NvbnZleCcpLFxuICAgIGV4cGxvZGUgPSByZXF1aXJlKCdAdHVyZi9leHBsb2RlJyksXG4gICAgcG9pbnQgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucG9pbnQ7XG5cbi8qKlxuICogVGFrZXMgYSBbZmVhdHVyZV0oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sI2ZlYXR1cmUtb2JqZWN0cylcbiAqIG9yIGEgW2ZlYXR1cmVDb2xsZWN0aW9uXShodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWwjZmVhdHVyZS1jb2xsZWN0aW9uLW9iamVjdHMpXG4gKiBhbmQgcmV0dXJucyBpdHMgW2NlbnRlciBvZiBtYXNzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50ZXJfb2ZfbWFzcylcbiAqIHVzaW5nIHRoaXMgZm9ybXVsYTogW0NlbnRyb2lkIG9mIFBvbHlnb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkI0NlbnRyb2lkX29mX3BvbHlnb24pLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZmMgLSB0aGUgZmVhdHVyZSBjb2xsZWN0aW9uIG9yIGZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gdGhlIGNlbnRlciBvZiBtYXNzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg1NDI0MDQxNzQ4MDQ2OSxcbiAqICAgICAgICAgICA0NS43NzI1ODIwMDM3NDQzM1xuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NDQ1ODQ0NjUwMjY4NTU1LFxuICogICAgICAgICAgIDQ1Ljc3NzQzMTA2ODQ4NDg5NFxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NDU0NDI3NzE5MTE2MjEsXG4gKiAgICAgICAgICAgNDUuNzc4NjU4MjM0MDU5NzU1XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg0NTkxNDg0MDY5ODI0MixcbiAqICAgICAgICAgICA0NS43NzkzNzY1NjIzNTI0MjVcbiAqICAgICAgICAgXSxcbiAqICAgICAgICAgW1xuICogICAgICAgICAgIDQuODQ2NjQ0NDAxNTUwMjkyLFxuICogICAgICAgICAgIDQ1Ljc4MDIxNDYwMDMzMTA4XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg0NzI0NTIxNjM2OTYyOSxcbiAqICAgICAgICAgICA0NS43ODA3ODMyNjE3ODU5M1xuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NDgwNjA2MDc5MTAxNTYsXG4gKiAgICAgICAgICAgNDUuNzgxMzgxODQ2NTI1MjNcbiAqICAgICAgICAgXSxcbiAqICAgICAgICAgW1xuICogICAgICAgICAgIDQuODQ4NzA0MzM4MDczNzMwNSxcbiAqICAgICAgICAgICA0NS43ODE4NjA3MDk2ODk2NFxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NDk1NjI2NDQ5NTg0OTUsXG4gKiAgICAgICAgICAgNDUuNzgyNDg5MjExMzUxMjRcbiAqICAgICAgICAgXSxcbiAqICAgICAgICAgW1xuICogICAgICAgICAgIDQuODUwODkzMDIwNjI5ODgzLFxuICogICAgICAgICAgIDQ1Ljc4MzAyNzkyMTQyMTk3XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg1MjAwODgxOTU4MDA3NyxcbiAqICAgICAgICAgICA0NS43ODM3NDYxOTM0MTg5NVxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NTI5OTU4NzI0OTc1NTksXG4gKiAgICAgICAgICAgNDUuNzg0MDc1Mzk4MzI0ODY2XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg1Mzg1NDE3OTM4MjMyNCxcbiAqICAgICAgICAgICA0NS43ODQ0MzQ1Mjg3MzIzNlxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NTQ5Njk5NzgzMzI1MTk1LFxuICogICAgICAgICAgIDQ1Ljc4NDcwMzg3NTAxOTc1XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg1NTY5OTUzOTE4NDU3LFxuICogICAgICAgICAgIDQ1Ljc4NDc5MzY1NjgyNjM0NVxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NTczMzAzMjIyNjU2MjQsXG4gKiAgICAgICAgICAgNDUuNzg0ODUzNTExMjgzNzY0XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg1ODIzMTU0NDQ5NDYyOSxcbiAqICAgICAgICAgICA0NS43ODQ5NDMyOTI4NDkzOFxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NTkzMDQ0MjgxMDA1ODUsXG4gKiAgICAgICAgICAgNDUuNzg0ODgzNDM4NDg4MzY1XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIFtcbiAqICAgICAgICAgICA0Ljg1ODM2MDI5MDUyNzM0NCxcbiAqICAgICAgICAgICA0NS43NzI5NDEyMDgxODQ3NFxuICogICAgICAgICBdLFxuICogICAgICAgICBbXG4gKiAgICAgICAgICAgNC44NTQyNDA0MTc0ODA0NjksXG4gKiAgICAgICAgICAgNDUuNzcyNTgyMDAzNzQ0MzNcbiAqICAgICAgICAgXVxuICogICAgICAgXVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgY2VudGVyT2ZNYXNzID0gdHVyZi5jZW50ZXJPZk1hc3MoZmVhdHVyZSk7XG4gKlxuICogLy89Y2VudGVyT2ZNYXNzXG4gKi9cbmZ1bmN0aW9uIGNlbnRlck9mTWFzcyhmYykge1xuICAgIGlmIChmYy50eXBlID09PSAnRmVhdHVyZScgJiYgZmMuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICAgICAgZWFjaChmYywgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICBjb29yZHMucHVzaChjb29yZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBuZXV0cmFsaXplIHRoZSBmZWF0dXJlIChzZXQgaXQgYXJvdW5kIGNvb3JkaW5hdGVzIFswLDBdKSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xuICAgICAgICAvLyBXZSB0YWtlIGFueSBwb2ludCB0byB0cmFuc2xhdGUgYWxsIHRoZSBwb2ludHMgYXJvdW5kIDBcbiAgICAgICAgdmFyIGNlbnRyZSA9IGNlbnRyb2lkKGZjKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gY2VudHJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICB2YXIgc3ggPSAwO1xuICAgICAgICB2YXIgc3kgPSAwO1xuICAgICAgICB2YXIgc0FyZWEgPSAwO1xuICAgICAgICB2YXIgaSwgcGksIHBqLCB4aSwgeGosIHlpLCB5aiwgYTtcblxuICAgICAgICB2YXIgbmV1dHJhbGl6ZWRQb2ludHMgPSBjb29yZHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBwb2ludFswXSAtIHRyYW5zbGF0aW9uWzBdLFxuICAgICAgICAgICAgICAgIHBvaW50WzFdIC0gdHJhbnNsYXRpb25bMV1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBwaSBpcyB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgcGkgPSBuZXV0cmFsaXplZFBvaW50c1tpXTtcbiAgICAgICAgICAgIHhpID0gcGlbMF07XG4gICAgICAgICAgICB5aSA9IHBpWzFdO1xuXG4gICAgICAgICAgICAvLyBwaiBpcyB0aGUgbmV4dCBwb2ludCAocGkrMSlcbiAgICAgICAgICAgIHBqID0gbmV1dHJhbGl6ZWRQb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgeGogPSBwalswXTtcbiAgICAgICAgICAgIHlqID0gcGpbMV07XG5cbiAgICAgICAgICAgIC8vIGEgaXMgdGhlIGNvbW1vbiBmYWN0b3IgdG8gY29tcHV0ZSB0aGUgc2lnbmVkIGFyZWEgYW5kIHRoZSBmaW5hbCBjb29yZGluYXRlc1xuICAgICAgICAgICAgYSA9IHhpICogeWogLSB4aiAqIHlpO1xuXG4gICAgICAgICAgICAvLyBzQXJlYSBpcyB0aGUgc3VtIHVzZWQgdG8gY29tcHV0ZSB0aGUgc2lnbmVkIGFyZWFcbiAgICAgICAgICAgIHNBcmVhICs9IGE7XG5cbiAgICAgICAgICAgIC8vIHN4IGFuZCBzeSBhcmUgdGhlIHN1bXMgdXNlZCB0byBjb21wdXRlIHRoZSBmaW5hbCBjb29yZGluYXRlc1xuICAgICAgICAgICAgc3ggKz0gKHhpICsgeGopICogYTtcbiAgICAgICAgICAgIHN5ICs9ICh5aSArIHlqKSAqIGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGFwZSBoYXMgbm8gYXJlYTogZmFsbGJhY2sgb24gdHVyZi5jZW50cm9pZFxuICAgICAgICBpZiAoc0FyZWEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjZW50cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBzaWduZWQgYXJlYSwgYW5kIGZhY3Rvcml6ZSAxLzZBXG4gICAgICAgICAgICB2YXIgYXJlYSA9IHNBcmVhICogMC41O1xuICAgICAgICAgICAgdmFyIGFyZWFGYWN0b3IgPSAxIC8gKDYgKiBhcmVhKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZmluYWwgY29vcmRpbmF0ZXMsIGFkZGluZyBiYWNrIHRoZSB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gbmV1dHJhbGl6ZWRcbiAgICAgICAgICAgIHJldHVybiBwb2ludChbXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25bMF0gKyBhcmVhRmFjdG9yICogc3gsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25bMV0gKyBhcmVhRmFjdG9yICogc3lcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgcG9seWdvbjogQ29tcHV0ZSB0aGUgY29udmV4IGh1bGwgYW5kIHdvcmsgd2l0aCB0aGF0XG4gICAgICAgIHZhciBodWxsID0gY29udmV4KGV4cGxvZGUoZmMpKTtcblxuICAgICAgICBpZiAoaHVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzKGh1bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSHVsbCBpcyBlbXB0eTogZmFsbGJhY2sgb24gdGhlIGNlbnRyb2lkXG4gICAgICAgICAgICByZXR1cm4gY2VudHJvaWQoZmMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNlbnRlck9mTWFzcztcbiIsInZhciBlYWNoID0gcmVxdWlyZSgnQHR1cmYvbWV0YScpLmNvb3JkRWFjaDtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2ludDtcblxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSBmZWF0dXJlcyBhbmQgY2FsY3VsYXRlcyB0aGUgY2VudHJvaWQgdXNpbmdcbiAqIHRoZSBtZWFuIG9mIGFsbCB2ZXJ0aWNlcy5cbiAqIFRoaXMgbGVzc2VucyB0aGUgZWZmZWN0IG9mIHNtYWxsIGlzbGFuZHMgYW5kIGFydGlmYWN0cyB3aGVuIGNhbGN1bGF0aW5nXG4gKiB0aGUgY2VudHJvaWQgb2YgYSBzZXQgb2YgcG9seWdvbnMuXG4gKlxuICogQG5hbWUgY2VudHJvaWRcbiAqIEBwYXJhbSB7KEZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb24pfSBmZWF0dXJlcyBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSB0aGUgY2VudHJvaWQgb2YgdGhlIGlucHV0IGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWzEwNS44MTg5MzksMjEuMDA0NzE0XSxcbiAqICAgICAgIFsxMDUuODE4OTM5LDIxLjA2MTc1NF0sXG4gKiAgICAgICBbMTA1Ljg5MDAwNywyMS4wNjE3NTRdLFxuICogICAgICAgWzEwNS44OTAwMDcsMjEuMDA0NzE0XSxcbiAqICAgICAgIFsxMDUuODE4OTM5LDIxLjAwNDcxNF1cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBjZW50cm9pZFB0ID0gdHVyZi5jZW50cm9pZChwb2x5KTtcbiAqXG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2x5LCBjZW50cm9pZFB0XVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICB2YXIgeFN1bSA9IDAsIHlTdW0gPSAwLCBsZW4gPSAwO1xuICAgIGVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICB4U3VtICs9IGNvb3JkWzBdO1xuICAgICAgICB5U3VtICs9IGNvb3JkWzFdO1xuICAgICAgICBsZW4rKztcbiAgICB9LCB0cnVlKTtcbiAgICByZXR1cm4gcG9pbnQoW3hTdW0gLyBsZW4sIHlTdW0gLyBsZW5dKTtcbn07XG4iLCJ2YXIgYmJveCA9IHJlcXVpcmUoJ0B0dXJmL2Jib3gnKSxcbiAgICBwb2ludCA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2ludDtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBGZWF0dXJlfSBvciB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGFuZCByZXR1cm5zIHRoZSBhYnNvbHV0ZSBjZW50ZXIgcG9pbnQgb2YgYWxsIGZlYXR1cmVzLlxuICpcbiAqIEBuYW1lIGNlbnRlclxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGxheWVyIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gYSBQb2ludCBmZWF0dXJlIGF0IHRoZSBhYnNvbHV0ZSBjZW50ZXIgcG9pbnQgb2YgYWxsIGlucHV0IGZlYXR1cmVzXG4gKiBAYWRkVG9NYXAgZmVhdHVyZXMsIGNlbnRlclB0XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUyMjI1OSwgMzUuNDY5MV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUwMjc1NCwgMzUuNDYzNDU1XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTA4MjY5LCAzNS40NjMyNDVdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTY4MDksIDM1LjQ2NTc3OV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxNTM3MiwgMzUuNDY3MDcyXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTA5MzYzLCAzNS40NjMwNTNdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTExMjMsIDM1LjQ2NjYwMV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxODU0NywgMzUuNDY5MzI3XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTE5NzA2LCAzNS40Njk2NTldXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTc4MzksIDM1LjQ2Njk5OF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUwODY3OCwgMzUuNDY0OTQyXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTE0OTE0LCAzNS40NjM0NTNdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBjZW50ZXJQdCA9IHR1cmYuY2VudGVyKGZlYXR1cmVzKTtcbiAqIGNlbnRlclB0LnByb3BlcnRpZXNbJ21hcmtlci1zaXplJ10gPSAnbGFyZ2UnO1xuICogY2VudGVyUHQucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnIzAwMCc7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gZmVhdHVyZXMuZmVhdHVyZXMuY29uY2F0KGNlbnRlclB0KTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICB2YXIgZXh0ID0gYmJveChsYXllcik7XG4gICAgdmFyIHggPSAoZXh0WzBdICsgZXh0WzJdKSAvIDI7XG4gICAgdmFyIHkgPSAoZXh0WzFdICsgZXh0WzNdKSAvIDI7XG4gICAgcmV0dXJuIHBvaW50KFt4LCB5XSk7XG59O1xuIiwidmFyIGRlc3RpbmF0aW9uID0gcmVxdWlyZSgnQHR1cmYvZGVzdGluYXRpb24nKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpO1xudmFyIHBvbHlnb24gPSBoZWxwZXJzLnBvbHlnb247XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBjYWxjdWxhdGVzIHRoZSBjaXJjbGUgcG9seWdvbiBnaXZlbiBhIHJhZGl1cyBpbiBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyczsgYW5kIHN0ZXBzIGZvciBwcmVjaXNpb24uXG4gKlxuICogQG5hbWUgY2lyY2xlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBjZW50ZXIgY2VudGVyIHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXBzPTY0XSBudW1iZXIgb2Ygc3RlcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gbWlsZXMsIGtpbG9tZXRlcnMsIGRlZ3JlZXMsIG9yIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBjaXJjbGUgcG9seWdvblxuICogQGV4YW1wbGVcbiAqIHZhciBjZW50ZXIgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqIHZhciByYWRpdXMgPSA1O1xuICogdmFyIHN0ZXBzID0gMTA7XG4gKiB2YXIgdW5pdHMgPSAna2lsb21ldGVycyc7XG4gKlxuICogdmFyIGNpcmNsZSA9IHR1cmYuY2lyY2xlKGNlbnRlciwgcmFkaXVzLCBzdGVwcywgdW5pdHMpO1xuICpcbiAqIC8vPWNpcmNsZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjZW50ZXIsIHJhZGl1cywgc3RlcHMsIHVuaXRzKSB7XG4gICAgc3RlcHMgPSBzdGVwcyB8fCA2NDtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICBjb29yZGluYXRlcy5wdXNoKGRlc3RpbmF0aW9uKGNlbnRlciwgcmFkaXVzLCBpICogMzYwIC8gc3RlcHMsIHVuaXRzKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgfVxuXG4gICAgY29vcmRpbmF0ZXMucHVzaChjb29yZGluYXRlc1swXSk7XG5cbiAgICByZXR1cm4gcG9seWdvbihbY29vcmRpbmF0ZXNdKTtcbn07XG4iLCJ2YXIgdHVyZmJib3ggPSByZXF1aXJlKCdAdHVyZi9iYm94Jyk7XG52YXIgaW5zaWRlID0gcmVxdWlyZSgnQHR1cmYvaW5zaWRlJyk7XG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuXG4vKipcbiAqIE1lcmdlcyBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgcG9pbnRzIGludG8gYVxuICogRmVhdHVyZUNvbGxlY3Rpb24gb2YgcG9seWdvbnMuIEdpdmVuIGFuIGBpblByb3BlcnR5YCBvbiBwb2ludHMgYW5kIGFuIGBvdXRQcm9wZXJ0eWBcbiAqIGZvciBwb2x5Z29ucywgdGhpcyBmaW5kcyBldmVyeSBwb2ludCB0aGF0IGxpZXMgd2l0aGluIGVhY2ggcG9seWdvbiwgY29sbGVjdHMgdGhlXG4gKiBgaW5Qcm9wZXJ0eWAgdmFsdWVzIGZyb20gdGhvc2UgcG9pbnRzLCBhbmQgYWRkcyB0aGVtIGFzIGFuIGFycmF5IHRvIGBvdXRQcm9wZXJ0eWBcbiAqIG9uIHRoZSBwb2x5Z29uLlxuICpcbiAqIEBuYW1lIGNvbGxlY3RcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25zIHBvbHlnb25zIHdpdGggdmFsdWVzIG9uIHdoaWNoIHRvIGFnZ3JlZ2F0ZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBwb2ludHMgdG8gYmUgYWdncmVnYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IGluUHJvcGVydHkgcHJvcGVydHkgdG8gYmUgbmVzdGVkIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nfSBvdXRQcm9wZXJ0eSBwcm9wZXJ0eSB0byBiZSBuZXN0ZWQgaW50b1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyB3aXRoIHByb3BlcnRpZXMgbGlzdGVkIGJhc2VkIG9uIGBvdXRGaWVsZGBcbiAqIEBhZGRUb01hcCBjb2xsZWN0ZWQsIHBvaW50RkNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seTEgPSB0dXJmLnBvbHlnb24oW1tbMCwwXSxbMTAsMF0sWzEwLDEwXSxbMCwxMF0sWzAsMF1dXSk7XG4gKiB2YXIgcG9seTIgPSB0dXJmLnBvbHlnb24oW1tbMTAsMF0sWzIwLDEwXSxbMjAsMjBdLFsyMCwwXSxbMTAsMF1dXSk7XG4gKiB2YXIgcG9seUZDID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbcG9seTEsIHBvbHkyXSk7XG4gKiB2YXIgcHQxID0gdHVyZi5wb2ludChbNSw1XSwge3BvcHVsYXRpb246IDIwMH0pO1xuICogdmFyIHB0MiA9IHR1cmYucG9pbnQoWzEsM10sIHtwb3B1bGF0aW9uOiA2MDB9KTtcbiAqIHZhciBwdDMgPSB0dXJmLnBvaW50KFsxNCwyXSwge3BvcHVsYXRpb246IDEwMH0pO1xuICogdmFyIHB0NCA9IHR1cmYucG9pbnQoWzEzLDFdLCB7cG9wdWxhdGlvbjogMjAwfSk7XG4gKiB2YXIgcHQ1ID0gdHVyZi5wb2ludChbMTksN10sIHtwb3B1bGF0aW9uOiAzMDB9KTtcbiAqIHZhciBwb2ludEZDID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbcHQxLCBwdDIsIHB0MywgcHQ0LCBwdDVdKTtcbiAqIHZhciBjb2xsZWN0ZWQgPSB0dXJmLmNvbGxlY3QocG9seUZDLCBwb2ludEZDLCAncG9wdWxhdGlvbicsICd2YWx1ZXMnKTtcbiAqIHZhciB2YWx1ZXMgPSBjb2xsZWN0ZWQuZmVhdHVyZXNbMF0ucHJvcGVydGllcy52YWx1ZXNcbiAqIC8vPXZhbHVlcyA9PiBbMjAwLCA2MDBdXG4gKiAvLz1wb2ludEZDXG4gKiAvLz1jb2xsZWN0ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9seWdvbnMsIHBvaW50cywgaW5Qcm9wZXJ0eSwgb3V0UHJvcGVydHkpIHtcbiAgICB2YXIgcnRyZWUgPSByYnVzaCg2KTtcblxuICAgIHZhciB0cmVlSXRlbXMgPSBwb2ludHMuZmVhdHVyZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBpdGVtLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgbWluWTogaXRlbS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgICAgIG1heFg6IGl0ZW0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgICAgICBtYXhZOiBpdGVtLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLFxuICAgICAgICAgICAgcHJvcGVydHk6IGl0ZW0ucHJvcGVydGllc1tpblByb3BlcnR5XVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcnRyZWUubG9hZCh0cmVlSXRlbXMpO1xuICAgIHBvbHlnb25zLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKHBvbHkpIHtcblxuICAgICAgICBpZiAoIXBvbHkucHJvcGVydGllcykge1xuICAgICAgICAgICAgcG9seS5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJib3ggPSB0dXJmYmJveChwb2x5KTtcbiAgICAgICAgdmFyIHBvdGVudGlhbFBvaW50cyA9IHJ0cmVlLnNlYXJjaCh7bWluWDogYmJveFswXSwgbWluWTogYmJveFsxXSwgbWF4WDogYmJveFsyXSwgbWF4WTogYmJveFszXX0pO1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIHBvdGVudGlhbFBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwdCkge1xuICAgICAgICAgICAgaWYgKGluc2lkZSh7J3R5cGUnOiAnUG9pbnQnLCAnY29vcmRpbmF0ZXMnOiBbcHQubWluWCwgcHQubWluWV19LCBwb2x5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHB0LnByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcG9seS5wcm9wZXJ0aWVzW291dFByb3BlcnR5XSA9IHZhbHVlcztcbiAgICB9KTtcblxuICAgIHJldHVybiBwb2x5Z29ucztcbn07XG4iLCIvLyAxLiBydW4gdGluIG9uIHBvaW50c1xuLy8gMi4gY2FsY3VsYXRlIGxlbnRoIG9mIGFsbCBlZGdlcyBhbmQgYXJlYSBvZiBhbGwgdHJpYW5nbGVzXG4vLyAzLiByZW1vdmUgdHJpYW5nbGVzIHRoYXQgZmFpbCB0aGUgbWF4IGxlbmd0aCB0ZXN0XG4vLyA0LiBidWZmZXIgdGhlIHJlc3VsdHMgc2xpZ2h0bHlcbi8vIDUuIG1lcmdlIHRoZSByZXN1bHRzXG52YXIgdGluID0gcmVxdWlyZSgnQHR1cmYvdGluJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCdAdHVyZi91bmlvbicpO1xudmFyIGRpc3RhbmNlID0gcmVxdWlyZSgnQHR1cmYvZGlzdGFuY2UnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiB7QGxpbmsgUG9pbnR8cG9pbnRzfSBhbmQgcmV0dXJucyBhIGNvbmNhdmUgaHVsbCBwb2x5Z29uLlxuICpcbiAqIEludGVybmFsbHksIHRoaXMgdXNlcyBbdHVyZi10aW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9UdXJmanMvdHVyZi10aW4pIHRvIGdlbmVyYXRlIGdlb21ldHJpZXMuXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhFZGdlIHRoZSBzaXplIG9mIGFuIGVkZ2UgbmVjZXNzYXJ5IGZvciBwYXJ0IG9mIHRoZVxuICogaHVsbCB0byBiZWNvbWUgY29uY2F2ZSAoaW4gbWlsZXMpXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IGEgY29uY2F2ZSBodWxsXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbWF4RWRnZSBwYXJhbWV0ZXIgaXMgbWlzc2luZyBvciB1bmFibGUgdG8gY29tcHV0ZSBodWxsXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My42MDEyMjYsIDQ0LjY0MjY0M11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjU5MTQ0MiwgNDQuNjUxNDM2XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNjMuNTgwNzk5LCA0NC42NDg3NDldXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My41NzM1ODksIDQ0LjY0MTc4OF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjU4NzY2NSwgNDQuNjQ1MzNdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My41OTUyMTgsIDQ0LjY0NzY1XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgaHVsbCA9IHR1cmYuY29uY2F2ZShwb2ludHMsIDEsICdtaWxlcycpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IHBvaW50cy5mZWF0dXJlcy5jb25jYXQoaHVsbCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5mdW5jdGlvbiBjb25jYXZlKHBvaW50cywgbWF4RWRnZSwgdW5pdHMpIHtcbiAgICBpZiAodHlwZW9mIG1heEVkZ2UgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ21heEVkZ2UgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG5cbiAgICB2YXIgdGluUG9seXMgPSB0aW4ocG9pbnRzKTtcbiAgICB2YXIgZmlsdGVyZWRQb2x5cyA9IHRpblBvbHlzLmZlYXR1cmVzLmZpbHRlcihmaWx0ZXJUcmlhbmdsZXMpO1xuICAgIHRpblBvbHlzLmZlYXR1cmVzID0gZmlsdGVyZWRQb2x5cztcbiAgICBpZiAodGluUG9seXMuZmVhdHVyZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgcG9seWdvbnMgZm91bmQgdG8gY29tcHV0ZSBjb25jYXZlIGh1bGwnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJUcmlhbmdsZXModHJpYW5nbGUpIHtcbiAgICAgICAgdmFyIHB0MSA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdO1xuICAgICAgICB2YXIgcHQyID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMV07XG4gICAgICAgIHZhciBwdDMgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsyXTtcbiAgICAgICAgdmFyIGRpc3QxID0gZGlzdGFuY2UocHQxLCBwdDIsIHVuaXRzKTtcbiAgICAgICAgdmFyIGRpc3QyID0gZGlzdGFuY2UocHQyLCBwdDMsIHVuaXRzKTtcbiAgICAgICAgdmFyIGRpc3QzID0gZGlzdGFuY2UocHQxLCBwdDMsIHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIChkaXN0MSA8PSBtYXhFZGdlICYmIGRpc3QyIDw9IG1heEVkZ2UgJiYgZGlzdDMgPD0gbWF4RWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlKHRpblBvbHlzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UocG9seWdvbnMpIHtcbiAgICB2YXIgbWVyZ2VkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwb2x5Z29ucy5mZWF0dXJlc1swXSkpLFxuICAgICAgICBmZWF0dXJlcyA9IHBvbHlnb25zLmZlYXR1cmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwb2x5ID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGlmIChwb2x5Lmdlb21ldHJ5KSB7XG4gICAgICAgICAgICBtZXJnZWQgPSB1bmlvbihtZXJnZWQsIHBvbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uY2F2ZTtcbiIsInZhciBqc3RzID0gcmVxdWlyZSgnanN0cycpO1xuXG4vKipcbiAqIFRha2VzIHR3byBvciBtb3JlIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBhbmQgcmV0dXJucyBhIGNvbWJpbmVkIHBvbHlnb24uIElmIHRoZSBpbnB1dCBwb2x5Z29ucyBhcmUgbm90IGNvbnRpZ3VvdXMsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHtAbGluayBNdWx0aVBvbHlnb259IGZlYXR1cmUuXG4gKlxuICogQG5hbWUgdW5pb25cbiAqIEBwYXJhbSB7Li4uRmVhdHVyZTxQb2x5Z29uPn0gQSBwb2x5Z29uIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPChQb2x5Z29ufE11bHRpUG9seWdvbik+fSBhIGNvbWJpbmVkIHtAbGluayBQb2x5Z29ufSBvciB7QGxpbmsgTXVsdGlQb2x5Z29ufSBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkxID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJmaWxsXCI6IFwiIzBmMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICBbLTgyLjU3NDc4NywgMzUuNTk0MDg3XSxcbiAqICAgICAgIFstODIuNTc0Nzg3LCAzNS42MTU1ODFdLFxuICogICAgICAgWy04Mi41NDUyNjEsIDM1LjYxNTU4MV0sXG4gKiAgICAgICBbLTgyLjU0NTI2MSwgMzUuNTk0MDg3XSxcbiAqICAgICAgIFstODIuNTc0Nzg3LCAzNS41OTQwODddXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2x5MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwMGZcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy04Mi41NjAwMjQsIDM1LjU4NTE1M10sXG4gKiAgICAgICBbLTgyLjU2MDAyNCwgMzUuNjAyNjAyXSxcbiAqICAgICAgIFstODIuNTI5NjQsIDM1LjYwMjYwMl0sXG4gKiAgICAgICBbLTgyLjUyOTY0LCAzNS41ODUxNTNdLFxuICogICAgICAgWy04Mi41NjAwMjQsIDM1LjU4NTE1M11cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICogdmFyIHBvbHlnb25zID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2x5MSwgcG9seTJdXG4gKiB9O1xuICpcbiAqIHZhciB1bmlvbiA9IHR1cmYudW5pb24ocG9seTEsIHBvbHkyKTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICpcbiAqIC8vPXVuaW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWFkZXIgPSBuZXcganN0cy5pby5HZW9KU09OUmVhZGVyKCk7XG4gICAgdmFyIHJlc3VsdCA9IHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50c1swXS5nZW9tZXRyeSkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnVuaW9uKHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50c1tpXS5nZW9tZXRyeSkpKTtcbiAgICB9XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IGpzdHMuaW8uR2VvSlNPTldyaXRlcigpO1xuICAgIHJlc3VsdCA9IHdyaXRlci53cml0ZShyZXN1bHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBnZW9tZXRyeTogcmVzdWx0LFxuICAgICAgICBwcm9wZXJ0aWVzOiBhcmd1bWVudHNbMF0ucHJvcGVydGllc1xuICAgIH07XG59O1xuIiwidmFyIGVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuY29vcmRFYWNoLFxuICAgIGNvbnZleEh1bGwgPSByZXF1aXJlKCdjb252ZXgtaHVsbCcpLFxuICAgIHBvbHlnb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucG9seWdvbjtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBGZWF0dXJlfSBvciBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gYW5kIHJldHVybnMgYSBjb252ZXggaHVsbCB7QGxpbmsgUG9seWdvbn0uXG4gKlxuICogSW50ZXJuYWxseSB0aGlzIHVzZXNcbiAqIHRoZSBbY29udmV4LWh1bGxdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWtvbGFseXNlbmtvL2NvbnZleC1odWxsKSBtb2R1bGUgdGhhdFxuICogaW1wbGVtZW50cyBhIFttb25vdG9uZSBjaGFpbiBodWxsXShodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9HZW9tZXRyeS9Db252ZXhfaHVsbC9Nb25vdG9uZV9jaGFpbikuXG4gKlxuICogQG5hbWUgY29udmV4XG4gKiBAcGFyYW0ge0ZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb259IGZlYXR1cmUgaW5wdXQgRmVhdHVyZSBvciBGZWF0dXJlQ29sbGVjdGlvblxuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IGEgY29udmV4IGh1bGxcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAuMTk1MzEyLCA0My43NTUyMjVdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwLjQwNDA1MiwgNDMuODQyNDUxMV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAuNTc5ODMzLCA0My42NTk5MjRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwLjM2MDEwNywgNDMuNTE2Njg4XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMC4xNDAzOCwgNDMuNTg4MzQ4XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMC4xOTUzMTIsIDQzLjc1NTIyNV1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIGh1bGwgPSB0dXJmLmNvbnZleChwb2ludHMpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IHBvaW50cy5mZWF0dXJlcy5jb25jYXQoaHVsbCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgLy8gUmVtb3ZlIFogaW4gY29vcmRpbmF0ZXMgYmVjYXVzZSBpdCBicmVha3MgdGhlIGNvbnZleEh1bGwgYWxnb3JpdGhtXG4gICAgZWFjaChmZWF0dXJlLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goW2Nvb3JkWzBdLCBjb29yZFsxXV0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGh1bGwgPSBjb252ZXhIdWxsKHBvaW50cyk7XG5cbiAgICAvLyBIdWxsIHNob3VsZCBoYXZlIGF0IGxlYXN0IDMgZGlmZmVyZW50IHZlcnRpY2VzIGluIG9yZGVyIHRvIGNyZWF0ZSBhIHZhbGlkIHBvbHlnb25cbiAgICBpZiAoaHVsbC5sZW5ndGggPj0gMykge1xuICAgICAgICB2YXIgcmluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJpbmcucHVzaChwb2ludHNbaHVsbFtpXVswXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJpbmcucHVzaChwb2ludHNbaHVsbFtodWxsLmxlbmd0aCAtIDFdWzFdXSk7XG4gICAgICAgIHJldHVybiBwb2x5Z29uKFtyaW5nXSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuIiwiLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vL2h0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG52YXIgZ2V0Q29vcmQgPSByZXF1aXJlKCdAdHVyZi9pbnZhcmlhbnQnKS5nZXRDb29yZDtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpO1xudmFyIHBvaW50ID0gaGVscGVycy5wb2ludDtcbnZhciBkaXN0YW5jZVRvUmFkaWFucyA9IGhlbHBlcnMuZGlzdGFuY2VUb1JhZGlhbnM7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBjYWxjdWxhdGVzIHRoZSBsb2NhdGlvbiBvZiBhIGRlc3RpbmF0aW9uIHBvaW50IGdpdmVuIGEgZGlzdGFuY2UgaW4gZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnM7IGFuZCBiZWFyaW5nIGluIGRlZ3JlZXMuIFRoaXMgdXNlcyB0aGUgW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKSB0byBhY2NvdW50IGZvciBnbG9iYWwgY3VydmF0dXJlLlxuICpcbiAqIEBuYW1lIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBmcm9tIHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIHJhbmdpbmcgZnJvbSAtMTgwIHRvIDE4MFxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSBtaWxlcywga2lsb21ldGVycywgZGVncmVlcywgb3IgcmFkaWFuc1xuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSBkZXN0aW5hdGlvbiBwb2ludFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwibWFya2VyLWNvbG9yXCI6IFwiIzBmMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjM0MywgMzkuOTg0XVxuICogICB9XG4gKiB9O1xuICogdmFyIGRpc3RhbmNlID0gNTA7XG4gKiB2YXIgYmVhcmluZyA9IDkwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgZGVzdGluYXRpb24gPSB0dXJmLmRlc3RpbmF0aW9uKHBvaW50LCBkaXN0YW5jZSwgYmVhcmluZywgdW5pdHMpO1xuICogZGVzdGluYXRpb24ucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnI2YwMCc7XG4gKlxuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9pbnQsIGRlc3RpbmF0aW9uXVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbSwgZGlzdGFuY2UsIGJlYXJpbmcsIHVuaXRzKSB7XG4gICAgdmFyIGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHJhZGlhbnMyZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMSA9IGdldENvb3JkKGZyb20pO1xuICAgIHZhciBsb25naXR1ZGUxID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMxWzBdO1xuICAgIHZhciBsYXRpdHVkZTEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMV07XG4gICAgdmFyIGJlYXJpbmdfcmFkID0gZGVncmVlczJyYWRpYW5zICogYmVhcmluZztcblxuICAgIHZhciByYWRpYW5zID0gZGlzdGFuY2VUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKTtcblxuICAgIHZhciBsYXRpdHVkZTIgPSBNYXRoLmFzaW4oTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguY29zKHJhZGlhbnMpICtcbiAgICAgICAgTWF0aC5jb3MobGF0aXR1ZGUxKSAqIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MoYmVhcmluZ19yYWQpKTtcbiAgICB2YXIgbG9uZ2l0dWRlMiA9IGxvbmdpdHVkZTEgKyBNYXRoLmF0YW4yKE1hdGguc2luKGJlYXJpbmdfcmFkKSAqXG4gICAgICAgIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MobGF0aXR1ZGUxKSxcbiAgICAgICAgTWF0aC5jb3MocmFkaWFucykgLSBNYXRoLnNpbihsYXRpdHVkZTEpICogTWF0aC5zaW4obGF0aXR1ZGUyKSk7XG5cbiAgICByZXR1cm4gcG9pbnQoW3JhZGlhbnMyZGVncmVlcyAqIGxvbmdpdHVkZTIsIHJhZGlhbnMyZGVncmVlcyAqIGxhdGl0dWRlMl0pO1xufTtcbiIsIi8vIGRlcGVuZCBvbiBqc3RzIGZvciBub3cgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9leGFtcGxlcy9vdmVybGF5Lmh0bWxcbnZhciBqc3RzID0gcmVxdWlyZSgnanN0cycpO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBieSBjbGlwcGluZyB0aGUgc2Vjb25kXG4gKiBwb2x5Z29uIGZyb20gdGhlIGZpcnN0LlxuICpcbiAqIEBuYW1lIGRpZmZlcmVuY2VcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcDEgaW5wdXQgUG9seWdvbiBmZWF0dXJlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHAyIFBvbHlnb24gZmVhdHVyZSB0byBkaWZmZXJlbmNlIGZyb20gYHAxYFxuICogQHJldHVybiB7RmVhdHVyZTwoUG9seWdvbnxNdWx0aVBvbHlnb24pPn0gYSBQb2x5Z29uIG9yIE11bHRpUG9seWdvbiBmZWF0dXJlIHNob3dpbmcgdGhlIGFyZWEgb2YgYHAxYCBleGNsdWRpbmcgdGhlIGFyZWEgb2YgYHAyYFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5MSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwZjBcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy00Ni43Mzg1ODYsIC0yMy41OTY3MTFdLFxuICogICAgICAgWy00Ni43Mzg1ODYsIC0yMy40NTgyMDddLFxuICogICAgICAgWy00Ni41NjAwNTgsIC0yMy40NTgyMDddLFxuICogICAgICAgWy00Ni41NjAwNTgsIC0yMy41OTY3MTFdLFxuICogICAgICAgWy00Ni43Mzg1ODYsIC0yMy41OTY3MTFdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2x5MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwMGZcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy00Ni42NTAwMDksIC0yMy42MzEzMTRdLFxuICogICAgICAgWy00Ni42NTAwMDksIC0yMy41MjM3XSxcbiAqICAgICAgIFstNDYuNTA5MjQ2LCAtMjMuNTIzN10sXG4gKiAgICAgICBbLTQ2LjUwOTI0NiwgLTIzLjYzMTMxNF0sXG4gKiAgICAgICBbLTQ2LjY1MDAwOSwgLTIzLjYzMTMxNF1cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBkaWZmZXJlbmNlZCA9IHR1cmYuZGlmZmVyZW5jZShwb2x5MSwgcG9seTIpO1xuICogZGlmZmVyZW5jZWQucHJvcGVydGllcy5maWxsID0gJyNmMDAnO1xuICpcbiAqIHZhciBwb2x5Z29ucyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9seTEsIHBvbHkyXVxuICogfTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICpcbiAqIC8vPWRpZmZlcmVuY2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgdmFyIHBvbHkxID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwMSkpO1xuICAgIHZhciBwb2x5MiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocDIpKTtcbiAgICBpZiAocG9seTEudHlwZSAhPT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIHBvbHkxID0ge1xuICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgICBnZW9tZXRyeTogcG9seTFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHBvbHkyLnR5cGUgIT09ICdGZWF0dXJlJykge1xuICAgICAgICBwb2x5MiA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHBvbHkyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgYSA9IHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KHBvbHkxLmdlb21ldHJ5KSk7XG4gICAgdmFyIGIgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShwb2x5Mi5nZW9tZXRyeSkpO1xuICAgIHZhciBkaWZmZXJlbmNlZCA9IGEuZGlmZmVyZW5jZShiKTtcblxuICAgIGlmIChkaWZmZXJlbmNlZC5pc0VtcHR5KCkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IGpzdHMuaW8uR2VvSlNPTldyaXRlcigpO1xuICAgIHZhciBnZW9qc29uR2VvbWV0cnkgPSB3cml0ZXIud3JpdGUoZGlmZmVyZW5jZWQpO1xuXG4gICAgcG9seTEuZ2VvbWV0cnkgPSBkaWZmZXJlbmNlZDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogcG9seTEucHJvcGVydGllcyxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb2pzb25HZW9tZXRyeVxuICAgIH07XG59O1xuIiwidmFyIHR1cmZVbmlvbiA9IHJlcXVpcmUoJ0B0dXJmL3VuaW9uJyk7XG52YXIgdHVyZk92ZXJsYXBzID0gcmVxdWlyZSgndHVyZi1vdmVybGFwcycpO1xudmFyIHR1cmZiYm94ID0gcmVxdWlyZSgnQHR1cmYvYmJveCcpO1xudmFyIFJidXNoID0gcmVxdWlyZSgncmJ1c2gnKTtcbnZhciBnanUgPSByZXF1aXJlKCdnZW9qc29uLXV0aWxzJyk7XG52YXIgZ2V0Q2xvc2VzdCA9IHJlcXVpcmUoJ2dldC1jbG9zZXN0Jyk7XG5cbi8qKlxuICogRGlzc29sdmVzIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgcG9seWdvbnMgYmFzZWQgb24gYSBwcm9wZXJ0eS4gTm90ZSB0aGF0IG11bHRpcGFydCBmZWF0dXJlcyB3aXRoaW4gdGhlIGNvbGxlY3Rpb24gYXJlIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAbmFtZSBkaXNzb2x2ZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gZmVhdHVyZUNvbGxlY3Rpb24gaW5wdXQgZmVhdHVyZSBjb2xsZWN0aW9uIHRvIGJlIGRpc3NvbHZlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eU5hbWVdIHByb3BlcnR5IG5hbWUgb24gd2hpY2ggdG8gZGlzc29sdmUgZmVhdHVyZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gYSBGZWF0dXJlQ29sbGVjdGlvbiBjb250YWluaW5nIHRoZSBkaXNzb2x2ZWQgcG9seWdvbnNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogXCJmZWF0dXJlc1wiOiBbXG4gKiAgIHtcbiAqICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICAgIFwiY29tYmluZVwiOiBcInllc1wiXG4gKiAgICAgfSxcbiAqICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tbMCwgMF0sIFswLCAxXSwgWzEsIDFdLCBbMSwgMF0sIFswLCAwXV1dXG4gKiAgICAgfVxuICogICB9LFxuICogICB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgICBcImNvbWJpbmVcIjogXCJ5ZXNcIlxuICogICAgIH0sXG4gKiAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgICBcImNvb3JkaW5hdGVzXCI6IFtbWzAsIC0xXSwgWzAsIDBdLCBbMSwgMF0sIFsxLCAtMV0sIFswLC0xXV1dXG4gKiAgICAgfVxuICogICB9LFxuICogICB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgICBcImNvbWJpbmVcIjogXCJub1wiXG4gKiAgICAgfSxcbiAqICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tbMSwtMV0sWzEsIDBdLCBbMiwgMF0sIFsyLCAtMV0sIFsxLCAtMV1dXVxuICogICAgIH1cbiAqICAgfVxuICogIF1cbiAqIH1cbiAqXG4gKiB2YXIgZGlzc29sdmVkID0gdHVyZi5kaXNzb2x2ZShmZWF0dXJlcywgJ2NvbWJpbmUnKTtcbiAqXG4gKiAvLz1kaXNzb2x2ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZUNvbGxlY3Rpb24sIHByb3BlcnR5TmFtZSkge1xuXG4gICAgdmFyIG9yaWdpbmFsSW5kZXhPZkl0ZW1zUmVtb3ZlZCA9IFtdO1xuICAgIHZhciB0cmVlSXRlbXMgPSBbXTtcbiAgICB2YXIgcnRyZWUgPSBuZXcgUmJ1c2goKTtcbiAgICBmb3IgKHZhciBwb2x5SW5kZXggPSAwOyBwb2x5SW5kZXggPCBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5sZW5ndGg7IHBvbHlJbmRleCsrKSB7XG4gICAgICAgIHZhciBpbnB1dEZlYXR1cmVCYm94ID0gdHVyZmJib3goZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbcG9seUluZGV4XSk7XG4gICAgICAgIHZhciB0cmVlT2JqID0ge1xuICAgICAgICAgICAgbWluWDogaW5wdXRGZWF0dXJlQmJveFswXSxcbiAgICAgICAgICAgIG1pblk6IGlucHV0RmVhdHVyZUJib3hbMV0sXG4gICAgICAgICAgICBtYXhYOiBpbnB1dEZlYXR1cmVCYm94WzJdLFxuICAgICAgICAgICAgbWF4WTogaW5wdXRGZWF0dXJlQmJveFszXSxcbiAgICAgICAgICAgIG9yaWdJbmRleFBvc2l0aW9uOiBwb2x5SW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZUl0ZW1zLnB1c2godHJlZU9iaik7XG4gICAgfVxuICAgIHJ0cmVlLmxvYWQodHJlZUl0ZW1zKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1tpXTtcblxuICAgICAgICB2YXIgcG9seUJvdW5kaW5nQm94ID0gdHVyZmJib3gocG9seWdvbik7XG4gICAgICAgIHZhciBzZWFyY2hPYmogPSB7XG4gICAgICAgICAgICBtaW5YOiBwb2x5Qm91bmRpbmdCb3hbMF0sXG4gICAgICAgICAgICBtaW5ZOiBwb2x5Qm91bmRpbmdCb3hbMV0sXG4gICAgICAgICAgICBtYXhYOiBwb2x5Qm91bmRpbmdCb3hbMl0sXG4gICAgICAgICAgICBtYXhZOiBwb2x5Qm91bmRpbmdCb3hbM11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvdGVudGlhbE1hdGNoaW5nRmVhdHVyZXMgPSBydHJlZS5zZWFyY2goc2VhcmNoT2JqKTtcblxuICAgICAgICB2YXIgZmVhdHVyZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBzZWFyY2hJbmRleCA9IDA7IHNlYXJjaEluZGV4IDwgcG90ZW50aWFsTWF0Y2hpbmdGZWF0dXJlcy5sZW5ndGg7IHNlYXJjaEluZGV4KyspIHtcbiAgICAgICAgICAgIHBvbHlnb24gPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1tpXTtcblxuICAgICAgICAgICAgdmFyIG1hdGNoRmVhdHVyZVBvc2l0aW9uID0gcG90ZW50aWFsTWF0Y2hpbmdGZWF0dXJlc1tzZWFyY2hJbmRleF0ub3JpZ0luZGV4UG9zaXRpb247XG5cbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4T2ZJdGVtc1JlbW92ZWQubGVuZ3RoID4gMCAmJiBtYXRjaEZlYXR1cmVQb3NpdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaEZlYXR1cmVQb3NpdGlvbiA+IG9yaWdpbmFsSW5kZXhPZkl0ZW1zUmVtb3ZlZFtvcmlnaW5hbEluZGV4T2ZJdGVtc1JlbW92ZWQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGZWF0dXJlUG9zaXRpb24gPSBtYXRjaEZlYXR1cmVQb3NpdGlvbiAtIChvcmlnaW5hbEluZGV4T2ZJdGVtc1JlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VzdE51bWJlciA9IGdldENsb3Nlc3QuZ3JlYXRlck51bWJlcihtYXRjaEZlYXR1cmVQb3NpdGlvbiwgb3JpZ2luYWxJbmRleE9mSXRlbXNSZW1vdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3ROdW1iZXIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmVhdHVyZVBvc2l0aW9uID0gbWF0Y2hGZWF0dXJlUG9zaXRpb24gLSBjbG9zZXN0TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hGZWF0dXJlUG9zaXRpb24gPT09IGkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXRjaEZlYXR1cmUgPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1ttYXRjaEZlYXR1cmVQb3NpdGlvbl07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hGZWF0dXJlLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSAhPT0gcG9seWdvbi5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcENoZWNrID0gdHVyZk92ZXJsYXBzKHBvbHlnb24sIG1hdGNoRmVhdHVyZSk7XG5cbiAgICAgICAgICAgIGlmICghb3ZlcmxhcENoZWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHlDbG9uZSA9IEpTT04uc3RyaW5naWZ5KHBvbHlnb24pO1xuICAgICAgICAgICAgICAgIHZhciBwb2x5QmVpbmdDaGVja2VkQ2xvbmUgPSBKU09OLnN0cmluZ2lmeShtYXRjaEZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lc3RyaW5nMSA9IHRvTGluZXN0cmluZyhKU09OLnBhcnNlKHBvbHlDbG9uZSkpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lc3RyaW5nMiA9IHRvTGluZXN0cmluZyhKU09OLnBhcnNlKHBvbHlCZWluZ0NoZWNrZWRDbG9uZSkpO1xuICAgICAgICAgICAgICAgIG92ZXJsYXBDaGVjayA9IGdqdS5saW5lU3RyaW5nc0ludGVyc2VjdChsaW5lc3RyaW5nMS5nZW9tZXRyeSwgbGluZXN0cmluZzIuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvdmVybGFwQ2hlY2spIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbaV0gPSB0dXJmVW5pb24ocG9seWdvbiwgbWF0Y2hGZWF0dXJlKTtcbiAgICAgICAgICAgIG9yaWdpbmFsSW5kZXhPZkl0ZW1zUmVtb3ZlZC5wdXNoKHBvdGVudGlhbE1hdGNoaW5nRmVhdHVyZXNbc2VhcmNoSW5kZXhdLm9yaWdJbmRleFBvc2l0aW9uKTtcbiAgICAgICAgICAgIG9yaWdpbmFsSW5kZXhPZkl0ZW1zUmVtb3ZlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJ0cmVlLnJlbW92ZShwb3RlbnRpYWxNYXRjaGluZ0ZlYXR1cmVzW3NlYXJjaEluZGV4XSk7XG4gICAgICAgICAgICBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5zcGxpY2UobWF0Y2hGZWF0dXJlUG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgc2VhcmNoT2JqLm9yaWdJbmRleFBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIHJ0cmVlLnJlbW92ZShzZWFyY2hPYmosIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEub3JpZ0luZGV4UG9zaXRpb24gPT09IGIub3JpZ0luZGV4UG9zaXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZlYXR1cmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVhdHVyZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBuZXdCb3VuZGluZ0JveCA9IHR1cmZiYm94KHBvbHlnb24pO1xuICAgICAgICAgICAgcnRyZWUuaW5zZXJ0KHtcbiAgICAgICAgICAgICAgICBtaW5YOiBuZXdCb3VuZGluZ0JveFswXSxcbiAgICAgICAgICAgICAgICBtaW5ZOiBuZXdCb3VuZGluZ0JveFsxXSxcbiAgICAgICAgICAgICAgICBtYXhYOiBuZXdCb3VuZGluZ0JveFsyXSxcbiAgICAgICAgICAgICAgICBtYXhZOiBuZXdCb3VuZGluZ0JveFszXSxcbiAgICAgICAgICAgICAgICBvcmlnSW5kZXhQb3NpdGlvbjogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uO1xufTtcblxuZnVuY3Rpb24gdG9MaW5lc3RyaW5nKHBvbHlnb24pIHtcbiAgICBpZiAocG9seWdvbiA9PT0gbnVsbCB8fCBwb2x5Z29uID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignTm8gcG9seWdvbiB3YXMgcGFzc2VkJyk7XG4gICAgcG9seWdvbi5nZW9tZXRyeS50eXBlID0gJ0xpbmVTdHJpbmcnO1xuICAgIHZhciBmbGF0X2FyciA9IFtdLmNvbmNhdC5hcHBseShbXSwgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGZsYXRfYXJyO1xuICAgIHJldHVybiBwb2x5Z29uO1xufVxuIiwidmFyIGdldENvb3JkID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50JykuZ2V0Q29vcmQ7XG52YXIgcmFkaWFuc1RvRGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucmFkaWFuc1RvRGlzdGFuY2U7XG4vL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbi8vaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB7QGxpbmsgUG9pbnR8cG9pbnRzfSBpbiBkZWdyZWVzLCByYWRpYW5zLFxuICogbWlsZXMsIG9yIGtpbG9tZXRlcnMuIFRoaXMgdXNlcyB0aGVcbiAqIFtIYXZlcnNpbmUgZm9ybXVsYV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYSlcbiAqIHRvIGFjY291bnQgZm9yIGdsb2JhbCBjdXJ2YXR1cmUuXG4gKlxuICogQG5hbWUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IGZyb20gb3JpZ2luIHBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSB0byBkZXN0aW5hdGlvbiBwb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwb2ludHNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZnJvbSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjM0MywgMzkuOTg0XVxuICogICB9XG4gKiB9O1xuICogdmFyIHRvID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuNTM0LCAzOS4xMjNdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgdW5pdHMgPSBcIm1pbGVzXCI7XG4gKlxuICogdmFyIHBvaW50cyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbZnJvbSwgdG9dXG4gKiB9O1xuICpcbiAqIC8vPXBvaW50c1xuICpcbiAqIHZhciBkaXN0YW5jZSA9IHR1cmYuZGlzdGFuY2UoZnJvbSwgdG8sIHVuaXRzKTtcbiAqXG4gKiAvLz1kaXN0YW5jZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmcm9tLCB0bywgdW5pdHMpIHtcbiAgICB2YXIgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgY29vcmRpbmF0ZXMxID0gZ2V0Q29vcmQoZnJvbSk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMiA9IGdldENvb3JkKHRvKTtcbiAgICB2YXIgZExhdCA9IGRlZ3JlZXMycmFkaWFucyAqIChjb29yZGluYXRlczJbMV0gLSBjb29yZGluYXRlczFbMV0pO1xuICAgIHZhciBkTG9uID0gZGVncmVlczJyYWRpYW5zICogKGNvb3JkaW5hdGVzMlswXSAtIGNvb3JkaW5hdGVzMVswXSk7XG4gICAgdmFyIGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMV07XG4gICAgdmFyIGxhdDIgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczJbMV07XG5cbiAgICB2YXIgYSA9IE1hdGgucG93KE1hdGguc2luKGRMYXQgLyAyKSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KE1hdGguc2luKGRMb24gLyAyKSwgMikgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xuXG4gICAgcmV0dXJuIHJhZGlhbnNUb0Rpc3RhbmNlKDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSksIHVuaXRzKTtcbn07XG4iLCJ2YXIgYmJveCA9IHJlcXVpcmUoJ0B0dXJmL2Jib3gnKTtcbnZhciBiYm94UG9seWdvbiA9IHJlcXVpcmUoJ0B0dXJmL2Jib3gtcG9seWdvbicpO1xuXG4vKipcbiAqIFRha2VzIGFueSBudW1iZXIgb2YgZmVhdHVyZXMgYW5kIHJldHVybnMgYSByZWN0YW5ndWxhciB7QGxpbmsgUG9seWdvbn0gdGhhdCBlbmNvbXBhc3NlcyBhbGwgdmVydGljZXMuXG4gKlxuICogQG5hbWUgZW52ZWxvcGVcbiAqIEBwYXJhbSB7KEZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb24pfSBmZWF0dXJlcyBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybiB7RmVhdHVyZTxQb2x5Z29uPn0gYSByZWN0YW5ndWxhciBQb2x5Z29uIGZlYXR1cmUgdGhhdCBlbmNvbXBhc3NlcyBhbGwgdmVydGljZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgICAgIFwibmFtZVwiOiBcIkxvY2F0aW9uIEFcIlxuICogICAgICAgfSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuMzQzLCAzOS45ODRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICAgICAgXCJuYW1lXCI6IFwiTG9jYXRpb24gQlwiXG4gKiAgICAgICB9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NS44MzMsIDM5LjI4NF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICogICAgICAgICBcIm5hbWVcIjogXCJMb2NhdGlvbiBDXCJcbiAqICAgICAgIH0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjUzNCwgMzkuMTIzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgZW52ZWxvcGVkID0gdHVyZi5lbnZlbG9wZShmYyk7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gZmMuZmVhdHVyZXMuY29uY2F0KGVudmVsb3BlZCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIGJib3hQb2x5Z29uKGJib3goZmVhdHVyZXMpKTtcbn07XG4iLCJ2YXIgcG9seWdvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2x5Z29uO1xuXG4vKipcbiAqIFRha2VzIGEgYmJveCBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50IHtAbGluayBQb2x5Z29ufHBvbHlnb259LlxuICpcbiAqIEBuYW1lIGJib3hQb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQHJldHVybiB7RmVhdHVyZTxQb2x5Z29uPn0gYSBQb2x5Z29uIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBib3VuZGluZyBib3hcbiAqIEBhZGRUb01hcCBwb2x5XG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBbMCwgMCwgMTAsIDEwXTtcbiAqXG4gKiB2YXIgcG9seSA9IHR1cmYuYmJveFBvbHlnb24oYmJveCk7XG4gKlxuICogLy89cG9seVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICB2YXIgbG93TGVmdCA9IFtiYm94WzBdLCBiYm94WzFdXTtcbiAgICB2YXIgdG9wTGVmdCA9IFtiYm94WzBdLCBiYm94WzNdXTtcbiAgICB2YXIgdG9wUmlnaHQgPSBbYmJveFsyXSwgYmJveFszXV07XG4gICAgdmFyIGxvd1JpZ2h0ID0gW2Jib3hbMl0sIGJib3hbMV1dO1xuXG4gICAgcmV0dXJuIHBvbHlnb24oW1tcbiAgICAgICAgbG93TGVmdCxcbiAgICAgICAgbG93UmlnaHQsXG4gICAgICAgIHRvcFJpZ2h0LFxuICAgICAgICB0b3BMZWZ0LFxuICAgICAgICBsb3dMZWZ0XG4gICAgXV0pO1xufTtcbiIsInZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBmZWF0dXJlRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5mZWF0dXJlRWFjaDtcbnZhciBjb29yZEVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuY29vcmRFYWNoO1xudmFyIHBvaW50ID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIGEgZmVhdHVyZSBvciBzZXQgb2YgZmVhdHVyZXMgYW5kIHJldHVybnMgYWxsIHBvc2l0aW9ucyBhc1xuICoge0BsaW5rIFBvaW50fHBvaW50c30uXG4gKlxuICogQG5hbWUgZXhwbG9kZVxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGdlb2pzb24gaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxwb2ludD59IHBvaW50cyByZXByZXNlbnRpbmcgdGhlIGV4cGxvZGVkIGlucHV0IGZlYXR1cmVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgZW5jb3VudGVycyBhbiB1bmtub3duIGdlb21ldHJ5IHR5cGVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICBbMTc3LjQzNDY5MiwgLTE3Ljc3NTE3XSxcbiAqICAgICAgIFsxNzcuNDAyMDc2LCAtMTcuNzc5MDkzXSxcbiAqICAgICAgIFsxNzcuMzgwNzksIC0xNy44MDM5MzddLFxuICogICAgICAgWzE3Ny40MDI0MiwgLTE3LjgyNjE2NF0sXG4gKiAgICAgICBbMTc3LjQzODQ2OCwgLTE3LjgyNDg1N10sXG4gKiAgICAgICBbMTc3LjQ1NDk0OCwgLTE3Ljc5Njc0Nl0sXG4gKiAgICAgICBbMTc3LjQzNDY5MiwgLTE3Ljc3NTE3XVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIHBvaW50cyA9IHR1cmYuZXhwbG9kZShwb2x5KTtcbiAqXG4gKiAvLz1wb2x5XG4gKlxuICogLy89cG9pbnRzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGdlb2pzb24pIHtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgY29vcmRFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KGNvb3JkLCBmZWF0dXJlLnByb3BlcnRpZXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludChjb29yZCwgZ2VvanNvbi5wcm9wZXJ0aWVzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24ocG9pbnRzKTtcbn07XG4iLCJ2YXIgZmVhdHVyZUVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuZmVhdHVyZUVhY2g7XG52YXIgZ2VvbUVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuZ2VvbUVhY2g7XG52YXIgZ2V0Q29vcmRzID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50JykuZ2V0Q29vcmRzO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJyk7XG52YXIgcG9pbnQgPSBoZWxwZXJzLnBvaW50O1xudmFyIGxpbmVTdHJpbmcgPSBoZWxwZXJzLmxpbmVTdHJpbmc7XG52YXIgcG9seWdvbiA9IGhlbHBlcnMucG9seWdvbjtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb247XG5cbi8qKlxuICogRmxhdHRlbnMgYW55IHtAbGluayBHZW9KU09OfSB0byBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gaW5zcGlyZWQgYnkgW2dlb2pzb24tZmxhdHRlbl0oaHR0cHM6Ly9naXRodWIuY29tL3RtY3cvZ2VvanNvbi1mbGF0dGVuKS5cbiAqXG4gKiBAbmFtZSBmbGF0dGVuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGdlb2pzb24gYW55IHZhbGlkIHtAbGluayBHZW9KU09OfSB3aXRoIG11bHRpLWdlb21ldHJ5IHtAbGluayBGZWF0dXJlfXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gYSBmbGF0dGVuZWQge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufVxuICogQGV4YW1wbGVcbiAqIHZhciBnZW9tZXRyeSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiTXVsdGlQb2x5Z29uXCIsXG4gKiAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgIFtbWzEwMi4wLCAyLjBdLCBbMTAzLjAsIDIuMF0sIFsxMDMuMCwgMy4wXSwgWzEwMi4wLCAzLjBdLCBbMTAyLjAsIDIuMF1dXSxcbiAqICAgICAgW1tbMTAwLjAsIDAuMF0sIFsxMDEuMCwgMC4wXSwgWzEwMS4wLCAxLjBdLCBbMTAwLjAsIDEuMF0sIFsxMDAuMCwgMC4wXV0sXG4gKiAgICAgIFtbMTAwLjIsIDAuMl0sIFsxMDAuOCwgMC4yXSwgWzEwMC44LCAwLjhdLCBbMTAwLjIsIDAuOF0sIFsxMDAuMiwgMC4yXV1dXG4gKiAgICBdXG4gKiAgfTtcbiAqXG4gKiB2YXIgZmxhdHRlbmVkID0gdHVyZi5mbGF0dGVuKGdlb21ldHJ5KTtcbiAqXG4gKiAvLz1mbGF0dGVuZWRcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihnZW9qc29uKSB7XG4gICAgdmFyIHR5cGUgPSAoZ2VvanNvbi5nZW9tZXRyeSkgPyBnZW9qc29uLmdlb21ldHJ5LnR5cGUgOiBnZW9qc29uLnR5cGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIHJldHVybiBmbGF0dGVuTXVsdGlQb2ludChnZW9qc29uKTtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICByZXR1cm4gZmxhdHRlbk11bHRpUG9seWdvbihnZW9qc29uKTtcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICByZXR1cm4gZmxhdHRlbk11bHRpTGluZVN0cmluZyhnZW9qc29uKTtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgIHJldHVybiBmbGF0dGVuRmVhdHVyZUNvbGxlY3Rpb24oZ2VvanNvbik7XG4gICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5HZW9tZXRyeUNvbGxlY3Rpb24oZ2VvanNvbik7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2pzb25dKTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG5cbi8qKlxuICogRmxhdHRlbiBNdWx0aVBvaW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxNdWx0aVBvaW50Pn0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IEZlYXR1cmUgQ29sbGVjdGlvblxuICovXG5mdW5jdGlvbiBmbGF0dGVuTXVsdGlQb2ludChnZW9qc29uKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGdldENvb3JkcyhnZW9qc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQoY29vcmRzLCBnZW9qc29uLnByb3BlcnRpZXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24ocG9pbnRzKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIE11bHRpTGluZVN0cmluZ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gRmVhdHVyZSBDb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5NdWx0aUxpbmVTdHJpbmcoZ2VvanNvbikge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGdldENvb3JkcyhnZW9qc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgbGluZXMucHVzaChsaW5lU3RyaW5nKGNvb3JkcywgZ2VvanNvbi5wcm9wZXJ0aWVzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGxpbmVzKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIE11bHRpUG9seWdvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gRmVhdHVyZSBDb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5NdWx0aVBvbHlnb24oZ2VvanNvbikge1xuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIGdldENvb3JkcyhnZW9qc29uKS5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKGNvb3JkcywgZ2VvanNvbi5wcm9wZXJ0aWVzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKHBvbHlnb25zKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIEZlYXR1cmVDb2xsZWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248YW55Pn0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxhbnk+fSBGZWF0dXJlIENvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkZlYXR1cmVDb2xsZWN0aW9uKGdlb2pzb24pIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAobXVsdGlGZWF0dXJlKSB7XG4gICAgICAgIHN3aXRjaCAobXVsdGlGZWF0dXJlLmdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICBmZWF0dXJlRWFjaChmbGF0dGVuKG11bHRpRmVhdHVyZSksIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKG11bHRpRmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gR2VvbWV0cnlDb2xsZWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7R2VvbWV0cnlDb2xsZWN0aW9uPGFueT59IGdlb2pzb24gR2VvSlNPTiBHZW9tZXRyeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0geyp9IFtwcm9wZXJ0aWVzXSB0cmFuc2xhdGUgcHJvcGVydGllcyB0byBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248YW55Pn0gRmVhdHVyZSBDb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5HZW9tZXRyeUNvbGxlY3Rpb24oZ2VvanNvbikge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICBmZWF0dXJlRWFjaChmbGF0dGVuKGdlb21ldHJ5KSwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbn1cbiIsInZhciBjb29yZEVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuY29vcmRFYWNoO1xuXG4vKipcbiAqIFRha2VzIGlucHV0IGZlYXR1cmVzIGFuZCBmbGlwcyBhbGwgb2YgdGhlaXIgY29vcmRpbmF0ZXNcbiAqIGZyb20gYFt4LCB5XWAgdG8gYFt5LCB4XWAuXG4gKlxuICogQG5hbWUgZmxpcFxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGlucHV0IGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJucyB7KEZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb24pfSBhIGZlYXR1cmUgb3Igc2V0IG9mIGZlYXR1cmVzIG9mIHRoZSBzYW1lIHR5cGUgYXMgYGlucHV0YCB3aXRoIGZsaXBwZWQgY29vcmRpbmF0ZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgc2VyYmlhID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsyMC41NjY0MDYsIDQzLjQyMTAwOF1cbiAqICAgfVxuICogfTtcbiAqXG4gKiAvLz1zZXJiaWFcbiAqXG4gKiB2YXIgc2F1ZGlBcmFiaWEgPSB0dXJmLmZsaXAoc2VyYmlhKTtcbiAqXG4gKiAvLz1zYXVkaUFyYWJpYVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsaXAoaW5wdXQpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCB3ZSBkb24ndCBtb2RpZnkgZmVhdHVyZXMgaW4tcGxhY2UgYW5kIGNoYW5nZXMgdG8gdGhlXG4gICAgLy8gb3V0cHV0IGRvIG5vdCBjaGFuZ2UgdGhlIHByZXZpb3VzIGZlYXR1cmUsIGluY2x1ZGluZyBjaGFuZ2VzIHRvIG5lc3RlZFxuICAgIC8vIHByb3BlcnRpZXMuXG4gICAgaW5wdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0KSk7XG5cbiAgICBjb29yZEVhY2goaW5wdXQsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBjb29yZC5yZXZlcnNlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEQyUiA9IE1hdGguUEkgLyAxODA7XG52YXIgUjJEID0gMTgwIC8gTWF0aC5QSTtcblxudmFyIENvb3JkID0gZnVuY3Rpb24gKGxvbiwgbGF0KSB7XG4gICAgdGhpcy5sb24gPSBsb247XG4gICAgdGhpcy5sYXQgPSBsYXQ7XG4gICAgdGhpcy54ID0gRDJSICogbG9uO1xuICAgIHRoaXMueSA9IEQyUiAqIGxhdDtcbn07XG5cbkNvb3JkLnByb3RvdHlwZS52aWV3ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5sb24pLnNsaWNlKDAsIDQpICsgJywnICsgU3RyaW5nKHRoaXMubGF0KS5zbGljZSgwLCA0KTtcbn07XG5cbkNvb3JkLnByb3RvdHlwZS5hbnRpcG9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW50aV9sYXQgPSAtMSAqIHRoaXMubGF0O1xuICAgIHZhciBhbnRpX2xvbiA9ICh0aGlzLmxvbiA8IDApID8gMTgwICsgdGhpcy5sb24gOiAoMTgwIC0gdGhpcy5sb24pICogLTE7XG4gICAgcmV0dXJuIG5ldyBDb29yZChhbnRpX2xvbiwgYW50aV9sYXQpO1xufTtcblxudmFyIExpbmVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb29yZHMgPSBbXTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5tb3ZlX3RvID0gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLmNvb3Jkcy5wdXNoKGNvb3JkKTtcbn07XG5cbnZhciBBcmMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgdGhpcy5nZW9tZXRyaWVzID0gW107XG59O1xuXG5BcmMucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4geydnZW9tZXRyeSc6IHsndHlwZSc6ICdMaW5lU3RyaW5nJywgJ2Nvb3JkaW5hdGVzJzogbnVsbH0sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnRmVhdHVyZScsICdwcm9wZXJ0aWVzJzogdGhpcy5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geydnZW9tZXRyeSc6IHsndHlwZSc6ICdMaW5lU3RyaW5nJywgJ2Nvb3JkaW5hdGVzJzogdGhpcy5nZW9tZXRyaWVzWzBdLmNvb3Jkc30sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnRmVhdHVyZScsICdwcm9wZXJ0aWVzJzogdGhpcy5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtdWx0aWxpbmUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG11bHRpbGluZS5wdXNoKHRoaXMuZ2VvbWV0cmllc1tpXS5jb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7J2dlb21ldHJ5Jzogeyd0eXBlJzogJ011bHRpTGluZVN0cmluZycsICdjb29yZGluYXRlcyc6IG11bHRpbGluZX0sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnRmVhdHVyZScsICdwcm9wZXJ0aWVzJzogdGhpcy5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8vIFRPRE8gLSBvdXRwdXQgcHJvcGVyIG11bHRpbGluZXN0cmluZ1xuQXJjLnByb3RvdHlwZS53a3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdrdF9zdHJpbmcgPSAnJztcbiAgICB2YXIgd2t0ID0gJ0xJTkVTVFJJTkcoJztcbiAgICB2YXIgY29sbGVjdCA9IGZ1bmN0aW9uIChjKSB7IHdrdCArPSBjWzBdICsgJyAnICsgY1sxXSArICcsJzsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5nZW9tZXRyaWVzW2ldLmNvb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnTElORVNUUklORyhlbXB0eSknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2VvbWV0cmllc1tpXS5jb29yZHM7XG4gICAgICAgICAgICBjb29yZHMuZm9yRWFjaChjb2xsZWN0KTtcbiAgICAgICAgICAgIHdrdF9zdHJpbmcgKz0gd2t0LnN1YnN0cmluZygwLCB3a3QubGVuZ3RoIC0gMSkgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdrdF9zdHJpbmc7XG59O1xuXG4vKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmVhdC1jaXJjbGVfZGlzdGFuY2VcbiAqXG4gKi9cbnZhciBHcmVhdENpcmNsZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFzdGFydCB8fCBzdGFydC54ID09PSB1bmRlZmluZWQgfHwgc3RhcnQueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR3JlYXRDaXJjbGUgY29uc3RydWN0b3IgZXhwZWN0cyB0d28gYXJnczogc3RhcnQgYW5kIGVuZCBvYmplY3RzIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzJyk7XG4gICAgfVxuICAgIGlmICghZW5kIHx8IGVuZC54ID09PSB1bmRlZmluZWQgfHwgZW5kLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyZWF0Q2lyY2xlIGNvbnN0cnVjdG9yIGV4cGVjdHMgdHdvIGFyZ3M6IHN0YXJ0IGFuZCBlbmQgb2JqZWN0cyB3aXRoIHggYW5kIHkgcHJvcGVydGllcycpO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0ID0gbmV3IENvb3JkKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgIHRoaXMuZW5kID0gbmV3IENvb3JkKGVuZC54LCBlbmQueSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcblxuICAgIHZhciB3ID0gdGhpcy5zdGFydC54IC0gdGhpcy5lbmQueDtcbiAgICB2YXIgaCA9IHRoaXMuc3RhcnQueSAtIHRoaXMuZW5kLnk7XG4gICAgdmFyIHogPSBNYXRoLnBvdyhNYXRoLnNpbihoIC8gMi4wKSwgMikgK1xuICAgICAgICAgICAgICAgIE1hdGguY29zKHRoaXMuc3RhcnQueSkgKlxuICAgICAgICAgICAgICAgICAgIE1hdGguY29zKHRoaXMuZW5kLnkpICpcbiAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguc2luKHcgLyAyLjApLCAyKTtcbiAgICB0aGlzLmcgPSAyLjAgKiBNYXRoLmFzaW4oTWF0aC5zcXJ0KHopKTtcblxuICAgIGlmICh0aGlzLmcgPT09IE1hdGguUEkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdCBhcHBlYXJzICcgKyBzdGFydC52aWV3KCkgKyAnIGFuZCAnICsgZW5kLnZpZXcoKSArICcgYXJlIFxcJ2FudGlwb2RhbFxcJywgZS5nIGRpYW1ldHJpY2FsbHkgb3Bwb3NpdGUsIHRodXMgdGhlcmUgaXMgbm8gc2luZ2xlIHJvdXRlIGJ1dCByYXRoZXIgaW5maW5pdGUnKTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHRoaXMuZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgY2FsY3VsYXRlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuICcgKyBzdGFydCArICcgYW5kICcgKyBlbmQpO1xuICAgIH1cbn07XG5cbi8qXG4gKiBodHRwOi8vd2lsbGlhbXMuYmVzdC52d2gubmV0L2F2Zm9ybS5odG0jSW50ZXJtZWRpYXRlXG4gKi9cbkdyZWF0Q2lyY2xlLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIEEgPSBNYXRoLnNpbigoMSAtIGYpICogdGhpcy5nKSAvIE1hdGguc2luKHRoaXMuZyk7XG4gICAgdmFyIEIgPSBNYXRoLnNpbihmICogdGhpcy5nKSAvIE1hdGguc2luKHRoaXMuZyk7XG4gICAgdmFyIHggPSBBICogTWF0aC5jb3ModGhpcy5zdGFydC55KSAqIE1hdGguY29zKHRoaXMuc3RhcnQueCkgKyBCICogTWF0aC5jb3ModGhpcy5lbmQueSkgKiBNYXRoLmNvcyh0aGlzLmVuZC54KTtcbiAgICB2YXIgeSA9IEEgKiBNYXRoLmNvcyh0aGlzLnN0YXJ0LnkpICogTWF0aC5zaW4odGhpcy5zdGFydC54KSArIEIgKiBNYXRoLmNvcyh0aGlzLmVuZC55KSAqIE1hdGguc2luKHRoaXMuZW5kLngpO1xuICAgIHZhciB6ID0gQSAqIE1hdGguc2luKHRoaXMuc3RhcnQueSkgKyBCICogTWF0aC5zaW4odGhpcy5lbmQueSk7XG4gICAgdmFyIGxhdCA9IFIyRCAqIE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpKTtcbiAgICB2YXIgbG9uID0gUjJEICogTWF0aC5hdGFuMih5LCB4KTtcbiAgICByZXR1cm4gW2xvbiwgbGF0XTtcbn07XG5cblxuXG4vKlxuICogR2VuZXJhdGUgcG9pbnRzIGFsb25nIHRoZSBncmVhdCBjaXJjbGVcbiAqL1xuR3JlYXRDaXJjbGUucHJvdG90eXBlLkFyYyA9IGZ1bmN0aW9uIChucG9pbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIGZpcnN0X3Bhc3MgPSBbXTtcbiAgICBpZiAoIW5wb2ludHMgfHwgbnBvaW50cyA8PSAyKSB7XG4gICAgICAgIGZpcnN0X3Bhc3MucHVzaChbdGhpcy5zdGFydC5sb24sIHRoaXMuc3RhcnQubGF0XSk7XG4gICAgICAgIGZpcnN0X3Bhc3MucHVzaChbdGhpcy5lbmQubG9uLCB0aGlzLmVuZC5sYXRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsdGEgPSAxLjAgLyAobnBvaW50cyAtIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5wb2ludHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBkZWx0YSAqIGk7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHRoaXMuaW50ZXJwb2xhdGUoc3RlcCk7XG4gICAgICAgICAgICBmaXJzdF9wYXNzLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogcGFydGlhbCBwb3J0IG9mIGRhdGVsaW5lIGhhbmRsaW5nIGZyb206XG4gICAgICBnZGFsL29nci9vZ3JnZW9tZXRyeWZhY3RvcnkuY3BwXG5cbiAgICAgIFRPRE8gLSBkb2VzIG5vdCBoYW5kbGUgYWxsIHdyYXBwaW5nIHNjZW5hcmlvcyB5ZXRcbiAgICAqL1xuICAgIHZhciBiSGFzQmlnRGlmZiA9IGZhbHNlO1xuICAgIHZhciBkZk1heFNtYWxsRGlmZkxvbmcgPSAwO1xuICAgIC8vIGZyb20gaHR0cDovL3d3dy5nZGFsLm9yZy9vZ3Iyb2dyLmh0bWxcbiAgICAvLyAtZGF0ZWxpbmVvZmZzZXQ6XG4gICAgLy8gKHN0YXJ0aW5nIHdpdGggR0RBTCAxLjEwKSBvZmZzZXQgZnJvbSBkYXRlbGluZSBpbiBkZWdyZWVzIChkZWZhdWx0IGxvbmcuID0gKy8tIDEwZGVnLCBnZW9tZXRyaWVzIHdpdGhpbiAxNzBkZWcgdG8gLTE3MGRlZyB3aWxsIGJlIHNwbGl0ZWQpXG4gICAgdmFyIGRmRGF0ZUxpbmVPZmZzZXQgPSBvcHRpb25zICYmIG9wdGlvbnMub2Zmc2V0ID8gb3B0aW9ucy5vZmZzZXQgOiAxMDtcbiAgICB2YXIgZGZMZWZ0Qm9yZGVyWCA9IDE4MCAtIGRmRGF0ZUxpbmVPZmZzZXQ7XG4gICAgdmFyIGRmUmlnaHRCb3JkZXJYID0gLTE4MCArIGRmRGF0ZUxpbmVPZmZzZXQ7XG4gICAgdmFyIGRmRGlmZlNwYWNlID0gMzYwIC0gZGZEYXRlTGluZU9mZnNldDtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9nZGFsL2Jsb2IvN2JmYjljNDUyYTU5YWFjOTU4YmZmMGM4Mzg2Yjg5MWVkZjgxNTRjYS9nZGFsL29nci9vZ3JnZW9tZXRyeWZhY3RvcnkuY3BwI0wyMzQyXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBmaXJzdF9wYXNzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBkZlByZXZYID0gZmlyc3RfcGFzc1tqIC0gMV1bMF07XG4gICAgICAgIHZhciBkZlggPSBmaXJzdF9wYXNzW2pdWzBdO1xuICAgICAgICB2YXIgZGZEaWZmTG9uZyA9IE1hdGguYWJzKGRmWCAtIGRmUHJldlgpO1xuICAgICAgICBpZiAoZGZEaWZmTG9uZyA+IGRmRGlmZlNwYWNlICYmXG4gICAgICAgICAgICAoKGRmWCA+IGRmTGVmdEJvcmRlclggJiYgZGZQcmV2WCA8IGRmUmlnaHRCb3JkZXJYKSB8fCAoZGZQcmV2WCA+IGRmTGVmdEJvcmRlclggJiYgZGZYIDwgZGZSaWdodEJvcmRlclgpKSkge1xuICAgICAgICAgICAgYkhhc0JpZ0RpZmYgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGRmRGlmZkxvbmcgPiBkZk1heFNtYWxsRGlmZkxvbmcpIHtcbiAgICAgICAgICAgIGRmTWF4U21hbGxEaWZmTG9uZyA9IGRmRGlmZkxvbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcG9NdWx0aSA9IFtdO1xuICAgIGlmIChiSGFzQmlnRGlmZiAmJiBkZk1heFNtYWxsRGlmZkxvbmcgPCBkZkRhdGVMaW5lT2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb05ld0xTID0gW107XG4gICAgICAgIHBvTXVsdGkucHVzaChwb05ld0xTKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBmaXJzdF9wYXNzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICB2YXIgZGZYMCA9IHBhcnNlRmxvYXQoZmlyc3RfcGFzc1trXVswXSk7XG4gICAgICAgICAgICBpZiAoayA+IDAgJiYgIE1hdGguYWJzKGRmWDAgLSBmaXJzdF9wYXNzW2sgLSAxXVswXSkgPiBkZkRpZmZTcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZlgxID0gcGFyc2VGbG9hdChmaXJzdF9wYXNzW2sgLSAxXVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIGRmWTEgPSBwYXJzZUZsb2F0KGZpcnN0X3Bhc3NbayAtIDFdWzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgZGZYMiA9IHBhcnNlRmxvYXQoZmlyc3RfcGFzc1trXVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIGRmWTIgPSBwYXJzZUZsb2F0KGZpcnN0X3Bhc3Nba11bMV0pO1xuICAgICAgICAgICAgICAgIGlmIChkZlgxID4gLTE4MCAmJiBkZlgxIDwgZGZSaWdodEJvcmRlclggJiYgZGZYMiA9PT0gMTgwICYmXG4gICAgICAgICAgICAgICAgICAgIGsgKyAxIDwgZmlyc3RfcGFzcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICBmaXJzdF9wYXNzW2sgLSAxXVswXSA+IC0xODAgJiYgZmlyc3RfcGFzc1trIC0gMV1bMF0gPCBkZlJpZ2h0Qm9yZGVyWCkge1xuICAgICAgICAgICAgICAgICAgICBwb05ld0xTLnB1c2goWy0xODAsIGZpcnN0X3Bhc3Nba11bMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgICAgICBwb05ld0xTLnB1c2goW2ZpcnN0X3Bhc3Nba11bMF0sIGZpcnN0X3Bhc3Nba11bMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZlgxID4gZGZMZWZ0Qm9yZGVyWCAmJiBkZlgxIDwgMTgwICYmIGRmWDIgPT09IC0xODAgJiZcbiAgICAgICAgICAgICAgICAgICAgIGsgKyAxIDwgZmlyc3RfcGFzcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3Bhc3NbayAtIDFdWzBdID4gZGZMZWZ0Qm9yZGVyWCAmJiBmaXJzdF9wYXNzW2sgLSAxXVswXSA8IDE4MCkge1xuICAgICAgICAgICAgICAgICAgICBwb05ld0xTLnB1c2goWzE4MCwgZmlyc3RfcGFzc1trXVsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICAgIHBvTmV3TFMucHVzaChbZmlyc3RfcGFzc1trXVswXSwgZmlyc3RfcGFzc1trXVsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGZYMSA8IGRmUmlnaHRCb3JkZXJYICYmIGRmWDIgPiBkZkxlZnRCb3JkZXJYKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN3YXAgZGZYMSwgZGZYMlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wWCA9IGRmWDE7XG4gICAgICAgICAgICAgICAgICAgIGRmWDEgPSBkZlgyO1xuICAgICAgICAgICAgICAgICAgICBkZlgyID0gdG1wWDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCBkZlkxLCBkZlkyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBZID0gZGZZMTtcbiAgICAgICAgICAgICAgICAgICAgZGZZMSA9IGRmWTI7XG4gICAgICAgICAgICAgICAgICAgIGRmWTIgPSB0bXBZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGZYMSA+IGRmTGVmdEJvcmRlclggJiYgZGZYMiA8IGRmUmlnaHRCb3JkZXJYKSB7XG4gICAgICAgICAgICAgICAgICAgIGRmWDIgKz0gMzYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGZYMSA8PSAxODAgJiYgZGZYMiA+PSAxODAgJiYgZGZYMSA8IGRmWDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRmUmF0aW8gPSAoMTgwIC0gZGZYMSkgLyAoZGZYMiAtIGRmWDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGZZID0gZGZSYXRpbyAqIGRmWTIgKyAoMSAtIGRmUmF0aW8pICogZGZZMTtcbiAgICAgICAgICAgICAgICAgICAgcG9OZXdMUy5wdXNoKFtmaXJzdF9wYXNzW2sgLSAxXVswXSA+IGRmTGVmdEJvcmRlclggPyAxODAgOiAtMTgwLCBkZlldKTtcbiAgICAgICAgICAgICAgICAgICAgcG9OZXdMUyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwb05ld0xTLnB1c2goW2ZpcnN0X3Bhc3NbayAtIDFdWzBdID4gZGZMZWZ0Qm9yZGVyWCA/IC0xODAgOiAxODAsIGRmWV0pO1xuICAgICAgICAgICAgICAgICAgICBwb011bHRpLnB1c2gocG9OZXdMUyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9OZXdMUyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwb011bHRpLnB1c2gocG9OZXdMUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvTmV3TFMucHVzaChbZGZYMCwgZmlyc3RfcGFzc1trXVsxXV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb05ld0xTLnB1c2goW2ZpcnN0X3Bhc3Nba11bMF0sIGZpcnN0X3Bhc3Nba11bMV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBub3JtYWxseVxuICAgICAgICB2YXIgcG9OZXdMUzAgPSBbXTtcbiAgICAgICAgcG9NdWx0aS5wdXNoKHBvTmV3TFMwKTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBmaXJzdF9wYXNzLmxlbmd0aDsgKytsKSB7XG4gICAgICAgICAgICBwb05ld0xTMC5wdXNoKFtmaXJzdF9wYXNzW2xdWzBdLCBmaXJzdF9wYXNzW2xdWzFdXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJjID0gbmV3IEFyYyh0aGlzLnByb3BlcnRpZXMpO1xuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgcG9NdWx0aS5sZW5ndGg7ICsrbSkge1xuICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lU3RyaW5nKCk7XG4gICAgICAgIGFyYy5nZW9tZXRyaWVzLnB1c2gobGluZSk7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb011bHRpW21dO1xuICAgICAgICBmb3IgKHZhciBqMCA9IDA7IGowIDwgcG9pbnRzLmxlbmd0aDsgKytqMCkge1xuICAgICAgICAgICAgbGluZS5tb3ZlX3RvKHBvaW50c1tqMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db29yZCA9IENvb3JkO1xubW9kdWxlLmV4cG9ydHMuQXJjID0gQXJjO1xubW9kdWxlLmV4cG9ydHMuR3JlYXRDaXJjbGUgPSBHcmVhdENpcmNsZTtcbiIsInZhciBhcmMgPSByZXF1aXJlKCcuL2FyYycpO1xudmFyIGdldENvb3JkID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50JykuZ2V0Q29vcmQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGdyZWF0IGNpcmNsZXMgcm91dGVzIGFzIHtAbGluayBMaW5lU3RyaW5nfVxuICpcbiAqIEBuYW1lIGdyZWF0Q2lyY2xlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBzdGFydCBzb3VyY2UgcG9pbnQgZmVhdHVyZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gZW5kIGRlc3RpbmF0aW9uIHBvaW50IGZlYXR1cmVcbiAqIEBwYXJhbSB7Kn0gW3Byb3BlcnRpZXM9e31dIGxpbmUgZmVhdHVyZSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge251bWJlcn0gW25wb2ludHM9MTAwXSBudW1iZXIgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0xMF0gb2Zmc2V0IGNvbnRyb2xzIHRoZSBsaWtlbHlob29kIHRoYXQgbGluZXMgd2lsbFxuICogYmUgc3BsaXQgd2hpY2ggY3Jvc3MgdGhlIGRhdGVsaW5lLiBUaGUgaGlnaGVyIHRoZSBudW1iZXIgdGhlIG1vcmUgbGlrZWx5LlxuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IGdyZWF0IGNpcmNsZSBsaW5lIGZlYXR1cmVcbiAqIEBhZGRUb01hcCBsaW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIHN0YXJ0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstMTIyLCA0OF1cbiAqICAgfVxuICogfVxuICogdmFyIGVuZCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc3LCAzOV1cbiAqICAgfVxuICogfVxuICogdmFyIGxpbmUgPSB0dXJmLmdyZWF0Q2lyY2xlKHN0YXJ0LCBlbmQsIHsnbmFtZSc6ICdTZWF0dGxlIHRvIERDJ30pO1xuICogLy89bGluZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwcm9wZXJ0aWVzLCBucG9pbnRzLCBvZmZzZXQpIHtcbiAgICBzdGFydCA9IGdldENvb3JkKHN0YXJ0KTtcbiAgICBlbmQgPSBnZXRDb29yZChlbmQpO1xuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgIG5wb2ludHMgPSBucG9pbnRzIHx8IDEwMDtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMTA7XG5cbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IGFyYy5HcmVhdENpcmNsZSh7eDogc3RhcnRbMF0sIHk6IHN0YXJ0WzFdfSwge3g6IGVuZFswXSwgeTogZW5kWzFdfSwgcHJvcGVydGllcyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICB2YXIgbGluZSA9IGdlbmVyYXRvci5BcmMobnBvaW50cywge29mZnNldDogb2Zmc2V0fSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgcmV0dXJuIGxpbmUuanNvbigpO1xufTtcbiIsIi8qKlxuICogV3JhcHMgYSBHZW9KU09OIHtAbGluayBHZW9tZXRyeX0gaW4gYSBHZW9KU09OIHtAbGluayBGZWF0dXJlfS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBpbnB1dCBnZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIGlucHV0IGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb21ldHJ5ID0ge1xuICogICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgICA2Ny41LFxuICogICAgICAgIDMyLjg0MjY3MzYzMTk1NDMxXG4gKiAgICAgIF1cbiAqICAgIH1cbiAqXG4gKiB2YXIgZmVhdHVyZSA9IHR1cmYuZmVhdHVyZShnZW9tZXRyeSk7XG4gKlxuICogLy89ZmVhdHVyZVxuICovXG5mdW5jdGlvbiBmZWF0dXJlKGdlb21ldHJ5LCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFnZW9tZXRyeSkgdGhyb3cgbmV3IEVycm9yKCdObyBnZW9tZXRyeSBwYXNzZWQnKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyB8fCB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzLmZlYXR1cmUgPSBmZWF0dXJlO1xuXG4vKipcbiAqIFRha2VzIGNvb3JkaW5hdGVzIGFuZCBwcm9wZXJ0aWVzIChvcHRpb25hbCkgYW5kIHJldHVybnMgYSBuZXcge0BsaW5rIFBvaW50fSBmZWF0dXJlLlxuICpcbiAqIEBuYW1lIHBvaW50XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcG9zaXRpb24gKGVhY2ggaW4gZGVjaW1hbCBkZWdyZWVzKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCB0aGF0IGlzIHVzZWQgYXMgdGhlIHtAbGluayBGZWF0dXJlfSdzXG4gKiBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wdDFcbiAqL1xubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBiZSBhdCBsZWFzdCAyIG51bWJlcnMgbG9uZycpO1xuICAgIGlmICh0eXBlb2YgY29vcmRpbmF0ZXNbMF0gIT09ICdudW1iZXInIHx8IHR5cGVvZiBjb29yZGluYXRlc1sxXSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBudW1iZXJzJyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5ncyBhbmQgb3B0aW9uYWxseSBhbiB7QGxpbmsgT2JqZWN0fSB3aXRoIHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgUG9seWdvbn0gZmVhdHVyZS5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZWFyUmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhIHByb3BlcnRpZXMgb2JqZWN0XG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gYSBQb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiBhIExpbmVhclJpbmcgb2YgdGhlIHBvbHlnb24gaGFzIHRvbyBmZXcgcG9zaXRpb25zXG4gKiBvciBpZiBhIExpbmVhclJpbmcgb2YgdGhlIFBvbHlnb24gZG9lcyBub3QgaGF2ZSBtYXRjaGluZyBQb3NpdGlvbnMgYXQgdGhlXG4gKiBiZWdpbm5pbmcgJiBlbmQuXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tcbiAqICBbLTIuMjc1NTQzLCA1My40NjQ1NDddLFxuICogIFstMi4yNzU1NDMsIDUzLjQ4OTI3MV0sXG4gKiAgWy0yLjIxNTExOCwgNTMuNDg5MjcxXSxcbiAqICBbLTIuMjE1MTE4LCA1My40NjQ1NDddLFxuICogIFstMi4yNzU1NDMsIDUzLjQ2NDU0N11cbiAqIF1dLCB7IG5hbWU6ICdwb2x5MScsIHBvcHVsYXRpb246IDQwMH0pO1xuICpcbiAqIC8vPXBvbHlnb25cbiAqL1xubW9kdWxlLmV4cG9ydHMucG9seWdvbiA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGlmIChyaW5nLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWFjaCBMaW5lYXJSaW5nIG9mIGEgUG9seWdvbiBtdXN0IGhhdmUgNCBvciBtb3JlIFBvc2l0aW9ucy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdbcmluZy5sZW5ndGggLSAxXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHJpbmdbcmluZy5sZW5ndGggLSAxXVtqXSAhPT0gcmluZ1swXVtqXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYW5kIGxhc3QgUG9zaXRpb24gYXJlIG5vdCBlcXVpdmFsZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIExpbmVTdHJpbmd9IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IGEgTGluZVN0cmluZyBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5nMSA9IHR1cmYubGluZVN0cmluZyhbXG4gKiAgIFstMjEuOTY0NDE2LCA2NC4xNDgyMDNdLFxuICogICBbLTIxLjk1NjE3NiwgNjQuMTQxMzE2XSxcbiAqICAgWy0yMS45MzkwMSwgNjQuMTM1OTI0XSxcbiAqICAgWy0yMS45MjczMzcsIDY0LjEzNjY3M11cbiAqIF0pO1xuICogdmFyIGxpbmVzdHJpbmcyID0gdHVyZi5saW5lU3RyaW5nKFtcbiAqICAgWy0yMS45MjkwNTQsIDY0LjEyNzk4NV0sXG4gKiAgIFstMjEuOTEyOTE4LCA2NC4xMzQ3MjZdLFxuICogICBbLTIxLjkxNjAwNywgNjQuMTQxMDE2XSxcbiAqICAgWy0yMS45MzAwODQsIDY0LjE0NDQ2XVxuICogXSwge25hbWU6ICdsaW5lIDEnLCBkaXN0YW5jZTogMTQ1fSk7XG4gKlxuICogLy89bGluZXN0cmluZzFcbiAqXG4gKiAvLz1saW5lc3RyaW5nMlxuICovXG5tb2R1bGUuZXhwb3J0cy5saW5lU3RyaW5nID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogVGFrZXMgb25lIG9yIG1vcmUge0BsaW5rIEZlYXR1cmV8RmVhdHVyZXN9IGFuZCBjcmVhdGVzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtGZWF0dXJlW119IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgaW5wdXQgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSBbXG4gKiAgdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSwge25hbWU6ICdMb2NhdGlvbiBBJ30pLFxuICogIHR1cmYucG9pbnQoWy03NS44MzMsIDM5LjI4NF0sIHtuYW1lOiAnTG9jYXRpb24gQid9KSxcbiAqICB0dXJmLnBvaW50KFstNzUuNTM0LCAzOS4xMjNdLCB7bmFtZTogJ0xvY2F0aW9uIEMnfSlcbiAqIF07XG4gKlxuICogdmFyIGZjID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcyk7XG4gKlxuICogLy89ZmNcbiAqL1xubW9kdWxlLmV4cG9ydHMuZmVhdHVyZUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICBpZiAoIWZlYXR1cmVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZlYXR1cmVzIHBhc3NlZCcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzXG4gICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBhIE11bHRpTGluZVN0cmluZyBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbW1swLDBdLFsxMCwxMF1dXSk7XG4gKlxuICogLy89bXVsdGlMaW5lXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5tdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuXG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvaW50Pn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvaW50XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb3NpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvaW50Pn0gYSBNdWx0aVBvaW50IGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUHQgPSB0dXJmLm11bHRpUG9pbnQoW1swLDBdLFsxMCwxMF1dKTtcbiAqXG4gKiAvLz1tdWx0aVB0XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5tdWx0aVBvaW50ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvbHlnb24+fSBhIG11bHRpcG9seWdvbiBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbW1tbMCwwXSxbMCwxMF0sWzEwLDEwXSxbMTAsMF0sWzAsMF1dXV0pO1xuICpcbiAqIC8vPW11bHRpUG9seVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMubXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8e0dlb21ldHJ5fT59IGdlb21ldHJpZXMgYW4gYXJyYXkgb2YgR2VvSlNPTiBHZW9tZXRyaWVzXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYSBHZW9KU09OIEdlb21ldHJ5Q29sbGVjdGlvbiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0ge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMDAsIDBdXG4gKiAgICAgfTtcbiAqIHZhciBsaW5lID0ge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsgWzEwMSwgMF0sIFsxMDIsIDFdIF1cbiAqICAgfTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeUNvbGxlY3Rpb24oW3B0LCBsaW5lXSk7XG4gKlxuICogLy89Y29sbGVjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgcHJvcGVydGllcykge1xuICAgIGlmICghZ2VvbWV0cmllcykgdGhyb3cgbmV3IEVycm9yKCdObyBnZW9tZXRyaWVzIHBhc3NlZCcpO1xuXG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgICAgZ2VvbWV0cmllczogZ2VvbWV0cmllc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxudmFyIGZhY3RvcnMgPSB7XG4gICAgbWlsZXM6IDM5NjAsXG4gICAgbmF1dGljYWxtaWxlczogMzQ0MS4xNDUsXG4gICAgZGVncmVlczogNTcuMjk1Nzc5NSxcbiAgICByYWRpYW5zOiAxLFxuICAgIGluY2hlczogMjUwOTA1NjAwLFxuICAgIHlhcmRzOiA2OTY5NjAwLFxuICAgIG1ldGVyczogNjM3MzAwMCxcbiAgICBtZXRyZXM6IDYzNzMwMDAsXG4gICAga2lsb21ldGVyczogNjM3MyxcbiAgICBraWxvbWV0cmVzOiA2MzczLFxuICAgIGZlZXQ6IDIwOTA4NzkyLjY1XG59O1xuXG4vKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IGZyb20gcmFkaWFucyB0byBhIG1vcmUgZnJpZW5kbHkgdW5pdC5cbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9EaXN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJhZGlhbnMgYWNyb3NzIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cbm1vZHVsZS5leHBvcnRzLnJhZGlhbnNUb0Rpc3RhbmNlID0gZnVuY3Rpb24gKHJhZGlhbnMsIHVuaXRzKSB7XG4gICAgdmFyIGZhY3RvciA9IGZhY3RvcnNbdW5pdHMgfHwgJ2tpbG9tZXRlcnMnXTtcbiAgICBpZiAoZmFjdG9yID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG5cbiAgICByZXR1cm4gcmFkaWFucyAqIGZhY3Rvcjtcbn07XG5cbi8qXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIHJhZGlhbnNcbiAqXG4gKiBAbmFtZSBkaXN0YW5jZVRvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJhZGlhbnNcbiAqL1xubW9kdWxlLmV4cG9ydHMuZGlzdGFuY2VUb1JhZGlhbnMgPSBmdW5jdGlvbiAoZGlzdGFuY2UsIHVuaXRzKSB7XG4gICAgdmFyIGZhY3RvciA9IGZhY3RvcnNbdW5pdHMgfHwgJ2tpbG9tZXRlcnMnXTtcbiAgICBpZiAoZmFjdG9yID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG5cbiAgICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59O1xuXG4vKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byBkZWdyZWVzXG4gKlxuICogQG5hbWUgZGlzdGFuY2VUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByZWFsIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogaW5jaGVzLCB5YXJkcywgbWV0cmVzLCBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmRpc3RhbmNlVG9EZWdyZWVzID0gZnVuY3Rpb24gKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzIHx8ICdraWxvbWV0ZXJzJ107XG4gICAgaWYgKGZhY3RvciA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdCcpO1xuXG4gICAgcmV0dXJuIChkaXN0YW5jZSAvIGZhY3RvcikgKiA1Ny4yOTU4O1xufTtcbiIsInZhciBwb2ludCA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2ludDtcbnZhciBwb2x5Z29uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLnBvbHlnb247XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9kaXN0YW5jZScpO1xudmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vL1ByZWNvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMgb2YgYW5nbGVzIHVzZWQgaW4gaGV4YWdvbiBjcmVhdGlvblxuLy8gZm9yIHBlcmZvcm1hbmNlIGdhaW5cbnZhciBjb3NpbmVzID0gW107XG52YXIgc2luZXMgPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgLyA2ICogaTtcbiAgICBjb3NpbmVzLnB1c2goTWF0aC5jb3MoYW5nbGUpKTtcbiAgICBzaW5lcy5wdXNoKE1hdGguc2luKGFuZ2xlKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBib3VuZGluZyBib3ggYW5kIGEgY2VsbCBzaXplIGluIGRlZ3JlZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIGZsYXQtdG9wcGVkXG4gKiBoZXhhZ29ucyAoe0BsaW5rIFBvbHlnb259IGZlYXR1cmVzKSBhbGlnbmVkIGluIGFuIFwib2RkLXFcIiB2ZXJ0aWNhbCBncmlkIGFzXG4gKiBkZXNjcmliZWQgaW4gW0hleGFnb25hbCBHcmlkc10oaHR0cDovL3d3dy5yZWRibG9iZ2FtZXMuY29tL2dyaWRzL2hleGFnb25zLykuXG4gKlxuICogQG5hbWUgaGV4R3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSBkaW1lbnNpb24gb2YgY2VsbCBpbiBzcGVjaWZpZWQgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gdXNlZCBpbiBjYWxjdWxhdGluZyBjZWxsU2l6ZSwgY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmlhbmdsZXM9ZmFsc2VdIHdoZXRoZXIgdG8gcmV0dXJuIGFzIHRyaWFuZ2xlcyBpbnN0ZWFkIG9mIGhleGFnb25zXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IGEgaGV4YWdvbmFsIGdyaWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgYmJveCA9IFstOTYsMzEsLTg0LDQwXTtcbiAqIHZhciBjZWxsU2l6ZSA9IDUwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgaGV4Z3JpZCA9IHR1cmYuaGV4R3JpZChiYm94LCBjZWxsU2l6ZSwgdW5pdHMpO1xuICpcbiAqIC8vPWhleGdyaWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoZXhHcmlkKGJib3gsIGNlbGxTaXplLCB1bml0cywgdHJpYW5nbGVzKSB7XG4gICAgdmFyIHhGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIHBvaW50KFtiYm94WzJdLCBiYm94WzFdXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxXaWR0aCA9IHhGcmFjdGlvbiAqIChiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdmFyIHlGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIHBvaW50KFtiYm94WzBdLCBiYm94WzNdXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSB5RnJhY3Rpb24gKiAoYmJveFszXSAtIGJib3hbMV0pO1xuICAgIHZhciByYWRpdXMgPSBjZWxsV2lkdGggLyAyO1xuXG4gICAgdmFyIGhleF93aWR0aCA9IHJhZGl1cyAqIDI7XG4gICAgdmFyIGhleF9oZWlnaHQgPSBNYXRoLnNxcnQoMykgLyAyICogY2VsbEhlaWdodDtcblxuICAgIHZhciBib3hfd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICB2YXIgYm94X2hlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuXG4gICAgdmFyIHhfaW50ZXJ2YWwgPSAzIC8gNCAqIGhleF93aWR0aDtcbiAgICB2YXIgeV9pbnRlcnZhbCA9IGhleF9oZWlnaHQ7XG5cbiAgICB2YXIgeF9zcGFuID0gYm94X3dpZHRoIC8gKGhleF93aWR0aCAtIHJhZGl1cyAvIDIpO1xuICAgIHZhciB4X2NvdW50ID0gTWF0aC5jZWlsKHhfc3Bhbik7XG4gICAgaWYgKE1hdGgucm91bmQoeF9zcGFuKSA9PT0geF9jb3VudCkge1xuICAgICAgICB4X2NvdW50Kys7XG4gICAgfVxuXG4gICAgdmFyIHhfYWRqdXN0ID0gKCh4X2NvdW50ICogeF9pbnRlcnZhbCAtIHJhZGl1cyAvIDIpIC0gYm94X3dpZHRoKSAvIDIgLSByYWRpdXMgLyAyO1xuXG4gICAgdmFyIHlfY291bnQgPSBNYXRoLmNlaWwoYm94X2hlaWdodCAvIGhleF9oZWlnaHQpO1xuXG4gICAgdmFyIHlfYWRqdXN0ID0gKGJveF9oZWlnaHQgLSB5X2NvdW50ICogaGV4X2hlaWdodCkgLyAyO1xuXG4gICAgdmFyIGhhc09mZnNldFkgPSB5X2NvdW50ICogaGV4X2hlaWdodCAtIGJveF9oZWlnaHQgPiBoZXhfaGVpZ2h0IC8gMjtcbiAgICBpZiAoaGFzT2Zmc2V0WSkge1xuICAgICAgICB5X2FkanVzdCAtPSBoZXhfaGVpZ2h0IC8gNDtcbiAgICB9XG5cbiAgICB2YXIgZmMgPSBmZWF0dXJlY29sbGVjdGlvbihbXSk7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB4X2NvdW50OyB4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0geV9jb3VudDsgeSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBpc09kZCA9IHggJSAyID09PSAxO1xuICAgICAgICAgICAgaWYgKHkgPT09IDAgJiYgaXNPZGQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHkgPT09IDAgJiYgaGFzT2Zmc2V0WSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2VudGVyX3ggPSB4ICogeF9pbnRlcnZhbCArIGJib3hbMF0gLSB4X2FkanVzdDtcbiAgICAgICAgICAgIHZhciBjZW50ZXJfeSA9IHkgKiB5X2ludGVydmFsICsgYmJveFsxXSArIHlfYWRqdXN0O1xuXG4gICAgICAgICAgICBpZiAoaXNPZGQpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXJfeSAtPSBoZXhfaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlhbmdsZXMpIHtcbiAgICAgICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoLmFwcGx5KGZjLmZlYXR1cmVzLCBoZXhUcmlhbmdsZXMoW2NlbnRlcl94LCBjZW50ZXJfeV0sIGNlbGxXaWR0aCAvIDIsIGNlbGxIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2goaGV4YWdvbihbY2VudGVyX3gsIGNlbnRlcl95XSwgY2VsbFdpZHRoIC8gMiwgY2VsbEhlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYztcbn07XG5cbi8vQ2VudGVyIHNob3VsZCBiZSBbeCwgeV1cbmZ1bmN0aW9uIGhleGFnb24oY2VudGVyLCByeCwgcnkpIHtcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICB2YXIgeCA9IGNlbnRlclswXSArIHJ4ICogY29zaW5lc1tpXTtcbiAgICAgICAgdmFyIHkgPSBjZW50ZXJbMV0gKyByeSAqIHNpbmVzW2ldO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4LCB5XSk7XG4gICAgfVxuICAgIC8vZmlyc3QgYW5kIGxhc3QgdmVydGV4IG11c3QgYmUgdGhlIHNhbWVcbiAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRpY2VzWzBdKTtcbiAgICByZXR1cm4gcG9seWdvbihbdmVydGljZXNdKTtcbn1cblxuLy9DZW50ZXIgc2hvdWxkIGJlIFt4LCB5XVxuZnVuY3Rpb24gaGV4VHJpYW5nbGVzKGNlbnRlciwgcngsIHJ5KSB7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNlbnRlcik7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgY2VudGVyWzBdICsgcnggKiBjb3NpbmVzW2ldLFxuICAgICAgICAgICAgY2VudGVyWzFdICsgcnkgKiBzaW5lc1tpXVxuICAgICAgICBdKTtcbiAgICAgICAgdmVydGljZXMucHVzaChbXG4gICAgICAgICAgICBjZW50ZXJbMF0gKyByeCAqIGNvc2luZXNbKGkgKyAxKSAlIDZdLFxuICAgICAgICAgICAgY2VudGVyWzFdICsgcnkgKiBzaW5lc1soaSArIDEpICUgNl1cbiAgICAgICAgXSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goY2VudGVyKTtcbiAgICAgICAgdHJpYW5nbGVzLnB1c2gocG9seWdvbihbdmVydGljZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG4iLCJ2YXIgZGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9kaXN0YW5jZScpO1xudmFyIHNxdWFyZUdyaWQgPSByZXF1aXJlKCdAdHVyZi9zcXVhcmUtZ3JpZCcpO1xudmFyIGNlbnRyb2lkID0gcmVxdWlyZSgnQHR1cmYvY2VudHJvaWQnKTtcbnZhciBiYm94ID0gcmVxdWlyZSgnQHR1cmYvYmJveCcpO1xuXG4vKipcbiAqXG4gKiBUYWtlcyBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIHBvaW50cyB3aXRoIGtub3duIHZhbHVlLCBhIHBvd2VyIHBhcmFtZXRlciwgYSBjZWxsIGRlcHRoLCBhIHVuaXQgb2YgbWVhc3VyZW1lbnRcbiAqIGFuZCByZXR1cm5zIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgcG9seWdvbnMgaW4gYSBzcXVhcmUtZ3JpZCB3aXRoIGFuIGludGVycG9sYXRlZCB2YWx1ZSBwcm9wZXJ0eSBcIklEV1wiIGZvciBlYWNoIGdyaWQgY2VsbC5cbiAqIEl0IGZpbmRzIGFwcGxpY2F0aW9uIHdoZW4gaW4gbmVlZCBvZiBjcmVhdGluZyBhIGNvbnRpbnVvdXMgc3VyZmFjZSAoaS5lLiByYWluZmFsbCwgdGVtcGVyYXR1cmUsIGNoZW1pY2FsIGRpc3BlcnNpb24gc3VyZmFjZS4uLilcbiAqIGZyb20gYSBzZXQgb2Ygc3BhdGlhbGx5IHNjYXR0ZXJlZCBwb2ludHMuXG4gKlxuICogQG5hbWUgaWR3XG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gY29udHJvbFBvaW50cyBTYW1wbGVkIHBvaW50cyB3aXRoIGtub3duIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVGaWVsZCBHZW9KU09OIGZpZWxkIGNvbnRhaW5pbmcgdGhlIGtub3duIHZhbHVlIHRvIGludGVycG9sYXRlIG9uXG4gKiBAcGFyYW0ge251bWJlcn0gYiBFeHBvbmVudCByZWd1bGF0aW5nIHRoZSBkaXN0YW5jZS1kZWNheSB3ZWlnaHRpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsV2lkdGggVGhlIGRpc3RhbmNlIGFjcm9zcyBlYWNoIGNlbGxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gdXNlZCBpbiBjYWxjdWxhdGluZyBjZWxsU2l6ZSwgY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IGdyaWQgQSBncmlkIG9mIHBvbHlnb25zIHdpdGggYSBwcm9wZXJ0eSBmaWVsZCBcIklEV1wiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRyb2xQb2ludHMsIHZhbHVlRmllbGQsIGIsIGNlbGxXaWR0aCwgdW5pdHMpIHtcbiAgICAvLyBjaGVjayBpZiBmaWVsZCBjb250YWluaW5nIGRhdGEgZXhpc3RzLi5cbiAgICB2YXIgZmlsdGVyZWQgPSBjb250cm9sUG9pbnRzLmZlYXR1cmVzLmZpbHRlcihmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzICYmXG4gICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCk7XG4gICAgfSk7XG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgLy8gY3JlYXRlIGEgc2FtcGxlIHNxdWFyZSBncmlkXG4gICAgICAvLyBjb21wYXJlZCB0byBhIHBvaW50IGdyaWQgaGVscHMgdmlzdWFsaXppbmcgdGhlIG91dHB1dCAobGlrZSBhIHJhc3Rlci4uKVxuICAgICAgICB2YXIgc2FtcGxpbmdHcmlkID0gc3F1YXJlR3JpZChiYm94KGNvbnRyb2xQb2ludHMpLCBjZWxsV2lkdGgsIHVuaXRzKTtcbiAgICAgICAgdmFyIE4gPSBzYW1wbGluZ0dyaWQuZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgdmFyIHp3ID0gMDtcbiAgICAgICAgICAgIHZhciBzdyA9IDA7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gZWFjaCBjb250cm9sIHBvaW50IHRvIGNlbGwncyBjZW50cm9pZFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUG9pbnRzLmZlYXR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBkaXN0YW5jZShjZW50cm9pZChzYW1wbGluZ0dyaWQuZmVhdHVyZXNbaV0pLCBjb250cm9sUG9pbnRzLmZlYXR1cmVzW2pdLCB1bml0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgencgPSBjb250cm9sUG9pbnRzLmZlYXR1cmVzW2pdLnByb3BlcnRpZXNbdmFsdWVGaWVsZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3ID0gMS4wIC8gTWF0aC5wb3coZCwgYik7XG4gICAgICAgICAgICAgICAgc3cgKz0gdztcbiAgICAgICAgICAgICAgICB6dyArPSB3ICogY29udHJvbFBvaW50cy5mZWF0dXJlc1tqXS5wcm9wZXJ0aWVzW3ZhbHVlRmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd3JpdGUgSURXIHZhbHVlIGZvciBlYWNoIGdyaWQgY2VsbFxuICAgICAgICAgICAgc2FtcGxpbmdHcmlkLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMueiA9IHp3IC8gc3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhbXBsaW5nR3JpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnU3BlY2lmaWVkIERhdGEgRmllbGQgaXMgTWlzc2luZycpO1xuICAgIH1cbn07XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50Jyk7XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXZlbiVFMiU4MCU5M29kZF9ydWxlXG4vLyBtb2RpZmllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gd2hpY2ggd2FzIG1vZGlmaWVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIFBvaW50fSBhbmQgYSB7QGxpbmsgUG9seWdvbn0gb3Ige0BsaW5rIE11bHRpUG9seWdvbn0gYW5kIGRldGVybWluZXMgaWYgdGhlIHBvaW50IHJlc2lkZXMgaW5zaWRlIHRoZSBwb2x5Z29uLiBUaGUgcG9seWdvbiBjYW5cbiAqIGJlIGNvbnZleCBvciBjb25jYXZlLiBUaGUgZnVuY3Rpb24gYWNjb3VudHMgZm9yIGhvbGVzLlxuICpcbiAqIEBuYW1lIGluc2lkZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQgaW5wdXQgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTwoUG9seWdvbnxNdWx0aVBvbHlnb24pPn0gcG9seWdvbiBpbnB1dCBwb2x5Z29uIG9yIG11bHRpcG9seWdvblxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgUG9pbnQgaXMgaW5zaWRlIHRoZSBQb2x5Z29uOyBgZmFsc2VgIGlmIHRoZSBQb2ludCBpcyBub3QgaW5zaWRlIHRoZSBQb2x5Z29uXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0gdHVyZi5wb2ludChbLTc3LCA0NF0pO1xuICogdmFyIHBvbHkgPSB0dXJmLnBvbHlnb24oW1tcbiAqICAgWy04MSwgNDFdLFxuICogICBbLTgxLCA0N10sXG4gKiAgIFstNzIsIDQ3XSxcbiAqICAgWy03MiwgNDFdLFxuICogICBbLTgxLCA0MV1cbiAqIF1dKTtcbiAqXG4gKiB2YXIgaXNJbnNpZGUgPSB0dXJmLmluc2lkZShwdCwgcG9seSk7XG4gKlxuICogLy89aXNJbnNpZGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnQsIHBvbHlnb24pIHtcbiAgICB2YXIgcHQgPSBpbnZhcmlhbnQuZ2V0Q29vcmQocG9pbnQpO1xuICAgIHZhciBwb2x5cyA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgLy8gbm9ybWFsaXplIHRvIG11bHRpcG9seWdvblxuICAgIGlmIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykgcG9seXMgPSBbcG9seXNdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGluc2lkZVBvbHkgPSBmYWxzZTsgaSA8IHBvbHlzLmxlbmd0aCAmJiAhaW5zaWRlUG9seTsgaSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBvdXRlciByaW5nIGZpcnN0XG4gICAgICAgIGlmIChpblJpbmcocHQsIHBvbHlzW2ldWzBdKSkge1xuICAgICAgICAgICAgdmFyIGluSG9sZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBwb2ludCBpbiBhbnkgb2YgdGhlIGhvbGVzXG4gICAgICAgICAgICB3aGlsZSAoayA8IHBvbHlzW2ldLmxlbmd0aCAmJiAhaW5Ib2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluUmluZyhwdCwgcG9seXNbaV1ba10sIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluSG9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5Ib2xlKSBpbnNpZGVQb2x5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlUG9seTtcbn07XG5cbi8vIHB0IGlzIFt4LHldIGFuZCByaW5nIGlzIFtbeCx5XSwgW3gseV0sLi5dXG5mdW5jdGlvbiBpblJpbmcocHQsIHJpbmcsIGlnbm9yZUJvdW5kYXJ5KSB7XG4gICAgdmFyIGlzSW5zaWRlID0gZmFsc2U7XG4gICAgaWYgKHJpbmdbMF1bMF0gPT09IHJpbmdbcmluZy5sZW5ndGggLSAxXVswXSAmJiByaW5nWzBdWzFdID09PSByaW5nW3JpbmcubGVuZ3RoIC0gMV1bMV0pIHJpbmcgPSByaW5nLnNsaWNlKDAsIHJpbmcubGVuZ3RoIC0gMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciB4aSA9IHJpbmdbaV1bMF0sIHlpID0gcmluZ1tpXVsxXTtcbiAgICAgICAgdmFyIHhqID0gcmluZ1tqXVswXSwgeWogPSByaW5nW2pdWzFdO1xuICAgICAgICB2YXIgb25Cb3VuZGFyeSA9IChwdFsxXSAqICh4aSAtIHhqKSArIHlpICogKHhqIC0gcHRbMF0pICsgeWogKiAocHRbMF0gLSB4aSkgPT09IDApICYmXG4gICAgICAgICAgICAoKHhpIC0gcHRbMF0pICogKHhqIC0gcHRbMF0pIDw9IDApICYmICgoeWkgLSBwdFsxXSkgKiAoeWogLSBwdFsxXSkgPD0gMCk7XG4gICAgICAgIGlmIChvbkJvdW5kYXJ5KSByZXR1cm4gIWlnbm9yZUJvdW5kYXJ5O1xuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gKCh5aSA+IHB0WzFdKSAhPT0gKHlqID4gcHRbMV0pKSAmJlxuICAgICAgICAocHRbMF0gPCAoeGogLSB4aSkgKiAocHRbMV0gLSB5aSkgLyAoeWogLSB5aSkgKyB4aSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3QpIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgIH1cbiAgICByZXR1cm4gaXNJbnNpZGU7XG59XG4iLCIvLyBkZXBlbmQgb24ganN0cyBmb3Igbm93IGh0dHA6Ly9iam9ybmhhcnJ0ZWxsLmdpdGh1Yi5pby9qc3RzL1xudmFyIGpzdHMgPSByZXF1aXJlKCdqc3RzJyk7XG5cbi8qKlxuICogVGFrZXMgdHdvIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBhbmQgZmluZHMgdGhlaXIgaW50ZXJzZWN0aW9uLiBJZiB0aGV5IHNoYXJlIGEgYm9yZGVyLCByZXR1cm5zIHRoZSBib3JkZXI7IGlmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAbmFtZSBpbnRlcnNlY3RcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcG9seTEgdGhlIGZpcnN0IHBvbHlnb25cbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcG9seTIgdGhlIHNlY29uZCBwb2x5Z29uXG4gKiBAcmV0dXJucyB7KEZlYXR1cmV8dW5kZWZpbmVkKX0gcmV0dXJucyBhIGZlYXR1cmUgcmVwcmVzZW50aW5nIHRoZSBwb2ludChzKSB0aGV5IHNoYXJlIChpbiBjYXNlIG9mIGEge0BsaW5rIFBvaW50fSAgb3Ige0BsaW5rIE11bHRpUG9pbnR9KSwgdGhlIGJvcmRlcnMgdGhleSBzaGFyZSAoaW4gY2FzZSBvZiBhIHtAbGluayBMaW5lU3RyaW5nfSBvciBhIHtAbGluayBNdWx0aUxpbmVTdHJpbmd9KSwgdGhlIGFyZWEgdGhleSBzaGFyZSAoaW4gY2FzZSBvZiB7QGxpbmsgUG9seWdvbn0gb3Ige0BsaW5rIE11bHRpUG9seWdvbn0pLiBJZiB0aGV5IGRvIG5vdCBzaGFyZSBhbnkgcG9pbnQsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkxID0gdHVyZi5wb2x5Z29uKFtbXG4gKiAgIFstMTIyLjgwMTc0MiwgNDUuNDg1NjVdLFxuICogICBbLTEyMi44MDE3NDIsIDQ1LjYwNDkxXSxcbiAqICAgWy0xMjIuNTg0NzYyLCA0NS42MDQ5MV0sXG4gKiAgIFstMTIyLjU4NDc2MiwgNDUuNDg1NjVdLFxuICogICBbLTEyMi44MDE3NDIsIDQ1LjQ4NTY1XVxuICogXV0pO1xuICpcbiAqIHZhciBwb2x5MiA9IHR1cmYucG9seWdvbihbW1xuICogICBbLTEyMi41MjAyMTcsIDQ1LjUzNTY5M10sXG4gKiAgIFstMTIyLjY0MDM4LCA0NS41NTM5NjddLFxuICogICBbLTEyMi43MjAwMzEsIDQ1LjUyNjU1NF0sXG4gKiAgIFstMTIyLjY2OTkwNiwgNDUuNTA3MzA5XSxcbiAqICAgWy0xMjIuNzIzNDY0LCA0NS40NDY2NDNdLFxuICogICBbLTEyMi41MzI1NzcsIDQ1LjQwODU3NF0sXG4gKiAgIFstMTIyLjQ4NzI1OCwgNDUuNDc3NDY2XSxcbiAqICAgWy0xMjIuNTIwMjE3LCA0NS41MzU2OTNdXG4gKiBdXSk7XG4gKlxuICogdmFyIGludGVyc2VjdGlvbiA9IHR1cmYuaW50ZXJzZWN0KHBvbHkxLCBwb2x5Mik7XG4gKlxuICogLy89aW50ZXJzZWN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvbHkxLCBwb2x5Mikge1xuICAgIHZhciBnZW9tMSwgZ2VvbTI7XG4gICAgaWYgKHBvbHkxLnR5cGUgPT09ICdGZWF0dXJlJykgZ2VvbTEgPSBwb2x5MS5nZW9tZXRyeTtcbiAgICBlbHNlIGdlb20xID0gcG9seTE7XG4gICAgaWYgKHBvbHkyLnR5cGUgPT09ICdGZWF0dXJlJykgZ2VvbTIgPSBwb2x5Mi5nZW9tZXRyeTtcbiAgICBlbHNlIGdlb20yID0gcG9seTI7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgYSA9IHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KGdlb20xKSk7XG4gICAgdmFyIGIgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShnZW9tMikpO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBhLmludGVyc2VjdGlvbihiKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05Xcml0ZXIoKTtcblxuICAgIHZhciBnZW9qc29uR2VvbWV0cnkgPSB3cml0ZXIud3JpdGUoaW50ZXJzZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBnZW9tZXRyeTogZ2VvanNvbkdlb21ldHJ5XG4gICAgfTtcbn07XG4iLCIvKipcbiAqIFVud3JhcCBhIGNvb3JkaW5hdGUgZnJvbSBhIFBvaW50IEZlYXR1cmUsIEdlb21ldHJ5IG9yIGEgc2luZ2xlIGNvb3JkaW5hdGUuXG4gKlxuICogQG5hbWUgZ2V0Q29vcmRcbiAqIEBwYXJhbSB7QXJyYXk8YW55PnxHZW9tZXRyeXxGZWF0dXJlPFBvaW50Pn0gb2JqIGFueSB2YWx1ZVxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gKi9cbmZ1bmN0aW9uIGdldENvb3JkKG9iaikge1xuICAgIGlmICghb2JqKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG9iaiBwYXNzZWQnKTtcblxuICAgIHZhciBjb29yZGluYXRlcyA9IGdldENvb3JkcyhvYmopO1xuXG4gICAgLy8gZ2V0Q29vcmQoKSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgdHdvIG51bWJlcnMgKFBvaW50KVxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxICYmXG4gICAgICAgIHR5cGVvZiBjb29yZGluYXRlc1swXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGNvb3JkaW5hdGVzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlIGlzIG5vdCBhIHZhbGlkIFBvaW50Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVud3JhcCBjb29yZGluYXRlcyBmcm9tIGEgRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5IG9mIG51bWJlcnNcbiAqXG4gKiBAbmFtZSBnZXRDb29yZHNcbiAqIEBwYXJhbSB7QXJyYXk8YW55PnxHZW9tZXRyeXxGZWF0dXJlPGFueT59IG9iaiBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheTxhbnk+fSBjb29yZGluYXRlc1xuICovXG5mdW5jdGlvbiBnZXRDb29yZHMob2JqKSB7XG4gICAgaWYgKCFvYmopIHRocm93IG5ldyBFcnJvcignTm8gb2JqIHBhc3NlZCcpO1xuICAgIHZhciBjb29yZGluYXRlcztcblxuICAgIC8vIEFycmF5IG9mIG51bWJlcnNcbiAgICBpZiAob2JqLmxlbmd0aCkge1xuICAgICAgICBjb29yZGluYXRlcyA9IG9iajtcblxuICAgIC8vIEdlb21ldHJ5IE9iamVjdFxuICAgIH0gZWxzZSBpZiAob2JqLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzID0gb2JqLmNvb3JkaW5hdGVzO1xuXG4gICAgLy8gRmVhdHVyZVxuICAgIH0gZWxzZSBpZiAob2JqLmdlb21ldHJ5ICYmIG9iai5nZW9tZXRyeS5jb29yZGluYXRlcykge1xuICAgICAgICBjb29yZGluYXRlcyA9IG9iai5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGlmIGNvb3JkaW5hdGVzIGNvbnRhaW5zIGEgbnVtYmVyXG4gICAgaWYgKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNvbnRhaW5zTnVtYmVyKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNvb3JkaW5hdGVzJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGNvb3JkaW5hdGVzIGNvbnRhaW5zIGEgbnVtYmVyXG4gKlxuICogQG5hbWUgY29udGFpbnNOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXMgR2VvSlNPTiBDb29yZGluYXRlc1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgQXJyYXkgY29udGFpbnMgYSBudW1iZXJcbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOdW1iZXIoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICB0eXBlb2YgY29vcmRpbmF0ZXNbMF0gPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBjb29yZGluYXRlc1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pICYmIGNvb3JkaW5hdGVzWzBdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29udGFpbnNOdW1iZXIoY29vcmRpbmF0ZXNbMF0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvb3JkaW5hdGVzIG11c3Qgb25seSBjb250YWluIG51bWJlcnMnKTtcbn1cblxuLyoqXG4gKiBFbmZvcmNlIGV4cGVjdGF0aW9ucyBhYm91dCB0eXBlcyBvZiBHZW9KU09OIG9iamVjdHMgZm9yIFR1cmYuXG4gKlxuICogQG5hbWUgZ2VvanNvblR5cGVcbiAqIEBwYXJhbSB7R2VvSlNPTn0gdmFsdWUgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBleHBlY3RlZCBHZW9KU09OIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxuICogQHRocm93cyB7RXJyb3J9IGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2VvanNvblR5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBpZiAoIXR5cGUgfHwgIW5hbWUpIHRocm93IG5ldyBFcnJvcigndHlwZSBhbmQgbmFtZSByZXF1aXJlZCcpO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICc6IG11c3QgYmUgYSAnICsgdHlwZSArICcsIGdpdmVuICcgKyB2YWx1ZS50eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmV9IGlucHV0cyBmb3IgVHVyZi5cbiAqIEludGVybmFsbHkgdGhpcyB1c2VzIHtAbGluayBnZW9qc29uVHlwZX0gdG8ganVkZ2UgZ2VvbWV0cnkgdHlwZXMuXG4gKlxuICogQG5hbWUgZmVhdHVyZU9mXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgYSBmZWF0dXJlIHdpdGggYW4gZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBlcnJvciBpZiB2YWx1ZSBpcyBub3QgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVPZihmZWF0dXJlLCB0eXBlLCBuYW1lKSB7XG4gICAgaWYgKCFmZWF0dXJlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZlYXR1cmUgcGFzc2VkJyk7XG4gICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJy5mZWF0dXJlT2YoKSByZXF1aXJlcyBhIG5hbWUnKTtcbiAgICBpZiAoIWZlYXR1cmUgfHwgZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScgfHwgIWZlYXR1cmUuZ2VvbWV0cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJywgRmVhdHVyZSB3aXRoIGdlb21ldHJ5IHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJzogbXVzdCBiZSBhICcgKyB0eXBlICsgJywgZ2l2ZW4gJyArIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gaW5wdXRzIGZvciBUdXJmLlxuICogSW50ZXJuYWxseSB0aGlzIHVzZXMge0BsaW5rIGdlb2pzb25UeXBlfSB0byBqdWRnZSBnZW9tZXRyeSB0eXBlcy5cbiAqXG4gKiBAbmFtZSBjb2xsZWN0aW9uT2ZcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb259IGZlYXR1cmVDb2xsZWN0aW9uIGEgRmVhdHVyZUNvbGxlY3Rpb24gZm9yIHdoaWNoIGZlYXR1cmVzIHdpbGwgYmUganVkZ2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBleHBlY3RlZCBHZW9KU09OIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxuICogQHRocm93cyB7RXJyb3J9IGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdGlvbk9mKGZlYXR1cmVDb2xsZWN0aW9uLCB0eXBlLCBuYW1lKSB7XG4gICAgaWYgKCFmZWF0dXJlQ29sbGVjdGlvbikgdGhyb3cgbmV3IEVycm9yKCdObyBmZWF0dXJlQ29sbGVjdGlvbiBwYXNzZWQnKTtcbiAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcignLmNvbGxlY3Rpb25PZigpIHJlcXVpcmVzIGEgbmFtZScpO1xuICAgIGlmICghZmVhdHVyZUNvbGxlY3Rpb24gfHwgZmVhdHVyZUNvbGxlY3Rpb24udHlwZSAhPT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnLCBGZWF0dXJlQ29sbGVjdGlvbiByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbaV07XG4gICAgICAgIGlmICghZmVhdHVyZSB8fCBmZWF0dXJlLnR5cGUgIT09ICdGZWF0dXJlJyB8fCAhZmVhdHVyZS5nZW9tZXRyeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJywgRmVhdHVyZSB3aXRoIGdlb21ldHJ5IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJzogbXVzdCBiZSBhICcgKyB0eXBlICsgJywgZ2l2ZW4gJyArIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdlb2pzb25UeXBlOiBnZW9qc29uVHlwZSxcbiAgICBjb2xsZWN0aW9uT2Y6IGNvbGxlY3Rpb25PZixcbiAgICBmZWF0dXJlT2Y6IGZlYXR1cmVPZixcbiAgICBnZXRDb29yZDogZ2V0Q29vcmQsXG4gICAgZ2V0Q29vcmRzOiBnZXRDb29yZHMsXG4gICAgY29udGFpbnNOdW1iZXI6IGNvbnRhaW5zTnVtYmVyXG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxMCwgSmFzb24gRGF2aWVzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGNvZGUgaXMgYmFzZWQgb24gQnJhZGxleSBXaGl0ZSdzIEphdmEgdmVyc2lvbixcbiAqIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gTmljaG9sYXMgWXVlJ3MgQysrIHZlcnNpb24sIHdoaWNoIGluIHR1cm4gaXMgYmFzZWRcbiAqIG9uIFBhdWwgRC4gQm91cmtlJ3Mgb3JpZ2luYWwgRm9ydHJhbiB2ZXJzaW9uLiAgU2VlIGJlbG93IGZvciB0aGUgcmVzcGVjdGl2ZVxuICogY29weXJpZ2h0IG5vdGljZXMuXG4gKlxuICogU2VlIGh0dHA6Ly9sb2NhbC53YXNwLnV3YS5lZHUuYXUvfnBib3Vya2UvcGFwZXJzL2NvbnJlYy8gZm9yIHRoZSBvcmlnaW5hbFxuICogcGFwZXIgYnkgUGF1bCBELiBCb3Vya2UuXG4gKlxuICogVGhlIHZlY3RvciBjb252ZXJzaW9uIGNvZGUgaXMgYmFzZWQgb24gaHR0cDovL2FwcHRyZWUubmV0L2NvbnJlYy5odG0gYnlcbiAqIEdyYWhhbSBDb3guXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIDxvcmdhbml6YXRpb24+IG5vciB0aGVcbiAqICAgICAgIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiAgICAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAqIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKiAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAqIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAqIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMTk5Ni0xOTk3IE5pY2hvbGFzIFl1ZVxuICpcbiAqIFRoaXMgc29mdHdhcmUgaXMgY29weXJpZ2h0ZWQgYnkgTmljaG9sYXMgWXVlLiBUaGlzIGNvZGUgaXMgYmFzZWQgb24gUGF1bCBELlxuICogQm91cmtlJ3MgQ09OUkVDLkYgcm91dGluZS5cbiAqXG4gKiBUaGUgYXV0aG9ycyBoZXJlYnkgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UsIGNvcHksIGFuZCBkaXN0cmlidXRlIHRoaXNcbiAqIHNvZnR3YXJlIGFuZCBpdHMgZG9jdW1lbnRhdGlvbiBmb3IgYW55IHB1cnBvc2UsIHByb3ZpZGVkIHRoYXQgZXhpc3RpbmdcbiAqIGNvcHlyaWdodCBub3RpY2VzIGFyZSByZXRhaW5lZCBpbiBhbGwgY29waWVzIGFuZCB0aGF0IHRoaXMgbm90aWNlIGlzXG4gKiBpbmNsdWRlZCB2ZXJiYXRpbSBpbiBhbnkgZGlzdHJpYnV0aW9ucy4gQWRkaXRpb25hbGx5LCB0aGUgYXV0aG9ycyBncmFudFxuICogcGVybWlzc2lvbiB0byBtb2RpZnkgdGhpcyBzb2Z0d2FyZSBhbmQgaXRzIGRvY3VtZW50YXRpb24gZm9yIGFueSBwdXJwb3NlLFxuICogcHJvdmlkZWQgdGhhdCBzdWNoIG1vZGlmaWNhdGlvbnMgYXJlIG5vdCBkaXN0cmlidXRlZCB3aXRob3V0IHRoZSBleHBsaWNpdFxuICogY29uc2VudCBvZiB0aGUgYXV0aG9ycyBhbmQgdGhhdCBleGlzdGluZyBjb3B5cmlnaHQgbm90aWNlcyBhcmUgcmV0YWluZWQgaW5cbiAqIGFsbCBjb3BpZXMuIFNvbWUgb2YgdGhlIGFsZ29yaXRobXMgaW1wbGVtZW50ZWQgYnkgdGhpcyBzb2Z0d2FyZSBhcmVcbiAqIHBhdGVudGVkLCBvYnNlcnZlIGFsbCBhcHBsaWNhYmxlIHBhdGVudCBsYXcuXG4gKlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgRElTVFJJQlVUT1JTIEJFIExJQUJMRSBUTyBBTlkgUEFSVFkgRk9SXG4gKiBESVJFQ1QsIElORElSRUNULCBTUEVDSUFMLCBJTkNJREVOVEFMLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgQVJJU0lORyBPVVRcbiAqIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgSVRTIERPQ1VNRU5UQVRJT04sIE9SIEFOWSBERVJJVkFUSVZFUyBUSEVSRU9GLFxuICogRVZFTiBJRiBUSEUgQVVUSE9SUyBIQVZFIEJFRU4gQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVEhFIEFVVEhPUlMgQU5EIERJU1RSSUJVVE9SUyBTUEVDSUZJQ0FMTFkgRElTQ0xBSU0gQU5ZIFdBUlJBTlRJRVMsXG4gKiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSwgQU5EIE5PTi1JTkZSSU5HRU1FTlQuICBUSElTIFNPRlRXQVJFIElTXG4gKiBQUk9WSURFRCBPTiBBTiBcIkFTIElTXCIgQkFTSVMsIEFORCBUSEUgQVVUSE9SUyBBTkQgRElTVFJJQlVUT1JTIEhBVkUgTk9cbiAqIE9CTElHQVRJT04gVE8gUFJPVklERSBNQUlOVEVOQU5DRSwgU1VQUE9SVCwgVVBEQVRFUywgRU5IQU5DRU1FTlRTLCBPUlxuICogTU9ESUZJQ0FUSU9OUy5cbiAqL1xuXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBDb25yZWM7XG5cbiAgdmFyIEVQU0lMT04gPSAxZS0xMDtcblxuICBmdW5jdGlvbiBwb2ludHNFcXVhbChhLCBiKSB7XG4gICAgICB2YXIgeCA9IGEueCAtIGIueCwgeSA9IGEueSAtIGIueTtcbiAgICAgIHJldHVybiB4ICogeCArIHkgKiB5IDwgRVBTSUxPTjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2VMaXN0KGxpc3QpIHtcbiAgICAgIHZhciBwcCA9IGxpc3QuaGVhZDtcblxuICAgICAgd2hpbGUgKHBwKSB7XG4gICAgICAvLyBzd2FwIHByZXYvbmV4dCBwb2ludGVyc1xuICAgICAgICAgIHZhciB0ZW1wID0gcHAubmV4dDtcbiAgICAgICAgICBwcC5uZXh0ID0gcHAucHJldjtcbiAgICAgICAgICBwcC5wcmV2ID0gdGVtcDtcblxuICAgICAgLy8gY29udGludWUgdGhyb3VnaCB0aGUgbGlzdFxuICAgICAgICAgIHBwID0gdGVtcDtcbiAgICAgIH1cblxuICAgIC8vIHN3YXAgaGVhZC90YWlsIHBvaW50ZXJzXG4gICAgICB2YXIgdGVtcCA9IGxpc3QuaGVhZDtcbiAgICAgIGxpc3QuaGVhZCA9IGxpc3QudGFpbDtcbiAgICAgIGxpc3QudGFpbCA9IHRlbXA7XG4gIH1cblxuICBmdW5jdGlvbiBDb250b3VyQnVpbGRlcihsZXZlbCkge1xuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgdGhpcy5zID0gbnVsbDtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG4gIENvbnRvdXJCdWlsZGVyLnByb3RvdHlwZS5yZW1vdmVfc2VxID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAvLyBpZiBsaXN0IGlzIHRoZSBmaXJzdCBpdGVtLCBzdGF0aWMgcHRyIHMgaXMgdXBkYXRlZFxuICAgICAgaWYgKGxpc3QucHJldikge1xuICAgICAgICAgIGxpc3QucHJldi5uZXh0ID0gbGlzdC5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnMgPSBsaXN0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0Lm5leHQpIHtcbiAgICAgICAgICBsaXN0Lm5leHQucHJldiA9IGxpc3QucHJldjtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5jb3VudDtcbiAgfTtcbiAgQ29udG91ckJ1aWxkZXIucHJvdG90eXBlLmFkZFNlZ21lbnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIHNzID0gdGhpcy5zO1xuICAgICAgdmFyIG1hID0gbnVsbDtcbiAgICAgIHZhciBtYiA9IG51bGw7XG4gICAgICB2YXIgcHJlcGVuZEEgPSBmYWxzZTtcbiAgICAgIHZhciBwcmVwZW5kQiA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoc3MpIHtcbiAgICAgICAgICBpZiAobWEgPT0gbnVsbCkge1xuICAgICAgICAvLyBubyBtYXRjaCBmb3IgYSB5ZXRcbiAgICAgICAgICAgICAgaWYgKHBvaW50c0VxdWFsKGEsIHNzLmhlYWQucCkpIHtcbiAgICAgICAgICAgICAgICAgIG1hID0gc3M7XG4gICAgICAgICAgICAgICAgICBwcmVwZW5kQSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRzRXF1YWwoYSwgc3MudGFpbC5wKSkge1xuICAgICAgICAgICAgICAgICAgbWEgPSBzcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWIgPT0gbnVsbCkge1xuICAgICAgICAvLyBubyBtYXRjaCBmb3IgYiB5ZXRcbiAgICAgICAgICAgICAgaWYgKHBvaW50c0VxdWFsKGIsIHNzLmhlYWQucCkpIHtcbiAgICAgICAgICAgICAgICAgIG1iID0gc3M7XG4gICAgICAgICAgICAgICAgICBwcmVwZW5kQiA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRzRXF1YWwoYiwgc3MudGFpbC5wKSkge1xuICAgICAgICAgICAgICAgICAgbWIgPSBzcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIC8vIGlmIHdlIG1hdGNoZWQgYm90aCBubyBuZWVkIHRvIGNvbnRpbnVlIHNlYXJjaGluZ1xuICAgICAgICAgIGlmIChtYiAhPSBudWxsICYmIG1hICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3MgPSBzcy5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIGMgaXMgdGhlIGNhc2Ugc2VsZWN0b3IgYmFzZWQgb24gd2hpY2ggb2YgbWEgYW5kL29yIG1iIGFyZSBzZXRcbiAgICAgIHZhciBjID0gKChtYSAhPSBudWxsKSA/IDEgOiAwKSB8ICgobWIgIT0gbnVsbCkgPyAyIDogMCk7XG5cbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSAwOiAgIC8vIGJvdGggdW5tYXRjaGVkLCBhZGQgYXMgbmV3IHNlcXVlbmNlXG4gICAgICAgICAgdmFyIGFhID0ge3A6IGEsIHByZXY6IG51bGx9O1xuICAgICAgICAgIHZhciBiYiA9IHtwOiBiLCBuZXh0OiBudWxsfTtcbiAgICAgICAgICBhYS5uZXh0ID0gYmI7XG4gICAgICAgICAgYmIucHJldiA9IGFhO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzZXF1ZW5jZSBlbGVtZW50IGFuZCBwdXNoIG9udG8gaGVhZCBvZiBtYWluIGxpc3QuIFRoZSBvcmRlclxuICAgICAgICAvLyBvZiBpdGVtcyBpbiB0aGlzIGxpc3QgaXMgdW5pbXBvcnRhbnRcbiAgICAgICAgICBtYSA9IHtoZWFkOiBhYSwgdGFpbDogYmIsIG5leHQ6IHRoaXMucywgcHJldjogbnVsbCwgY2xvc2VkOiBmYWxzZX07XG4gICAgICAgICAgaWYgKHRoaXMucykge1xuICAgICAgICAgICAgICB0aGlzLnMucHJldiA9IG1hO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnMgPSBtYTtcblxuICAgICAgICAgICsrdGhpcy5jb3VudDsgICAgLy8gbm90IGVzc2VudGlhbCAtIHRyYWNrcyBudW1iZXIgb2YgdW5tZXJnZWQgc2VxdWVuY2VzXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTogICAvLyBhIG1hdGNoZWQsIGIgZGlkIG5vdCAtIHRodXMgYiBleHRlbmRzIHNlcXVlbmNlIG1hXG4gICAgICAgICAgdmFyIHBwID0ge3A6IGJ9O1xuXG4gICAgICAgICAgaWYgKHByZXBlbmRBKSB7XG4gICAgICAgICAgICAgIHBwLm5leHQgPSBtYS5oZWFkO1xuICAgICAgICAgICAgICBwcC5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgICAgbWEuaGVhZC5wcmV2ID0gcHA7XG4gICAgICAgICAgICAgIG1hLmhlYWQgPSBwcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgcHAucHJldiA9IG1hLnRhaWw7XG4gICAgICAgICAgICAgIG1hLnRhaWwubmV4dCA9IHBwO1xuICAgICAgICAgICAgICBtYS50YWlsID0gcHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6ICAgLy8gYiBtYXRjaGVkLCBhIGRpZCBub3QgLSB0aHVzIGEgZXh0ZW5kcyBzZXF1ZW5jZSBtYlxuICAgICAgICAgIHZhciBwcCA9IHtwOiBhfTtcblxuICAgICAgICAgIGlmIChwcmVwZW5kQikge1xuICAgICAgICAgICAgICBwcC5uZXh0ID0gbWIuaGVhZDtcbiAgICAgICAgICAgICAgcHAucHJldiA9IG51bGw7XG4gICAgICAgICAgICAgIG1iLmhlYWQucHJldiA9IHBwO1xuICAgICAgICAgICAgICBtYi5oZWFkID0gcHA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgIHBwLnByZXYgPSBtYi50YWlsO1xuICAgICAgICAgICAgICBtYi50YWlsLm5leHQgPSBwcDtcbiAgICAgICAgICAgICAgbWIudGFpbCA9IHBwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOiAgIC8vIGJvdGggbWF0Y2hlZCwgY2FuIG1lcmdlIHNlcXVlbmNlc1xuICAgICAgICAvLyBpZiB0aGUgc2VxdWVuY2VzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZywgYXMgd2UgYXJlIHNpbXBseSBjbG9zaW5nIHRoaXMgcGF0aCAoY291bGQgc2V0IGEgZmxhZylcblxuICAgICAgICAgIGlmIChtYSA9PT0gbWIpIHtcbiAgICAgICAgICAgICAgdmFyIHBwID0ge3A6IG1hLnRhaWwucCwgbmV4dDogbWEuaGVhZCwgcHJldjogbnVsbH07XG4gICAgICAgICAgICAgIG1hLmhlYWQucHJldiA9IHBwO1xuICAgICAgICAgICAgICBtYS5oZWFkID0gcHA7XG4gICAgICAgICAgICAgIG1hLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyB0aGVyZSBhcmUgNCB3YXlzIHRoZSBzZXF1ZW5jZSBwYWlyIGNhbiBiZSBqb2luZWQuIFRoZSBjdXJyZW50IHNldHRpbmcgb2YgcHJlcGVuZEEgYW5kXG4gICAgICAgIC8vIHByZXBlbmRCIHdpbGwgdGVsbCB1cyB3aGljaCB0eXBlIG9mIGpvaW4gaXMgbmVlZGVkLiBGb3IgaGVhZC9oZWFkIGFuZCB0YWlsL3RhaWwgam9pbnNcbiAgICAgICAgLy8gb25lIHNlcXVlbmNlIG5lZWRzIHRvIGJlIHJldmVyc2VkXG4gICAgICAgICAgc3dpdGNoICgocHJlcGVuZEEgPyAxIDogMCkgfCAocHJlcGVuZEIgPyAyIDogMCkpIHtcbiAgICAgICAgICBjYXNlIDA6ICAgLy8gdGFpbC10YWlsXG4gICAgICAgICAgICAvLyByZXZlcnNlIG1hIGFuZCBhcHBlbmQgdG8gbWJcbiAgICAgICAgICAgICAgcmV2ZXJzZUxpc3QobWEpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIGhlYWQvdGFpbCBjYXNlXG4gICAgICAgICAgY2FzZSAxOiAgIC8vIGhlYWQtdGFpbFxuICAgICAgICAgICAgLy8gbWEgaXMgYXBwZW5kZWQgdG8gbWIgYW5kIG1hIGRpc2NhcmRlZFxuICAgICAgICAgICAgICBtYi50YWlsLm5leHQgPSBtYS5oZWFkO1xuICAgICAgICAgICAgICBtYS5oZWFkLnByZXYgPSBtYi50YWlsO1xuICAgICAgICAgICAgICBtYi50YWlsID0gbWEudGFpbDtcblxuICAgICAgICAgICAgLy9kaXNjYXJkIG1hIHNlcXVlbmNlIHJlY29yZFxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZV9zZXEobWEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzogICAvLyBoZWFkLWhlYWRcbiAgICAgICAgICAgIC8vIHJldmVyc2UgbWEgYW5kIGFwcGVuZCBtYiB0byBpdFxuICAgICAgICAgICAgICByZXZlcnNlTGlzdChtYSk7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGFpbC9oZWFkIGNhc2VcbiAgICAgICAgICBjYXNlIDI6ICAgLy8gdGFpbC1oZWFkXG4gICAgICAgICAgICAvLyBtYiBpcyBhcHBlbmRlZCB0byBtYSBhbmQgbWIgaXMgZGlzY2FyZGVkXG4gICAgICAgICAgICAgIG1hLnRhaWwubmV4dCA9IG1iLmhlYWQ7XG4gICAgICAgICAgICAgIG1iLmhlYWQucHJldiA9IG1hLnRhaWw7XG4gICAgICAgICAgICAgIG1hLnRhaWwgPSBtYi50YWlsO1xuXG4gICAgICAgICAgICAvL2Rpc2NhcmQgbWIgc2VxdWVuY2UgcmVjb3JkXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlX3NlcShtYik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBJbXBsZW1lbnRzIENPTlJFQy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZHJhd0NvbnRvdXIgZnVuY3Rpb24gZm9yIGRyYXdpbmcgY29udG91ci4gIERlZmF1bHRzIHRvIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tIFwiY29udG91ciBidWlsZGVyXCIsIHdoaWNoIHBvcHVsYXRlcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udG91cnMgcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBDb25yZWMoZHJhd0NvbnRvdXIpIHtcbiAgICAgIGlmICghZHJhd0NvbnRvdXIpIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXM7XG4gICAgICAgICAgYy5jb250b3VycyA9IHt9O1xuICAgICAgLyoqXG4gICAgICAgKiBkcmF3Q29udG91ciAtIGludGVyZmFjZSBmb3IgaW1wbGVtZW50aW5nIHRoZSB1c2VyIHN1cHBsaWVkIG1ldGhvZCB0b1xuICAgICAgICogcmVuZGVyIHRoZSBjb3VudG91cnMuXG4gICAgICAgKlxuICAgICAgICogRHJhd3MgYSBsaW5lIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMuXG4gICAgICAgKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSBzdGFydFggICAgLSBzdGFydCBjb29yZGluYXRlIGZvciBYXG4gICAgICAgKiBAcGFyYW0gc3RhcnRZICAgIC0gc3RhcnQgY29vcmRpbmF0ZSBmb3IgWVxuICAgICAgICogQHBhcmFtIGVuZFggICAgICAtIGVuZCBjb29yZGluYXRlIGZvciBYXG4gICAgICAgKiBAcGFyYW0gZW5kWSAgICAgIC0gZW5kIGNvb3JkaW5hdGUgZm9yIFlcbiAgICAgICAqIEBwYXJhbSBjb250b3VyTGV2ZWwgLSBDb250b3VyIGxldmVsIGZvciBsaW5lLlxuICAgICAgICovXG4gICAgICAgICAgdGhpcy5kcmF3Q29udG91ciA9IGZ1bmN0aW9uIChzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgY29udG91ckxldmVsLCBrKSB7XG4gICAgICAgICAgICAgIHZhciBjYiA9IGMuY29udG91cnNba107XG4gICAgICAgICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgICAgICAgIGNiID0gYy5jb250b3Vyc1trXSA9IG5ldyBDb250b3VyQnVpbGRlcihjb250b3VyTGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNiLmFkZFNlZ21lbnQoe3g6IHN0YXJ0WCwgeTogc3RhcnRZfSwge3g6IGVuZFgsIHk6IGVuZFl9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuY29udG91ckxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gW107XG4gICAgICAgICAgICAgIHZhciBhID0gYy5jb250b3VycztcbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcyA9IGFba10ucztcbiAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IGFba10ubGV2ZWw7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAocykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gcy5oZWFkO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIGwyLmxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgbDIuayA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGggJiYgaC5wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGwyLnB1c2goaC5wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGgubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbC5wdXNoKGwyKTtcbiAgICAgICAgICAgICAgICAgICAgICBzID0gcy5uZXh0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGwuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5rIC0gYi5rOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kcmF3Q29udG91ciA9IGRyYXdDb250b3VyO1xuICAgICAgfVxuICAgICAgdGhpcy5oICA9IG5ldyBBcnJheSg1KTtcbiAgICAgIHRoaXMuc2ggPSBuZXcgQXJyYXkoNSk7XG4gICAgICB0aGlzLnhoID0gbmV3IEFycmF5KDUpO1xuICAgICAgdGhpcy55aCA9IG5ldyBBcnJheSg1KTtcbiAgfVxuXG4gIC8qXG4gICAqIGNvbnRvdXIgaXMgYSBjb250b3VyaW5nIHN1YnJvdXRpbmUgZm9yIHJlY3Rhbmd1bGFyaWx5IHNwYWNlZCBkYXRhXG4gICAqXG4gICAqIEl0IGVtaXRzIGNhbGxzIHRvIGEgbGluZSBkcmF3aW5nIHN1YnJvdXRpbmUgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hpY2hcbiAgICogZHJhd3MgYSBjb250b3VyIG1hcCBjb3JyZXNwb25kaW5nIHRvIHJlYWwqNGRhdGEgb24gYSByYW5kb21seSBzcGFjZWRcbiAgICogcmVjdGFuZ3VsYXIgZ3JpZC4gVGhlIGNvb3JkaW5hdGVzIGVtaXR0ZWQgYXJlIGluIHRoZSBzYW1lIHVuaXRzIGdpdmVuIGluXG4gICAqIHRoZSB4KCkgYW5kIHkoKSBhcnJheXMuXG4gICAqXG4gICAqIEFueSBudW1iZXIgb2YgY29udG91ciBsZXZlbHMgbWF5IGJlIHNwZWNpZmllZCBidXQgdGhleSBtdXN0IGJlIGluIG9yZGVyIG9mXG4gICAqIGluY3JlYXNpbmcgdmFsdWUuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gZCAtIG1hdHJpeCBvZiBkYXRhIHRvIGNvbnRvdXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlsYixpdWIsamxiLGp1YiAtIGluZGV4IGJvdW5kcyBvZiBkYXRhIG1hdHJpeFxuICAgKlxuICAgKiAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHR3bywgb25lIGRpbWVuc2lvbmFsIGFycmF5cyAoeCBhbmQgeSkgY29udGFpblxuICAgKiAgICAgICAgICAgICB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZXMgb2YgZWFjaCBzYW1wbGUgcG9pbnRzLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSB4ICAtIGRhdGEgbWF0cml4IGNvbHVtbiBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge251bWJlcltdfSB5ICAtIGRhdGEgbWF0cml4IHJvdyBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbmMgICAtIG51bWJlciBvZiBjb250b3VyIGxldmVsc1xuICAgKiBAcGFyYW0ge251bWJlcltdfSB6ICAtIGNvbnRvdXIgbGV2ZWxzIGluIGluY3JlYXNpbmcgb3JkZXIuXG4gICAqL1xuICBDb25yZWMucHJvdG90eXBlLmNvbnRvdXIgPSBmdW5jdGlvbiAoZCwgaWxiLCBpdWIsIGpsYiwganViLCB4LCB5LCBuYywgeikge1xuICAgICAgdmFyIGggPSB0aGlzLmgsIHNoID0gdGhpcy5zaCwgeGggPSB0aGlzLnhoLCB5aCA9IHRoaXMueWg7XG4gICAgICB2YXIgZHJhd0NvbnRvdXIgPSB0aGlzLmRyYXdDb250b3VyO1xuICAgICAgdGhpcy5jb250b3VycyA9IHt9O1xuXG4gICAgICB2YXIgeHNlY3QgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgICAgcmV0dXJuIChoW3AyXSAqIHhoW3AxXSAtIGhbcDFdICogeGhbcDJdKSAvIChoW3AyXSAtIGhbcDFdKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB5c2VjdCA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgICByZXR1cm4gKGhbcDJdICogeWhbcDFdIC0gaFtwMV0gKiB5aFtwMl0pIC8gKGhbcDJdIC0gaFtwMV0pO1xuICAgICAgfTtcbiAgICAgIHZhciBtMTtcbiAgICAgIHZhciBtMjtcbiAgICAgIHZhciBtMztcbiAgICAgIHZhciBjYXNlX3ZhbHVlO1xuICAgICAgdmFyIGRtaW47XG4gICAgICB2YXIgZG1heDtcbiAgICAgIHZhciB4MSA9IDAuMDtcbiAgICAgIHZhciB4MiA9IDAuMDtcbiAgICAgIHZhciB5MSA9IDAuMDtcbiAgICAgIHZhciB5MiA9IDAuMDtcblxuICAgIC8vIFRoZSBpbmRleGluZyBvZiBpbSBhbmQgam0gc2hvdWxkIGJlIG5vdGVkIGFzIGl0IGhhcyB0byBzdGFydCBmcm9tIHplcm9cbiAgICAvLyB1bmxpa2UgdGhlIGZvcnRyYW4gY291bnRlciBwYXJ0XG4gICAgICB2YXIgaW0gPSBbMCwgMSwgMSwgMF07XG4gICAgICB2YXIgam0gPSBbMCwgMCwgMSwgMV07XG5cbiAgICAvLyBOb3RlIHRoYXQgY2FzdGFiIGlzIGFycmFuZ2VkIGRpZmZlcmVudGx5IGZyb20gdGhlIEZPUlRSQU4gY29kZSBiZWNhdXNlXG4gICAgLy8gRm9ydHJhbiBhbmQgQy9DKysgYXJyYXlzIGFyZSB0cmFuc3Bvc2VkIG9mIGVhY2ggb3RoZXIsIGluIHRoaXMgY2FzZVxuICAgIC8vIGl0IGlzIG1vcmUgdHJpY2t5IGFzIGNhc3RhYiBpcyBpbiAzIGRpbWVuc2lvbnNcbiAgICAgIHZhciBjYXN0YWIgPSBbXG4gICAgICAgICAgW1xuICAgICAgICBbMCwgMCwgOF0sIFswLCAyLCA1XSwgWzcsIDYsIDldXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbXG4gICAgICAgIFswLCAzLCA0XSwgWzEsIDMsIDFdLCBbNCwgMywgMF1cbiAgICAgICAgICBdLFxuICAgICAgICAgIFtcbiAgICAgICAgWzksIDYsIDddLCBbNSwgMiwgMF0sIFs4LCAwLCAwXVxuICAgICAgICAgIF1cbiAgICAgIF07XG5cbiAgICAgIGZvciAodmFyIGogPSAoanViIC0gMSk7IGogPj0gamxiOyBqLS0pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gaWxiOyBpIDw9IGl1YiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdGVtcDEsIHRlbXAyO1xuICAgICAgICAgICAgICB0ZW1wMSA9IE1hdGgubWluKGRbaV1bal0sIGRbaV1baiArIDFdKTtcbiAgICAgICAgICAgICAgdGVtcDIgPSBNYXRoLm1pbihkW2kgKyAxXVtqXSwgZFtpICsgMV1baiArIDFdKTtcbiAgICAgICAgICAgICAgZG1pbiAgPSBNYXRoLm1pbih0ZW1wMSwgdGVtcDIpO1xuICAgICAgICAgICAgICB0ZW1wMSA9IE1hdGgubWF4KGRbaV1bal0sIGRbaV1baiArIDFdKTtcbiAgICAgICAgICAgICAgdGVtcDIgPSBNYXRoLm1heChkW2kgKyAxXVtqXSwgZFtpICsgMV1baiArIDFdKTtcbiAgICAgICAgICAgICAgZG1heCAgPSBNYXRoLm1heCh0ZW1wMSwgdGVtcDIpO1xuXG4gICAgICAgICAgICAgIGlmIChkbWF4ID49IHpbMF0gJiYgZG1pbiA8PSB6W25jIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh6W2tdID49IGRtaW4gJiYgeltrXSA8PSBkbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSA0OyBtID49IDA7IG0tLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtID4gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGluZGV4aW5nIG9mIGltIGFuZCBqbSBzaG91bGQgYmUgbm90ZWQgYXMgaXQgaGFzIHRvXG4gICAgICAgICAgICAgICAgICAvLyBzdGFydCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhbbV0gPSBkW2kgKyBpbVttIC0gMV1dW2ogKyBqbVttIC0gMV1dIC0geltrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoW21dID0geFtpICsgaW1bbSAtIDFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHloW21dID0geVtqICsgam1bbSAtIDFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhbMF0gPSAwLjI1ICogKGhbMV0gKyBoWzJdICsgaFszXSArIGhbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhbMF0gPSAwLjUgKiAoeFtpXSArIHhbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHloWzBdID0gMC41ICogKHlbal0gKyB5W2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaFttXSA+IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoW21dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoW21dIDwgLUVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaFttXSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICBzaFttXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIE5vdGU6IGF0IHRoaXMgc3RhZ2UgdGhlIHJlbGF0aXZlIGhlaWdodHMgb2YgdGhlIGNvcm5lcnMgYW5kIHRoZVxuICAgICAgICAgICAgICAvLyBjZW50cmUgYXJlIGluIHRoZSBoIGFycmF5LCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29vcmRpbmF0ZXMgYXJlXG4gICAgICAgICAgICAgIC8vIGluIHRoZSB4aCBhbmQgeWggYXJyYXlzLiBUaGUgY2VudHJlIG9mIHRoZSBib3ggaXMgaW5kZXhlZCBieSAwXG4gICAgICAgICAgICAgIC8vIGFuZCB0aGUgNCBjb3JuZXJzIGJ5IDEgdG8gNCBhcyBzaG93biBiZWxvdy5cbiAgICAgICAgICAgICAgLy8gRWFjaCB0cmlhbmdsZSBpcyB0aGVuIGluZGV4ZWQgYnkgdGhlIHBhcmFtZXRlciBtLCBhbmQgdGhlIDNcbiAgICAgICAgICAgICAgLy8gdmVydGljZXMgb2YgZWFjaCB0cmlhbmdsZSBhcmUgaW5kZXhlZCBieSBwYXJhbWV0ZXJzIG0xLG0yLGFuZFxuICAgICAgICAgICAgICAvLyBtMy5cbiAgICAgICAgICAgICAgLy8gSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBjZW50cmUgb2YgdGhlIGJveCBpcyBhbHdheXMgdmVydGV4IDJcbiAgICAgICAgICAgICAgLy8gdGhvdWdoIHRoaXMgaXNpbXBvcnRhbnQgb25seSB3aGVuIGFsbCAzIHZlcnRpY2VzIGxpZSBleGFjdGx5IG9uXG4gICAgICAgICAgICAgIC8vIHRoZSBzYW1lIGNvbnRvdXIgbGV2ZWwsIGluIHdoaWNoIGNhc2Ugb25seSB0aGUgc2lkZSBvZiB0aGUgYm94XG4gICAgICAgICAgICAgIC8vIGlzIGRyYXduLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAgICAgIHZlcnRleCA0ICstLS0tLS0tLS0tLS0tLS0tLS0tKyB2ZXJ0ZXggM1xuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgXFwgICAgICAgICAgICAgICAvIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICAgXFwgICAgbS0zICAgIC8gICB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgICAgXFwgICAgICAgLyAgICAgfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgICAgICAgXFwgICAvICAgICAgIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICBtPTIgICAgWCAgIG09MiAgIHwgICAgICAgdGhlIGNlbnRyZSBpcyB2ZXJ0ZXggMFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgICAgICAgLyAgIFxcICAgICAgIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICAgICAvICAgICAgIFxcICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgIC8gICAgbT0xICAgIFxcICAgfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgLyAgICAgICAgICAgICAgIFxcIHxcbiAgICAgICAgICAgICAgLy8gICAgICB2ZXJ0ZXggMSArLS0tLS0tLS0tLS0tLS0tLS0tLSsgdmVydGV4IDJcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICBTY2FuIGVhY2ggdHJpYW5nbGUgaW4gdGhlIGJveFxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG0gPSAxOyBtIDw9IDQ7IG0rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0xID0gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gIT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTMgPSBtICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2VfdmFsdWUgPSBjYXN0YWJbc2hbbTFdICsgMV1bc2hbbTJdICsgMV1bc2hbbTNdICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhc2VfdmFsdWUgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjYXNlX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBMaW5lIGJldHdlZW4gdmVydGljZXMgMSBhbmQgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhoW20xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5aFttMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geGhbbTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHloW20yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBMaW5lIGJldHdlZW4gdmVydGljZXMgMiBhbmQgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhoW20yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5aFttMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geGhbbTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHloW20zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiAvLyBMaW5lIGJldHdlZW4gdmVydGljZXMgMyBhbmQgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhoW20zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5aFttM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geGhbbTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHloW20xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiAvLyBMaW5lIGJldHdlZW4gdmVydGV4IDEgYW5kIHNpZGUgMi0zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geGhbbTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHloW20xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4c2VjdChtMiwgbTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHlzZWN0KG0yLCBtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gTGluZSBiZXR3ZWVuIHZlcnRleCAyIGFuZCBzaWRlIDMtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhoW20yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5aFttMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geHNlY3QobTMsIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5c2VjdChtMywgbTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IC8vICBMaW5lIGJldHdlZW4gdmVydGV4IDMgYW5kIHNpZGUgMS0yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geGhbbTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHloW20zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4c2VjdChtMSwgbTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHlzZWN0KG0xLCBtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogLy8gTGluZSBiZXR3ZWVuIHNpZGVzIDEtMiBhbmQgMi0zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geHNlY3QobTEsIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5c2VjdChtMSwgbTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhzZWN0KG0yLCBtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geXNlY3QobTIsIG0zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiAvLyBMaW5lIGJldHdlZW4gc2lkZXMgMi0zIGFuZCAzLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4c2VjdChtMiwgbTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHlzZWN0KG0yLCBtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geHNlY3QobTMsIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5c2VjdChtMywgbTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IC8vIExpbmUgYmV0d2VlbiBzaWRlcyAzLTEgYW5kIDEtMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhzZWN0KG0zLCBtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geXNlY3QobTMsIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4c2VjdChtMSwgbTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHlzZWN0KG0xLCBtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFB1dCB5b3VyIHByb2Nlc3NpbmcgY29kZSBoZXJlIGFuZCBjb21tZW50IG91dCB0aGUgcHJpbnRmXG4gICAgICAgICAgICAgICAgICAvL3ByaW50ZihcIiVmICVmICVmICVmICVmXFxuXCIseDEseTEseDIseTIseltrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3Q29udG91cih4MSwgeTEsIHgyLCB5MiwgeltrXSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG4iLCIvL2h0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbmRhdmllcy9jb25yZWMuanNcbi8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjMzMDUvZHJhd2luZy1hLXRvcG9ncmFwaGljYWwtbWFwXG52YXIgdGluID0gcmVxdWlyZSgnQHR1cmYvdGluJyk7XG52YXIgaW5zaWRlID0gcmVxdWlyZSgnQHR1cmYvaW5zaWRlJyk7XG52YXIgZ3JpZCA9IHJlcXVpcmUoJ0B0dXJmL3BvaW50LWdyaWQnKTtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyk7XG52YXIgYmJveCA9IHJlcXVpcmUoJ0B0dXJmL2Jib3gnKTtcbnZhciBwbGFuZXBvaW50ID0gcmVxdWlyZSgnQHR1cmYvcGxhbmVwb2ludCcpO1xudmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIGxpbmVzdHJpbmcgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykubGluZVN0cmluZztcbnZhciBwb2ludCA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2ludDtcbnZhciBzcXVhcmUgPSByZXF1aXJlKCdAdHVyZi9zcXVhcmUnKTtcbnZhciBDb25yZWMgPSByZXF1aXJlKCcuL2NvbnJlYycpO1xuXG4vKipcbiAqIFRha2VzIHtAbGluayBQb2ludHxwb2ludHN9IHdpdGggei12YWx1ZXMgYW5kIGFuIGFycmF5IG9mXG4gKiB2YWx1ZSBicmVha3MgYW5kIGdlbmVyYXRlcyBbaXNvbGluZXNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSXNvbGluZSkuXG4gKlxuICogQG5hbWUgaXNvbGluZXNcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgaW5wdXQgcG9pbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30geiB0aGUgcHJvcGVydHkgbmFtZSBpbiBgcG9pbnRzYCBmcm9tIHdoaWNoIHotdmFsdWVzIHdpbGwgYmUgcHVsbGVkXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiByZXNvbHV0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGdyaWRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYnJlYWtzIHdoZXJlIHRvIGRyYXcgY29udG91cnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gaXNvbGluZXNcbiAqIEBleGFtcGxlXG4gKiAvLyBjcmVhdGUgcmFuZG9tIHBvaW50cyB3aXRoIHJhbmRvbVxuICogLy8gei12YWx1ZXMgaW4gdGhlaXIgcHJvcGVydGllc1xuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tKCdwb2ludCcsIDEwMCwge1xuICogICBiYm94OiBbMCwgMzAsIDIwLCA1MF1cbiAqIH0pO1xuICogZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgcG9pbnRzLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMueiA9IE1hdGgucmFuZG9tKCkgKiAxMDtcbiAqIH1cbiAqIHZhciBicmVha3MgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdO1xuICogdmFyIGlzb2xpbmVkID0gdHVyZi5pc29saW5lcyhwb2ludHMsICd6JywgMTUsIGJyZWFrcyk7XG4gKiAvLz1pc29saW5lZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHosIHJlc29sdXRpb24sIGJyZWFrcykge1xuICAgIHZhciB0aW5SZXN1bHQgPSB0aW4ocG9pbnRzLCB6KTtcbiAgICB2YXIgYmJveEJCb3ggPSBiYm94KHBvaW50cyk7XG4gICAgdmFyIHNxdWFyZUJCb3ggPSBzcXVhcmUoYmJveEJCb3gpO1xuICAgIHZhciBzaXplQ2VsbEdyaWQgPSBkaXN0YW5jZShwb2ludChbc3F1YXJlQkJveFswXSwgc3F1YXJlQkJveFsxXV0pLCBwb2ludChbc3F1YXJlQkJveFsyXSwgc3F1YXJlQkJveFsxXV0pLCAna2lsb21ldGVycycpIC8gcmVzb2x1dGlvbjtcbiAgICB2YXIgZ3JpZFJlc3VsdCA9IGdyaWQoc3F1YXJlQkJveCwgc2l6ZUNlbGxHcmlkLCAna2lsb21ldGVycycpO1xuICAgIHZhciBkYXRhID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyaWRSZXN1bHQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gZ3JpZFJlc3VsdC5mZWF0dXJlc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aW5SZXN1bHQuZmVhdHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZSA9IHRpblJlc3VsdC5mZWF0dXJlc1tqXTtcbiAgICAgICAgICAgIGlmIChpbnNpZGUocHQsIHRyaWFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIHB0LnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBwdC5wcm9wZXJ0aWVzW3pdID0gcGxhbmVwb2ludChwdCwgdHJpYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoID0gTWF0aC5zcXJ0KGdyaWRSZXN1bHQuZmVhdHVyZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRlcHRoOyB4KyspIHtcbiAgICAgICAgdmFyIHhHcm91cCA9IGdyaWRSZXN1bHQuZmVhdHVyZXMuc2xpY2UoeCAqIGRlcHRoLCAoeCArIDEpICogZGVwdGgpO1xuICAgICAgICB2YXIgeEZsYXQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IHhHcm91cC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgaWYgKHhHcm91cFtnXS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgeEZsYXQucHVzaCh4R3JvdXBbZ10ucHJvcGVydGllc1t6XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhGbGF0LnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdXNoKHhGbGF0KTtcbiAgICB9XG4gICAgdmFyIGludGVydmFsID0gKHNxdWFyZUJCb3hbMl0gLSBzcXVhcmVCQm94WzBdKSAvIGRlcHRoO1xuICAgIHZhciB4Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB2YXIgeUNvb3JkaW5hdGVzID0gW107XG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgZCsrKSB7XG4gICAgICAgIHhDb29yZGluYXRlcy5wdXNoKGQgKiBpbnRlcnZhbCArIHNxdWFyZUJCb3hbMF0pO1xuICAgICAgICB5Q29vcmRpbmF0ZXMucHVzaChkICogaW50ZXJ2YWwgKyBzcXVhcmVCQm94WzFdKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IG5ldyBDb25yZWMoKTtcbiAgICBjLmNvbnRvdXIoZGF0YSwgMCwgcmVzb2x1dGlvbiwgMCwgcmVzb2x1dGlvbiwgeENvb3JkaW5hdGVzLCB5Q29vcmRpbmF0ZXMsIGJyZWFrcy5sZW5ndGgsIGJyZWFrcyk7XG4gICAgdmFyIGNvbnRvdXJMaXN0ID0gYy5jb250b3VyTGlzdCgpO1xuXG4gICAgdmFyIGZjID0gZmVhdHVyZWNvbGxlY3Rpb24oW10pO1xuICAgIGNvbnRvdXJMaXN0LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIHBvbHlDb29yZGluYXRlcyA9IFtdO1xuICAgICAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHBvbHlDb29yZGluYXRlcy5wdXNoKFtjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwb2x5ID0gbGluZXN0cmluZyhwb2x5Q29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgcG9seS5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBwb2x5LnByb3BlcnRpZXNbel0gPSBjLmxldmVsO1xuXG4gICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKHBvbHkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmM7XG59O1xuIiwidmFyIHBvaW50ID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIExpbmVTdHJpbmd8bGluZXN0cmluZ30sIHtAbGluayBNdWx0aUxpbmVTdHJpbmd8bXVsdGktbGluZXN0cmluZ30sIHtAbGluayBNdWx0aVBvbHlnb258bXVsdGktcG9seWdvbn0sIG9yIHtAbGluayBQb2x5Z29ufHBvbHlnb259IGFuZCByZXR1cm5zIHtAbGluayBQb2ludHxwb2ludHN9IGF0IGFsbCBzZWxmLWludGVyc2VjdGlvbnMuXG4gKlxuICogQG5hbWUga2lua3NcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb258UG9seWdvbj59IGZlYXR1cmVJbiBpbnB1dCBmZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBzZWxmLWludGVyc2VjdGlvbnNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICBbLTEyLjAzNDgzNSwgOC45MDExODNdLFxuICogICAgICAgWy0xMi4wNjA0MTMsIDguODk5ODI2XSxcbiAqICAgICAgIFstMTIuMDM2MzgsIDguODczMTk5XSxcbiAqICAgICAgIFstMTIuMDU5MzgzLCA4Ljg3MTQxOF0sXG4gKiAgICAgICBbLTEyLjAzNDgzNSwgOC45MDExODNdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIga2lua3MgPSB0dXJmLmtpbmtzKHBvbHkpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IGtpbmtzLmZlYXR1cmVzLmNvbmNhdChwb2x5KTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVJbikge1xuICAgIHZhciBjb29yZGluYXRlcztcbiAgICB2YXIgZmVhdHVyZTtcbiAgICB2YXIgcmVzdWx0cyA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgfTtcbiAgICBpZiAoZmVhdHVyZUluLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZUluLmdlb21ldHJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlSW47XG4gICAgfVxuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBjb29yZGluYXRlcyA9IFtmZWF0dXJlLmNvb3JkaW5hdGVzXTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmNvb3JkaW5hdGVzO1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBjb29yZGluYXRlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgZmVhdHVyZS5jb29yZGluYXRlcyk7XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBjb29yZGluYXRlcyA9IGZlYXR1cmUuY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZywgTXVsdGlMaW5lU3RyaW5nLCAnICtcbiAgICAgICAgICAgICdQb2x5Z29uLCBvciBNdWx0aVBvbHlnb24gRmVhdHVyZSBvciBHZW9tZXRyeScpO1xuICAgIH1cbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50MSkge1xuICAgICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50Mikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50MS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlZ21lbnQyLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBjaGVjayBhZGphY2VudCBzaWRlcyBvZiBhIGdpdmVuIHNlZ21lbnQsIHNpbmNlIG9mIGNvdXJzZSB0aGV5IGludGVyc2VjdCBpbiBhIHZlcnRleC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQxID09PSBzZWdtZW50MiAmJiAoTWF0aC5hYnMoaSAtIGspID09PSAxIHx8IE1hdGguYWJzKGkgLSBrKSA9PT0gc2VnbWVudDEubGVuZ3RoIC0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzKHNlZ21lbnQxW2ldWzBdLCBzZWdtZW50MVtpXVsxXSwgc2VnbWVudDFbaSArIDFdWzBdLCBzZWdtZW50MVtpICsgMV1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50MltrXVswXSwgc2VnbWVudDJba11bMV0sIHNlZ21lbnQyW2sgKyAxXVswXSwgc2VnbWVudDJbayArIDFdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5mZWF0dXJlcy5wdXNoKHBvaW50KFtpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cDovL2pzZmlkZGxlLm5ldC9qdXN0aW5fY19yb3VuZHMvR2QyUzIvbGlnaHQvXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0cyhsaW5lMVN0YXJ0WCwgbGluZTFTdGFydFksIGxpbmUxRW5kWCwgbGluZTFFbmRZLCBsaW5lMlN0YXJ0WCwgbGluZTJTdGFydFksIGxpbmUyRW5kWCwgbGluZTJFbmRZKSB7XG4gICAgLy8gaWYgdGhlIGxpbmVzIGludGVyc2VjdCwgdGhlIHJlc3VsdCBjb250YWlucyB0aGUgeCBhbmQgeSBvZiB0aGUgaW50ZXJzZWN0aW9uICh0cmVhdGluZyB0aGUgbGluZXMgYXMgaW5maW5pdGUpIGFuZCBib29sZWFucyBmb3Igd2hldGhlciBsaW5lIHNlZ21lbnQgMSBvciBsaW5lIHNlZ21lbnQgMiBjb250YWluIHRoZSBwb2ludFxuICAgIHZhciBkZW5vbWluYXRvciwgYSwgYiwgbnVtZXJhdG9yMSwgbnVtZXJhdG9yMixcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICBvbkxpbmUxOiBmYWxzZSxcbiAgICAgICAgICAgIG9uTGluZTI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgZGVub21pbmF0b3IgPSAoKGxpbmUyRW5kWSAtIGxpbmUyU3RhcnRZKSAqIChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkpIC0gKChsaW5lMkVuZFggLSBsaW5lMlN0YXJ0WCkgKiAobGluZTFFbmRZIC0gbGluZTFTdGFydFkpKTtcbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgaWYgKHJlc3VsdC54ICE9PSBudWxsICYmIHJlc3VsdC55ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGEgPSBsaW5lMVN0YXJ0WSAtIGxpbmUyU3RhcnRZO1xuICAgIGIgPSBsaW5lMVN0YXJ0WCAtIGxpbmUyU3RhcnRYO1xuICAgIG51bWVyYXRvcjEgPSAoKGxpbmUyRW5kWCAtIGxpbmUyU3RhcnRYKSAqIGEpIC0gKChsaW5lMkVuZFkgLSBsaW5lMlN0YXJ0WSkgKiBiKTtcbiAgICBudW1lcmF0b3IyID0gKChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkgKiBhKSAtICgobGluZTFFbmRZIC0gbGluZTFTdGFydFkpICogYik7XG4gICAgYSA9IG51bWVyYXRvcjEgLyBkZW5vbWluYXRvcjtcbiAgICBiID0gbnVtZXJhdG9yMiAvIGRlbm9taW5hdG9yO1xuXG4gICAgLy8gaWYgd2UgY2FzdCB0aGVzZSBsaW5lcyBpbmZpbml0ZWx5IGluIGJvdGggZGlyZWN0aW9ucywgdGhleSBpbnRlcnNlY3QgaGVyZTpcbiAgICByZXN1bHQueCA9IGxpbmUxU3RhcnRYICsgKGEgKiAobGluZTFFbmRYIC0gbGluZTFTdGFydFgpKTtcbiAgICByZXN1bHQueSA9IGxpbmUxU3RhcnRZICsgKGEgKiAobGluZTFFbmRZIC0gbGluZTFTdGFydFkpKTtcblxuICAgIC8vIGlmIGxpbmUxIGlzIGEgc2VnbWVudCBhbmQgbGluZTIgaXMgaW5maW5pdGUsIHRoZXkgaW50ZXJzZWN0IGlmOlxuICAgIGlmIChhID49IDAgJiYgYSA8PSAxKSB7XG4gICAgICAgIHJlc3VsdC5vbkxpbmUxID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgbGluZTIgaXMgYSBzZWdtZW50IGFuZCBsaW5lMSBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGIgPj0gMCAmJiBiIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0Lm9uTGluZTIgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBpZiBsaW5lMSBhbmQgbGluZTIgYXJlIHNlZ21lbnRzLCB0aGV5IGludGVyc2VjdCBpZiBib3RoIG9mIHRoZSBhYm92ZSBhcmUgdHJ1ZVxuICAgIGlmIChyZXN1bHQub25MaW5lMSAmJiByZXN1bHQub25MaW5lMikge1xuICAgICAgICByZXR1cm4gW3Jlc3VsdC54LCByZXN1bHQueV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsInZhciBkZXN0aW5hdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2Rlc3RpbmF0aW9uJyk7XG52YXIgY2lyY2xlID0gcmVxdWlyZSgnQHR1cmYvY2lyY2xlJyk7XG52YXIgbGluZVN0cmluZyA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5saW5lU3RyaW5nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXJjdWxhciBhcmMsIG9mIGEgY2lyY2xlIG9mIHRoZSBnaXZlbiByYWRpdXMgYW5kIGNlbnRlciBwb2ludCwgYmV0d2VlbiBiZWFyaW5nMSBhbmQgYmVhcmluZzI7XG4gKiAwIGJlYXJpbmcgaXMgTm9ydGggb2YgY2VudGVyIHBvaW50LCBwb3NpdGl2ZSBjbG9ja3dpc2UuXG4gKlxuICogQG5hbWUgbGluZS1hcmNcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IGNlbnRlciBjZW50ZXIgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nMSBhbmdsZSwgaW4gZGVjaW1hbCBkZWdyZWVzLCBvZiB0aGUgZmlyc3QgcmFkaXVzIG9mIHRoZSBhcmNcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nMiBhbmdsZSwgaW4gZGVjaW1hbCBkZWdyZWVzLCBvZiB0aGUgc2Vjb25kIHJhZGl1cyBvZiB0aGUgYXJjXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXBzPTY0XSBudW1iZXIgb2Ygc3RlcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gbWlsZXMsIGtpbG9tZXRlcnMsIGRlZ3JlZXMsIG9yIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIGFyY1xuICogQGV4YW1wbGVcbiAqIHZhciBjZW50ZXIgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NSwgNDBdXG4gKiAgIH1cbiAqIH1cbiAqIHZhciByYWRpdXMgPSA1O1xuICogdmFyIGJlYXJpbmcxID0gMjU7XG4gKiB2YXIgYmVhcmluZzIgPSA0NztcbiAqXG4gKiB2YXIgYXJjID0gdHVyZi5saW5lQXJjKGNlbnRlciwgcmFkaXVzLCBiZWFyaW5nMSwgYmVhcmluZzIpO1xuICpcbiAqIC8vYWRkVG9NYXBcbiAqIHZhciBhZGRUb01hcCA9IFtjZW50ZXIsIGFyY11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2VudGVyLCByYWRpdXMsIGJlYXJpbmcxLCBiZWFyaW5nMiwgc3RlcHMsIHVuaXRzKSB7XG4gICAgLy8gdmFsaWRhdGlvblxuICAgIGlmICghY2VudGVyKSB0aHJvdyBuZXcgRXJyb3IoJ2NlbnRlciBpcyByZXF1aXJlZCcpO1xuICAgIGlmIChiZWFyaW5nMSA9PT0gdW5kZWZpbmVkIHx8IGJlYXJpbmcxID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ2JlYXJpbmcxIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKGJlYXJpbmcyID09PSB1bmRlZmluZWQgfHwgYmVhcmluZzIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignYmVhcmluZzIgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIXJhZGl1cykgdGhyb3cgbmV3IEVycm9yKCdyYWRpdXMgaXMgcmVxdWlyZWQnKTtcblxuICAgIC8vIGRlZmF1bHQgcGFyYW1zXG4gICAgc3RlcHMgPSBzdGVwcyB8fCA2NDtcblxuICAgIHZhciBhbmdsZTEgPSBjb252ZXJ0QW5nbGVUbzM2MChiZWFyaW5nMSk7XG4gICAgdmFyIGFuZ2xlMiA9IGNvbnZlcnRBbmdsZVRvMzYwKGJlYXJpbmcyKTtcbiAgICB2YXIgcHJvcGVydGllcyA9IGNlbnRlci5wcm9wZXJ0aWVzO1xuXG4gICAgLy8gaGFuZGxlIGFuZ2xlIHBhcmFtZXRlcnNcbiAgICBpZiAoYW5nbGUxID09PSBhbmdsZTIpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoY2lyY2xlKGNlbnRlciwgcmFkaXVzLCBzdGVwcywgdW5pdHMpLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgdmFyIGFyY1N0YXJ0RGVncmVlID0gYW5nbGUxO1xuICAgIHZhciBhcmNFbmREZWdyZWUgPSAoYW5nbGUxIDwgYW5nbGUyKSA/IGFuZ2xlMiA6IGFuZ2xlMiArIDM2MDtcblxuICAgIHZhciBhbGZhID0gYXJjU3RhcnREZWdyZWU7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGFsZmEgPCBhcmNFbmREZWdyZWUpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaChkZXN0aW5hdGlvbihjZW50ZXIsIHJhZGl1cywgYWxmYSwgdW5pdHMpLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgaSsrO1xuICAgICAgICBhbGZhID0gYXJjU3RhcnREZWdyZWUgKyBpICogMzYwIC8gc3RlcHM7XG4gICAgfVxuICAgIGlmIChhbGZhID4gYXJjRW5kRGVncmVlKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzLnB1c2goZGVzdGluYXRpb24oY2VudGVyLCByYWRpdXMsIGFyY0VuZERlZ3JlZSwgdW5pdHMpLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpO1xufTtcblxuXG4vKipcbiAqIFRha2VzIGFueSBhbmdsZSBpbiAgZGVncmVlc1xuICogYW5kIHJldHVybnMgYSB2YWxpZCBhbmdsZSBiZXR3ZWVuIDAtMzYwIGRlZ3JlZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGFsZmEgYW5nbGUgYmV0d2VlbiAtMTgwLTE4MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBiZXR3ZWVuIDAtMzYwIGRlZ3JlZXNcbiAqL1xuZnVuY3Rpb24gY29udmVydEFuZ2xlVG8zNjAoYWxmYSkge1xuICAgIHZhciBiZXRhID0gYWxmYSAlIDM2MDtcbiAgICBpZiAoYmV0YSA8IDApIHtcbiAgICAgICAgYmV0YSArPSAzNjA7XG4gICAgfVxuICAgIHJldHVybiBiZXRhO1xufVxuIiwidmFyIGxpbmVTbGljZUFsb25nID0gcmVxdWlyZSgnQHR1cmYvbGluZS1zbGljZS1hbG9uZycpO1xudmFyIGxpbmVEaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2xpbmUtZGlzdGFuY2UnKTtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBmZWF0dXJlRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5mZWF0dXJlRWFjaDtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnQHR1cmYvZmxhdHRlbicpO1xuXG4vKipcbiAqIERpdmlkZXMgYSB7QGxpbmsgTGluZVN0cmluZ30gaW50byBjaHVua3Mgb2YgYSBzcGVjaWZpZWQgbGVuZ3RoLlxuICogSWYgdGhlIGxpbmUgaXMgc2hvcnRlciB0aGFuIHRoZSBzZWdtZW50IGxlbmd0aCB0aGVuIHRoZSBvcmlnaW5hbCBsaW5lIGlzIHJldHVybmVkLlxuICpcbiAqIEBuYW1lIGxpbmVDaHVua1xuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPExpbmVTdHJpbmd8TXVsdGlMaW5lU3RyaW5nPn0gZmVhdHVyZUluIHRoZSBsaW5lcyB0byBzcGxpdFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRMZW5ndGggaG93IGxvbmcgdG8gbWFrZSBlYWNoIHNlZ21lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfVt1bml0cz0na2lsb21ldGVycyddIHVuaXRzIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHBhcmFtIHtib29sZWFufVtyZXZlcnNlPWZhbHNlXSByZXZlcnNlcyBjb29yZGluYXRlcyB0byBzdGFydCB0aGUgZmlyc3QgY2h1bmtlZCBzZWdtZW50IGF0IHRoZSBlbmRcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gY29sbGVjdGlvbiBvZiBsaW5lIHNlZ21lbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTk1LCA0MF0sXG4gKiAgICAgICBbLTkzLCA0NV0sXG4gKiAgICAgICBbLTg1LCA1MF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcmVzdWx0ID0gdHVyZi5saW5lQ2h1bmsobGluZSwgMTUsICdtaWxlcycpO1xuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVJbiwgc2VnbWVudExlbmd0aCwgdW5pdHMsIHJldmVyc2UpIHtcbiAgICB2YXIgb3V0RmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHNbJzQnXTsgLy8gSGlkZGVuIEBwYXJhbSB7Ym9vbGVhbn0gRW5hYmxlIGRlYnVnIG1vZGVcblxuICAgIC8vIEhhbmRsZXMgRmVhdHVyZUNvbGxlY3Rpb25cbiAgICBmZWF0dXJlRWFjaChmZWF0dXJlSW4sIGZ1bmN0aW9uIChtdWx0aUZlYXR1cmUpIHtcblxuICAgICAgICAvLyBIYW5kbGVzIE11bHRpTGluZVN0cmluZ1xuICAgICAgICBpZiAobXVsdGlGZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICBtdWx0aUZlYXR1cmUgPSBmbGF0dGVuKG11bHRpRmVhdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGwgZmVhdHVyZXMgYXJlIHNpbXBsZSBMaW5lU3RyaW5nXG4gICAgICAgIGZlYXR1cmVFYWNoKG11bHRpRmVhdHVyZSwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmVTZWdtZW50cyA9IHNsaWNlTGluZVNlZ21lbnRzKGZlYXR1cmUsIHNlZ21lbnRMZW5ndGgsIHVuaXRzKTtcbiAgICAgICAgICAgIGxpbmVTZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChpbmRleCAlIDIgPT09IDApID8gJ0YnIDogJzAnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IChpbmRleCAlIDIgPT09IDApID8gJzAnIDogJzAnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IChpbmRleCAlIDIgPT09IDApID8gJzAnIDogJ0YnO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnByb3BlcnRpZXNbJ3N0cm9rZSddID0gJyMnICsgciArIGcgKyBiO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnByb3BlcnRpZXNbJ3N0cm9rZS13aWR0aCddID0gNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0RmVhdHVyZXMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24ob3V0RmVhdHVyZXMpO1xufTtcblxuLyoqXG4gKiBTbGljZSBMaW5lIFNlZ21lbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZSBHZW9KU09OIExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50TGVuZ3RoIGhvdyBsb25nIHRvIG1ha2UgZWFjaCBzZWdtZW50XG4gKiBAcGFyYW0ge3N0cmluZ31bdW5pdHM9J2tpbG9tZXRlcnMnXSB1bml0cyBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtBcnJheTxGZWF0dXJlPExpbmVTdHJpbmc+Pn0gc2xpY2VkIGxpbmVzXG4gKi9cbmZ1bmN0aW9uIHNsaWNlTGluZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRMZW5ndGgsIHVuaXRzKSB7XG4gICAgdmFyIGxpbmVTZWdtZW50cyA9IFtdO1xuICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZURpc3RhbmNlKGxpbmUsIHVuaXRzKTtcblxuICAgIC8vIElmIHRoZSBsaW5lIGlzIHNob3J0ZXIgdGhhbiB0aGUgc2VnbWVudCBsZW5ndGggdGhlbiB0aGUgb3JnaW5hbCBsaW5lIGlzIHJldHVybmVkLlxuICAgIGlmIChsaW5lTGVuZ3RoIDw9IHNlZ21lbnRMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtsaW5lXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtYmVyT2ZTZWdtZW50cyA9IE1hdGguZmxvb3IobGluZUxlbmd0aCAvIHNlZ21lbnRMZW5ndGgpICsgMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRsaW5lID0gbGluZVNsaWNlQWxvbmcobGluZSwgc2VnbWVudExlbmd0aCAqIGksIHNlZ21lbnRMZW5ndGggKiAoaSArIDEpLCB1bml0cyk7XG4gICAgICAgIGxpbmVTZWdtZW50cy5wdXNoKG91dGxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZVNlZ21lbnRzO1xufVxuIiwidmFyIGRpc3RhbmNlID0gcmVxdWlyZSgnQHR1cmYvZGlzdGFuY2UnKTtcbnZhciBmZWF0dXJlRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5mZWF0dXJlRWFjaDtcbnZhciBjb29yZFJlZHVjZSA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5jb29yZFJlZHVjZTtcbnZhciBnZW9tRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5nZW9tRWFjaDtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnQHR1cmYvZmxhdHRlbicpO1xudmFyIGxpbmVTdHJpbmcgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykubGluZVN0cmluZztcbnZhciBwb2ludCA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2ludDtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfSBvciB7QGxpbmsgUG9seWdvbn0gYW5kIG1lYXN1cmVzIGl0cyBsZW5ndGggaW4gdGhlIHNwZWNpZmllZCB1bml0cy5cbiAqXG4gKiBAbmFtZSBsaW5lRGlzdGFuY2VcbiAqIEBwYXJhbSB7RmVhdHVyZTwoTGluZVN0cmluZ3xQb2x5Z29uKT58RmVhdHVyZUNvbGxlY3Rpb248KExpbmVTdHJpbmd8UG9seWdvbik+fSBnZW9qc29uIGZlYXR1cmUgdG8gbWVhc3VyZVxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGxlbmd0aCBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTc3LjAzMTY2OSwgMzguODc4NjA1XSxcbiAqICAgICAgIFstNzcuMDI5NjA5LCAzOC44ODE5NDZdLFxuICogICAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgICBbLTc3LjAyNTY2MSwgMzguODg1ODIxXSxcbiAqICAgICAgIFstNzcuMDIxODg0LCAzOC44ODk1NjNdLFxuICogICAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIGxlbmd0aCA9IHR1cmYubGluZURpc3RhbmNlKGxpbmUsICdtaWxlcycpO1xuICpcbiAqIC8vPWxpbmVcbiAqXG4gKiAvLz1sZW5ndGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5lRGlzdGFuY2UoZ2VvanNvbiwgdW5pdHMpIHtcbiAgICAvLyBJbnB1dCBWYWxpZGF0aW9uXG4gICAgaWYgKCFnZW9qc29uKSB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24gaXMgcmVxdWlyZWQnKTtcbiAgICBnZW9tRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHRocm93IG5ldyBFcnJvcignZ2VvanNvbiBjYW5ub3QgYmUgYSBQb2ludCcpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24gY2Fubm90IGJlIGEgTXVsdGlQb2ludCcpO1xuICAgIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gMi12ZXJ0ZXggbGluZSBzZWdlbWVudHNcbiAgICByZXR1cm4gc2VnbWVudFJlZHVjZShnZW9qc29uLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgc2VnbWVudCkge1xuICAgICAgICB2YXIgY29vcmRzID0gc2VnbWVudC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnQoY29vcmRzWzBdKTtcbiAgICAgICAgdmFyIGVuZCA9IHBvaW50KGNvb3Jkc1sxXSk7XG4gICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgZGlzdGFuY2Uoc3RhcnQsIGVuZCwgdW5pdHMpO1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgMi12ZXJ0ZXggbGluZSBzZWdtZW50IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPGFueT59IGdlb2pzb24gYW55IEdlb0pTT05cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRTZWdtZW50LCBjdXJyZW50SW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dXG4gKiAgIH1cbiAqIH1cbiAqIHR1cmYuc2VnbWVudEVhY2gocG9seWdvbiwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAqICAgLy89IHNlZ21lbnRcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBzZWdtZW50RWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZmVhdHVyZUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKG11bHRpRmVhdHVyZSkge1xuICAgICAgICBmZWF0dXJlRWFjaChmbGF0dGVuKG11bHRpRmVhdHVyZSksIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBjb29yZFJlZHVjZShmZWF0dXJlLCBmdW5jdGlvbiAocHJldmlvdXNDb29yZHMsIGN1cnJlbnRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVTdHJpbmcoW3ByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRzXSwgZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhsaW5lLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENvb3JkcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZWR1Y2UgMi12ZXJ0ZXggbGluZSBzZWdtZW50IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmU8YW55Pn0gZ2VvanNvbiBhbnkgR2VvSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFNlZ21lbnQsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2VnbWVudFJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgc2VnbWVudEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRTZWdtZW50LCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRTZWdtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRTZWdtZW50LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG4iLCJ2YXIgaGVscGVycyA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnQHR1cmYvbWV0YScpO1xudmFyIGxpbmVTZWdtZW50ID0gcmVxdWlyZSgnQHR1cmYvbGluZS1zZWdtZW50Jyk7XG52YXIgZ2V0Q29vcmRzID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50JykuZ2V0Q29vcmRzO1xudmFyIHJidXNoID0gcmVxdWlyZSgnZ2VvanNvbi1yYnVzaCcpO1xudmFyIHBvaW50ID0gaGVscGVycy5wb2ludDtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgZmVhdHVyZUVhY2ggPSBtZXRhLmZlYXR1cmVFYWNoO1xuXG4vKipcbiAqIFRha2VzIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb24gR2VvSlNPTiBhbmQgcmV0dXJucyB0aGUgaW50ZXJzZWN0aW5nIHBvaW50KHMpLlxuICpcbiAqIEBuYW1lIGxpbmVJbnRlcnNlY3RcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUxIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUyIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50KHMpIHRoYXQgaW50ZXJzZWN0IGJvdGhcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZTEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbWzEyNiwgLTExXSwgWzEyOSwgLTIxXV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBsaW5lMiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbMTIzLCAtMThdLCBbMTMxLCAtMTRdXVxuICogICB9XG4gKiB9O1xuICogdmFyIHBvaW50cyA9IHR1cmYubGluZUludGVyc2VjdChsaW5lMSwgbGluZTIpO1xuICogLy89IHBvaW50c1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaW5lMSwgbGluZTIpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIC8vIEhhbmRsZXMgc2ltcGxlIDItdmVydGV4IHNlZ21lbnRzXG4gICAgaWYgKGxpbmUxLmdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyAmJlxuICAgICAgICBsaW5lMi5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgJiZcbiAgICAgICAgbGluZTEuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgIGxpbmUyLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gaW50ZXJzZWN0cyhsaW5lMSwgbGluZTIpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0KSByZXN1bHRzLnB1c2goaW50ZXJzZWN0KTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKHJlc3VsdHMpO1xuICAgIH1cbiAgICAvLyBIYW5kbGVzIGNvbXBsZXggR2VvSlNPTiBHZW9tZXRyaWVzXG4gICAgdmFyIHRyZWUgPSByYnVzaCgpO1xuICAgIHRyZWUubG9hZChsaW5lU2VnbWVudChsaW5lMikpO1xuICAgIGZlYXR1cmVFYWNoKGxpbmVTZWdtZW50KGxpbmUxKSwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgZmVhdHVyZUVhY2godHJlZS5zZWFyY2goc2VnbWVudCksIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGludGVyc2VjdHMoc2VnbWVudCwgbWF0Y2gpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkgcmVzdWx0cy5wdXNoKGludGVyc2VjdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbn07XG5cbi8qKlxuICogRmluZCBhIHBvaW50IHRoYXQgaW50ZXJzZWN0cyBMaW5lU3RyaW5ncyB3aXRoIHR3byBjb29yZGluYXRlcyBlYWNoXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZTEgR2VvSlNPTiBMaW5lU3RyaW5nIChNdXN0IG9ubHkgY29udGFpbiAyIGNvb3JkaW5hdGVzKVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lMiBHZW9KU09OIExpbmVTdHJpbmcgKE11c3Qgb25seSBjb250YWluIDIgY29vcmRpbmF0ZXMpXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGludGVyc2VjdGluZyBHZW9KU09OIFBvaW50XG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdHMobGluZTEsIGxpbmUyKSB7XG4gICAgdmFyIGNvb3JkczEgPSBnZXRDb29yZHMobGluZTEpO1xuICAgIHZhciBjb29yZHMyID0gZ2V0Q29vcmRzKGxpbmUyKTtcbiAgICBpZiAoY29vcmRzMS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8aW50ZXJzZWN0cz4gbGluZTEgbXVzdCBvbmx5IGNvbnRhaW4gMiBjb29yZGluYXRlcycpO1xuICAgIH1cbiAgICBpZiAoY29vcmRzMi5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8aW50ZXJzZWN0cz4gbGluZTIgbXVzdCBvbmx5IGNvbnRhaW4gMiBjb29yZGluYXRlcycpO1xuICAgIH1cbiAgICB2YXIgeDEgPSBjb29yZHMxWzBdWzBdO1xuICAgIHZhciB5MSA9IGNvb3JkczFbMF1bMV07XG4gICAgdmFyIHgyID0gY29vcmRzMVsxXVswXTtcbiAgICB2YXIgeTIgPSBjb29yZHMxWzFdWzFdO1xuICAgIHZhciB4MyA9IGNvb3JkczJbMF1bMF07XG4gICAgdmFyIHkzID0gY29vcmRzMlswXVsxXTtcbiAgICB2YXIgeDQgPSBjb29yZHMyWzFdWzBdO1xuICAgIHZhciB5NCA9IGNvb3JkczJbMV1bMV07XG4gICAgdmFyIGRlbm9tID0gKCh5NCAtIHkzKSAqICh4MiAtIHgxKSkgLSAoKHg0IC0geDMpICogKHkyIC0geTEpKTtcbiAgICB2YXIgbnVtZUEgPSAoKHg0IC0geDMpICogKHkxIC0geTMpKSAtICgoeTQgLSB5MykgKiAoeDEgLSB4MykpO1xuICAgIHZhciBudW1lQiA9ICgoeDIgLSB4MSkgKiAoeTEgLSB5MykpIC0gKCh5MiAtIHkxKSAqICh4MSAtIHgzKSk7XG5cbiAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgICAgaWYgKG51bWVBID09PSAwICYmIG51bWVCID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdUEgPSBudW1lQSAvIGRlbm9tO1xuICAgIHZhciB1QiA9IG51bWVCIC8gZGVub207XG5cbiAgICBpZiAodUEgPj0gMCAmJiB1QSA8PSAxICYmIHVCID49IDAgJiYgdUIgPD0gMSkge1xuICAgICAgICB2YXIgeCA9IHgxICsgKHVBICogKHgyIC0geDEpKTtcbiAgICAgICAgdmFyIHkgPSB5MSArICh1QSAqICh5MiAtIHkxKSk7XG4gICAgICAgIHJldHVybiBwb2ludChbeCwgeV0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbiIsInZhciBsaW5lU2VnbWVudCA9IHJlcXVpcmUoJ0B0dXJmL2xpbmUtc2VnbWVudCcpO1xudmFyIGdldENvb3JkcyA9IHJlcXVpcmUoJ0B0dXJmL2ludmFyaWFudCcpLmdldENvb3JkcztcbnZhciByYnVzaCA9IHJlcXVpcmUoJ2dlb2pzb24tcmJ1c2gnKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBmZWF0dXJlRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5mZWF0dXJlRWFjaDtcblxuLyoqXG4gKiBUYWtlcyBhbnkgTGluZVN0cmluZyBvciBQb2x5Z29uIGFuZCByZXR1cm5zIHRoZSBvdmVybGFwcGluZyBsaW5lcyBiZXR3ZWVuIGJvdGggZmVhdHVyZXMuXG4gKlxuICogQG5hbWUgbGluZU92ZXJsYXBcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUxIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUyIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gbGluZXMocykgdGhhdCBhcmUgb3ZlcmxhcHBpbmcgYmV0d2VlbiBib3RoIGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUxID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1sxMTUsIC0zNV0sIFsxMjUsIC0zMF0sIFsxMzUsIC0zMF0sIFsxNDUsIC0zNV1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH1cbiAqIHZhciBsaW5lMiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbMTE1LCAtMjVdLCBbMTI1LCAtMzBdLCBbMTM1LCAtMzBdLCBbMTQ1LCAtMjVdXG4gKiAgICAgXVxuICogICB9XG4gKiB9XG4gKiB2YXIgb3ZlcmxhcHBpbmcgPSB0dXJmLmxpbmVPdmVybGFwKGxpbmUxLCBsaW5lMik7XG4gKiAvLz0gb3ZlcmxhcHBpbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGluZTEsIGxpbmUyKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIENyZWF0ZSBTcGF0aWFsIEluZGV4XG4gICAgdmFyIHRyZWUgPSByYnVzaCgpO1xuICAgIHRyZWUubG9hZChsaW5lU2VnbWVudChsaW5lMSkpO1xuICAgIHZhciBvdmVybGFwcztcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBsaW5lIHNlZ21lbnRzXG4gICAgZmVhdHVyZUVhY2gobGluZVNlZ21lbnQobGluZTIpLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICB2YXIgZG9lc092ZXJsYXBzID0gZmFsc2U7XG4gICAgICAgIGZlYXR1cmVFYWNoKHRyZWUuc2VhcmNoKHNlZ21lbnQpLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChkb2VzT3ZlcmxhcHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkczEgPSBnZXRDb29yZHMoc2VnbWVudCkuc29ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMyID0gZ2V0Q29vcmRzKG1hdGNoKS5zb3J0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZWdtZW50IG92ZXJsYXBzIGZlYXR1cmVcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwoY29vcmRzMSwgY29vcmRzMikpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9lc092ZXJsYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcmxhcHMgYWxyZWFkeSBleGlzdHMgLSBvbmx5IGFwcGVuZCBsYXN0IGNvb3JkaW5hdGUgb2Ygc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHMpIG92ZXJsYXBzID0gY29uY2F0U2VnbWVudChvdmVybGFwcywgc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugb3ZlcmxhcHMgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNlZ21lbnQgZG9lc24ndCBvdmVybGFwIC0gYWRkIG92ZXJsYXBzIHRvIHJlc3VsdHMgJiByZXNldFxuICAgICAgICBpZiAoZG9lc092ZXJsYXBzID09PSBmYWxzZSAmJiBvdmVybGFwcykge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG92ZXJsYXBzKTtcbiAgICAgICAgICAgIG92ZXJsYXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGxhc3Qgc2VnbWVudCBpZiBleGlzdHNcbiAgICBpZiAob3ZlcmxhcHMpIHJlc3VsdHMucHVzaChvdmVybGFwcyk7XG5cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24ocmVzdWx0cyk7XG59O1xuXG5cbi8qKlxuICogQ29uY2F0IFNlZ21lbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gc2VnbWVudCAyLXZlcnRleCBMaW5lU3RyaW5nXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY29uY2F0IGxpbmVzdHJpbmdcbiAqL1xuZnVuY3Rpb24gY29uY2F0U2VnbWVudChsaW5lLCBzZWdtZW50KSB7XG4gICAgdmFyIGNvb3JkcyA9IGdldENvb3JkcyhzZWdtZW50KTtcbiAgICB2YXIgbGluZUNvb3JkcyA9IGdldENvb3JkcyhsaW5lKTtcbiAgICB2YXIgc3RhcnQgPSBsaW5lQ29vcmRzWzBdO1xuICAgIHZhciBlbmQgPSBsaW5lQ29vcmRzW2xpbmVDb29yZHMubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZXF1YWwoY29vcmRzWzBdLCBzdGFydCkpIHtcbiAgICAgICAgbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy51bnNoaWZ0KGNvb3Jkc1sxXSk7XG4gICAgfSBlbHNlIGlmIChlcXVhbChjb29yZHNbMF0sIGVuZCkpIHtcbiAgICAgICAgbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy5wdXNoKGNvb3Jkc1sxXSk7XG4gICAgfSBlbHNlIGlmIChlcXVhbChjb29yZHNbMV0sIHN0YXJ0KSkge1xuICAgICAgICBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnVuc2hpZnQoY29vcmRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKGVxdWFsKGNvb3Jkc1sxXSwgZW5kKSkge1xuICAgICAgICBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnB1c2goY29vcmRzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJ0B0dXJmL2ZsYXR0ZW4nKTtcbnZhciBmZWF0dXJlRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5mZWF0dXJlRWFjaDtcbnZhciBsaW5lU3RyaW5nID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmxpbmVTdHJpbmc7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgZ2V0Q29vcmRzID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50JykuZ2V0Q29vcmRzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIDItdmVydGV4IHtAbGluayBMaW5lU3RyaW5nfSBzZWdtZW50cyBmcm9tIGEge0BsaW5rIExpbmVTdHJpbmd9LCB7QGxpbmsgTXVsdGlMaW5lU3RyaW5nfSwge0BsaW5rIE11bHRpUG9seWdvbn0gb3Ige0BsaW5rIFBvbHlnb259LlxuICpcbiAqIEBuYW1lIGxpbmVTZWdtZW50XG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmU8TGluZVN0cmluZ3xNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29ufFBvbHlnb24+fSBnZW9qc29uIEdlb0pTT04gUG9seWdvbiBvciBMaW5lU3RyaW5nXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248TGluZVN0cmluZz59IDItdmVydGV4IGxpbmUgc2VnbWVudHNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dXG4gKiAgIH1cbiAqIH1cbiAqIHZhciBzZWdtZW50cyA9IHR1cmYubGluZVNlZ21lbnQocG9seWdvbik7XG4gKiAvLz1zZWdtZW50c1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZlYXR1cmVFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChtdWx0aUZlYXR1cmUpIHtcbiAgICAgICAgZmVhdHVyZUVhY2goZmxhdHRlbihtdWx0aUZlYXR1cmUpLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSAoZmVhdHVyZS5nZW9tZXRyeSkgPyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgOiBmZWF0dXJlLnR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAgICAgICAgIGNvb3JkcyA9IGdldENvb3JkcyhmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNvb3JkcyA9IFtnZXRDb29yZHMoZmVhdHVyZSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gY3JlYXRlU2VnbWVudHMoY29vcmQsIGZlYXR1cmUucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LmlkID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24ocmVzdWx0cyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBTZWdtZW50cyBmcm9tIExpbmVTdHJpbmcgY29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtMaW5lU3RyaW5nfSBjb29yZHMgTGluZVN0cmluZyBjb29yZGluYXRlc1xuICogQHBhcmFtIHsqfSBwcm9wZXJ0aWVzIEdlb0pTT04gcHJvcGVydGllc1xuICogQHJldHVybnMge0FycmF5PEZlYXR1cmU8TGluZVN0cmluZz4+fSBsaW5lIHNlZ21lbnRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlZ21lbnRzKGNvb3JkcywgcHJvcGVydGllcykge1xuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIGNvb3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRzKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gbGluZVN0cmluZyhbcHJldmlvdXNDb29yZHMsIGN1cnJlbnRDb29yZHNdLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgc2VnbWVudC5iYm94ID0gYmJveChwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3Jkcyk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q29vcmRzO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWdtZW50cztcbn1cblxuLyoqXG4gKiBDcmVhdGUgQkJveCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyAoZmFzdGVyIHRoYW4gQHR1cmYvYmJveClcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBjb29yZHMxIFBvaW50IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gY29vcmRzMiBQb2ludCBjb29yZGluYXRlXG4gKiBAcmV0dXJucyB7QkJveH0gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqL1xuZnVuY3Rpb24gYmJveChjb29yZHMxLCBjb29yZHMyKSB7XG4gICAgdmFyIHgxID0gY29vcmRzMVswXTtcbiAgICB2YXIgeTEgPSBjb29yZHMxWzFdO1xuICAgIHZhciB4MiA9IGNvb3JkczJbMF07XG4gICAgdmFyIHkyID0gY29vcmRzMlsxXTtcbiAgICB2YXIgd2VzdCA9ICh4MSA8IHgyKSA/IHgxIDogeDI7XG4gICAgdmFyIHNvdXRoID0gKHkxIDwgeTIpID8geTEgOiB5MjtcbiAgICB2YXIgZWFzdCA9ICh4MSA+IHgyKSA/IHgxIDogeDI7XG4gICAgdmFyIG5vcnRoID0gKHkxID4geTIpID8geTEgOiB5MjtcbiAgICByZXR1cm4gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF07XG59XG4iLCJ2YXIgYmVhcmluZyA9IHJlcXVpcmUoJ0B0dXJmL2JlYXJpbmcnKTtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyk7XG52YXIgZGVzdGluYXRpb24gPSByZXF1aXJlKCdAdHVyZi9kZXN0aW5hdGlvbicpO1xudmFyIGxpbmVTdHJpbmcgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykubGluZVN0cmluZztcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfGxpbmV9LCBhIHNwZWNpZmllZCBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSB0byBhIHN0YXJ0IHtAbGluayBQb2ludH0sXG4gKiBhbmQgYSBzcGVjaWZpZWQgIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIHRvIGEgc3RvcCBwb2ludFxuICogYW5kIHJldHVybnMgYSBzdWJzZWN0aW9uIG9mIHRoZSBsaW5lIGluLWJldHdlZW4gdGhvc2UgcG9pbnRzLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZXh0cmFjdGluZyBvbmx5IHRoZSBwYXJ0IG9mIGEgcm91dGUgYmV0d2VlbiB0d28gZGlzdGFuY2VzLlxuICpcbiAqIEBuYW1lIGxpbmVTbGljZUFsb25nXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz58TGluZVN0cmluZ30gbGluZSBpbnB1dCBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnREaXN0IGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIHRvIHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcERpc3QgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgdG8gZW5kaW5nIHBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IHNsaWNlZCBsaW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbIDcuNjY4NDU3MDMxMjUsIDQ1LjA1ODAwMTQzNTM5ODI5NiBdLFxuICogICAgICAgWyA5LjIwNjU0Mjk2ODc1LCA0NS40NjAxMzA2Mzc5MjEwMDQgXSxcbiAqICAgICAgIFsgMTEuMzQ4ODc2OTUzMTI1LCA0NC40ODg2NjgzMzEzOTQ2NyBdLFxuICogICAgICAgWyAxMi4xNzI4NTE1NjI1LCA0NS40MzcwMDgyODg2NzM4OSBdLFxuICogICAgICAgWyAxMi41MzU0MDAzOTA2MjUsIDQzLjk4NDkxMDExNDA0NjkyIF0sXG4gKiAgICAgICBbIDEyLjQyNTUzNzEwOTM3NSwgNDEuODY5NTYwODI2OTk0NTUgXSxcbiAqICAgICAgIFsgMTQuMjQzNzc0NDE0MDYyNSwgNDAuODM4NzQ5MTM3OTY0NTkgXSxcbiAqICAgICAgIFsgMTQuNzY1NjI1LCA0MC42ODE2Nzk0NTg3MTU2MzUgXVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqIHZhciBzdGFydCA9IDEyLjU7XG4gKlxuICogdmFyIHN0b3AgPSAyNTtcbiAqXG4gKiB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICpcbiAqIHZhciBzbGljZWQgPSB0dXJmLmxpbmVTbGljZUFsb25nKGxpbmUsIHN0YXJ0LCBzdG9wLCB1bml0cyk7XG4gKlxuICogLy89bGluZVxuICpcbiAqIC8vPXNsaWNlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaW5lLCBzdGFydERpc3QsIHN0b3BEaXN0LCB1bml0cykge1xuICAgIHZhciBjb29yZHM7XG4gICAgdmFyIHNsaWNlID0gW107XG4gICAgaWYgKGxpbmUudHlwZSA9PT0gJ0ZlYXR1cmUnKSBjb29yZHMgPSBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIGVsc2UgaWYgKGxpbmUudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSBjb29yZHMgPSBsaW5lLmNvb3JkaW5hdGVzO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZyBGZWF0dXJlIG9yIEdlb21ldHJ5Jyk7XG5cbiAgICB2YXIgdHJhdmVsbGVkID0gMDtcbiAgICB2YXIgb3ZlcnNob3QsIGRpcmVjdGlvbiwgaW50ZXJwb2xhdGVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdGFydERpc3QgPj0gdHJhdmVsbGVkICYmIGkgPT09IGNvb3Jkcy5sZW5ndGggLSAxKSBicmVhaztcbiAgICAgICAgZWxzZSBpZiAodHJhdmVsbGVkID4gc3RhcnREaXN0ICYmIHNsaWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3ZlcnNob3QgPSBzdGFydERpc3QgLSB0cmF2ZWxsZWQ7XG4gICAgICAgICAgICBpZiAoIW92ZXJzaG90KSB7XG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChjb29yZHNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lU3RyaW5nKHNsaWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGJlYXJpbmcoY29vcmRzW2ldLCBjb29yZHNbaSAtIDFdKSAtIDE4MDtcbiAgICAgICAgICAgIGludGVycG9sYXRlZCA9IGRlc3RpbmF0aW9uKGNvb3Jkc1tpXSwgb3ZlcnNob3QsIGRpcmVjdGlvbiwgdW5pdHMpO1xuICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnBvbGF0ZWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYXZlbGxlZCA+PSBzdG9wRGlzdCkge1xuICAgICAgICAgICAgb3ZlcnNob3QgPSBzdG9wRGlzdCAtIHRyYXZlbGxlZDtcbiAgICAgICAgICAgIGlmICghb3ZlcnNob3QpIHtcbiAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGNvb3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoc2xpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aW9uID0gYmVhcmluZyhjb29yZHNbaV0sIGNvb3Jkc1tpIC0gMV0pIC0gMTgwO1xuICAgICAgICAgICAgaW50ZXJwb2xhdGVkID0gZGVzdGluYXRpb24oY29vcmRzW2ldLCBvdmVyc2hvdCwgZGlyZWN0aW9uLCB1bml0cyk7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGludGVycG9sYXRlZC5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbGluZVN0cmluZyhzbGljZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhdmVsbGVkID49IHN0YXJ0RGlzdCkge1xuICAgICAgICAgICAgc2xpY2UucHVzaChjb29yZHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IGNvb3Jkcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZVN0cmluZyhzbGljZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmF2ZWxsZWQgKz0gZGlzdGFuY2UoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdLCB1bml0cyk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lU3RyaW5nKGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0pO1xufTtcbiIsInZhciBsaW5lc3RyaW5nID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmxpbmVTdHJpbmc7XG52YXIgcG9pbnRPbkxpbmUgPSByZXF1aXJlKCdAdHVyZi9wb2ludC1vbi1saW5lJyk7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgTGluZVN0cmluZ3xsaW5lfSwgYSBzdGFydCB7QGxpbmsgUG9pbnR9LCBhbmQgYSBzdG9wIHBvaW50XG4gKiBhbmQgcmV0dXJucyBhIHN1YnNlY3Rpb24gb2YgdGhlIGxpbmUgaW4tYmV0d2VlbiB0aG9zZSBwb2ludHMuXG4gKiBUaGUgc3RhcnQgJiBzdG9wIHBvaW50cyBkb24ndCBuZWVkIHRvIGZhbGwgZXhhY3RseSBvbiB0aGUgbGluZS5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGV4dHJhY3Rpbmcgb25seSB0aGUgcGFydCBvZiBhIHJvdXRlIGJldHdlZW4gd2F5cG9pbnRzLlxuICpcbiAqIEBuYW1lIGxpbmVTbGljZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gc3RhcnRQdCBzdGFydGluZyBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gc3RvcFB0IHN0b3BwaW5nIHBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz58TGluZVN0cmluZ30gbGluZSBsaW5lIHRvIHNsaWNlXG4gKiBAcmV0dXJuIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBzbGljZWQgbGluZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgWy03Ny4wMzE2NjksIDM4Ljg3ODYwNV0sXG4gKiAgICAgICBbLTc3LjAyOTYwOSwgMzguODgxOTQ2XSxcbiAqICAgICAgIFstNzcuMDIwMzM5LCAzOC44ODQwODRdLFxuICogICAgICAgWy03Ny4wMjU2NjEsIDM4Ljg4NTgyMV0sXG4gKiAgICAgICBbLTc3LjAyMTg4NCwgMzguODg5NTYzXSxcbiAqICAgICAgIFstNzcuMDE5ODI0LCAzOC44OTIzNjhdXG4gKiAgICAgXVxuICogICB9XG4gKiB9O1xuICogdmFyIHN0YXJ0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzcuMDI5NjA5LCAzOC44ODE5NDZdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgc3RvcCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc3LjAyMTg4NCwgMzguODg5NTYzXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBzbGljZWQgPSB0dXJmLmxpbmVTbGljZShzdGFydCwgc3RvcCwgbGluZSk7XG4gKlxuICogLy89bGluZVxuICpcbiAqIC8vPXNsaWNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluZVNsaWNlKHN0YXJ0UHQsIHN0b3BQdCwgbGluZSkge1xuICAgIHZhciBjb29yZHM7XG4gICAgaWYgKGxpbmUudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNvb3JkcyA9IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIGlmIChsaW5lLnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBjb29yZHMgPSBsaW5lLmNvb3JkaW5hdGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBiZSBhIExpbmVTdHJpbmcgRmVhdHVyZSBvciBHZW9tZXRyeScpO1xuICAgIH1cblxuICAgIHZhciBzdGFydFZlcnRleCA9IHBvaW50T25MaW5lKGxpbmUsIHN0YXJ0UHQpO1xuICAgIHZhciBzdG9wVmVydGV4ID0gcG9pbnRPbkxpbmUobGluZSwgc3RvcFB0KTtcbiAgICB2YXIgZW5kcztcbiAgICBpZiAoc3RhcnRWZXJ0ZXgucHJvcGVydGllcy5pbmRleCA8PSBzdG9wVmVydGV4LnByb3BlcnRpZXMuaW5kZXgpIHtcbiAgICAgICAgZW5kcyA9IFtzdGFydFZlcnRleCwgc3RvcFZlcnRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kcyA9IFtzdG9wVmVydGV4LCBzdGFydFZlcnRleF07XG4gICAgfVxuICAgIHZhciBjbGlwTGluZSA9IGxpbmVzdHJpbmcoW2VuZHNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCB7fSk7XG4gICAgZm9yICh2YXIgaSA9IGVuZHNbMF0ucHJvcGVydGllcy5pbmRleCArIDE7IGkgPCBlbmRzWzFdLnByb3BlcnRpZXMuaW5kZXggKyAxOyBpKyspIHtcbiAgICAgICAgY2xpcExpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucHVzaChjb29yZHNbaV0pO1xuICAgIH1cbiAgICBjbGlwTGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy5wdXNoKGVuZHNbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgIHJldHVybiBjbGlwTGluZTtcbn07XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJ0B0dXJmL2ZsYXR0ZW4nKTtcbnZhciBwb2ludE9uTGluZSA9IHJlcXVpcmUoJ0B0dXJmL3BvaW50LW9uLWxpbmUnKTtcbnZhciBsaW5lU2VnbWVudCA9IHJlcXVpcmUoJ0B0dXJmL2xpbmUtc2VnbWVudCcpO1xudmFyIGdldENvb3JkcyA9IHJlcXVpcmUoJ0B0dXJmL2ludmFyaWFudCcpLmdldENvb3JkcztcbnZhciBsaW5lSW50ZXJzZWN0ID0gcmVxdWlyZSgnQHR1cmYvbGluZS1pbnRlcnNlY3QnKTtcbnZhciByYnVzaCA9IHJlcXVpcmUoJ2dlb2pzb24tcmJ1c2gnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpO1xudmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gaGVscGVycy5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBsaW5lU3RyaW5nID0gaGVscGVycy5saW5lU3RyaW5nO1xudmFyIG1ldGEgPSByZXF1aXJlKCdAdHVyZi9tZXRhJyk7XG52YXIgZmVhdHVyZUVhY2ggPSBtZXRhLmZlYXR1cmVFYWNoO1xudmFyIGZlYXR1cmVSZWR1Y2UgPSBtZXRhLmZlYXR1cmVSZWR1Y2U7XG5cbi8qKlxuICogU3BsaXQgYSBMaW5lU3RyaW5nIGJ5IGFub3RoZXIgR2VvSlNPTiBGZWF0dXJlLlxuICpcbiAqIEBuYW1lIGxpbmVTcGxpdFxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIExpbmVTdHJpbmcgRmVhdHVyZSB0byBzcGxpdFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50fE11bHRpUG9pbnR8TGluZVN0cmluZ3xNdWx0aUxpbmVTdHJpbmd8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBzcGxpdHRlciBGZWF0dXJlIHVzZWQgdG8gc3BsaXQgbGluZVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSBTcGxpdCBMaW5lU3RyaW5nc1xuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1sxMjAsIC0yNV0sIFsxNDUsIC0yNV1dXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgc3BsaXR0ZXIgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbWzEzMCwgLTE1XSwgWzEzMCwgLTM1XV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBzcGxpdCA9IHR1cmYubGluZVNwbGl0KGxpbmUsIHNwbGl0dGVyKTtcbiAqIC8vPXNwbGl0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpbmUsIHNwbGl0dGVyKSB7XG4gICAgaWYgKGdlb21UeXBlKGxpbmUpICE9PSAnTGluZVN0cmluZycpIHRocm93IG5ldyBFcnJvcignPGxpbmU+IG11c3QgYmUgTGluZVN0cmluZycpO1xuICAgIGlmIChnZW9tVHlwZShzcGxpdHRlcikgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHRocm93IG5ldyBFcnJvcignPHNwbGl0dGVyPiBjYW5ub3QgYmUgYSBGZWF0dXJlQ29sbGVjdGlvbicpO1xuXG4gICAgc3dpdGNoIChnZW9tVHlwZShzcGxpdHRlcikpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIHJldHVybiBzcGxpdExpbmVXaXRoUG9pbnQobGluZSwgc3BsaXR0ZXIpO1xuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICByZXR1cm4gc3BsaXRMaW5lV2l0aFBvaW50cyhsaW5lLCBmbGF0dGVuKHNwbGl0dGVyKSk7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICByZXR1cm4gc3BsaXRMaW5lV2l0aFBvaW50cyhsaW5lLCBsaW5lSW50ZXJzZWN0KGxpbmUsIHNwbGl0dGVyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8c3BsaXR0ZXI+IGdlb21ldHJ5IHR5cGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIEdlb21ldHJ5IFR5cGUgZnJvbSBHZW9KU09OXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxhbnk+fSBnZW9qc29uIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEdlb21ldHJ5IFR5cGVcbiAqL1xuZnVuY3Rpb24gZ2VvbVR5cGUoZ2VvanNvbikge1xuICAgIHJldHVybiAoZ2VvanNvbi5nZW9tZXRyeSkgPyBnZW9qc29uLmdlb21ldHJ5LnR5cGUgOiBnZW9qc29uLnR5cGU7XG59XG5cbi8qKlxuICogU3BsaXQgTGluZVN0cmluZyB3aXRoIE11bHRpUG9pbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBzcGxpdHRlciBQb2ludFxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSBzcGxpdCBMaW5lU3RyaW5nc1xuICovXG5mdW5jdGlvbiBzcGxpdExpbmVXaXRoUG9pbnRzKGxpbmUsIHNwbGl0dGVyKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdHJlZSA9IHJidXNoKCk7XG5cbiAgICBmZWF0dXJlRWFjaChzcGxpdHRlciwgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIC8vIEFkZCBpbmRleC9pZCB0byBmZWF0dXJlcyAobmVlZGVkIGZvciBmaWx0ZXIpXG4gICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpcnN0IFBvaW50IC0gZG9lc24ndCBuZWVkIHRvIGhhbmRsZSBhbnkgcHJldmlvdXMgbGluZSByZXN1bHRzXG4gICAgICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBzcGxpdExpbmVXaXRoUG9pbnQobGluZSwgcG9pbnQpLmZlYXR1cmVzO1xuICAgICAgICAgICAgdHJlZS5sb2FkKGZlYXR1cmVDb2xsZWN0aW9uKHJlc3VsdHMpKTtcbiAgICAgICAgLy8gU3BsaXQgd2l0aCByZW1haW5pbmcgcG9pbnRzIC0gbGluZXMgbWlnaHQgbmVlZGVkIHRvIGJlIHNwbGl0IG11bHRpcGxlIHRpbWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBsaW5lcyB0aGF0IGFyZSB3aXRoaW4gdGhlIHNwbGl0dGVyJ3MgYmJveFxuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHRyZWUuc2VhcmNoKHBvaW50KTtcblxuICAgICAgICAgICAgLy8gUkJ1c2ggbWlnaHQgcmV0dXJuIG11bHRpcGxlIGxpbmVzIC0gb25seSBwcm9jZXNzIHRoZSBjbG9zZXN0IGxpbmUgdG8gc3BsaXR0ZXJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0TGluZSA9IGZpbmRDbG9zZXN0RmVhdHVyZShwb2ludCwgc2VhcmNoKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNsb3Nlc3QgbGluZSBmcm9tIHJlc3VsdHMgc2luY2UgdGhpcyB3aWxsIGJlIHNwbGl0IGludG8gdHdvIGxpbmVzXG4gICAgICAgICAgICAvLyBUaGlzIHJlbW92ZXMgYW55IGR1cGxpY2F0ZXMgaW5zaWRlIHRoZSByZXN1bHRzICYgaW5kZXhcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAoZmVhdHVyZSkgeyByZXR1cm4gZmVhdHVyZS5pZCAhPT0gY2xvc2VzdExpbmUuaWQ7IH0pO1xuICAgICAgICAgICAgdHJlZS5yZW1vdmUoY2xvc2VzdExpbmUpO1xuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHR3byBuZXdseSBzcGxpdCBsaW5lcyBpbnRvIHRoZSByZXN1bHRzXG4gICAgICAgICAgICBmZWF0dXJlRWFjaChzcGxpdExpbmVXaXRoUG9pbnQoY2xvc2VzdExpbmUsIHBvaW50KSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgdHJlZS5pbnNlcnQobGluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbn1cblxuLyoqXG4gKiBTcGxpdCBMaW5lU3RyaW5nIHdpdGggTXVsdGlQb2ludFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgTGluZVN0cmluZ1xuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gc3BsaXR0ZXIgUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gc3BsaXQgTGluZVN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lV2l0aFBvaW50KGxpbmUsIHNwbGl0dGVyKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIENyZWF0ZSBzcGF0aWFsIGluZGV4XG4gICAgdmFyIHRyZWUgPSByYnVzaCgpO1xuICAgIHZhciBzZWdtZW50cyA9IGxpbmVTZWdtZW50KGxpbmUpO1xuICAgIHRyZWUubG9hZChzZWdtZW50cyk7XG5cbiAgICAvLyBGaW5kIGFsbCBzZWdtZW50cyB0aGF0IGFyZSB3aXRoaW4gYmJveCBvZiBzcGxpdHRlclxuICAgIHZhciBzZWFyY2ggPSB0cmVlLnNlYXJjaChzcGxpdHRlcik7XG5cbiAgICAvLyBSZXR1cm4gaXRzZWxmIGlmIHBvaW50IGlzIG5vdCB3aXRoaW4gc3BhdGlhbCBpbmRleFxuICAgIGlmICghc2VhcmNoLmZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKFtsaW5lXSk7XG5cbiAgICAvLyBSQnVzaCBtaWdodCByZXR1cm4gbXVsdGlwbGUgbGluZXMgLSBvbmx5IHByb2Nlc3MgdGhlIGNsb3Nlc3QgbGluZSB0byBzcGxpdHRlclxuICAgIHZhciBjbG9zZXN0U2VnbWVudCA9IGZpbmRDbG9zZXN0RmVhdHVyZShzcGxpdHRlciwgc2VhcmNoKTtcblxuICAgIC8vIEluaXRpYWwgdmFsdWUgaXMgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBmaXJzdCBzZWdtZW50cyAoYmVnaW5pbmcgb2YgbGluZSlcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gW2dldENvb3JkcyhzZWdtZW50cy5mZWF0dXJlc1swXSlbMF1dO1xuICAgIHZhciBsYXN0Q29vcmRzID0gZmVhdHVyZVJlZHVjZShzZWdtZW50cywgZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50LCBpbmRleCkge1xuXG4gICAgICAgIC8vIExvY2F0aW9uIHdoZXJlIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIGxpbmVcbiAgICAgICAgaWYgKGluZGV4ID09PSBjbG9zZXN0U2VnbWVudC5pZCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGdldENvb3JkcyhzcGxpdHRlcik7XG4gICAgICAgICAgICBwcmV2aW91cy5wdXNoKGNvb3Jkcyk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobGluZVN0cmluZyhwcmV2aW91cykpO1xuICAgICAgICAgICAgcmV0dXJuIFtjb29yZHMsIGdldENvb3JkcyhjdXJyZW50KVsxXV07XG5cbiAgICAgICAgLy8gS2VlcCBpdGVyYXRpbmcgb3ZlciBjb29yZHMgdW50aWwgZmluaXNoZWQgb3IgaW50ZXJzZWN0aW9uIGlzIGZvdW5kXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91cy5wdXNoKGdldENvb3JkcyhjdXJyZW50KVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9LCBpbml0aWFsVmFsdWUpO1xuICAgIC8vIEFwcGVuZCBsYXN0IGxpbmUgdG8gZmluYWwgc3BsaXQgcmVzdWx0c1xuICAgIHJlc3VsdHMucHVzaChsaW5lU3RyaW5nKGxhc3RDb29yZHMpKTtcbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24ocmVzdWx0cyk7XG59XG5cbi8qKlxuICogRmluZCBDbG9zZXN0IEZlYXR1cmVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQgRmVhdHVyZSBtdXN0IGJlIGNsb3Nlc3QgdG8gdGhpcyBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gbGluZXMgQ29sbGVjdGlvbiBvZiBGZWF0dXJlc1xuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IGNsb3Nlc3QgTGluZVN0cmluZ1xuICovXG5mdW5jdGlvbiBmaW5kQ2xvc2VzdEZlYXR1cmUocG9pbnQsIGxpbmVzKSB7XG4gICAgLy8gRmlsdGVyIHRvIG9uZSBzZWdtZW50IHRoYXQgaXMgdGhlIGNsb3Nlc3QgdG8gdGhlIGxpbmVcbiAgICB2YXIgY2xvc2VzdERpc3RhbmNlO1xuICAgIHZhciBjbG9zZXN0RmVhdHVyZTtcbiAgICBpZiAoIWxpbmVzLmZlYXR1cmVzKSB0aHJvdyBuZXcgRXJyb3IoJzxsaW5lcz4gbXVzdCBjb250YWluIGZlYXR1cmVzJyk7XG4gICAgaWYgKGxpbmVzLmZlYXR1cmVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpbmVzLmZlYXR1cmVzWzBdO1xuXG4gICAgZmVhdHVyZUVhY2gobGluZXMsIGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50T25MaW5lKHNlZ21lbnQsIHBvaW50KTtcbiAgICAgICAgdmFyIGRpc3QgPSBwdC5wcm9wZXJ0aWVzLmRpc3Q7XG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvc2VzdEZlYXR1cmUgPSBzZWdtZW50O1xuICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXN0IDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0RmVhdHVyZSA9IHNlZ21lbnQ7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RGZWF0dXJlO1xufVxuIiwidmFyIGZlYXR1cmVFYWNoID0gcmVxdWlyZSgnQHR1cmYvbWV0YScpLmZlYXR1cmVFYWNoO1xudmFyIHJidXNoID0gcmVxdWlyZSgncmJ1c2gnKTtcbnZhciB0dXJmQkJveCA9IHJlcXVpcmUoJ0B0dXJmL2Jib3gnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgnQHR1cmYvdW5pb24nKTtcblxuLyoqXG4gKiBUYWtlcyBhbnkgdHlwZSBvZiB7QGxpbmsgUG9seWdvbnxwb2x5Z29ufSBhbmQgYW4gb3B0aW9uYWwgbWFzayBhbmQgcmV0dXJucyBhIHtAbGluayBQb2x5Z29ufHBvbHlnb259IGV4dGVyaW9yIHJpbmcgd2l0aCBob2xlcy5cbiAqXG4gKiBAbmFtZSBtYXNrXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmU8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBwb2x5Z29uIEdlb0pTT04gUG9seWdvbiB1c2VkIGFzIGludGVyaW9yIHJpbmdzIG9yIGhvbGVzLlxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBbbWFza10gR2VvSlNPTiBQb2x5Z29uIHVzZWQgYXMgdGhlIGV4dGVyaW9yIHJpbmcgKGlmIHVuZGVmaW5lZCwgdGhlIHdvcmxkIGV4dGVudCBpcyB1c2VkKVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IE1hc2tlZCBQb2x5Z29uIChleHRlcmlvciByaW5nIHdpdGggaG9sZXMpLlxuICogQGFkZFRvTWFwIG1hc2tlZFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tbMTEyLCAtMjFdLCBbMTE2LCAtMzZdLCBbMTQ2LCAtMzldLCBbMTUzLCAtMjRdLCBbMTMzLCAtMTBdLCBbMTEyLCAtMjFdXV1cbiAqICAgfVxuICogfVxuICogdmFyIG1hc2sgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1s5MCwgLTU1XSwgWzE3MCwgLTU1XSwgWzE3MCwgMTBdLCBbOTAsIDEwXSwgWzkwLCAtNTVdXV1cbiAqICAgfVxuICogfVxuICogdmFyIG1hc2tlZCA9IHR1cmYubWFzayhwb2x5Z29uLCBtYXNrKTtcbiAqIC8vPW1hc2tlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2x5Z29uLCBtYXNrKSB7XG4gICAgLy8gRGVmaW5lIG1hc2tcbiAgICB2YXIgbWFza1BvbHlnb24gPSBjcmVhdGVNYXNrKG1hc2spO1xuXG4gICAgLy8gRGVmaW5lIHBvbHlnb25cbiAgICB2YXIgc2VwYXJhdGVkID0gc2VwYXJhdGVQb2x5Z29ucyhwb2x5Z29uKTtcbiAgICB2YXIgcG9seWdvbk91dGVycyA9IHNlcGFyYXRlZFswXTtcbiAgICB2YXIgcG9seWdvbklubmVycyA9IHNlcGFyYXRlZFsxXTtcblxuICAgIC8vIFVuaW9uIE91dGVycyAmIElubmVyc1xuICAgIHBvbHlnb25PdXRlcnMgPSB1bmlvblBvbHlnb25zKHBvbHlnb25PdXRlcnMpO1xuICAgIHBvbHlnb25Jbm5lcnMgPSB1bmlvblBvbHlnb25zKHBvbHlnb25Jbm5lcnMpO1xuXG4gICAgLy8gQ3JlYXRlIG1hc2tlZCBhcmVhXG4gICAgdmFyIG1hc2tlZCA9IGJ1aWxkTWFzayhtYXNrUG9seWdvbiwgcG9seWdvbk91dGVycywgcG9seWdvbklubmVycyk7XG4gICAgcmV0dXJuIG1hc2tlZDtcbn07XG5cbi8qKlxuICogQnVpbGQgTWFza1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IG1hc2tQb2x5Z29uIE1hc2sgT3V0ZXJcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25PdXRlcnMgUG9seWdvbiBPdXRlcnNcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25Jbm5lcnMgUG9seWdvbiBJbm5lcnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBGZWF0dXJlIFBvbHlnb25cbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXNrKG1hc2tQb2x5Z29uLCBwb2x5Z29uT3V0ZXJzLCBwb2x5Z29uSW5uZXJzKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gW107XG4gICAgY29vcmRpbmF0ZXMucHVzaChtYXNrUG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XG5cbiAgICBmZWF0dXJlRWFjaChwb2x5Z29uT3V0ZXJzLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBjb29yZGluYXRlcy5wdXNoKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0pO1xuICAgIH0pO1xuXG4gICAgZmVhdHVyZUVhY2gocG9seWdvbklubmVycywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaChmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVscGVycy5wb2x5Z29uKGNvb3JkaW5hdGVzKTtcbn1cblxuLyoqXG4gKiBTZXBhcmF0ZSBQb2x5Z29ucyB0byBpbm5lcnMgJiBvdXRlcnNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPFBvbHlnb258TXVsdGlQb2x5Z29uPn0gcG9seWdvbiBHZW9KU09OIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtBcnJheTxGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPiwgRmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj4+fSBPdXRlciAmIElubmVyIGxpbmVzXG4gKi9cbmZ1bmN0aW9uIHNlcGFyYXRlUG9seWdvbnMocG9seWdvbikge1xuICAgIHZhciBvdXRlcnMgPSBbXTtcbiAgICB2YXIgaW5uZXJzID0gW107XG4gICAgZmVhdHVyZUVhY2gocG9seWdvbiwgZnVuY3Rpb24gKG11bHRpRmVhdHVyZSkge1xuICAgICAgICBpZiAobXVsdGlGZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICBtdWx0aUZlYXR1cmUgPSBmbGF0dGVuTXVsdGlQb2x5Z29uKG11bHRpRmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZUVhY2gobXVsdGlGZWF0dXJlLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIHZhciBmZWF0dXJlT3V0ZXIgPSBjb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlSW5uZXIgPSBjb29yZGluYXRlcy5zbGljZSgxKTtcbiAgICAgICAgICAgIG91dGVycy5wdXNoKGhlbHBlcnMucG9seWdvbihbZmVhdHVyZU91dGVyXSkpO1xuICAgICAgICAgICAgZmVhdHVyZUlubmVyLmZvckVhY2goZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJzLnB1c2goaGVscGVycy5wb2x5Z29uKFtpbm5lcl0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2hlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb24ob3V0ZXJzKSwgaGVscGVycy5mZWF0dXJlQ29sbGVjdGlvbihpbm5lcnMpXTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIE11bHRpUG9seWdvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gbXVsdGlQb2x5Z29uIEdlb0pTT04gRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBGZWF0dXJlIENvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbk11bHRpUG9seWdvbihtdWx0aVBvbHlnb24pIHtcbiAgICB2YXIgcG9seWdvbnMgPSBbXTtcbiAgICBtdWx0aVBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcG9seWdvbnMucHVzaChoZWxwZXJzLnBvbHlnb24oY29vcmRpbmF0ZXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVscGVycy5mZWF0dXJlQ29sbGVjdGlvbihwb2x5Z29ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIE1hc2sgQ29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBbbWFza10gZGVmYXVsdCB0byB3b3JsZCBpZiB1bmRlZmluZWRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBtYXNrIGNvb3JkaW5hdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFzayhtYXNrKSB7XG4gICAgdmFyIHdvcmxkID0gW1tbMTgwLCA5MF0sIFstMTgwLCA5MF0sIFstMTgwLCAtOTBdLCBbMTgwLCAtOTBdLCBbMTgwLCA5MF1dXTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBtYXNrICYmIG1hc2suZ2VvbWV0cnkuY29vcmRpbmF0ZXMgfHwgd29ybGQ7XG4gICAgcmV0dXJuIGhlbHBlcnMucG9seWdvbihjb29yZGluYXRlcyk7XG59XG5cbi8qKlxuICogVW5pb24gUG9seWdvbnNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gcG9seWdvbnMgY29sbGVjdGlvbiBvZiBwb2x5Z29uc1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyBvbmx5IGFwcGx5IHVuaW9uIGlmIHRoZXkgY29sbGlkZVxuICovXG5mdW5jdGlvbiB1bmlvblBvbHlnb25zKHBvbHlnb25zKSB7XG4gICAgaWYgKHBvbHlnb25zLmZlYXR1cmVzLmxlbmd0aCA8PSAxKSByZXR1cm4gcG9seWdvbnM7XG5cbiAgICB2YXIgdHJlZSA9IGNyZWF0ZUluZGV4KHBvbHlnb25zKTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciByZW1vdmVkID0ge307XG5cbiAgICBmZWF0dXJlRWFjaChwb2x5Z29ucywgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgLy8gRXhjbHVkZSBhbnkgcmVtb3ZlZCBmZWF0dXJlc1xuICAgICAgICBpZiAocmVtb3ZlZFtjdXJyZW50SW5kZXhdKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBEb24ndCBzZWFyY2ggZm9yIGl0c2VsZlxuICAgICAgICB0cmVlLnJlbW92ZSh7aW5kZXg6IGN1cnJlbnRJbmRleH0sIGZpbHRlckJ5SW5kZXgpO1xuICAgICAgICByZW1vdmVkW2N1cnJlbnRJbmRleF0gPSB0cnVlO1xuXG4gICAgICAgIC8vIEtlZXAgYXBwbHlpbmcgdGhlIHVuaW9uIG9wZXJhdGlvbiB1bnRpbCBubyBtb3JlIG92ZXJsYXBwaW5nIGZlYXR1cmVzXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IHR1cmZCQm94KGN1cnJlbnRGZWF0dXJlKTtcbiAgICAgICAgICAgIHZhciBzZWFyY2ggPSB0cmVlLnNlYXJjaCh7XG4gICAgICAgICAgICAgICAgbWluWDogYmJveFswXSxcbiAgICAgICAgICAgICAgICBtaW5ZOiBiYm94WzFdLFxuICAgICAgICAgICAgICAgIG1heFg6IGJib3hbMl0sXG4gICAgICAgICAgICAgICAgbWF4WTogYmJveFszXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9seXMgPSBzZWFyY2gubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRbaXRlbS5pbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cmVlLnJlbW92ZSh7aW5kZXg6IGl0ZW0uaW5kZXh9LCBmaWx0ZXJCeUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2VvanNvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwb2x5cy5wdXNoKGN1cnJlbnRGZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmVhdHVyZSA9IHVuaW9uLmFwcGx5KHRoaXMsIHBvbHlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbmVcbiAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzLnB1c2goY3VycmVudEZlYXR1cmUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb24ocmVzdWx0cyk7XG59XG5cbi8qKlxuICogRmlsdGVyIGJ5IEluZGV4IC0gUkJ1c2ggaGVscGVyIGZ1bmN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIHJlbW92ZSBpdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gYiBzZWFyY2ggaXRlbVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbWF0Y2hlc1xuICovXG5mdW5jdGlvbiBmaWx0ZXJCeUluZGV4KGEsIGIpIHtcbiAgICByZXR1cm4gYS5pbmRleCA9PT0gYi5pbmRleDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgUkJ1c2ggVHJlZSBJbmRleFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPGFueT59IGZlYXR1cmVzIEdlb0pTT04gRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtSQnVzaH0gUkJ1c2ggVHJlZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmRleChmZWF0dXJlcykge1xuICAgIHZhciB0cmVlID0gcmJ1c2goKTtcbiAgICB2YXIgbG9hZCA9IFtdO1xuICAgIGZlYXR1cmVFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoZmVhdHVyZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGJib3ggPSB0dXJmQkJveChmZWF0dXJlKTtcbiAgICAgICAgbG9hZC5wdXNoKHtcbiAgICAgICAgICAgIG1pblg6IGJib3hbMF0sXG4gICAgICAgICAgICBtaW5ZOiBiYm94WzFdLFxuICAgICAgICAgICAgbWF4WDogYmJveFsyXSxcbiAgICAgICAgICAgIG1heFk6IGJib3hbM10sXG4gICAgICAgICAgICBnZW9qc29uOiBmZWF0dXJlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRyZWUubG9hZChsb2FkKTtcbiAgICByZXR1cm4gdHJlZTtcbn1cbiIsIi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkRWFjaFxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2FsbGJhY2sgY29vcmRFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gY3VycmVudENvb3JkcyBUaGUgY3VycmVudCBjb29yZGluYXRlcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGVcbiAqIGFycmF5LlN0YXJ0cyBhdCBpbmRleCAwLCBpZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQsIGFuZCBhdCBpbmRleCAxIG90aGVyd2lzZS5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgY29vcmRFYWNoXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50Q29vcmRzLCBjdXJyZW50SW5kZXgpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmNvb3JkRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRDb29yZHMsIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1jdXJyZW50Q29vcmRzXG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChsYXllciwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICB2YXIgaSwgaiwgaywgZywgbCwgZ2VvbWV0cnksIHN0b3BHLCBjb29yZHMsXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgICB3cmFwU2hyaW5rID0gMCxcbiAgICAgICAgY3VycmVudEluZGV4ID0gMCxcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSBsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBpc0ZlYXR1cmUgPSBsYXllci50eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gbGF5ZXIuZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gICAgZm9yIChpID0gMDsgaSA8IHN0b3A7IGkrKykge1xuXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6XG4gICAgICAgIChpc0ZlYXR1cmUgPyBsYXllci5nZW9tZXRyeSA6IGxheWVyKSk7XG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XG4gICAgICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICAgICAgZm9yIChnID0gMDsgZyA8IHN0b3BHOyBnKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gP1xuICAgICAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuICAgICAgICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIHdyYXBTaHJpbmsgPSAoZXhjbHVkZVdyYXBDb29yZCAmJlxuICAgICAgICAgICAgICAgIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpKSA/XG4gICAgICAgICAgICAgICAgMSA6IDA7XG5cbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjb29yZHNbal0sIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvb3Jkc1tqXVtrXSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBjb29yZHNbal1ba10ubGVuZ3RoIC0gd3JhcFNocmluazsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdW2xdLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICBjb29yZEVhY2goZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvbWV0cnkgVHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMuY29vcmRFYWNoID0gY29vcmRFYWNoO1xuXG4vKipcbiAqIENhbGxiYWNrIGZvciBjb29yZFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBjb29yZFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBjdXJyZW50Q29vcmRzIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlXG4gKiBhcnJheS5TdGFydHMgYXQgaW5kZXggMCwgaWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkLCBhbmQgYXQgaW5kZXggMSBvdGhlcndpc2UuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpXG4gKlxuICogQG5hbWUgY29vcmRSZWR1Y2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZHMsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmNvb3JkUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkcywgY3VycmVudEluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudENvb3Jkc1xuICogICAvLz1jdXJyZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRDb29yZHM7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRSZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUsIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBjb29yZEVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmRzLCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRDb29yZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkcywgY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxubW9kdWxlLmV4cG9ydHMuY29vcmRSZWR1Y2UgPSBjb29yZFJlZHVjZTtcblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcEVhY2hcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhbGxiYWNrIHByb3BFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgcHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGVcbiAqIGFycmF5LlN0YXJ0cyBhdCBpbmRleCAwLCBpZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQsIGFuZCBhdCBpbmRleCAxIG90aGVyd2lzZS5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBwcm9wRWFjaFxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudFByb3BlcnRpZXMsIGN1cnJlbnRJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XCJmb29cIjogXCJiYXJcIn0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcImhlbGxvXCI6IFwid29ybGRcIn0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMzYsIDUzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqIHR1cmYucHJvcEVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50UHJvcGVydGllcywgY3VycmVudEluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHByb3BFYWNoKGxheWVyLCBjYWxsYmFjaykge1xuICAgIHZhciBpO1xuICAgIHN3aXRjaCAobGF5ZXIudHlwZSkge1xuICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXllci5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIucHJvcGVydGllcywgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLnByb3BFYWNoID0gcHJvcEVhY2g7XG5cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBwcm9wUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0geyp9IGN1cnJlbnRQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IHByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlXG4gKiBhcnJheS5TdGFydHMgYXQgaW5kZXggMCwgaWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkLCBhbmQgYXQgaW5kZXggMSBvdGhlcndpc2UuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZSxcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBwcm9wZXJ0aWVzIGlzIHVubmVjZXNzYXJ5LlxuICpcbiAqIEBuYW1lIHByb3BSZWR1Y2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBjdXJyZW50SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcImZvb1wiOiBcImJhclwifSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyNiwgMzddXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1wiaGVsbG9cIjogXCJ3b3JsZFwifSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFszNiwgNTNdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICogdHVyZi5wcm9wUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWN1cnJlbnRJbmRleFxuICogICByZXR1cm4gY3VycmVudFByb3BlcnRpZXNcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGxheWVyLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgcHJvcEVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjdXJyZW50UHJvcGVydGllcywgY3VycmVudEluZGV4KSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50UHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50UHJvcGVydGllcywgY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxubW9kdWxlLmV4cG9ydHMucHJvcFJlZHVjZSA9IHByb3BSZWR1Y2U7XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVFYWNoXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBmZWF0dXJlRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgZmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGVcbiAqIGFycmF5LlN0YXJ0cyBhdCBpbmRleCAwLCBpZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQsIGFuZCBhdCBpbmRleCAxIG90aGVyd2lzZS5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmVhdHVyZUVhY2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBjdXJyZW50SW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjYsIDM3XVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmZlYXR1cmVFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1jdXJyZW50SW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlRWFjaChsYXllciwgY2FsbGJhY2spIHtcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNhbGxiYWNrKGxheWVyLCAwKTtcbiAgICB9IGVsc2UgaWYgKGxheWVyLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXIuZmVhdHVyZXNbaV0sIGkpO1xuICAgICAgICB9XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMuZmVhdHVyZUVhY2ggPSBmZWF0dXJlRWFjaDtcblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZmVhdHVyZVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBmZWF0dXJlUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGVcbiAqIGFycmF5LlN0YXJ0cyBhdCBpbmRleCAwLCBpZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQsIGFuZCBhdCBpbmRleCAxIG90aGVyd2lzZS5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZmVhdHVyZVJlZHVjZVxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1wiZm9vXCI6IFwiYmFyXCJ9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI2LCAzN11cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmZlYXR1cmVSZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgY3VycmVudEluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89Y3VycmVudEluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVSZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBmZWF0dXJlRWFjaChsYXllciwgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRGZWF0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5tb2R1bGUuZXhwb3J0cy5mZWF0dXJlUmVkdWNlID0gZmVhdHVyZVJlZHVjZTtcblxuLyoqXG4gKiBHZXQgYWxsIGNvb3JkaW5hdGVzIGZyb20gYW55IEdlb0pTT04gb2JqZWN0LlxuICpcbiAqIEBuYW1lIGNvb3JkQWxsXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGUgcG9zaXRpb24gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyNiwgMzddXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMzYsIDUzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqIHZhciBjb29yZHMgPSB0dXJmLmNvb3JkQWxsKGZlYXR1cmVzKTtcbiAqIC8vPWNvb3Jkc1xuICovXG5mdW5jdGlvbiBjb29yZEFsbChsYXllcikge1xuICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICBjb29yZEVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBjb29yZHMucHVzaChjb29yZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvb3Jkcztcbn1cbm1vZHVsZS5leHBvcnRzLmNvb3JkQWxsID0gY29vcmRBbGw7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggZ2VvbWV0cnkgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LmZvckVhY2goKVxuICpcbiAqIEBuYW1lIGdlb21FYWNoXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50R2VvbWV0cnksIGN1cnJlbnRJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyNiwgMzddXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMzYsIDUzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqIHR1cmYuZ2VvbUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50R2VvbWV0cnksIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89Y3VycmVudEluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZ2VvbUVhY2gobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGosIGcsIGdlb21ldHJ5LCBzdG9wRyxcbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgICAgICBjdXJyZW50SW5kZXggPSAwLFxuICAgICAgICBpc0ZlYXR1cmVDb2xsZWN0aW9uID0gbGF5ZXIudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgaXNGZWF0dXJlID0gbGF5ZXIudHlwZSA9PT0gJ0ZlYXR1cmUnLFxuICAgICAgICBzdG9wID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGxheWVyLmZlYXR1cmVzLmxlbmd0aCA6IDE7XG5cbiAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgLy8gaXMgYmVjYXVzZSBpdCdzIHRyeWluZyB0byBiZSBmYXN0LiBHZW9KU09OIHN1cHBvcnRzIG11bHRpcGxlIGtpbmRzXG4gIC8vIG9mIG9iamVjdHMgYXQgaXRzIHJvb3Q6IEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlcywgR2VvbWV0cmllcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAvLyBtZWFucyB0aGF0IHNvbWUgb2YgdGhlIGBmb3JgIGxvb3BzIHlvdSBzZWUgYmVsb3cgYWN0dWFsbHkganVzdCBkb24ndCBhcHBseVxuICAvLyB0byBjZXJ0YWluIGlucHV0cy4gRm9yIGluc3RhbmNlLCBpZiB5b3UgZ2l2ZSB0aGlzIGp1c3QgYVxuICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAvLyBpcyBncmFkdWFsbHkgcmVuYW1lIHRoZSBpbnB1dCB1bnRpbCBpdCdzIGNhbGxlZCAnZ2VvbWV0cnknLlxuICAvL1xuICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgLy8gZmV3IG51bWJlcnMgYW5kIGJvb2xlYW5zLCByYXRoZXIgdGhhbiBhbnkgdGVtcG9yYXJ5IGFycmF5cyBhcyB3b3VsZFxuICAvLyBiZSByZXF1aXJlZCB3aXRoIHRoZSBub3JtYWxpemF0aW9uIGFwcHJvYWNoLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdG9wOyBpKyspIHtcblxuICAgICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IChpc0ZlYXR1cmVDb2xsZWN0aW9uID8gbGF5ZXIuZmVhdHVyZXNbaV0uZ2VvbWV0cnkgOlxuICAgICAgICAoaXNGZWF0dXJlID8gbGF5ZXIuZ2VvbWV0cnkgOiBsYXllcikpO1xuICAgICAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLnR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nO1xuICAgICAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggOiAxO1xuXG4gICAgICAgIGZvciAoZyA9IDA7IGcgPCBzdG9wRzsgZysrKSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID9cbiAgICAgICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXNbZ10gOiBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbjtcblxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcgfHxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcgfHxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZ2VvbWV0cnksIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvbWV0cnkgVHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMuZ2VvbUVhY2ggPSBnZW9tRWFjaDtcblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYWxsYmFjayBnZW9tUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0geyp9IGN1cnJlbnRHZW9tZXRyeSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZVxuICogYXJyYXkuU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICovXG5cbi8qKlxuICogUmVkdWNlIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBnZW9tUmVkdWNlXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1wiZm9vXCI6IFwiYmFyXCJ9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI2LCAzN11cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzM2LCA1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB0dXJmLmdlb21SZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGN1cnJlbnRJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRHZW9tZXRyeVxuICogICAvLz1jdXJyZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRHZW9tZXRyeVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21SZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBnZW9tRWFjaChsYXllciwgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgY3VycmVudEluZGV4KSB7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50R2VvbWV0cnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2socHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5tb2R1bGUuZXhwb3J0cy5nZW9tUmVkdWNlID0gZ2VvbVJlZHVjZTtcbiIsInZhciBiZWFyaW5nID0gcmVxdWlyZSgnQHR1cmYvYmVhcmluZycpO1xudmFyIGRlc3RpbmF0aW9uID0gcmVxdWlyZSgnQHR1cmYvZGVzdGluYXRpb24nKTtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyk7XG5cbi8qKlxuICogVGFrZXMgdHdvIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCByZXR1cm5zIGEgcG9pbnQgbWlkd2F5IGJldHdlZW4gdGhlbS5cbiAqIFRoZSBtaWRwb2ludCBpcyBjYWxjdWxhdGVkIGdlb2Rlc2ljYWxseSwgbWVhbmluZyB0aGUgY3VydmF0dXJlIG9mIHRoZSBlYXJ0aCBpcyB0YWtlbiBpbnRvIGFjY291bnQuXG4gKlxuICogQG5hbWUgbWlkcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IGZyb20gZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHRvIHNlY29uZCBwb2ludFxuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSBhIHBvaW50IG1pZHdheSBiZXR3ZWVuIGBwdDFgIGFuZCBgcHQyYFxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWzE0NC44MzQ4MjMsIC0zNy43NzEyNTddXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcHQyID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxNDUuMTQyNDQsIC0zNy44MzA5MzddXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIG1pZHBvaW50ZWQgPSB0dXJmLm1pZHBvaW50KHB0MSwgcHQyKTtcbiAqIG1pZHBvaW50ZWQucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnI2YwMCc7XG4gKlxuICpcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW3B0MSwgcHQyLCBtaWRwb2ludGVkXVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGZyb20sIHRvLCAnbWlsZXMnKTtcbiAgICB2YXIgaGVhZGluZyA9IGJlYXJpbmcoZnJvbSwgdG8pO1xuICAgIHZhciBtaWRwb2ludCA9IGRlc3RpbmF0aW9uKGZyb20sIGRpc3QgLyAyLCBoZWFkaW5nLCAnbWlsZXMnKTtcblxuICAgIHJldHVybiBtaWRwb2ludDtcbn07XG4iLCJ2YXIgZGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgcmVmZXJlbmNlIHtAbGluayBQb2ludHxwb2ludH0gYW5kIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgRmVhdHVyZXNcbiAqIHdpdGggUG9pbnQgZ2VvbWV0cmllcyBhbmQgcmV0dXJucyB0aGVcbiAqIHBvaW50IGZyb20gdGhlIEZlYXR1cmVDb2xsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIHJlZmVyZW5jZS4gVGhpcyBjYWxjdWxhdGlvblxuICogaXMgZ2VvZGVzaWMuXG4gKlxuICogQG5hbWUgbmVhcmVzdFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gdGFyZ2V0UG9pbnQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBhZ2FpbnN0IGlucHV0IHBvaW50IHNldFxuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSB0aGUgY2xvc2VzdCBwb2ludCBpbiB0aGUgc2V0IHRvIHRoZSByZWZlcmVuY2UgcG9pbnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcIm1hcmtlci1jb2xvclwiOiBcIiMwZjBcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWzI4Ljk2NTc5NywgNDEuMDEwMDg2XVxuICogICB9XG4gKiB9O1xuICogdmFyIGFnYWluc3QgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyOC45NzM4NjUsIDQxLjAxMTEyMl1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjguOTQ4NDU5LCA0MS4wMjQyMDRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI4LjkzODY3NCwgNDEuMDEzMzI0XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgbmVhcmVzdCA9IHR1cmYubmVhcmVzdChwb2ludCwgYWdhaW5zdCk7XG4gKiBuZWFyZXN0LnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyNmMDAnO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IGFnYWluc3QuZmVhdHVyZXMuY29uY2F0KHBvaW50KTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldFBvaW50LCBwb2ludHMpIHtcbiAgICB2YXIgbmVhcmVzdFBvaW50LCBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Qb2ludCA9IGRpc3RhbmNlKHRhcmdldFBvaW50LCBwb2ludHMuZmVhdHVyZXNbaV0sICdtaWxlcycpO1xuICAgICAgICBpZiAoZGlzdGFuY2VUb1BvaW50IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgbmVhcmVzdFBvaW50ID0gcG9pbnRzLmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgbWluRGlzdCA9IGRpc3RhbmNlVG9Qb2ludDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmVhcmVzdFBvaW50O1xufTtcbiIsIi8qKlxuICogVGFrZXMgYSB0cmlhbmd1bGFyIHBsYW5lIGFzIGEge0BsaW5rIFBvbHlnb259XG4gKiBhbmQgYSB7QGxpbmsgUG9pbnR9IHdpdGhpbiB0aGF0IHRyaWFuZ2xlIGFuZCByZXR1cm5zIHRoZSB6LXZhbHVlXG4gKiBhdCB0aGF0IHBvaW50LiBUaGUgUG9seWdvbiBuZWVkcyB0byBoYXZlIHByb3BlcnRpZXMgYGFgLCBgYmAsIGFuZCBgY2BcbiAqIHRoYXQgZGVmaW5lIHRoZSB2YWx1ZXMgYXQgaXRzIHRocmVlIGNvcm5lcnMuXG4gKlxuICogQG5hbWUgcGxhbmVwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQgdGhlIFBvaW50IGZvciB3aGljaCBhIHotdmFsdWUgd2lsbCBiZSBjYWxjdWxhdGVkXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHRyaWFuZ2xlIGEgUG9seWdvbiBmZWF0dXJlIHdpdGggdGhyZWUgdmVydGljZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB6LXZhbHVlIGZvciBgaW50ZXJwb2xhdGVkUG9pbnRgXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuMzIyMSwgMzkuNTI5XVxuICogICB9XG4gKiB9O1xuICogdmFyIHBvaW50ID0gdHVyZi5wb2ludChbLTc1LjMyMjEsIDM5LjUyOV0pO1xuICogLy8gdHJpYW5nbGUgaXMgYSBwb2x5Z29uIHdpdGggXCJhXCIsIFwiYlwiLFxuICogLy8gYW5kIFwiY1wiIHZhbHVlcyByZXByZXNlbnRpbmdcbiAqIC8vIHRoZSB2YWx1ZXMgb2YgdGhlIGNvb3JkaW5hdGVzIGluIG9yZGVyLlxuICogdmFyIHRyaWFuZ2xlID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJhXCI6IDExLFxuICogICAgIFwiYlwiOiAxMjIsXG4gKiAgICAgXCJjXCI6IDQ0XG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICBbLTc1LjEyMjEsIDM5LjU3XSxcbiAqICAgICAgIFstNzUuNTgsIDM5LjE4XSxcbiAqICAgICAgIFstNzUuOTcsIDM5Ljg2XSxcbiAqICAgICAgIFstNzUuMTIyMSwgMzkuNTddXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW3RyaWFuZ2xlLCBwb2ludF1cbiAqIH07XG4gKlxuICogdmFyIHpWYWx1ZSA9IHR1cmYucGxhbmVwb2ludChwb2ludCwgdHJpYW5nbGUpO1xuICpcbiAqIC8vPWZlYXR1cmVzXG4gKlxuICogLy89elZhbHVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50LCB0cmlhbmdsZSkge1xuICAgIHZhciB4ID0gcG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIHkgPSBwb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgeDEgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVswXVswXSxcbiAgICAgICAgeTEgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVswXVsxXSxcbiAgICAgICAgejEgPSB0cmlhbmdsZS5wcm9wZXJ0aWVzLmEsXG4gICAgICAgIHgyID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMV1bMF0sXG4gICAgICAgIHkyID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMV1bMV0sXG4gICAgICAgIHoyID0gdHJpYW5nbGUucHJvcGVydGllcy5iLFxuICAgICAgICB4MyA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzJdWzBdLFxuICAgICAgICB5MyA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzJdWzFdLFxuICAgICAgICB6MyA9IHRyaWFuZ2xlLnByb3BlcnRpZXMuYztcblxuICAgIHZhciB6ID0gKHozICogKHggLSB4MSkgKiAoeSAtIHkyKSArIHoxICogKHggLSB4MikgKiAoeSAtIHkzKSArIHoyICogKHggLSB4MykgKiAoeSAtIHkxKSAtXG4gICAgICB6MiAqICh4IC0geDEpICogKHkgLSB5MykgLSB6MyAqICh4IC0geDIpICogKHkgLSB5MSkgLSB6MSAqICh4IC0geDMpICogKHkgLSB5MikpIC9cbiAgICAgICgoeCAtIHgxKSAqICh5IC0geTIpICsgKHggLSB4MikgKiAoeSAtIHkzKSArICh4IC0geDMpICogKHkgLSB5MSkgLVxuICAgICAgICh4IC0geDEpICogKHkgLSB5MykgLSAoeCAtIHgyKSAqICh5IC0geTEpIC0gKHggLSB4MykgKiAoeSAtIHkyKSk7XG5cbiAgICByZXR1cm4gejtcbn07XG4iLCJ2YXIgcG9pbnQgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucG9pbnQ7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9kaXN0YW5jZScpO1xudmFyIHR1cmZCQm94ID0gcmVxdWlyZSgnQHR1cmYvYmJveCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9pbnR9IGdyaWQgZnJvbSBhIGJvdW5kaW5nIGJveCwge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBvciB7QGxpbmsgRmVhdHVyZX0uXG4gKlxuICogQG5hbWUgcG9pbnRHcmlkXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj58RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZTxhbnk+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSB0aGUgZGlzdGFuY2UgYWNyb3NzIGVhY2ggY2VsbFxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSB1c2VkIGluIGNhbGN1bGF0aW5nIGNlbGxTaXplLCBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NlbnRlcmVkPWZhbHNlXSBhZGp1c3QgcG9pbnRzIHBvc2l0aW9uIHRvIGNlbnRlciB0aGUgZ3JpZCBpbnRvIGJib3hcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IGdyaWQgb2YgcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGV4dGVudCA9IFstNzAuODIzMzY0LCAtMzMuNTUzOTg0LCAtNzAuNDczMTc1LCAtMzMuMzAyOTg2XTtcbiAqIHZhciBjZWxsU2l6ZSA9IDM7XG4gKiB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICpcbiAqIHZhciBncmlkID0gdHVyZi5wb2ludEdyaWQoZXh0ZW50LCBjZWxsU2l6ZSwgdW5pdHMpO1xuICpcbiAqIC8vPWdyaWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYmJveCwgY2VsbFNpemUsIHVuaXRzLCBjZW50ZXJlZCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAvLyB2YWxpZGF0aW9uXG4gICAgaWYgKCFiYm94KSB0aHJvdyBuZXcgRXJyb3IoJ2Jib3ggaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmJveCkpIGJib3ggPSB0dXJmQkJveChiYm94KTsgLy8gQ29udmVydCBHZW9KU09OIHRvIGJib3hcbiAgICBpZiAoYmJveC5sZW5ndGggIT09IDQpIHRocm93IG5ldyBFcnJvcignYmJveCBtdXN0IGNvbnRhaW4gNCBudW1iZXJzJyk7XG5cbiAgICB2YXIgd2VzdCA9IGJib3hbMF07XG4gICAgdmFyIHNvdXRoID0gYmJveFsxXTtcbiAgICB2YXIgZWFzdCA9IGJib3hbMl07XG4gICAgdmFyIG5vcnRoID0gYmJveFszXTtcblxuICAgIHZhciB4RnJhY3Rpb24gPSBjZWxsU2l6ZSAvIChkaXN0YW5jZShwb2ludChbd2VzdCwgc291dGhdKSwgcG9pbnQoW2Vhc3QsIHNvdXRoXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxXaWR0aCA9IHhGcmFjdGlvbiAqIChlYXN0IC0gd2VzdCk7XG4gICAgdmFyIHlGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFt3ZXN0LCBzb3V0aF0pLCBwb2ludChbd2VzdCwgbm9ydGhdKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbEhlaWdodCA9IHlGcmFjdGlvbiAqIChub3J0aCAtIHNvdXRoKTtcblxuICAgIGlmIChjZW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgYmJveEhvcml6b250YWxTaWRlID0gKGVhc3QgLSB3ZXN0KTtcbiAgICAgICAgdmFyIGJib3hWZXJ0aWNhbFNpZGUgPSAobm9ydGggLSBzb3V0aCk7XG4gICAgICAgIHZhciBjb2x1bW5zID0gTWF0aC5mbG9vcihiYm94SG9yaXpvbnRhbFNpZGUgLyBjZWxsV2lkdGgpO1xuICAgICAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IoYmJveFZlcnRpY2FsU2lkZSAvIGNlbGxIZWlnaHQpO1xuICAgICAgICAvLyBhZGp1c3Qgb3JpZ2luIG9mIHRoZSBncmlkXG4gICAgICAgIHZhciBkZWx0YVggPSAoYmJveEhvcml6b250YWxTaWRlIC0gY29sdW1ucyAqIGNlbGxXaWR0aCkgLyAyO1xuICAgICAgICB2YXIgZGVsdGFZID0gKGJib3hWZXJ0aWNhbFNpZGUgLSByb3dzICogY2VsbEhlaWdodCkgLyAyO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50WCA9IHdlc3Q7XG4gICAgaWYgKGNlbnRlcmVkID09PSB0cnVlKSBjdXJyZW50WCArPSBkZWx0YVg7XG4gICAgd2hpbGUgKGN1cnJlbnRYIDw9IGVhc3QpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRZID0gc291dGg7XG4gICAgICAgIGlmIChjZW50ZXJlZCA9PT0gdHJ1ZSkgY3VycmVudFkgKz0gZGVsdGFZO1xuICAgICAgICB3aGlsZSAoY3VycmVudFkgPD0gbm9ydGgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChwb2ludChbY3VycmVudFgsIGN1cnJlbnRZXSkpO1xuICAgICAgICAgICAgY3VycmVudFkgKz0gY2VsbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50WCArPSBjZWxsV2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKHJlc3VsdHMpO1xufTtcbiIsInZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyk7XG52YXIgcG9pbnQgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucG9pbnQ7XG52YXIgYmVhcmluZyA9IHJlcXVpcmUoJ0B0dXJmL2JlYXJpbmcnKTtcbnZhciBkZXN0aW5hdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2Rlc3RpbmF0aW9uJyk7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBhIHtAbGluayBMaW5lU3RyaW5nfSBhbmQgY2FsY3VsYXRlcyB0aGUgY2xvc2VzdCBQb2ludCBvbiB0aGUgTGluZVN0cmluZy5cbiAqXG4gKiBAbmFtZSBwb2ludE9uTGluZVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIGxpbmUgdG8gc25hcCB0b1xuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcHQgcG9pbnQgdG8gc25hcCBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHJldHVybiB7RmVhdHVyZTxQb2ludD59IGNsb3Nlc3QgcG9pbnQgb24gdGhlIGBsaW5lYCB0byBgcG9pbnRgLiBUaGUgcHJvcGVydGllcyBvYmplY3Qgd2lsbCBjb250YWluIHRocmVlIHZhbHVlczogYGluZGV4YDogY2xvc2VzdCBwb2ludCB3YXMgZm91bmQgb24gbnRoIGxpbmUgcGFydCwgYGRpc3RgOiBkaXN0YW5jZSBiZXR3ZWVuIHB0IGFuZCB0aGUgY2xvc2VzdCBwb2ludCwgYGxvY2F0aW9uYDogZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgYmV0d2VlbiBzdGFydCBhbmQgdGhlIGNsb3Nlc3QgcG9pbnQuXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTc3LjAzMTY2OSwgMzguODc4NjA1XSxcbiAqICAgICAgIFstNzcuMDI5NjA5LCAzOC44ODE5NDZdLFxuICogICAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgICBbLTc3LjAyNTY2MSwgMzguODg1ODIxXSxcbiAqICAgICAgIFstNzcuMDIxODg0LCAzOC44ODk1NjNdLFxuICogICAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03Ny4wMzcwNzYsIDM4Ljg4NDAxN11cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgc25hcHBlZCA9IHR1cmYucG9pbnRPbkxpbmUobGluZSwgcHQsICdtaWxlcycpO1xuICogc25hcHBlZC5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjMDBmJ1xuICpcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW2xpbmUsIHB0LCBzbmFwcGVkXVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaW5lLCBwdCwgdW5pdHMpIHtcbiAgICB2YXIgY29vcmRzO1xuICAgIGlmIChsaW5lLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjb29yZHMgPSBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIH0gZWxzZSBpZiAobGluZS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgY29vcmRzID0gbGluZS5jb29yZGluYXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBMaW5lU3RyaW5nIEZlYXR1cmUgb3IgR2VvbWV0cnknKTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VzdFB0ID0gcG9pbnQoW0luZmluaXR5LCBJbmZpbml0eV0sIHtcbiAgICAgICAgZGlzdDogSW5maW5pdHlcbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gMC4wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb2ludChjb29yZHNbaV0pO1xuICAgICAgICB2YXIgc3RvcCA9IHBvaW50KGNvb3Jkc1tpICsgMV0pO1xuICAgICAgICAvL3N0YXJ0XG4gICAgICAgIHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlKHB0LCBzdGFydCwgdW5pdHMpO1xuICAgICAgICAvL3N0b3BcbiAgICAgICAgc3RvcC5wcm9wZXJ0aWVzLmRpc3QgPSBkaXN0YW5jZShwdCwgc3RvcCwgdW5pdHMpO1xuICAgICAgICAvLyBzZWN0aW9uTGVuZ3RoXG4gICAgICAgIHZhciBzZWN0aW9uTGVuZ3RoID0gZGlzdGFuY2Uoc3RhcnQsIHN0b3AsIHVuaXRzKTtcbiAgICAgICAgLy9wZXJwZW5kaWN1bGFyXG4gICAgICAgIHZhciBoZWlnaHREaXN0YW5jZSA9IE1hdGgubWF4KHN0YXJ0LnByb3BlcnRpZXMuZGlzdCwgc3RvcC5wcm9wZXJ0aWVzLmRpc3QpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gYmVhcmluZyhzdGFydCwgc3RvcCk7XG4gICAgICAgIHZhciBwZXJwZW5kaWN1bGFyUHQxID0gZGVzdGluYXRpb24ocHQsIGhlaWdodERpc3RhbmNlLCBkaXJlY3Rpb24gKyA5MCwgdW5pdHMpO1xuICAgICAgICB2YXIgcGVycGVuZGljdWxhclB0MiA9IGRlc3RpbmF0aW9uKHB0LCBoZWlnaHREaXN0YW5jZSwgZGlyZWN0aW9uIC0gOTAsIHVuaXRzKTtcbiAgICAgICAgdmFyIGludGVyc2VjdCA9IGxpbmVJbnRlcnNlY3RzKFxuICAgICAgICAgICAgcGVycGVuZGljdWxhclB0MS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgICAgIHBlcnBlbmRpY3VsYXJQdDEuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXG4gICAgICAgICAgICBwZXJwZW5kaWN1bGFyUHQyLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgcGVycGVuZGljdWxhclB0Mi5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgICAgIHN0YXJ0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgc3RhcnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXG4gICAgICAgICAgICBzdG9wLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgc3RvcC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXVxuICAgICAgICApO1xuICAgICAgICB2YXIgaW50ZXJzZWN0UHQ7XG4gICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdFB0ID0gcG9pbnQoaW50ZXJzZWN0KTtcbiAgICAgICAgICAgIGludGVyc2VjdFB0LnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlKHB0LCBpbnRlcnNlY3RQdCwgdW5pdHMpO1xuICAgICAgICAgICAgaW50ZXJzZWN0UHQucHJvcGVydGllcy5sb2NhdGlvbiA9IGxlbmd0aCArIGRpc3RhbmNlKHN0YXJ0LCBjbG9zZXN0UHQsIHVuaXRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydC5wcm9wZXJ0aWVzLmRpc3QgPCBjbG9zZXN0UHQucHJvcGVydGllcy5kaXN0KSB7XG4gICAgICAgICAgICBjbG9zZXN0UHQgPSBzdGFydDtcbiAgICAgICAgICAgIGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmluZGV4ID0gaTtcbiAgICAgICAgICAgIGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmxvY2F0aW9uID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wLnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RQdCA9IHN0b3A7XG4gICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5pbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMubG9jYXRpb24gPSBsZW5ndGggKyBzZWN0aW9uTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnNlY3RQdCAmJiBpbnRlcnNlY3RQdC5wcm9wZXJ0aWVzLmRpc3QgPCBjbG9zZXN0UHQucHJvcGVydGllcy5kaXN0KSB7XG4gICAgICAgICAgICBjbG9zZXN0UHQgPSBpbnRlcnNlY3RQdDtcbiAgICAgICAgICAgIGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgbGVuZ3RoXG4gICAgICAgIGxlbmd0aCArPSBzZWN0aW9uTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0UHQ7XG59O1xuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvanVzdGluX2Nfcm91bmRzL0dkMlMyL2xpZ2h0L1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHMobGluZTFTdGFydFgsIGxpbmUxU3RhcnRZLCBsaW5lMUVuZFgsIGxpbmUxRW5kWSwgbGluZTJTdGFydFgsIGxpbmUyU3RhcnRZLCBsaW5lMkVuZFgsIGxpbmUyRW5kWSkge1xuICAgIC8vIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3QsIHRoZSByZXN1bHQgY29udGFpbnMgdGhlIHggYW5kIHkgb2YgdGhlIGludGVyc2VjdGlvbiAodHJlYXRpbmcgdGhlIGxpbmVzIGFzIGluZmluaXRlKSBhbmQgYm9vbGVhbnMgZm9yIHdoZXRoZXIgbGluZSBzZWdtZW50IDEgb3IgbGluZSBzZWdtZW50IDIgY29udGFpbiB0aGUgcG9pbnRcbiAgICB2YXIgZGVub21pbmF0b3IsIGEsIGIsIG51bWVyYXRvcjEsIG51bWVyYXRvcjI7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgeDogbnVsbCxcbiAgICAgICAgeTogbnVsbCxcbiAgICAgICAgb25MaW5lMTogZmFsc2UsXG4gICAgICAgIG9uTGluZTI6IGZhbHNlXG4gICAgfTtcbiAgICBkZW5vbWluYXRvciA9ICgobGluZTJFbmRZIC0gbGluZTJTdGFydFkpICogKGxpbmUxRW5kWCAtIGxpbmUxU3RhcnRYKSkgLSAoKGxpbmUyRW5kWCAtIGxpbmUyU3RhcnRYKSAqIChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkpO1xuICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICBpZiAocmVzdWx0LnggIT09IG51bGwgJiYgcmVzdWx0LnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYSA9IGxpbmUxU3RhcnRZIC0gbGluZTJTdGFydFk7XG4gICAgYiA9IGxpbmUxU3RhcnRYIC0gbGluZTJTdGFydFg7XG4gICAgbnVtZXJhdG9yMSA9ICgobGluZTJFbmRYIC0gbGluZTJTdGFydFgpICogYSkgLSAoKGxpbmUyRW5kWSAtIGxpbmUyU3RhcnRZKSAqIGIpO1xuICAgIG51bWVyYXRvcjIgPSAoKGxpbmUxRW5kWCAtIGxpbmUxU3RhcnRYKSAqIGEpIC0gKChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkgKiBiKTtcbiAgICBhID0gbnVtZXJhdG9yMSAvIGRlbm9taW5hdG9yO1xuICAgIGIgPSBudW1lcmF0b3IyIC8gZGVub21pbmF0b3I7XG5cbiAgICAvLyBpZiB3ZSBjYXN0IHRoZXNlIGxpbmVzIGluZmluaXRlbHkgaW4gYm90aCBkaXJlY3Rpb25zLCB0aGV5IGludGVyc2VjdCBoZXJlOlxuICAgIHJlc3VsdC54ID0gbGluZTFTdGFydFggKyAoYSAqIChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkpO1xuICAgIHJlc3VsdC55ID0gbGluZTFTdGFydFkgKyAoYSAqIChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkpO1xuXG4gICAgLy8gaWYgbGluZTEgaXMgYSBzZWdtZW50IGFuZCBsaW5lMiBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGEgPiAwICYmIGEgPCAxKSB7XG4gICAgICAgIHJlc3VsdC5vbkxpbmUxID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgbGluZTIgaXMgYSBzZWdtZW50IGFuZCBsaW5lMSBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGIgPiAwICYmIGIgPCAxKSB7XG4gICAgICAgIHJlc3VsdC5vbkxpbmUyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgbGluZTEgYW5kIGxpbmUyIGFyZSBzZWdtZW50cywgdGhleSBpbnRlcnNlY3QgaWYgYm90aCBvZiB0aGUgYWJvdmUgYXJlIHRydWVcbiAgICBpZiAocmVzdWx0Lm9uTGluZTEgJiYgcmVzdWx0Lm9uTGluZTIpIHtcbiAgICAgICAgcmV0dXJuIFtyZXN1bHQueCwgcmVzdWx0LnldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCJ2YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgY2VudHJvaWQgPSByZXF1aXJlKCdAdHVyZi9jZW50ZXInKTtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyk7XG52YXIgaW5zaWRlID0gcmVxdWlyZSgnQHR1cmYvaW5zaWRlJyk7XG52YXIgZXhwbG9kZSA9IHJlcXVpcmUoJ0B0dXJmL2V4cGxvZGUnKTtcblxuLyoqXG4gKiBUYWtlcyBhIGZlYXR1cmUgYW5kIHJldHVybnMgYSB7QGxpbmsgUG9pbnR9IGd1YXJhbnRlZWQgdG8gYmUgb24gdGhlIHN1cmZhY2Ugb2YgdGhlIGZlYXR1cmUuXG4gKlxuICogKiBHaXZlbiBhIHtAbGluayBQb2x5Z29ufSwgdGhlIHBvaW50IHdpbGwgYmUgaW4gdGhlIGFyZWEgb2YgdGhlIHBvbHlnb25cbiAqICogR2l2ZW4gYSB7QGxpbmsgTGluZVN0cmluZ30sIHRoZSBwb2ludCB3aWxsIGJlIGFsb25nIHRoZSBzdHJpbmdcbiAqICogR2l2ZW4gYSB7QGxpbmsgUG9pbnR9LCB0aGUgcG9pbnQgd2lsbCB0aGUgc2FtZSBhcyB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gZmMgYW55IGZlYXR1cmUgb3Igc2V0IG9mIGZlYXR1cmVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZX0gYSBwb2ludCBvbiB0aGUgc3VyZmFjZSBvZiBgaW5wdXRgXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRlIGEgcmFuZG9tIHBvbHlnb25cbiAqIHZhciBwb2x5Z29uID0gdHVyZi5yYW5kb20oJ3BvbHlnb24nKTtcbiAqXG4gKiAvLz1wb2x5Z29uXG4gKlxuICogdmFyIHBvaW50T25Qb2x5Z29uID0gdHVyZi5wb2ludE9uU3VyZmFjZShwb2x5Z29uKTtcbiAqXG4qIHZhciByZXN1bHRGZWF0dXJlcyA9IHBvbHlnb24uZmVhdHVyZXMuY29uY2F0KHBvaW50T25Qb2x5Z29uKTtcbiogdmFyIHJlc3VsdCA9IHtcbiogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuZnVuY3Rpb24gcG9pbnRPblN1cmZhY2UoZmMpIHtcbiAgICAvLyBub3JtYWxpemVcbiAgICBpZiAoZmMudHlwZSAhPT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBpZiAoZmMudHlwZSAhPT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgICAgICBmYyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGZjLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZjID0gZmVhdHVyZUNvbGxlY3Rpb24oW2ZjXSk7XG4gICAgfVxuXG4gICAgLy9nZXQgY2VudHJvaWRcbiAgICB2YXIgY2VudCA9IGNlbnRyb2lkKGZjKTtcblxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBjZW50cm9pZCBpcyBvbiBzdXJmYWNlXG4gICAgdmFyIG9uU3VyZmFjZSA9IGZhbHNlO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoIW9uU3VyZmFjZSAmJiBpIDwgZmMuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBnZW9tID0gZmMuZmVhdHVyZXNbaV0uZ2VvbWV0cnk7XG4gICAgICAgIHZhciB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgaztcbiAgICAgICAgdmFyIG9uTGluZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2VvbS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICBpZiAoY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSA9PT0gZ2VvbS5jb29yZGluYXRlc1swXSAmJlxuICAgICAgICBjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdID09PSBnZW9tLmNvb3JkaW5hdGVzWzFdKSB7XG4gICAgICAgICAgICAgICAgb25TdXJmYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9tLnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgdmFyIG9uTXVsdGlQb2ludCA9IGZhbHNlO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoIW9uTXVsdGlQb2ludCAmJiBrIDwgZ2VvbS5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSA9PT0gZ2VvbS5jb29yZGluYXRlc1trXVswXSAmJlxuICAgICAgICAgIGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0gPT09IGdlb20uY29vcmRpbmF0ZXNba11bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb25TdXJmYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb25NdWx0aVBvaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb20udHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgIHdoaWxlICghb25MaW5lICYmIGsgPCBnZW9tLmNvb3JkaW5hdGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB4ID0gY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICB5ID0gY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgICAgICB4MSA9IGdlb20uY29vcmRpbmF0ZXNba11bMF07XG4gICAgICAgICAgICAgICAgeTEgPSBnZW9tLmNvb3JkaW5hdGVzW2tdWzFdO1xuICAgICAgICAgICAgICAgIHgyID0gZ2VvbS5jb29yZGluYXRlc1trICsgMV1bMF07XG4gICAgICAgICAgICAgICAgeTIgPSBnZW9tLmNvb3JkaW5hdGVzW2sgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRPblNlZ21lbnQoeCwgeSwgeDEsIHkxLCB4MiwgeTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VyZmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9tLnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGdlb20uY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb25MaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBnZW9tLmNvb3JkaW5hdGVzW2pdO1xuICAgICAgICAgICAgICAgIHdoaWxlICghb25MaW5lICYmIGsgPCBsaW5lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB4MSA9IGxpbmVba11bMF07XG4gICAgICAgICAgICAgICAgICAgIHkxID0gbGluZVtrXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBsaW5lW2sgKyAxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBsaW5lW2sgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50T25TZWdtZW50KHgsIHksIHgxLCB5MSwgeDIsIHkyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25MaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VyZmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgdmFyIGYgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGluc2lkZShjZW50LCBmKSkge1xuICAgICAgICAgICAgICAgIG9uU3VyZmFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAob25TdXJmYWNlKSB7XG4gICAgICAgIHJldHVybiBjZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGZlYXR1cmVDb2xsZWN0aW9uKFtdKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZjLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5mZWF0dXJlcyA9IHZlcnRpY2VzLmZlYXR1cmVzLmNvbmNhdChleHBsb2RlKGZjLmZlYXR1cmVzW2ldKS5mZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsb3Nlc3RWZXJ0ZXg7XG4gICAgICAgIHZhciBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGNlbnQsIHZlcnRpY2VzLmZlYXR1cmVzW2ldLCAnbWlsZXMnKTtcbiAgICAgICAgICAgIGlmIChkaXN0IDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0VmVydGV4ID0gdmVydGljZXMuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RWZXJ0ZXg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwb2ludE9uU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBhYiA9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIHZhciBhcCA9IE1hdGguc3FydCgoeCAtIHgxKSAqICh4IC0geDEpICsgKHkgLSB5MSkgKiAoeSAtIHkxKSk7XG4gICAgdmFyIHBiID0gTWF0aC5zcXJ0KCh4MiAtIHgpICogKHgyIC0geCkgKyAoeTIgLSB5KSAqICh5MiAtIHkpKTtcbiAgICBpZiAoYWIgPT09IGFwICsgcGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBvaW50T25TdXJmYWNlO1xuIiwidmFyIGdldENvb3JkcyA9IHJlcXVpcmUoJ0B0dXJmL2ludmFyaWFudCcpLmdldENvb3JkcztcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpO1xudmFyIGxpbmVTdHJpbmcgPSBoZWxwZXJzLmxpbmVTdHJpbmc7XG52YXIgbXVsdGlMaW5lU3RyaW5nID0gaGVscGVycy5tdWx0aUxpbmVTdHJpbmc7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIFBvbHlnb259IG9yIHtAbGluayBNdWx0aVBvbHlnb259IHRvIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBvZiB7QGxpbmsgTGluZVN0cmluZ30gb3Ige0BsaW5rIE11bHRpTGluZVN0cmluZ30uXG4gKlxuICogQG5hbWUgcG9seWdvblRvTGluZVN0cmluZ1xuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb258TXVsdGlQb2x5Z29uPn0gcG9seWdvbiBGZWF0dXJlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nfE11bHRpTGluZXN0cmluZz59IGNvbnZlcnRlZCBGZWF0dXJlIHRvIExpbmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkgPSB7XG4gKiAgICd0eXBlJzogJ0ZlYXR1cmUnLFxuICogICAncHJvcGVydGllcyc6IHt9LFxuICogICAnZ2VvbWV0cnknOiB7XG4gKiAgICAgJ3R5cGUnOiAnUG9seWdvbicsXG4gKiAgICAgJ2Nvb3JkaW5hdGVzJzogW1tbMTI1LCAtMzBdLCBbMTQ1LCAtMzBdLCBbMTQ1LCAtMjBdLCBbMTI1LCAtMjBdLCBbMTI1LCAtMzBdXV1cbiAqICAgfVxuICogfVxuICogdmFyIGxpbmVzID0gdHVyZi5wb2x5Z29uVG9MaW5lU3RyaW5nKHBvbHkpO1xuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmVzXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgdmFyIGdlb20gPSBnZXRHZW9tVHlwZShwb2x5Z29uKTtcbiAgICB2YXIgY29vcmRzID0gZ2V0Q29vcmRzKHBvbHlnb24pO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gcG9seWdvbi5wcm9wZXJ0aWVzO1xuICAgIGlmICghY29vcmRzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdwb2x5Z29uIG11c3QgY29udGFpbiBjb29yZGluYXRlcycpO1xuXG4gICAgc3dpdGNoIChnZW9tKSB7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihbY29vcmRzVG9MaW5lKGNvb3JkcywgcHJvcGVydGllcyldKTtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGNvb3Jkc1RvTGluZShjb29yZCwgcHJvcGVydGllcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGxpbmVzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb20gJyArIGdlb20gKyAnIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb29yZHNUb0xpbmUoY29vcmRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAxKSByZXR1cm4gbXVsdGlMaW5lU3RyaW5nKGNvb3JkcywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRzWzBdLCBwcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0R2VvbVR5cGUoZmVhdHVyZSkge1xuICAgIHJldHVybiAoZmVhdHVyZS5nZW9tZXRyeSkgPyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgOiBmZWF0dXJlLnR5cGU7XG59XG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnZ2VvanNvbi1yYW5kb20nKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIHtAbGluayBHZW9KU09OfSBkYXRhLCBpbmNsdWRpbmcge0BsaW5rIFBvaW50fFBvaW50c30gYW5kIHtAbGluayBQb2x5Z29ufFBvbHlnb25zfSwgZm9yIHRlc3RpbmdcbiAqIGFuZCBleHBlcmltZW50YXRpb24uXG4gKlxuICogQG5hbWUgcmFuZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J3BvaW50J10gdHlwZSBvZiBmZWF0dXJlcyBkZXNpcmVkOiAncG9pbnRzJyBvciAncG9seWdvbnMnXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvdW50PTFdIGhvdyBtYW55IGdlb21ldHJpZXMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgcmVsZXZhbnQgdG8gdGhlIGZlYXR1cmUgZGVzaXJlZC4gQ2FuIGluY2x1ZGU6XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9wdGlvbnMuYmJveCBhIGJvdW5kaW5nIGJveCBpbnNpZGUgb2Ygd2hpY2ggZ2VvbWV0cmllc1xuICogYXJlIHBsYWNlZC4gSW4gdGhlIGNhc2Ugb2Yge0BsaW5rIFBvaW50fSBmZWF0dXJlcywgdGhleSBhcmUgZ3VhcmFudGVlZCB0byBiZSB3aXRoaW4gdGhpcyBib3VuZHMsXG4gKiB3aGlsZSB7QGxpbmsgUG9seWdvbn0gZmVhdHVyZXMgaGF2ZSB0aGVpciBjZW50cm9pZCB3aXRoaW4gdGhlIGJvdW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5udW1fdmVydGljZXM9MTBdIG9wdGlvbnMudmVydGljZXMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBhZGRlZFxuICogdG8gcG9seWdvbiBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhfcmFkaWFsX2xlbmd0aD0xMF0gdGhlIHRvdGFsIG51bWJlciBvZiBkZWNpbWFsXG4gKiBkZWdyZWVzIGxvbmdpdHVkZSBvciBsYXRpdHVkZSB0aGF0IGEgcG9seWdvbiBjYW4gZXh0ZW50IG91dHdhcmRzIHRvXG4gKiBmcm9tIGl0cyBjZW50ZXIuXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGdlbmVyYXRlZCByYW5kb20gZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5yYW5kb20oJ3BvaW50cycsIDEwMCwge1xuICogICBiYm94OiBbLTcwLCA0MCwgLTYwLCA2MF1cbiAqIH0pO1xuICpcbiAqIC8vPXBvaW50c1xuICpcbiAqIHZhciBwb2x5Z29ucyA9IHR1cmYucmFuZG9tKCdwb2x5Z29ucycsIDQsIHtcbiAqICAgYmJveDogWy03MCwgNDAsIC02MCwgNjBdXG4gKiB9KTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0eXBlLCBjb3VudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvdW50ID0gY291bnQgfHwgMTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdwb2ludCc6XG4gICAgY2FzZSAncG9pbnRzJzpcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHJhbmRvbS5wb2ludChjb3VudCwgb3B0aW9ucy5iYm94KTtcbiAgICBjYXNlICdwb2x5Z29uJzpcbiAgICBjYXNlICdwb2x5Z29ucyc6XG4gICAgICAgIHJldHVybiByYW5kb20ucG9seWdvbihcbiAgICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bV92ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heF9yYWRpYWxfbGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmJveCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgZ2l2ZW46IHZhbGlkIG9wdGlvbnMgYXJlIHBvaW50cyBhbmQgcG9seWdvbnMnKTtcbiAgICB9XG59O1xuIiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTkzNTE3NS9zYW1wbGluZy1hLXJhbmRvbS1zdWJzZXQtZnJvbS1hbi1hcnJheVxudmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBhbmQgcmV0dXJucyBhIEZlYXR1cmVDb2xsZWN0aW9uIHdpdGggZ2l2ZW4gbnVtYmVyIG9mIHtAbGluayBGZWF0dXJlfGZlYXR1cmVzfSBhdCByYW5kb20uXG4gKlxuICogQG5hbWUgc2FtcGxlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufSBmZWF0dXJlY29sbGVjdGlvbiBzZXQgb2YgaW5wdXQgZmVhdHVyZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gbnVtYmVyIG9mIGZlYXR1cmVzIHRvIHNlbGVjdFxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBhIEZlYXR1cmVDb2xsZWN0aW9uIHdpdGggYG5gIGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tKCdwb2ludHMnLCAxMDAwKTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiB2YXIgc2FtcGxlID0gdHVyZi5zYW1wbGUocG9pbnRzLCAxMCk7XG4gKlxuICogLy89c2FtcGxlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVjb2xsZWN0aW9uLCBudW0pIHtcbiAgICB2YXIgb3V0RkMgPSBmZWF0dXJlQ29sbGVjdGlvbihnZXRSYW5kb21TdWJhcnJheShmZWF0dXJlY29sbGVjdGlvbi5mZWF0dXJlcywgbnVtKSk7XG4gICAgcmV0dXJuIG91dEZDO1xufTtcblxuZnVuY3Rpb24gZ2V0UmFuZG9tU3ViYXJyYXkoYXJyLCBzaXplKSB7XG4gICAgdmFyIHNodWZmbGVkID0gYXJyLnNsaWNlKDApLCBpID0gYXJyLmxlbmd0aCwgbWluID0gaSAtIHNpemUsIHRlbXAsIGluZGV4O1xuICAgIHdoaWxlIChpLS0gPiBtaW4pIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChpICsgMSkgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdGVtcCA9IHNodWZmbGVkW2luZGV4XTtcbiAgICAgICAgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbaV07XG4gICAgICAgIHNodWZmbGVkW2ldID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkLnNsaWNlKG1pbik7XG59XG4iLCJ2YXIgc2ltcGxpZnkgPSByZXF1aXJlKCdzaW1wbGlmeS1qcycpO1xuXG4vLyBzdXBwb3J0ZWQgR2VvSlNPTiBnZW9tZXRyaWVzLCB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgdG8gd3JhcCBpbiBzaW1wbGVGZWF0dXJlKClcbnZhciBzdXBwb3J0ZWRUeXBlcyA9IFsnTGluZVN0cmluZycsICdNdWx0aUxpbmVTdHJpbmcnLCAnUG9seWdvbicsICdNdWx0aVBvbHlnb24nXTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfSBvciB7QGxpbmsgUG9seWdvbn0gYW5kIHJldHVybnMgYSBzaW1wbGlmaWVkIHZlcnNpb24uIEludGVybmFsbHkgdXNlcyBbc2ltcGxpZnktanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pIHRvIHBlcmZvcm0gc2ltcGxpZmljYXRpb24uXG4gKlxuICogQG5hbWUgc2ltcGxpZnlcbiAqIEBwYXJhbSB7RmVhdHVyZTwoTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24pPnxGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeUNvbGxlY3Rpb259IGZlYXR1cmUgZmVhdHVyZSB0byBiZSBzaW1wbGlmaWVkXG4gKiBAcGFyYW0ge251bWJlcn0gW3RvbGVyYW5jZT0xXSBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hRdWFsaXR5PWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBzcGVuZCBtb3JlIHRpbWUgdG8gY3JlYXRlXG4gKiBhIGhpZ2hlci1xdWFsaXR5IHNpbXBsaWZpY2F0aW9uIHdpdGggYSBkaWZmZXJlbnQgYWxnb3JpdGhtXG4gKiBAcmV0dXJucyB7RmVhdHVyZTwoTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24pPnxGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeUNvbGxlY3Rpb259IGEgc2ltcGxpZmllZCBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICAqIHZhciBmZWF0dXJlID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstNzAuNjAzNjM3LCAtMzMuMzk5OTE4XSxcbiAqICAgICAgIFstNzAuNjE0NjI0LCAtMzMuMzk1MzMyXSxcbiAqICAgICAgIFstNzAuNjM5MzQzLCAtMzMuMzkyNDY2XSxcbiAqICAgICAgIFstNzAuNjU5OTQyLCAtMzMuMzk0NzU5XSxcbiAqICAgICAgIFstNzAuNjgzOTc1LCAtMzMuNDA0NTA0XSxcbiAqICAgICAgIFstNzAuNjk3MDIxLCAtMzMuNDE5NDA2XSxcbiAqICAgICAgIFstNzAuNzAxMTQxLCAtMzMuNDM0MzA2XSxcbiAqICAgICAgIFstNzAuNzAwNDU0LCAtMzMuNDQ2MzM5XSxcbiAqICAgICAgIFstNzAuNjk0Mjc0LCAtMzMuNDU4MzY5XSxcbiAqICAgICAgIFstNzAuNjgyNjAxLCAtMzMuNDY1ODE2XSxcbiAqICAgICAgIFstNzAuNjY4ODY5LCAtMzMuNDcyMTE3XSxcbiAqICAgICAgIFstNzAuNjQ2MjA5LCAtMzMuNDczODM1XSxcbiAqICAgICAgIFstNzAuNjI0OTIzLCAtMzMuNDcyMTE3XSxcbiAqICAgICAgIFstNzAuNjA5ODE3LCAtMzMuNDY4MTA3XSxcbiAqICAgICAgIFstNzAuNTk1Mzk3LCAtMzMuNDU4MzY5XSxcbiAqICAgICAgIFstNzAuNTg3MTU4LCAtMzMuNDQyOTAxXSxcbiAqICAgICAgIFstNzAuNTg3MTU4LCAtMzMuNDI2MjgzXSxcbiAqICAgICAgIFstNzAuNTkwNTkxLCAtMzMuNDE0MjQ4XSxcbiAqICAgICAgIFstNzAuNTk0NzExLCAtMzMuNDA2MjI0XSxcbiAqICAgICAgIFstNzAuNjAzNjM3LCAtMzMuMzk5OTE4XVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG5cbiAqIHZhciB0b2xlcmFuY2UgPSAwLjAxO1xuICpcbiAqIHZhciBzaW1wbGlmaWVkID0gdHVyZi5zaW1wbGlmeShcbiAqICBmZWF0dXJlLCB0b2xlcmFuY2UsIGZhbHNlKTtcbiAqXG4gKiAvLz1mZWF0dXJlXG4gKlxuICogLy89c2ltcGxpZmllZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KSB7XG4gICAgaWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVGZWF0dXJlKFxuICAgICAgICAgICAgc2ltcGxpZnlIZWxwZXIoZmVhdHVyZSwgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSksXG4gICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmUuZmVhdHVyZXMubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbXBsaWZpZWQgPSBzaW1wbGlmeUhlbHBlcihmLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGNyZWF0ZSBzaW1wbGVGZWF0dXJlIGhlcmUgYmVjYXVzZSBpdCBkb2Vzbid0IGFwcGx5IHRvIEdlb21ldHJ5Q29sbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbid0IGNyZWF0ZSBpdCBhdCBzaW1wbGlmeUhlbHBlcigpXG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFR5cGVzLmluZGV4T2Yoc2ltcGxpZmllZC50eXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVGZWF0dXJlKHNpbXBsaWZpZWQsIGYucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgZ2VvbWV0cmllczogZmVhdHVyZS5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbiAoZykge1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRUeXBlcy5pbmRleE9mKGcudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlIZWxwZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdcbiAgICAgICAgICAgICAgICAgICAgfSwgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9XG59O1xuXG5cbmZ1bmN0aW9uIHNpbXBsaWZ5SGVscGVyKGZlYXR1cmUsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpIHtcbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBzaW1wbGlmeUxpbmUoZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChsaW5lcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUxpbmUobGluZXMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICAgICAgICBjb29yZGluYXRlczogc2ltcGxpZnlQb2x5Z29uKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAocmluZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlQb2x5Z29uKHJpbmdzLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBzdXBwbGllZFxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9XG59XG5cbi8qXG4qIHJldHVybnMgdHJ1ZSBpZiByaW5nJ3MgZmlyc3QgY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyBpdHMgbGFzdFxuKi9cbmZ1bmN0aW9uIGNoZWNrVmFsaWRpdHkocmluZykge1xuICAgIGlmIChyaW5nLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vaWYgdGhlIGxhc3QgcG9pbnQgaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0LCBpdCdzIG5vdCBhIHRyaWFuZ2xlXG4gICAgfSBlbHNlIGlmIChyaW5nLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgKChyaW5nWzJdWzBdID09PSByaW5nWzBdWzBdKSAmJiAocmluZ1syXVsxXSA9PT0gcmluZ1swXVsxXSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb20sXG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeUxpbmUoY29vcmRpbmF0ZXMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpIHtcbiAgICByZXR1cm4gc2ltcGxpZnkoY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICByZXR1cm4ge3g6IGNvb3JkWzBdLCB5OiBjb29yZFsxXSwgejogY29vcmRbMl19O1xuICAgIH0pLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KS5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gKGNvb3Jkcy56KSA/IFtjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56XSA6IFtjb29yZHMueCwgY29vcmRzLnldO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVBvbHlnb24oY29vcmRpbmF0ZXMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChyaW5nKSB7XG4gICAgICAgIHZhciBwdHMgPSByaW5nLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7eDogY29vcmRbMF0sIHk6IGNvb3JkWzFdfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwdHMubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvbHlnb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2ltcGxlUmluZyA9IHNpbXBsaWZ5KHB0cywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29vcmRzLngsIGNvb3Jkcy55XTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vcmVtb3ZlIDEgcGVyY2VudCBvZiB0b2xlcmFuY2UgdW50aWwgZW5vdWdoIHBvaW50cyB0byBtYWtlIGEgdHJpYW5nbGVcbiAgICAgICAgd2hpbGUgKCFjaGVja1ZhbGlkaXR5KHNpbXBsZVJpbmcpKSB7XG4gICAgICAgICAgICB0b2xlcmFuY2UgLT0gdG9sZXJhbmNlICogMC4wMTtcbiAgICAgICAgICAgIHNpbXBsZVJpbmcgPSBzaW1wbGlmeShwdHMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb29yZHMueCwgY29vcmRzLnldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHNpbXBsZVJpbmdbc2ltcGxlUmluZy5sZW5ndGggLSAxXVswXSAhPT0gc2ltcGxlUmluZ1swXVswXSkgfHxcbiAgICAgICAgICAgICAgICAoc2ltcGxlUmluZ1tzaW1wbGVSaW5nLmxlbmd0aCAtIDFdWzFdICE9PSBzaW1wbGVSaW5nWzBdWzFdKSkge1xuICAgICAgICAgICAgc2ltcGxlUmluZy5wdXNoKHNpbXBsZVJpbmdbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGVSaW5nO1xuICAgIH0pO1xufVxuIiwidmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIHBvaW50ID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLnBvaW50O1xudmFyIHBvbHlnb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucG9seWdvbjtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyk7XG52YXIgdHVyZkJCb3ggPSByZXF1aXJlKCdAdHVyZi9iYm94Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNxdWFyZSBncmlkIGZyb20gYSBib3VuZGluZyBib3gsIHtAbGluayBGZWF0dXJlfSBvciB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259LlxuICpcbiAqIEBuYW1lIHNxdWFyZUdyaWRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPGFueT59IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplIHdpZHRoIG9mIGVhY2ggY2VsbFxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSB1c2VkIGluIGNhbGN1bGF0aW5nIGNlbGxTaXplLCBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbXBsZXRlbHlXaXRoaW49ZmFsc2VdIGFkanVzdCB3aWR0aCAmIGhlaWdodCBjZWxsU2l6ZSB0byBmaXQgZXhhY3RseSB3aXRoaW4gYmJveFxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBncmlkIGEgZ3JpZCBvZiBwb2x5Z29uc1xuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gWy05NSwgMzAgLC04NSwgNDBdO1xuICogdmFyIGNlbGxTaXplID0gNTA7XG4gKiB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICpcbiAqIHZhciBzcXVhcmVHcmlkID0gdHVyZi5zcXVhcmVHcmlkKGJib3gsIGNlbGxTaXplLCB1bml0cyk7XG4gKiAvLz1zcXVhcmVHcmlkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3F1YXJlR3JpZChiYm94LCBjZWxsU2l6ZSwgdW5pdHMsIGNvbXBsZXRlbHlXaXRoaW4pIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gdmFsaWRhdGlvblxuICAgIGlmICghYmJveCkgdGhyb3cgbmV3IEVycm9yKCdiYm94IGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJib3gpKSBiYm94ID0gdHVyZkJCb3goYmJveCk7IC8vIENvbnZlcnQgR2VvSlNPTiB0byBiYm94XG4gICAgaWYgKGJib3gubGVuZ3RoICE9PSA0KSB0aHJvdyBuZXcgRXJyb3IoJ2Jib3ggbXVzdCBjb250YWluIDQgbnVtYmVycycpO1xuXG4gICAgdmFyIHdlc3QgPSBiYm94WzBdO1xuICAgIHZhciBzb3V0aCA9IGJib3hbMV07XG4gICAgdmFyIGVhc3QgPSBiYm94WzJdO1xuICAgIHZhciBub3J0aCA9IGJib3hbM107XG5cbiAgICAvLyBkaXN0YW5jZVxuICAgIHZhciB4RGlzdGFuY2UgPSBkaXN0YW5jZShwb2ludChbd2VzdCwgc291dGhdKSwgcG9pbnQoW2Vhc3QsIHNvdXRoXSksIHVuaXRzKTtcbiAgICB2YXIgeURpc3RhbmNlID0gZGlzdGFuY2UocG9pbnQoW3dlc3QsIHNvdXRoXSksIHBvaW50KFt3ZXN0LCBub3J0aF0pLCB1bml0cyk7XG5cbiAgICAvLyByb3dzICYgY29sdW1uc1xuICAgIHZhciBjb2x1bW5zID0gTWF0aC5jZWlsKHhEaXN0YW5jZSAvIGNlbGxTaXplKTtcbiAgICB2YXIgcm93cyA9IE1hdGguY2VpbCh5RGlzdGFuY2UgLyBjZWxsU2l6ZSk7XG5cbiAgICAvLyBjb2x1bW5zIHwgd2lkdGggfCB4XG4gICAgdmFyIHhGcmFjdGlvbiA9IGNlbGxTaXplIC8geERpc3RhbmNlO1xuICAgIHZhciBjZWxsV2lkdGggPSB4RnJhY3Rpb24gKiAoZWFzdCAtIHdlc3QpO1xuICAgIGlmIChjb21wbGV0ZWx5V2l0aGluID09PSB0cnVlKSBjZWxsV2lkdGggPSBjZWxsV2lkdGggKiAoKHhEaXN0YW5jZSAvIGNlbGxTaXplKSAvIGNvbHVtbnMpO1xuXG4gICAgLy8gcm93cyB8IGhlaWdodCB8IHlcbiAgICB2YXIgeUZyYWN0aW9uID0gY2VsbFNpemUgLyB5RGlzdGFuY2U7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSB5RnJhY3Rpb24gKiAobm9ydGggLSBzb3V0aCk7XG4gICAgaWYgKGNvbXBsZXRlbHlXaXRoaW4gPT09IHRydWUpIGNlbGxIZWlnaHQgPSBjZWxsSGVpZ2h0ICogKCh5RGlzdGFuY2UgLyBjZWxsU2l6ZSkgLyByb3dzKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBjb2x1bW5zICYgcm93c1xuICAgIHZhciBjdXJyZW50WCA9IHdlc3Q7XG4gICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgY29sdW1uczsgY29sdW1uKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRZID0gc291dGg7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbFBvbHkgPSBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgXV0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNlbGxQb2x5KTtcblxuICAgICAgICAgICAgY3VycmVudFkgKz0gY2VsbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50WCArPSBjZWxsV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbn07XG4iLCJ2YXIgZGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBjYWxjdWxhdGVzIHRoZSBtaW5pbXVtIHNxdWFyZSBib3VuZGluZyBib3ggdGhhdFxuICogd291bGQgY29udGFpbiB0aGUgaW5wdXQuXG4gKlxuICogQG5hbWUgc3F1YXJlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggZXh0ZW50IGluIFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIG9yZGVyXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gYSBzcXVhcmUgc3Vycm91bmRpbmcgYGJib3hgXG4gKiBAYWRkVG9NYXAgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgYmJveCA9IFstMjAsLTIwLC0xNSwwXTtcbiAqXG4gKiB2YXIgc3F1YXJlZCA9IHR1cmYuc3F1YXJlKGJib3gpO1xuICpcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAgdHVyZi5iYm94UG9seWdvbihiYm94KSxcbiAqICAgICB0dXJmLmJib3hQb2x5Z29uKHNxdWFyZWQpXG4gKiAgIF1cbiAqIH07XG4gKlxuICogLy89ZmVhdHVyZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYmJveCkge1xuICAgIHZhciB3ZXN0ID0gYmJveFswXTtcbiAgICB2YXIgc291dGggPSBiYm94WzFdO1xuICAgIHZhciBlYXN0ID0gYmJveFsyXTtcbiAgICB2YXIgbm9ydGggPSBiYm94WzNdO1xuXG4gICAgdmFyIGhvcml6b250YWxEaXN0YW5jZSA9IGRpc3RhbmNlKGJib3guc2xpY2UoMCwgMiksIFtlYXN0LCBzb3V0aF0pO1xuICAgIHZhciB2ZXJ0aWNhbERpc3RhbmNlID0gZGlzdGFuY2UoYmJveC5zbGljZSgwLCAyKSwgW3dlc3QsIG5vcnRoXSk7XG4gICAgaWYgKGhvcml6b250YWxEaXN0YW5jZSA+PSB2ZXJ0aWNhbERpc3RhbmNlKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNhbE1pZHBvaW50ID0gKHNvdXRoICsgbm9ydGgpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHdlc3QsXG4gICAgICAgICAgICB2ZXJ0aWNhbE1pZHBvaW50IC0gKChlYXN0IC0gd2VzdCkgLyAyKSxcbiAgICAgICAgICAgIGVhc3QsXG4gICAgICAgICAgICB2ZXJ0aWNhbE1pZHBvaW50ICsgKChlYXN0IC0gd2VzdCkgLyAyKVxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBob3Jpem9udGFsTWlkcG9pbnQgPSAod2VzdCArIGVhc3QpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGhvcml6b250YWxNaWRwb2ludCAtICgobm9ydGggLSBzb3V0aCkgLyAyKSxcbiAgICAgICAgICAgIHNvdXRoLFxuICAgICAgICAgICAgaG9yaXpvbnRhbE1pZHBvaW50ICsgKChub3J0aCAtIHNvdXRoKSAvIDIpLFxuICAgICAgICAgICAgbm9ydGhcbiAgICAgICAgXTtcbiAgICB9XG59O1xuIiwidmFyIGluc2lkZSA9IHJlcXVpcmUoJ0B0dXJmL2luc2lkZScpO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBhIHNldCBvZiB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gYW5kIHBlcmZvcm1zIGEgc3BhdGlhbCBqb2luLlxuICpcbiAqIEBuYW1lIHRhZ1xuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25zIGlucHV0IHBvbHlnb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgcHJvcGVydHkgaW4gYHBvbHlnb25zYCB0byBhZGQgdG8gam9pbmVkIHs8UG9pbnQ+fSBmZWF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IG91dEZpZWxkIHByb3BlcnR5IGluIGBwb2ludHNgIGluIHdoaWNoIHRvIHN0b3JlIGpvaW5lZCBwcm9wZXJ0eSBmcm9tIGBwb2x5Z29uc2BcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyB3aXRoIGBjb250YWluaW5nUG9seUlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHZhbHVlcyBmcm9tIGBwb2x5SWRgXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0MSA9IHR1cmYucG9pbnQoWy03NywgNDRdKTtcbiAqIHZhciBwdDIgPSB0dXJmLnBvaW50KFstNzcsIDM4XSk7XG4gKiB2YXIgcG9seTEgPSB0dXJmLnBvbHlnb24oW1tcbiAqICAgWy04MSwgNDFdLFxuICogICBbLTgxLCA0N10sXG4gKiAgIFstNzIsIDQ3XSxcbiAqICAgWy03MiwgNDFdLFxuICogICBbLTgxLCA0MV1cbiAqIF1dLCB7cG9wOiAzMDAwfSk7XG4gKiB2YXIgcG9seTIgPSB0dXJmLnBvbHlnb24oW1tcbiAqICAgWy04MSwgMzVdLFxuICogICBbLTgxLCA0MV0sXG4gKiAgIFstNzIsIDQxXSxcbiAqICAgWy03MiwgMzVdLFxuICogICBbLTgxLCAzNV1cbiAqIF1dLCB7cG9wOiAxMDAwfSk7XG4gKlxuICogdmFyIHBvaW50cyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW3B0MSwgcHQyXSk7XG4gKiB2YXIgcG9seWdvbnMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtwb2x5MSwgcG9seTJdKTtcbiAqXG4gKiB2YXIgdGFnZ2VkID0gdHVyZi50YWcocG9pbnRzLCBwb2x5Z29ucyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAncG9wJywgJ3BvcHVsYXRpb24nKTtcbiAqXG4gKiAvLz10YWdnZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBwb2x5Z29ucywgZmllbGQsIG91dEZpZWxkKSB7XG4gICAgLy8gcHJldmVudCBtdXRhdGlvbnNcbiAgICBwb2ludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBvaW50cykpO1xuICAgIHBvbHlnb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwb2x5Z29ucykpO1xuICAgIHBvaW50cy5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChwdCkge1xuICAgICAgICBpZiAoIXB0LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHB0LnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwb2x5Z29ucy5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2x5KSB7XG4gICAgICAgICAgICBpZiAocHQucHJvcGVydGllc1tvdXRGaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0luc2lkZSA9IGluc2lkZShwdCwgcG9seSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHB0LnByb3BlcnRpZXNbb3V0RmllbGRdID0gcG9seS5wcm9wZXJ0aWVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwb2ludHM7XG59O1xuIiwidmFyIHBvbHlnb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykucG9seWdvbjtcbnZhciBlYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcblxuXG4vKipcbiAqIFRlc3NlbGF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxQb2x5Z29uPn0gaW50byBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gb2YgdHJpYW5nbGVzXG4gKiB1c2luZyBbZWFyY3V0XShodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L2VhcmN1dCkuXG4gKlxuICogQG5hbWUgdGVzc2VsYXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHBvbHkgdGhlIHBvbHlnb24gdG8gdGVzc2VsYXRlXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IGEgZ2VvbWV0cnljb2xsZWN0aW9uIGZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seSA9IHR1cmYucmFuZG9tKCdwb2x5Z29uJykuZmVhdHVyZXNbMF07XG4gKlxuICogdmFyIHRyaWFuZ2xlcyA9IHR1cmYudGVzc2VsYXRlKHBvbHkpO1xuICpcbiAqIC8vPXRyaWFuZ2xlc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2x5KSB7XG4gICAgaWYgKCFwb2x5Lmdlb21ldHJ5IHx8IChwb2x5Lmdlb21ldHJ5LnR5cGUgIT09ICdQb2x5Z29uJyAmJiBwb2x5Lmdlb21ldHJ5LnR5cGUgIT09ICdNdWx0aVBvbHlnb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBQb2x5Z29uIG9yIE11bHRpUG9seWdvbicpO1xuICAgIH1cblxuICAgIHZhciBmYyA9IHt0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLCBmZWF0dXJlczogW119O1xuXG4gICAgaWYgKHBvbHkuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGZjLmZlYXR1cmVzID0gcHJvY2Vzc1BvbHlnb24ocG9seS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9seS5nZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgZmMuZmVhdHVyZXMgPSBmYy5mZWF0dXJlcy5jb25jYXQocHJvY2Vzc1BvbHlnb24oY29vcmRpbmF0ZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZjO1xufTtcblxuZnVuY3Rpb24gcHJvY2Vzc1BvbHlnb24oY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgZGF0YSA9IGZsYXR0ZW5Db29yZHMoY29vcmRpbmF0ZXMpO1xuICAgIHZhciBkaW0gPSAyO1xuICAgIHZhciByZXN1bHQgPSBlYXJjdXQoZGF0YS52ZXJ0aWNlcywgZGF0YS5ob2xlcywgZGltKTtcblxuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHZlcnQsIGkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0W2ldO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtkYXRhLnZlcnRpY2VzW2luZGV4ICogZGltXSwgZGF0YS52ZXJ0aWNlc1tpbmRleCAqIGRpbSArIDFdXSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB2ZXJ0aWNlcy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGNvb3Jkcy5wdXNoKHZlcnRpY2VzW2ldKTtcbiAgICAgICAgZmVhdHVyZXMucHVzaChwb2x5Z29uKFtjb29yZHNdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ29vcmRzKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGF1bmF5X3RyaWFuZ3VsYXRpb25cbi8vaHR0cHM6Ly9naXRodWIuY29tL2lyb253YWxsYWJ5L2RlbGF1bmF5XG52YXIgcG9seWdvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5wb2x5Z29uO1xudmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCB0aGUgbmFtZSBvZiBhIHotdmFsdWUgcHJvcGVydHkgYW5kXG4gKiBjcmVhdGVzIGEgW1RyaWFuZ3VsYXRlZCBJcnJlZ3VsYXIgTmV0d29ya10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ucmlhbmd1bGF0ZWRfaXJyZWd1bGFyX25ldHdvcmspLFxuICogb3IgYSBUSU4gZm9yIHNob3J0LCByZXR1cm5lZCBhcyBhIGNvbGxlY3Rpb24gb2YgUG9seWdvbnMuIFRoZXNlIGFyZSBvZnRlbiB1c2VkXG4gKiBmb3IgZGV2ZWxvcGluZyBlbGV2YXRpb24gY29udG91ciBtYXBzIG9yIHN0ZXBwZWQgaGVhdCB2aXN1YWxpemF0aW9ucy5cbiAqXG4gKiBUaGlzIHRyaWFuZ3VsYXRlcyB0aGUgcG9pbnRzLCBhcyB3ZWxsIGFzIGFkZHMgcHJvcGVydGllcyBjYWxsZWQgYGFgLCBgYmAsXG4gKiBhbmQgYGNgIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGBwcm9wZXJ0eU5hbWVgIGF0IGVhY2ggb2ZcbiAqIHRoZSBwb2ludHMgdGhhdCByZXByZXNlbnQgdGhlIGNvcm5lcnMgb2YgdGhlIHRyaWFuZ2xlLlxuICpcbiAqIEBuYW1lIHRpblxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbel0gbmFtZSBvZiB0aGUgcHJvcGVydHkgZnJvbSB3aGljaCB0byBwdWxsIHogdmFsdWVzXG4gKiBUaGlzIGlzIG9wdGlvbmFsOiBpZiBub3QgZ2l2ZW4sIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBleHRyYSBkYXRhIGFkZGVkIHRvIHRoZSBkZXJpdmVkIHRyaWFuZ2xlcy5cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gVElOIG91dHB1dFxuICogQGV4YW1wbGVcbiAqIC8vIGdlbmVyYXRlIHNvbWUgcmFuZG9tIHBvaW50IGRhdGFcbiAqIHZhciBwb2ludHMgPSB0dXJmLnJhbmRvbSgncG9pbnRzJywgMzAsIHtcbiAqICAgYmJveDogWzUwLCAzMCwgNzAsIDUwXVxuICogfSk7XG4gKiAvLz1wb2ludHNcbiAqIC8vIGFkZCBhIHJhbmRvbSBwcm9wZXJ0eSB0byBlYWNoIHBvaW50IGJldHdlZW4gMCBhbmQgOVxuICogZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgcG9pbnRzLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMueiA9IH5+KE1hdGgucmFuZG9tKCkgKiA5KTtcbiAqIH1cbiAqIHZhciB0aW4gPSB0dXJmLnRpbihwb2ludHMsICd6JylcbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgdGluLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gKiAgIHZhciBwcm9wZXJ0aWVzICA9IHRpbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzO1xuICogICAvLyByb3VnaGx5IHR1cm4gdGhlIHByb3BlcnRpZXMgb2YgZWFjaFxuICogICAvLyB0cmlhbmdsZSBpbnRvIGEgZmlsbCBjb2xvclxuICogICAvLyBzbyB3ZSBjYW4gdmlzdWFsaXplIHRoZSByZXN1bHRcbiAqICAgcHJvcGVydGllcy5maWxsID0gJyMnICsgcHJvcGVydGllcy5hICtcbiAqICAgICBwcm9wZXJ0aWVzLmIgKyBwcm9wZXJ0aWVzLmM7XG4gKiB9XG4gKiAvLz10aW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCB6KSB7XG4gICAgLy9icmVhayBkb3duIHBvaW50c1xuICAgIHJldHVybiBmZWF0dXJlY29sbGVjdGlvbih0cmlhbmd1bGF0ZShwb2ludHMuZmVhdHVyZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgICAgICB5OiBwLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXG4gICAgICAgIH07XG4gICAgICAgIGlmICh6KSBwb2ludC56ID0gcC5wcm9wZXJ0aWVzW3pdO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSkpLm1hcChmdW5jdGlvbiAodHJpYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHBvbHlnb24oW1tcbiAgICAgICAgW3RyaWFuZ2xlLmEueCwgdHJpYW5nbGUuYS55XSxcbiAgICAgICAgW3RyaWFuZ2xlLmIueCwgdHJpYW5nbGUuYi55XSxcbiAgICAgICAgW3RyaWFuZ2xlLmMueCwgdHJpYW5nbGUuYy55XSxcbiAgICAgICAgW3RyaWFuZ2xlLmEueCwgdHJpYW5nbGUuYS55XVxuICAgICAgICBdXSwge1xuICAgICAgICAgICAgYTogdHJpYW5nbGUuYS56LFxuICAgICAgICAgICAgYjogdHJpYW5nbGUuYi56LFxuICAgICAgICAgICAgYzogdHJpYW5nbGUuYy56XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn07XG5cbmZ1bmN0aW9uIFRyaWFuZ2xlKGEsIGIsIGMpIHtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG4gICAgdGhpcy5jID0gYztcblxuICAgIHZhciBBID0gYi54IC0gYS54LFxuICAgICAgICBCID0gYi55IC0gYS55LFxuICAgICAgICBDID0gYy54IC0gYS54LFxuICAgICAgICBEID0gYy55IC0gYS55LFxuICAgICAgICBFID0gQSAqIChhLnggKyBiLngpICsgQiAqIChhLnkgKyBiLnkpLFxuICAgICAgICBGID0gQyAqIChhLnggKyBjLngpICsgRCAqIChhLnkgKyBjLnkpLFxuICAgICAgICBHID0gMiAqIChBICogKGMueSAtIGIueSkgLSBCICogKGMueCAtIGIueCkpLFxuICAgICAgICBkeCwgZHk7XG5cbiAgICAvLyBJZiB0aGUgcG9pbnRzIG9mIHRoZSB0cmlhbmdsZSBhcmUgY29sbGluZWFyLCB0aGVuIGp1c3QgZmluZCB0aGVcbiAgICAvLyBleHRyZW1lcyBhbmQgdXNlIHRoZSBtaWRwb2ludCBhcyB0aGUgY2VudGVyIG9mIHRoZSBjaXJjdW1jaXJjbGUuXG4gICAgdGhpcy54ID0gKEQgKiBFIC0gQiAqIEYpIC8gRztcbiAgICB0aGlzLnkgPSAoQSAqIEYgLSBDICogRSkgLyBHO1xuICAgIGR4ID0gdGhpcy54IC0gYS54O1xuICAgIGR5ID0gdGhpcy55IC0gYS55O1xuICAgIHRoaXMuciA9IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBieVgoYSwgYikge1xuICAgIHJldHVybiBiLnggLSBhLng7XG59XG5cbmZ1bmN0aW9uIGRlZHVwKGVkZ2VzKSB7XG4gICAgdmFyIGogPSBlZGdlcy5sZW5ndGgsXG4gICAgICAgIGEsIGIsIGksIG0sIG47XG5cbiAgICBvdXRlcjpcbiAgd2hpbGUgKGopIHtcbiAgICAgIGIgPSBlZGdlc1stLWpdO1xuICAgICAgYSA9IGVkZ2VzWy0tal07XG4gICAgICBpID0gajtcbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgICAgbiA9IGVkZ2VzWy0taV07XG4gICAgICAgICAgbSA9IGVkZ2VzWy0taV07XG4gICAgICAgICAgaWYgKChhID09PSBtICYmIGIgPT09IG4pIHx8IChhID09PSBuICYmIGIgPT09IG0pKSB7XG4gICAgICAgICAgICAgIGVkZ2VzLnNwbGljZShqLCAyKTtcbiAgICAgICAgICAgICAgZWRnZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICBqIC09IDI7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlhbmd1bGF0ZSh2ZXJ0aWNlcykge1xuICAgIC8vIEJhaWwgaWYgdGhlcmUgYXJlbid0IGVub3VnaCB2ZXJ0aWNlcyB0byBmb3JtIGFueSB0cmlhbmdsZXMuXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDMpXG4gICAgICAgIHJldHVybiBbXTtcblxuICAgIC8vIEVuc3VyZSB0aGUgdmVydGV4IGFycmF5IGlzIGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgWCBjb29yZGluYXRlXG4gICAgLy8gKHdoaWNoIGlzIG5lZWRlZCB0byBlbnN1cmUgYSBzdWJxdWFkcmF0aWMgcnVudGltZSksIGFuZCB0aGVuIGZpbmRcbiAgICAvLyB0aGUgYm91bmRpbmcgYm94IGFyb3VuZCB0aGUgcG9pbnRzLlxuICAgIHZlcnRpY2VzLnNvcnQoYnlYKTtcblxuICAgIHZhciBpID0gdmVydGljZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgeG1pbiA9IHZlcnRpY2VzW2ldLngsXG4gICAgICAgIHhtYXggPSB2ZXJ0aWNlc1swXS54LFxuICAgICAgICB5bWluID0gdmVydGljZXNbaV0ueSxcbiAgICAgICAgeW1heCA9IHltaW4sXG4gICAgICAgIGVwc2lsb24gPSAxZS0xMjtcblxuICAgIHZhciBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBBLFxuICAgICAgICBCLFxuICAgICAgICBHO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodmVydGljZXNbaV0ueSA8IHltaW4pXG4gICAgICAgICAgICB5bWluID0gdmVydGljZXNbaV0ueTtcbiAgICAgICAgaWYgKHZlcnRpY2VzW2ldLnkgPiB5bWF4KVxuICAgICAgICAgICAgeW1heCA9IHZlcnRpY2VzW2ldLnk7XG4gICAgfVxuXG4gICAgLy9GaW5kIGEgc3VwZXJ0cmlhbmdsZSwgd2hpY2ggaXMgYSB0cmlhbmdsZSB0aGF0IHN1cnJvdW5kcyBhbGwgdGhlXG4gICAgLy92ZXJ0aWNlcy4gVGhpcyBpcyB1c2VkIGxpa2Ugc29tZXRoaW5nIG9mIGEgc2VudGluZWwgdmFsdWUgdG8gcmVtb3ZlXG4gICAgLy9jYXNlcyBpbiB0aGUgbWFpbiBhbGdvcml0aG0sIGFuZCBpcyByZW1vdmVkIGJlZm9yZSB3ZSByZXR1cm4gYW55XG4gICAgLy8gcmVzdWx0cy5cblxuICAgIC8vIE9uY2UgZm91bmQsIHB1dCBpdCBpbiB0aGUgXCJvcGVuXCIgbGlzdC4gKFRoZSBcIm9wZW5cIiBsaXN0IGlzIGZvclxuICAgIC8vIHRyaWFuZ2xlcyB3aG8gbWF5IHN0aWxsIG5lZWQgdG8gYmUgY29uc2lkZXJlZDsgdGhlIFwiY2xvc2VkXCIgbGlzdCBpc1xuICAgIC8vIGZvciB0cmlhbmdsZXMgd2hpY2ggZG8gbm90LilcbiAgICB2YXIgZHggPSB4bWF4IC0geG1pbixcbiAgICAgICAgZHkgPSB5bWF4IC0geW1pbixcbiAgICAgICAgZG1heCA9IChkeCA+IGR5KSA/IGR4IDogZHksXG4gICAgICAgIHhtaWQgPSAoeG1heCArIHhtaW4pICogMC41LFxuICAgICAgICB5bWlkID0gKHltYXggKyB5bWluKSAqIDAuNSxcbiAgICAgICAgb3BlbiA9IFtcbiAgICAgICAgICAgIG5ldyBUcmlhbmdsZSh7XG4gICAgICAgICAgICAgICAgeDogeG1pZCAtIDIwICogZG1heCxcbiAgICAgICAgICAgICAgICB5OiB5bWlkIC0gZG1heCxcbiAgICAgICAgICAgICAgICBfX3NlbnRpbmVsOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogeG1pZCxcbiAgICAgICAgICAgICAgICB5OiB5bWlkICsgMjAgKiBkbWF4LFxuICAgICAgICAgICAgICAgIF9fc2VudGluZWw6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiB4bWlkICsgMjAgKiBkbWF4LFxuICAgICAgICAgICAgICAgIHk6IHltaWQgLSBkbWF4LFxuICAgICAgICAgICAgICAgIF9fc2VudGluZWw6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKV0sXG4gICAgICAgIGNsb3NlZCA9IFtdLFxuICAgICAgICBlZGdlcyA9IFtdLFxuICAgICAgICBqO1xuXG4gICAgLy8gSW5jcmVtZW50YWxseSBhZGQgZWFjaCB2ZXJ0ZXggdG8gdGhlIG1lc2guXG4gICAgaSA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIG9wZW4gdHJpYW5nbGUsIGNoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCBwb2ludCBpc1xuICAgICAgICAvLyBpbnNpZGUgaXQncyBjaXJjdW1jaXJjbGUuIElmIGl0IGlzLCByZW1vdmUgdGhlIHRyaWFuZ2xlIGFuZCBhZGRcbiAgICAgICAgLy8gaXQncyBlZGdlcyB0byBhbiBlZGdlIGxpc3QuXG4gICAgICAgIGVkZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIGogPSBvcGVuLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBwb2ludCBpcyB0byB0aGUgcmlnaHQgb2YgdGhpcyB0cmlhbmdsZSdzIGNpcmN1bWNpcmNsZSxcbiAgICAgICAgICAgIC8vIHRoZW4gdGhpcyB0cmlhbmdsZSBzaG91bGQgbmV2ZXIgZ2V0IGNoZWNrZWQgYWdhaW4uIFJlbW92ZSBpdFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3BlbiBsaXN0LCBhZGQgaXQgdG8gdGhlIGNsb3NlZCBsaXN0LCBhbmQgc2tpcC5cbiAgICAgICAgICAgIGR4ID0gdmVydGljZXNbaV0ueCAtIG9wZW5bal0ueDtcbiAgICAgICAgICAgIGlmIChkeCA+IDAgJiYgZHggKiBkeCA+IG9wZW5bal0ucikge1xuICAgICAgICAgICAgICAgIGNsb3NlZC5wdXNoKG9wZW5bal0pO1xuICAgICAgICAgICAgICAgIG9wZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBub3QsIHNraXAgdGhpcyB0cmlhbmdsZS5cbiAgICAgICAgICAgIGR5ID0gdmVydGljZXNbaV0ueSAtIG9wZW5bal0ueTtcbiAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IG9wZW5bal0ucilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmlhbmdsZSBhbmQgYWRkIGl0J3MgZWRnZXMgdG8gdGhlIGVkZ2UgbGlzdC5cbiAgICAgICAgICAgIGVkZ2VzLnB1c2goXG4gICAgICAgIG9wZW5bal0uYSwgb3BlbltqXS5iLFxuICAgICAgICBvcGVuW2pdLmIsIG9wZW5bal0uYyxcbiAgICAgICAgb3BlbltqXS5jLCBvcGVuW2pdLmFcbiAgICAgICk7XG4gICAgICAgICAgICBvcGVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZG91YmxlZCBlZGdlcy5cbiAgICAgICAgZGVkdXAoZWRnZXMpO1xuXG4gICAgICAgIC8vIEFkZCBhIG5ldyB0cmlhbmdsZSBmb3IgZWFjaCBlZGdlLlxuICAgICAgICBqID0gZWRnZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaikge1xuICAgICAgICAgICAgYiA9IGVkZ2VzWy0tal07XG4gICAgICAgICAgICBhID0gZWRnZXNbLS1qXTtcbiAgICAgICAgICAgIGMgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIC8vIEF2b2lkIGFkZGluZyBjb2xpbmVhciB0cmlhbmdsZXMgKHdoaWNoIGhhdmUgZXJyb3ItcHJvbmVcbiAgICAgICAgICAgIC8vIGNpcmN1bWNpcmNsZXMpXG4gICAgICAgICAgICBBID0gYi54IC0gYS54O1xuICAgICAgICAgICAgQiA9IGIueSAtIGEueTtcbiAgICAgICAgICAgIEcgPSAyICogKEEgKiAoYy55IC0gYi55KSAtIEIgKiAoYy54IC0gYi54KSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoRykgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgb3Blbi5wdXNoKG5ldyBUcmlhbmdsZShhLCBiLCBjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb3B5IGFueSByZW1haW5pbmcgb3BlbiB0cmlhbmdsZXMgdG8gdGhlIGNsb3NlZCBsaXN0LCBhbmQgdGhlblxuICAgIC8vIHJlbW92ZSBhbnkgdHJpYW5nbGVzIHRoYXQgc2hhcmUgYSB2ZXJ0ZXggd2l0aCB0aGUgc3VwZXJ0cmlhbmdsZS5cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjbG9zZWQsIG9wZW4pO1xuXG4gICAgaSA9IGNsb3NlZC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaWYgKGNsb3NlZFtpXS5hLl9fc2VudGluZWwgfHxcbiAgICAgIGNsb3NlZFtpXS5iLl9fc2VudGluZWwgfHxcbiAgICAgIGNsb3NlZFtpXS5jLl9fc2VudGluZWwpXG4gICAgICAgICAgICBjbG9zZWQuc3BsaWNlKGksIDEpO1xuXG4gICAgcmV0dXJuIGNsb3NlZDtcbn1cbiIsInZhciBmZWF0dXJlY29sbGVjdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBwb2x5Z29uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLnBvbHlnb247XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCdAdHVyZi9kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBhIGNlbGwgZGVwdGggYW5kIHJldHVybnMgYSBzZXQgb2YgdHJpYW5ndWxhciB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gaW4gYSBncmlkLlxuICpcbiAqIEBuYW1lIHRyaWFuZ2xlR3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSBkaW1lbnNpb24gb2YgZWFjaCBjZWxsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIHVzZWQgaW4gY2FsY3VsYXRpbmcgY2VsbFNpemUsIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBncmlkIG9mIHBvbHlnb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBbLTk2LDMxLC04NCw0MF1cbiAqIHZhciBjZWxsU2l6ZSA9IDEwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgdHJpYW5nbGVHcmlkID0gdHVyZi50cmlhbmdsZUdyaWQoYmJveCwgY2VsbFNpemUsIHVuaXRzKTtcbiAqXG4gKiAvLz10cmlhbmdsZUdyaWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYmJveCwgY2VsbFNpemUsIHVuaXRzKSB7XG4gICAgdmFyIGZjID0gZmVhdHVyZWNvbGxlY3Rpb24oW10pO1xuICAgIHZhciB4RnJhY3Rpb24gPSBjZWxsU2l6ZSAvIChkaXN0YW5jZShbYmJveFswXSwgYmJveFsxXV0sIFtiYm94WzJdLCBiYm94WzFdXSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbFdpZHRoID0geEZyYWN0aW9uICogKGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICB2YXIgeUZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UoW2Jib3hbMF0sIGJib3hbMV1dLCBbYmJveFswXSwgYmJveFszXV0sIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSB5RnJhY3Rpb24gKiAoYmJveFszXSAtIGJib3hbMV0pO1xuXG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgY3VycmVudFggPSBiYm94WzBdO1xuICAgIHdoaWxlIChjdXJyZW50WCA8PSBiYm94WzJdKSB7XG4gICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50WSA9IGJib3hbMV07XG4gICAgICAgIHdoaWxlIChjdXJyZW50WSA8PSBiYm94WzNdKSB7XG4gICAgICAgICAgICBpZiAoeGkgJSAyID09PSAwICYmIHlpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV1cbiAgICAgICAgICAgICAgICBdXSksIHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF1cbiAgICAgICAgICAgICAgICBdXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4aSAlIDIgPT09IDAgJiYgeWkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgICAgIF1dKSwgcG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeWkgJSAyID09PSAwICYmIHhpICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pLCBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgICAgIF1dKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlpICUgMiA9PT0gMSAmJiB4aSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pLCBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdXG4gICAgICAgICAgICAgICAgXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRZICs9IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICB5aSsrO1xuICAgICAgICB9XG4gICAgICAgIHhpKys7XG4gICAgICAgIGN1cnJlbnRYICs9IGNlbGxXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGZjO1xufTtcblxuIiwiLyoqXG4gKiBUYWtlcyBhIEdlb0pTT04gRmVhdHVyZSBvciBGZWF0dXJlQ29sbGVjdGlvbiBhbmQgdHJ1bmNhdGVzIHRoZSBwcmVjaXNpb24gb2YgdGhlIGdlb21ldHJ5LlxuICpcbiAqIEBuYW1lIHRydW5jYXRlXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gbGF5ZXIgYW55IEdlb0pTT04gRmVhdHVyZSBvciBGZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249Nl0gY29vcmRpbmF0ZSBkZWNpbWFsIHByZWNpc2lvblxuICogQHBhcmFtIHtudW1iZXJ9IFtjb29yZGluYXRlcz0yXSBtYXhpbXVtIG51bWJlciBvZiBjb29yZGluYXRlcyAocHJpbWFybHkgdXNlZCB0byByZW1vdmUgeiBjb29yZGluYXRlcylcbiAqIEByZXR1cm5zIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGxheWVyIHdpdGggdHJ1bmNhdGVkIGdlb21ldHJ5XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0ge1xuICogICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICAgICAgICA3MC40NjkyMzA1NTU2Njg1OSxcbiAqICAgICAgICAgICAgIDU4LjExMDg4ODkwODAyOTA2LFxuICogICAgICAgICAgICAgMTUwOFxuICogICAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBcInByb3BlcnRpZXNcIjoge31cbiAqIH07XG4gKiB2YXIgcG9pbnRUcnVuYyA9IHR1cmYudHJ1bmNhdGUocG9pbnQpO1xuICogLy89IHBvaW50VHJ1bmNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGF5ZXIsIHByZWNpc2lvbiwgY29vcmRpbmF0ZXMpIHtcbiAgICBwcmVjaXNpb24gPSAocHJlY2lzaW9uICE9PSB1bmRlZmluZWQpID8gcHJlY2lzaW9uIDogNjtcbiAgICBjb29yZGluYXRlcyA9IChjb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkKSA/IGNvb3JkaW5hdGVzIDogMjtcblxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ2xheWVyIGlzIHJlcXVpcmVkJyk7XG5cbiAgICBzd2l0Y2ggKGxheWVyLnR5cGUpIHtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6IHtcbiAgICAgICAgbGF5ZXIuZmVhdHVyZXMgPSBsYXllci5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVuY2F0ZShmZWF0dXJlLCBwcmVjaXNpb24sIGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG4gICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAgIHJldHVybiB0cnVuY2F0ZShsYXllciwgcHJlY2lzaW9uLCBjb29yZGluYXRlcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShmZWF0dXJlLCBwcmVjaXNpb24sIGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKGNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQpIHsgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGRlZXBTbGljZShmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcyk7IH1cbiAgICBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gdG9GaXgoZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gdG9GaXgoYXJyYXksIHByZWNpc2lvbikge1xuICAgIHJldHVybiBhcnJheS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7IHJldHVybiB0b0ZpeCh2YWx1ZSwgcHJlY2lzaW9uKTsgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlLnRvRml4ZWQocHJlY2lzaW9uKSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlIEFycmF5LnByb3RvdHlwZS5zbGljZSgpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRGVuaXNDYXJyaWVyZS9kZWVwLXNsaWNlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIEFycmF5IGlucHV0XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzZWN0aW9uIG9mIGFuIGFycmF5LlxuICogQGV4YW1wbGVcbiAqIGRlZXBTbGljZShbWzEwLCAyMCwgMzBdLCBbNDAsIDUwLCA2MF1dLCAwLCAyKVxuICogLy89W1sxMCwgMjBdLCBbNDAsIDUwXV1cbiAqL1xuZnVuY3Rpb24gZGVlcFNsaWNlKGl0ZW1zLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtc1swXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBkZWVwU2xpY2UoaXRlbSwgc3RhcnQsIGVuZCk7XG4gICAgfSk7XG59XG4iLCIvKmVzbGludCBnbG9iYWwtcmVxdWlyZTogMCovXG5cbi8qKlxuICogVHVyZiBpcyBhIG1vZHVsYXIgZ2Vvc3BhdGlhbCBhbmFseXNpcyBlbmdpbmUgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LiBJdCBwZXJmb3JtcyBnZW9zcGF0aWFsXG4gKiBwcm9jZXNzaW5nIHRhc2tzIHdpdGggR2VvSlNPTiBkYXRhIGFuZCBjYW4gYmUgcnVuIG9uIGEgc2VydmVyIG9yIGluIGEgYnJvd3Nlci5cbiAqXG4gKiBAbW9kdWxlIHR1cmZcbiAqIEBzdW1tYXJ5IEdlb3NwYXRpYWwgYW5hbHlzaXMgZm9yIEphdmFTY3JpcHRcbiAqL1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnQHR1cmYvaW52YXJpYW50Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKTtcblxudmFyIHR1cmYgPSB7XG4gICAgaXNvbGluZXM6IHJlcXVpcmUoJ0B0dXJmL2lzb2xpbmVzJyksXG4gICAgY29udmV4OiByZXF1aXJlKCdAdHVyZi9jb252ZXgnKSxcbiAgICB3aXRoaW46IHJlcXVpcmUoJ0B0dXJmL3dpdGhpbicpLFxuICAgIGNvbmNhdmU6IHJlcXVpcmUoJ0B0dXJmL2NvbmNhdmUnKSxcbiAgICBkaWZmZXJlbmNlOiByZXF1aXJlKCdAdHVyZi9kaWZmZXJlbmNlJyksXG4gICAgZGlzc29sdmU6IHJlcXVpcmUoJ0B0dXJmL2Rpc3NvbHZlJyksXG4gICAgY29sbGVjdDogcmVxdWlyZSgnQHR1cmYvY29sbGVjdCcpLFxuICAgIGZsaXA6IHJlcXVpcmUoJ0B0dXJmL2ZsaXAnKSxcbiAgICBzaW1wbGlmeTogcmVxdWlyZSgnQHR1cmYvc2ltcGxpZnknKSxcbiAgICBiZXppZXI6IHJlcXVpcmUoJ0B0dXJmL2JlemllcicpLFxuICAgIHRhZzogcmVxdWlyZSgnQHR1cmYvdGFnJyksXG4gICAgc2FtcGxlOiByZXF1aXJlKCdAdHVyZi9zYW1wbGUnKSxcbiAgICBlbnZlbG9wZTogcmVxdWlyZSgnQHR1cmYvZW52ZWxvcGUnKSxcbiAgICBzcXVhcmU6IHJlcXVpcmUoJ0B0dXJmL3NxdWFyZScpLFxuICAgIGNpcmNsZTogcmVxdWlyZSgnQHR1cmYvY2lyY2xlJyksXG4gICAgbWlkcG9pbnQ6IHJlcXVpcmUoJ0B0dXJmL21pZHBvaW50JyksXG4gICAgYnVmZmVyOiByZXF1aXJlKCdAdHVyZi9idWZmZXInKSxcbiAgICBjZW50ZXI6IHJlcXVpcmUoJ0B0dXJmL2NlbnRlcicpLFxuICAgIGNlbnRlck9mTWFzczogcmVxdWlyZSgnQHR1cmYvY2VudGVyLW9mLW1hc3MnKSxcbiAgICBjZW50cm9pZDogcmVxdWlyZSgnQHR1cmYvY2VudHJvaWQnKSxcbiAgICBjb21iaW5lOiByZXF1aXJlKCdAdHVyZi9jb21iaW5lJyksXG4gICAgZGlzdGFuY2U6IHJlcXVpcmUoJ0B0dXJmL2Rpc3RhbmNlJyksXG4gICAgZXhwbG9kZTogcmVxdWlyZSgnQHR1cmYvZXhwbG9kZScpLFxuICAgIGJib3g6IHJlcXVpcmUoJ0B0dXJmL2Jib3gnKSxcbiAgICB0ZXNzZWxhdGU6IHJlcXVpcmUoJ0B0dXJmL3Rlc3NlbGF0ZScpLFxuICAgIGJib3hQb2x5Z29uOiByZXF1aXJlKCdAdHVyZi9iYm94LXBvbHlnb24nKSxcbiAgICBpbnNpZGU6IHJlcXVpcmUoJ0B0dXJmL2luc2lkZScpLFxuICAgIGludGVyc2VjdDogcmVxdWlyZSgnQHR1cmYvaW50ZXJzZWN0JyksXG4gICAgbmVhcmVzdDogcmVxdWlyZSgnQHR1cmYvbmVhcmVzdCcpLFxuICAgIHBsYW5lcG9pbnQ6IHJlcXVpcmUoJ0B0dXJmL3BsYW5lcG9pbnQnKSxcbiAgICByYW5kb206IHJlcXVpcmUoJ0B0dXJmL3JhbmRvbScpLFxuICAgIHRpbjogcmVxdWlyZSgnQHR1cmYvdGluJyksXG4gICAgdW5pb246IHJlcXVpcmUoJ0B0dXJmL3VuaW9uJyksXG4gICAgYmVhcmluZzogcmVxdWlyZSgnQHR1cmYvYmVhcmluZycpLFxuICAgIGRlc3RpbmF0aW9uOiByZXF1aXJlKCdAdHVyZi9kZXN0aW5hdGlvbicpLFxuICAgIGtpbmtzOiByZXF1aXJlKCdAdHVyZi9raW5rcycpLFxuICAgIHBvaW50T25TdXJmYWNlOiByZXF1aXJlKCdAdHVyZi9wb2ludC1vbi1zdXJmYWNlJyksXG4gICAgYXJlYTogcmVxdWlyZSgnQHR1cmYvYXJlYScpLFxuICAgIGFsb25nOiByZXF1aXJlKCdAdHVyZi9hbG9uZycpLFxuICAgIGxpbmVEaXN0YW5jZTogcmVxdWlyZSgnQHR1cmYvbGluZS1kaXN0YW5jZScpLFxuICAgIGxpbmVTbGljZTogcmVxdWlyZSgnQHR1cmYvbGluZS1zbGljZScpLFxuICAgIGxpbmVTbGljZUFsb25nOiByZXF1aXJlKCdAdHVyZi9saW5lLXNsaWNlLWFsb25nJyksXG4gICAgcG9pbnRPbkxpbmU6IHJlcXVpcmUoJ0B0dXJmL3BvaW50LW9uLWxpbmUnKSxcbiAgICBwb2ludEdyaWQ6IHJlcXVpcmUoJ0B0dXJmL3BvaW50LWdyaWQnKSxcbiAgICBzcXVhcmVHcmlkOiByZXF1aXJlKCdAdHVyZi9zcXVhcmUtZ3JpZCcpLFxuICAgIHRyaWFuZ2xlR3JpZDogcmVxdWlyZSgnQHR1cmYvdHJpYW5nbGUtZ3JpZCcpLFxuICAgIGhleEdyaWQ6IHJlcXVpcmUoJ0B0dXJmL2hleC1ncmlkJyksXG4gICAgaWR3OiByZXF1aXJlKCdAdHVyZi9pZHcnKSxcbiAgICB0cnVuY2F0ZTogcmVxdWlyZSgnQHR1cmYvdHJ1bmNhdGUnKSxcbiAgICBmbGF0dGVuOiByZXF1aXJlKCdAdHVyZi9mbGF0dGVuJyksXG4gICAgbGluZUludGVyc2VjdDogcmVxdWlyZSgnQHR1cmYvbGluZS1pbnRlcnNlY3QnKSxcbiAgICBtYXNrOiByZXF1aXJlKCdAdHVyZi9tYXNrJyksXG4gICAgbGluZUNodW5rOiByZXF1aXJlKCdAdHVyZi9saW5lLWNodW5rJyksXG4gICAgdW5raW5rUG9seWdvbjogcmVxdWlyZSgnQHR1cmYvdW5raW5rLXBvbHlnb24nKSxcbiAgICBncmVhdENpcmNsZTogcmVxdWlyZSgnQHR1cmYvZ3JlYXQtY2lyY2xlJyksXG4gICAgbGluZVNlZ21lbnQ6IHJlcXVpcmUoJ0B0dXJmL2xpbmUtc2VnbWVudCcpLFxuICAgIGxpbmVTcGxpdDogcmVxdWlyZSgnQHR1cmYvbGluZS1zcGxpdCcpLFxuICAgIGxpbmVBcmM6IHJlcXVpcmUoJ0B0dXJmL2xpbmUtYXJjJyksXG4gICAgcG9seWdvblRvTGluZVN0cmluZzogcmVxdWlyZSgnQHR1cmYvcG9seWdvbi10by1saW5lc3RyaW5nJyksXG4gICAgYmJveENsaXA6IHJlcXVpcmUoJ0B0dXJmL2Jib3gtY2xpcCcpLFxuICAgIGxpbmVPdmVybGFwOiByZXF1aXJlKCdAdHVyZi9saW5lLW92ZXJsYXAnKSxcbiAgICBwb2ludDogaGVscGVycy5wb2ludCxcbiAgICBwb2x5Z29uOiBoZWxwZXJzLnBvbHlnb24sXG4gICAgbGluZVN0cmluZzogaGVscGVycy5saW5lU3RyaW5nLFxuICAgIG11bHRpUG9pbnQ6IGhlbHBlcnMubXVsdGlQb2ludCxcbiAgICBtdWx0aVBvbHlnb246IGhlbHBlcnMubXVsdGlQb2x5Z29uLFxuICAgIG11bHRpTGluZVN0cmluZzogaGVscGVycy5tdWx0aUxpbmVTdHJpbmcsXG4gICAgZmVhdHVyZTogaGVscGVycy5mZWF0dXJlLFxuICAgIGZlYXR1cmVDb2xsZWN0aW9uOiBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uLFxuICAgIGdlb21ldHJ5Q29sbGVjdGlvbjogaGVscGVycy5nZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgcmFkaWFuc1RvRGlzdGFuY2U6IGhlbHBlcnMucmFkaWFuc1RvRGlzdGFuY2UsXG4gICAgZGlzdGFuY2VUb1JhZGlhbnM6IGhlbHBlcnMuZGlzdGFuY2VUb1JhZGlhbnMsXG4gICAgZGlzdGFuY2VUb0RlZ3JlZXM6IGhlbHBlcnMuZGlzdGFuY2VUb0RlZ3JlZXMsXG4gICAgZ2V0Q29vcmQ6IGludmFyaWFudC5nZXRDb29yZCxcbiAgICBnZXRDb29yZHM6IGludmFyaWFudC5nZXRDb29yZHMsXG4gICAgZ2VvanNvblR5cGU6IGludmFyaWFudC5nZW9qc29uVHlwZSxcbiAgICBmZWF0dXJlT2Y6IGludmFyaWFudC5mZWF0dXJlT2YsXG4gICAgY29sbGVjdGlvbk9mOiBpbnZhcmlhbnQuY29sbGVjdGlvbk9mLFxuICAgIGNvbnRhaW5zTnVtYmVyOiBpbnZhcmlhbnQuY29udGFpbnNOdW1iZXIsXG4gICAgY29vcmRFYWNoOiBtZXRhLmNvb3JkRWFjaCxcbiAgICBjb29yZFJlZHVjZTogbWV0YS5jb29yZFJlZHVjZSxcbiAgICBwcm9wRWFjaDogbWV0YS5wcm9wRWFjaCxcbiAgICBwcm9wUmVkdWNlOiBtZXRhLnByb3BSZWR1Y2UsXG4gICAgZmVhdHVyZUVhY2g6IG1ldGEuZmVhdHVyZUVhY2gsXG4gICAgZmVhdHVyZVJlZHVjZTogbWV0YS5mZWF0dXJlUmVkdWNlLFxuICAgIGNvb3JkQWxsOiBtZXRhLmNvb3JkQWxsLFxuICAgIGdlb21FYWNoOiBtZXRhLmdlb21FYWNoLFxuICAgIGdlb21SZWR1Y2U6IG1ldGEuZ2VvbVJlZHVjZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0dXJmO1xuIiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84Mzk4OTkvaG93LWRvLWktY2FsY3VsYXRlLWEtcG9pbnQtb24tYS1jaXJjbGVzLWNpcmN1bWZlcmVuY2Vcbi8vIHJhZGlhbnMgPSBkZWdyZWVzICogKHBpLzE4MClcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvYnVmZmVyLmh0bWxcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJyk7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIGpzdHMgPSByZXF1aXJlKCdqc3RzJyk7XG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnQG1hcGJveC9nZW9qc29uLW5vcm1hbGl6ZScpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBidWZmZXIgZm9yIGlucHV0IGZlYXR1cmVzIGZvciBhIGdpdmVuIHJhZGl1cy4gVW5pdHMgc3VwcG9ydGVkIGFyZSBtaWxlcywga2lsb21ldGVycywgYW5kIGRlZ3JlZXMuXG4gKlxuICogQG5hbWUgYnVmZmVyXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gZmVhdHVyZSBpbnB1dCB0byBiZSBidWZmZXJlZFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBkaXN0YW5jZSB0byBkcmF3IHRoZSBidWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0cyBhbnkgb2YgdGhlIG9wdGlvbnMgc3VwcG9ydGVkIGJ5IHR1cmYgdW5pdHNcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fEZlYXR1cmVDb2xsZWN0aW9uPE11bHRpUG9seWdvbj58UG9seWdvbnxNdWx0aVBvbHlnb259IGJ1ZmZlcmVkIGZlYXR1cmVzXG4gKiBAYWRkVG9NYXAgcHQsIGJ1ZmZlcmVkXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTAuNTQ4NjMwLCAxNC42MTY1OTldXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgdW5pdCA9ICdtaWxlcyc7XG4gKlxuICogdmFyIGJ1ZmZlcmVkID0gdHVyZi5idWZmZXIocHQsIDUwMCwgdW5pdCk7XG4gKlxuICogLy89YnVmZmVyZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlLCByYWRpdXMsIHVuaXRzKSB7XG5cbiAgICB2YXIgZGVncmVlcyA9IGhlbHBlcnMuZGlzdGFuY2VUb0RlZ3JlZXMocmFkaXVzLCB1bml0cyk7XG4gICAgdmFyIGZjID0gbm9ybWFsaXplKGZlYXR1cmUpO1xuICAgIHZhciBidWZmZXJlZCA9IG5vcm1hbGl6ZShmZWF0dXJlQ29sbGVjdGlvbihmYy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlck9wKGYsIGRlZ3JlZXMpO1xuICAgIH0pKSk7XG5cbiAgICBpZiAoYnVmZmVyZWQuZmVhdHVyZXMubGVuZ3RoID4gMSkgcmV0dXJuIGJ1ZmZlcmVkO1xuICAgIGVsc2UgaWYgKGJ1ZmZlcmVkLmZlYXR1cmVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ1ZmZlcmVkLmZlYXR1cmVzWzBdO1xufTtcblxuZnVuY3Rpb24gYnVmZmVyT3AoZmVhdHVyZSwgcmFkaXVzKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgZ2VvbSA9IHJlYWRlci5yZWFkKGZlYXR1cmUuZ2VvbWV0cnkpO1xuICAgIHZhciBidWZmZXJlZCA9IGdlb20uYnVmZmVyKHJhZGl1cyk7XG4gICAgdmFyIHdyaXRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05Xcml0ZXIoKTtcbiAgICBidWZmZXJlZCA9IHdyaXRlci53cml0ZShidWZmZXJlZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBidWZmZXJlZCxcbiAgICAgICAgcHJvcGVydGllczoge31cbiAgICB9O1xufVxuIiwidmFyIG1ldGEgPSByZXF1aXJlKCdAdHVyZi9tZXRhJyk7XG5cbi8qKlxuICogQ29tYmluZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIHtAbGluayBQb2ludH0sXG4gKiB7QGxpbmsgTGluZVN0cmluZ30sIG9yIHtAbGluayBQb2x5Z29ufSBmZWF0dXJlc1xuICogaW50byB7QGxpbmsgTXVsdGlQb2ludH0sIHtAbGluayBNdWx0aUxpbmVTdHJpbmd9LCBvclxuICoge0BsaW5rIE11bHRpUG9seWdvbn0gZmVhdHVyZXMuXG4gKlxuICogQG5hbWUgY29tYmluZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjwoUG9pbnR8TGluZVN0cmluZ3xQb2x5Z29uKT59IGZjIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgYW55IHR5cGVcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPChNdWx0aVBvaW50fE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24pPn0gYSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBjb3JyZXNwb25kaW5nIHR5cGUgdG8gaW5wdXRcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxOS4wMjY0MzIsIDQ3LjQ5MTM0XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxOS4wNzQ0OTcsIDQ3LjUwOTU0OF1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIGNvbWJpbmVkID0gdHVyZi5jb21iaW5lKGZjKTtcbiAqXG4gKiAvLz1jb21iaW5lZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZjKSB7XG4gICAgdmFyIGdyb3VwcyA9IHtcbiAgICAgICAgTXVsdGlQb2ludDoge2Nvb3JkaW5hdGVzOiBbXSwgcHJvcGVydGllczogW119LFxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IHtjb29yZGluYXRlczogW10sIHByb3BlcnRpZXM6IFtdfSxcbiAgICAgICAgTXVsdGlQb2x5Z29uOiB7Y29vcmRpbmF0ZXM6IFtdLCBwcm9wZXJ0aWVzOiBbXX1cbiAgICB9O1xuXG4gICAgdmFyIG11bHRpTWFwcGluZyA9IE9iamVjdC5rZXlzKGdyb3VwcykucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBpdGVtKSB7XG4gICAgICAgIG1lbW9baXRlbS5yZXBsYWNlKCdNdWx0aScsICcnKV0gPSBpdGVtO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSk7XG5cbiAgICBmdW5jdGlvbiBhZGRUb0dyb3VwKGZlYXR1cmUsIGtleSwgbXVsdGkpIHtcbiAgICAgICAgaWYgKCFtdWx0aSkge1xuICAgICAgICAgICAgZ3JvdXBzW2tleV0uY29vcmRpbmF0ZXMucHVzaChmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3Vwc1trZXldLmNvb3JkaW5hdGVzID0gZ3JvdXBzW2tleV0uY29vcmRpbmF0ZXMuY29uY2F0KGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3Vwc1trZXldLnByb3BlcnRpZXMucHVzaChmZWF0dXJlLnByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIG1ldGEuZmVhdHVyZUVhY2goZmMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSkgcmV0dXJuO1xuICAgICAgICBpZiAoZ3JvdXBzW2ZlYXR1cmUuZ2VvbWV0cnkudHlwZV0pIHtcbiAgICAgICAgICAgIGFkZFRvR3JvdXAoZmVhdHVyZSwgZmVhdHVyZS5nZW9tZXRyeS50eXBlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aU1hcHBpbmdbZmVhdHVyZS5nZW9tZXRyeS50eXBlXSkge1xuICAgICAgICAgICAgYWRkVG9Hcm91cChmZWF0dXJlLCBtdWx0aU1hcHBpbmdbZmVhdHVyZS5nZW9tZXRyeS50eXBlXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBmZWF0dXJlczogT2JqZWN0LmtleXMoZ3JvdXBzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3Vwc1trZXldLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFByb3BlcnRpZXM6IGdyb3Vwc1trZXldLnByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBncm91cHNba2V5XS5jb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgfTtcbn07XG4iLCJ2YXIgc2ltcGxlcG9seWdvbiA9IHJlcXVpcmUoJ3NpbXBsZXBvbHlnb24nKTtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnQHR1cmYvZmxhdHRlbicpO1xudmFyIGZlYXR1cmVFYWNoID0gcmVxdWlyZSgnQHR1cmYvbWV0YScpLmZlYXR1cmVFYWNoO1xudmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRha2VzIGEga2lua2VkIHBvbHlnb24gYW5kIHJldHVybnMgYSBmZWF0dXJlIGNvbGxlY3Rpb24gb2YgcG9seWdvbnMgdGhhdCBoYXZlIG5vIGtpbmtzLlxuICogVXNlcyBbc2ltcGxlcG9seWdvbl0oaHR0cHM6Ly9naXRodWIuY29tL21jbGFleXNiL3NpbXBsZXBvbHlnb24pIGludGVybmFsbHkuXG4gKlxuICogQG5hbWUgdW5raW5rUG9seWdvblxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPFBvbHlnb258TXVsdGlQb2x5Z29uPn0gZ2VvanNvbiBHZW9KU09OIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IFVua2lua2VkIHBvbHlnb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkgPSB7XG4gKiAgICAndHlwZSc6ICdGZWF0dXJlJyxcbiAqICAgICAgJ2dlb21ldHJ5Jzoge1xuICogICAgICAgICAndHlwZSc6ICdQb2x5Z29uJyxcbiAqICAgICAgICAnY29vcmRpbmF0ZXMnOiBbW1swLCAwXSwgWzIsIDBdLCBbMCwgMl0sIFsyLCAyXSwgWzAsIDBdXV1cbiAqICAgICAgIH1cbiAqIH07XG4gKlxuICogdmFyIHJlc3VsdCA9IHR1cmYudW5raW5rUG9seWdvbihwb2x5KTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZ2VvanNvbikge1xuICAgIHZhciByZXN1bHRzID0gZmVhdHVyZUNvbGxlY3Rpb24oW10pO1xuXG4gICAgLy8gSGFuZGxlcyBGZWF0dXJlQ29sbGVjdGlvbiAmIEZlYXR1cmVcbiAgICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuXG4gICAgICAgIC8vIEhhbmRsZSBNdWx0aVBvbHlnb25zIGFzIEZlYXR1cmUgb3IgRmVhdHVyZUNvbGxlY3Rpb25cbiAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHsgZmVhdHVyZSA9IGZsYXR0ZW4oZmVhdHVyZSk7IH1cblxuICAgICAgICAvLyBTdG9yZSBzaW1wbGUgcG9seWdvbnMgaW4gcmVzdWx0c1xuICAgICAgICBmZWF0dXJlRWFjaChmZWF0dXJlLCBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICAgICAgdmFyIHNpbXBsZSA9IHNpbXBsZXBvbHlnb24ocG9seWdvbik7XG5cbiAgICAgICAgICAgIGZlYXR1cmVFYWNoKHNpbXBsZSwgZnVuY3Rpb24gKHBvbHkpIHtcbiAgICAgICAgICAgICAgICBwb2x5LnByb3BlcnRpZXMgPSAocG9seWdvbi5wcm9wZXJ0aWVzKSA/IHBvbHlnb24ucHJvcGVydGllcyA6IHt9O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuZmVhdHVyZXMucHVzaChwb2x5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG4iLCJ2YXIgaW5zaWRlID0gcmVxdWlyZSgnQHR1cmYvaW5zaWRlJyk7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2Yge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIGEgc2V0IG9mIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBhbmQgcmV0dXJucyB0aGUgcG9pbnRzIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHBvbHlnb25zLlxuICpcbiAqIEBuYW1lIHdpdGhpblxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25zIGlucHV0IHBvbHlnb25zXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgdGhhdCBsYW5kIHdpdGhpbiBhdCBsZWFzdCBvbmUgcG9seWdvblxuICogQGV4YW1wbGVcbiAqIHZhciBzZWFyY2hXaXRoaW4gPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgICAgICBbLTQ2LjY1MywtMjMuNTQzXSxcbiAqICAgICAgICAgICBbLTQ2LjYzNCwtMjMuNTM0Nl0sXG4gKiAgICAgICAgICAgWy00Ni42MTMsLTIzLjU0M10sXG4gKiAgICAgICAgICAgWy00Ni42MTQsLTIzLjU1OV0sXG4gKiAgICAgICAgICAgWy00Ni42MzEsLTIzLjU2N10sXG4gKiAgICAgICAgICAgWy00Ni42NTMsLTIzLjU2MF0sXG4gKiAgICAgICAgICAgWy00Ni42NTMsLTIzLjU0M11cbiAqICAgICAgICAgXV1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB2YXIgcG9pbnRzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjYzMTgsIC0yMy41NTIzXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNDYuNjI0NiwgLTIzLjUzMjVdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy00Ni42MDYyLCAtMjMuNTUxM11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjY2MywgLTIzLjU1NF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjY0MywgLTIzLjU1N11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIHB0c1dpdGhpbiA9IHR1cmYud2l0aGluKHBvaW50cywgc2VhcmNoV2l0aGluKTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiAvLz1zZWFyY2hXaXRoaW5cbiAqXG4gKiAvLz1wdHNXaXRoaW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBwb2x5Z29ucykge1xuICAgIHZhciBwb2ludHNXaXRoaW4gPSBmZWF0dXJlQ29sbGVjdGlvbihbXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29ucy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5mZWF0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlzSW5zaWRlID0gaW5zaWRlKHBvaW50cy5mZWF0dXJlc1tqXSwgcG9seWdvbnMuZmVhdHVyZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGlzSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzV2l0aGluLmZlYXR1cmVzLnB1c2gocG9pbnRzLmZlYXR1cmVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzV2l0aGluO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmZmluZUh1bGxcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpXG5cbmZ1bmN0aW9uIGxpbmVhcmx5SW5kZXBlbmRlbnQocG9pbnRzLCBkKSB7XG4gIHZhciBuaHVsbCA9IG5ldyBBcnJheShkKzEpXG4gIGZvcih2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIG5odWxsW2ldID0gcG9pbnRzW2ldXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8PXBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIGZvcih2YXIgaj1wb2ludHMubGVuZ3RoOyBqPD1kOyArK2opIHtcbiAgICAgIHZhciB4ID0gbmV3IEFycmF5KGQpXG4gICAgICBmb3IodmFyIGs9MDsgazxkOyArK2spIHtcbiAgICAgICAgeFtrXSA9IE1hdGgucG93KGorMS1pLCBrKVxuICAgICAgfVxuICAgICAgbmh1bGxbal0gPSB4XG4gICAgfVxuICAgIHZhciBvID0gb3JpZW50LmFwcGx5KHZvaWQgMCwgbmh1bGwpXG4gICAgaWYobykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFmZmluZUh1bGwocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgaWYobiA9PT0gMSkge1xuICAgIHJldHVybiBbMF1cbiAgfVxuICB2YXIgZCA9IHBvaW50c1swXS5sZW5ndGhcbiAgdmFyIGZyYW1lID0gWyBwb2ludHNbMF0gXVxuICB2YXIgaW5kZXggPSBbIDAgXVxuICBmb3IodmFyIGk9MTsgaTxuOyArK2kpIHtcbiAgICBmcmFtZS5wdXNoKHBvaW50c1tpXSlcbiAgICBpZighbGluZWFybHlJbmRlcGVuZGVudChmcmFtZSwgZCkpIHtcbiAgICAgIGZyYW1lLnBvcCgpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpbmRleC5wdXNoKGkpXG4gICAgaWYoaW5kZXgubGVuZ3RoID09PSBkKzEpIHtcbiAgICAgIHJldHVybiBpbmRleFxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn0iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIiIsIid1c2Ugc3RyaWN0JzsgLyogQGZsb3cgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVhcFJ1bGVyO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB2ZXJ5IGZhc3QgYXBwcm94aW1hdGlvbnMgdG8gY29tbW9uIGdlb2Rlc2ljIG1lYXN1cmVtZW50cy4gVXNlZnVsIGZvciBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgY29kZSB0aGF0IG1lYXN1cmVzIHRoaW5ncyBvbiBhIGNpdHkgc2NhbGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxhdCBsYXRpdHVkZVxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz0na2lsb21ldGVycyddXG4gKiBAcmV0dXJucyB7Q2hlYXBSdWxlcn1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcnVsZXIgPSBjaGVhcFJ1bGVyKDM1LjA1LCAnbWlsZXMnKTtcbiAqIC8vPXJ1bGVyXG4gKi9cbmZ1bmN0aW9uIGNoZWFwUnVsZXIobGF0IC8qOiBudW1iZXIgKi8sIHVuaXRzIC8qOiA/c3RyaW5nICovKSB7XG4gICAgcmV0dXJuIG5ldyBDaGVhcFJ1bGVyKGxhdCwgdW5pdHMpO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXJzIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gdW5pdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGNvbnZlcnQgNTAgbWV0ZXJzIHRvIHlhcmRzXG4gKiA1MCAqIGNoZWFwUnVsZXIudW5pdHMueWFyZHMgLyBjaGVhcFJ1bGVyLnVuaXRzLm1ldGVycztcbiAqL1xudmFyIGZhY3RvcnMgPSBjaGVhcFJ1bGVyLnVuaXRzID0ge1xuICAgIGtpbG9tZXRlcnM6IDEsXG4gICAgbWlsZXM6IDEwMDAgLyAxNjA5LjM0NCxcbiAgICBuYXV0aWNhbG1pbGVzOiAxMDAwIC8gMTg1MixcbiAgICBtZXRlcnM6IDEwMDAsXG4gICAgbWV0cmVzOiAxMDAwLFxuICAgIHlhcmRzOiAxMDAwIC8gMC45MTQ0LFxuICAgIGZlZXQ6IDEwMDAgLyAwLjMwNDgsXG4gICAgaW5jaGVzOiAxMDAwIC8gMC4wMjU0XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBydWxlciBvYmplY3QgZnJvbSB0aWxlIGNvb3JkaW5hdGVzICh5IGFuZCB6KS4gQ29udmVuaWVudCBpbiB0aWxlLXJlZHVjZSBzY3JpcHRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gelxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz0na2lsb21ldGVycyddXG4gKiBAcmV0dXJucyB7Q2hlYXBSdWxlcn1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcnVsZXIgPSBjaGVhcFJ1bGVyLmZyb21UaWxlKDE1NjcsIDEyKTtcbiAqIC8vPXJ1bGVyXG4gKi9cbmNoZWFwUnVsZXIuZnJvbVRpbGUgPSBmdW5jdGlvbiAoeSwgeiwgdW5pdHMpIHtcbiAgICB2YXIgbiA9IE1hdGguUEkgKiAoMSAtIDIgKiAoeSArIDAuNSkgLyBNYXRoLnBvdygyLCB6KSk7XG4gICAgdmFyIGxhdCA9IE1hdGguYXRhbigwLjUgKiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgcmV0dXJuIG5ldyBDaGVhcFJ1bGVyKGxhdCwgdW5pdHMpO1xufTtcblxuZnVuY3Rpb24gQ2hlYXBSdWxlcihsYXQsIHVuaXRzKSB7XG4gICAgaWYgKGxhdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGxhdGl0dWRlIGdpdmVuLicpO1xuICAgIGlmICh1bml0cyAmJiAhZmFjdG9yc1t1bml0c10pIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyArICcuIFVzZSBvbmUgb2Y6ICcgKyBPYmplY3Qua2V5cyhmYWN0b3JzKSk7XG5cbiAgICB2YXIgbSA9IHVuaXRzID8gZmFjdG9yc1t1bml0c10gOiAxO1xuXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKGxhdCAqIE1hdGguUEkgLyAxODApO1xuICAgIHZhciBjb3MyID0gMiAqIGNvcyAqIGNvcyAtIDE7XG4gICAgdmFyIGNvczMgPSAyICogY29zICogY29zMiAtIGNvcztcbiAgICB2YXIgY29zNCA9IDIgKiBjb3MgKiBjb3MzIC0gY29zMjtcbiAgICB2YXIgY29zNSA9IDIgKiBjb3MgKiBjb3M0IC0gY29zMztcblxuICAgIC8vIG11bHRpcGxpZXJzIGZvciBjb252ZXJ0aW5nIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgZGVncmVlcyBpbnRvIGRpc3RhbmNlIChodHRwOi8vMS51c2EuZ292LzFXYjFidjcpXG4gICAgdGhpcy5reCA9IG0gKiAoMTExLjQxNTEzICogY29zIC0gMC4wOTQ1NSAqIGNvczMgKyAwLjAwMDEyICogY29zNSk7XG4gICAgdGhpcy5reSA9IG0gKiAoMTExLjEzMjA5IC0gMC41NjYwNSAqIGNvczIgKyAwLjAwMTIgKiBjb3M0KTtcbn1cblxuQ2hlYXBSdWxlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdHdvIHBvaW50cyBvZiB0aGUgZm9ybSBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0sIHJldHVybnMgdGhlIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYiBwb2ludCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGRpc3RhbmNlID0gcnVsZXIuZGlzdGFuY2UoWzMwLjUsIDUwLjVdLCBbMzAuNTEsIDUwLjQ5XSk7XG4gICAgICogLy89ZGlzdGFuY2VcbiAgICAgKi9cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGR4ID0gKGFbMF0gLSBiWzBdKSAqIHRoaXMua3g7XG4gICAgICAgIHZhciBkeSA9IChhWzFdIC0gYlsxXSkgKiB0aGlzLmt5O1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVhcmluZyBiZXR3ZWVuIHR3byBwb2ludHMgaW4gYW5nbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYiBwb2ludCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBiZWFyaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYmVhcmluZyA9IHJ1bGVyLmJlYXJpbmcoWzMwLjUsIDUwLjVdLCBbMzAuNTEsIDUwLjQ5XSk7XG4gICAgICogLy89YmVhcmluZ1xuICAgICAqL1xuICAgIGJlYXJpbmc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBkeCA9IChiWzBdIC0gYVswXSkgKiB0aGlzLmt4O1xuICAgICAgICB2YXIgZHkgPSAoYlsxXSAtIGFbMV0pICogdGhpcy5reTtcbiAgICAgICAgaWYgKCFkeCAmJiAhZHkpIHJldHVybiAwO1xuICAgICAgICB2YXIgYmVhcmluZyA9IE1hdGguYXRhbjIoLWR5LCBkeCkgKiAxODAgLyBNYXRoLlBJICsgOTA7XG4gICAgICAgIGlmIChiZWFyaW5nID4gMTgwKSBiZWFyaW5nIC09IDM2MDtcbiAgICAgICAgcmV0dXJuIGJlYXJpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgZ2l2ZW4gZGlzdGFuY2UgYW5kIGJlYXJpbmcgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHAgcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3QgZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZ1xuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBwb2ludCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2ludCA9IHJ1bGVyLmRlc3RpbmF0aW9uKFszMC41LCA1MC41XSwgMC4xLCA5MCk7XG4gICAgICogLy89cG9pbnRcbiAgICAgKi9cbiAgICBkZXN0aW5hdGlvbjogZnVuY3Rpb24gKHAsIGRpc3QsIGJlYXJpbmcpIHtcbiAgICAgICAgdmFyIGEgPSAoOTAgLSBiZWFyaW5nKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldChwLFxuICAgICAgICAgICAgTWF0aC5jb3MoYSkgKiBkaXN0LFxuICAgICAgICAgICAgTWF0aC5zaW4oYSkgKiBkaXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCBnaXZlbiBlYXN0aW5nIGFuZCBub3J0aGluZyBvZmZzZXRzIChpbiBydWxlciB1bml0cykgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHAgcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4IGVhc3RpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHkgbm9ydGhpbmdcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9pbnQgPSBydWxlci5vZmZzZXQoWzMwLjUsIDUwLjVdLCAxMCwgMTApO1xuICAgICAqIC8vPXBvaW50XG4gICAgICovXG4gICAgb2Zmc2V0OiBmdW5jdGlvbiAocCwgZHgsIGR5KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwWzBdICsgZHggLyB0aGlzLmt4LFxuICAgICAgICAgICAgcFsxXSArIGR5IC8gdGhpcy5reVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpbmUgKGFuIGFycmF5IG9mIHBvaW50cyksIHJldHVybnMgdGhlIHRvdGFsIGxpbmUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwb2ludHMgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAgICogQHJldHVybnMge251bWJlcn0gdG90YWwgbGluZSBkaXN0YW5jZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxlbmd0aCA9IHJ1bGVyLmxpbmVEaXN0YW5jZShbXG4gICAgICogICAgIFstNjcuMDMxLCA1MC40NThdLCBbLTY3LjAzMSwgNTAuNTM0XSxcbiAgICAgKiAgICAgWy02Ni45MjksIDUwLjUzNF0sIFstNjYuOTI5LCA1MC40NThdXG4gICAgICogXSk7XG4gICAgICogLy89bGVuZ3RoXG4gICAgICovXG4gICAgbGluZURpc3RhbmNlOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdG90YWwgKz0gdGhpcy5kaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2x5Z29uIChhbiBhcnJheSBvZiByaW5ncywgd2hlcmUgZWFjaCByaW5nIGlzIGFuIGFycmF5IG9mIHBvaW50cyksIHJldHVybnMgdGhlIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gcG9seWdvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGFyZWEgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCB1bml0cyAoc3F1YXJlIGtpbG9tZXRlcnMgYnkgZGVmYXVsdClcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhcmVhID0gcnVsZXIuYXJlYShbW1xuICAgICAqICAgICBbLTY3LjAzMSwgNTAuNDU4XSwgWy02Ny4wMzEsIDUwLjUzNF0sIFstNjYuOTI5LCA1MC41MzRdLFxuICAgICAqICAgICBbLTY2LjkyOSwgNTAuNDU4XSwgWy02Ny4wMzEsIDUwLjQ1OF1cbiAgICAgKiBdXSk7XG4gICAgICogLy89YXJlYVxuICAgICAqL1xuICAgIGFyZWE6IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2ldO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gcmluZy5sZW5ndGgsIGsgPSBsZW4gLSAxOyBqIDwgbGVuOyBrID0gaisrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IChyaW5nW2pdWzBdIC0gcmluZ1trXVswXSkgKiAocmluZ1tqXVsxXSArIHJpbmdba11bMV0pICogKGkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyhzdW0pIC8gMikgKiB0aGlzLmt4ICogdGhpcy5reTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgYXQgYSBzcGVjaWZpZWQgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBsaW5lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3QgZGlzdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9pbnQgPSBydWxlci5hbG9uZyhsaW5lLCAyLjUpO1xuICAgICAqIC8vPXBvaW50XG4gICAgICovXG4gICAgYWxvbmc6IGZ1bmN0aW9uIChsaW5lLCBkaXN0KSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgIGlmIChkaXN0IDw9IDApIHJldHVybiBsaW5lWzBdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwMCA9IGxpbmVbaV07XG4gICAgICAgICAgICB2YXIgcDEgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZShwMCwgcDEpO1xuICAgICAgICAgICAgc3VtICs9IGQ7XG4gICAgICAgICAgICBpZiAoc3VtID4gZGlzdCkgcmV0dXJuIGludGVycG9sYXRlKHAwLCBwMSwgKGRpc3QgLSAoc3VtIC0gZCkpIC8gZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZVtsaW5lLmxlbmd0aCAtIDFdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0aGUgZm9ybSB7cG9pbnQsIGluZGV4fSB3aGVyZSBwb2ludCBpcyBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIGZyb20gdGhlIGdpdmVuIHBvaW50LCBhbmQgaW5kZXggaXMgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50IHdpdGggdGhlIGNsb3Nlc3QgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcG9pbnRPbkxpbmVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBsaW5lXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHtwb2ludCwgaW5kZXh9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9pbnQgPSBydWxlci5wb2ludE9uTGluZShsaW5lLCBbLTY3LjA0LCA1MC41XSkucG9pbnQ7XG4gICAgICogLy89cG9pbnRcbiAgICAgKi9cbiAgICBwb2ludE9uTGluZTogZnVuY3Rpb24gKGxpbmUsIHApIHtcbiAgICAgICAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pblgsIG1pblksIG1pbkksIG1pblQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgeCA9IGxpbmVbaV1bMF07XG4gICAgICAgICAgICB2YXIgeSA9IGxpbmVbaV1bMV07XG4gICAgICAgICAgICB2YXIgZHggPSAobGluZVtpICsgMV1bMF0gLSB4KSAqIHRoaXMua3g7XG4gICAgICAgICAgICB2YXIgZHkgPSAobGluZVtpICsgMV1bMV0gLSB5KSAqIHRoaXMua3k7XG5cbiAgICAgICAgICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHQgPSAoKHBbMF0gLSB4KSAqIHRoaXMua3ggKiBkeCArIChwWzFdIC0geSkgKiB0aGlzLmt5ICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICAgICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbGluZVtpICsgMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHkgPSBsaW5lW2kgKyAxXVsxXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSAoZHggLyB0aGlzLmt4KSAqIHQ7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gKGR5IC8gdGhpcy5reSkgKiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHggPSAocFswXSAtIHgpICogdGhpcy5reDtcbiAgICAgICAgICAgIGR5ID0gKHBbMV0gLSB5KSAqIHRoaXMua3k7XG5cbiAgICAgICAgICAgIHZhciBzcURpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgIGlmIChzcURpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICAgICAgICBtaW5JID0gaTtcbiAgICAgICAgICAgICAgICBtaW5UID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogW21pblgsIG1pblldLFxuICAgICAgICAgICAgaW5kZXg6IG1pbkksXG4gICAgICAgICAgICB0OiBtaW5UXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXJ0IG9mIHRoZSBnaXZlbiBsaW5lIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCB0aGUgc3RvcCBwb2ludHMgKG9yIHRoZWlyIGNsb3Nlc3QgcG9pbnRzIG9uIHRoZSBsaW5lKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc3RhcnQgcG9pbnQgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzdG9wIHBvaW50IFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGxpbmUgcGFydCBvZiBhIGxpbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsaW5lMiA9IHJ1bGVyLmxpbmVTbGljZShbLTY3LjA0LCA1MC41XSwgWy02Ny4wNSwgNTAuNTZdLCBsaW5lMSk7XG4gICAgICogLy89bGluZTJcbiAgICAgKi9cbiAgICBsaW5lU2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCwgbGluZSkge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnBvaW50T25MaW5lKGxpbmUsIHN0YXJ0KTtcbiAgICAgICAgdmFyIHAyID0gdGhpcy5wb2ludE9uTGluZShsaW5lLCBzdG9wKTtcblxuICAgICAgICBpZiAocDEuaW5kZXggPiBwMi5pbmRleCB8fCAocDEuaW5kZXggPT09IHAyLmluZGV4ICYmIHAxLnQgPiBwMi50KSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHAxO1xuICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgIHAyID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsaWNlID0gW3AxLnBvaW50XTtcblxuICAgICAgICB2YXIgbCA9IHAxLmluZGV4ICsgMTtcbiAgICAgICAgdmFyIHIgPSBwMi5pbmRleDtcblxuICAgICAgICBpZiAoIWVxdWFscyhsaW5lW2xdLCBzbGljZVswXSkgJiYgbCA8PSByKVxuICAgICAgICAgICAgc2xpY2UucHVzaChsaW5lW2xdKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gbCArIDE7IGkgPD0gcjsgaSsrKSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGxpbmVbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcXVhbHMobGluZVtyXSwgcDIucG9pbnQpKVxuICAgICAgICAgICAgc2xpY2UucHVzaChwMi5wb2ludCk7XG5cbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFydCBvZiB0aGUgZ2l2ZW4gbGluZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgdGhlIHN0b3AgcG9pbnRzIGluZGljYXRlZCBieSBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBkaXN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdG9wIGRpc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbGluZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbGluZSBwYXJ0IG9mIGEgbGluZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxpbmUyID0gcnVsZXIubGluZVNsaWNlQWxvbmcoMTAsIDIwLCBsaW5lMSk7XG4gICAgICogLy89bGluZTJcbiAgICAgKi9cbiAgICBsaW5lU2xpY2VBbG9uZzogZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBsaW5lKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgc2xpY2UgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcDAgPSBsaW5lW2ldO1xuICAgICAgICAgICAgdmFyIHAxID0gbGluZVtpICsgMV07XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2UocDAsIHAxKTtcblxuICAgICAgICAgICAgc3VtICs9IGQ7XG5cbiAgICAgICAgICAgIGlmIChzdW0gPiBzdGFydCAmJiBzbGljZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVycG9sYXRlKHAwLCBwMSwgKHN0YXJ0IC0gKHN1bSAtIGQpKSAvIGQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN1bSA+PSBzdG9wKSB7XG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnBvbGF0ZShwMCwgcDEsIChzdG9wIC0gKHN1bSAtIGQpKSAvIGQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdW0gPiBzdGFydCkgc2xpY2UucHVzaChwMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcG9pbnQsIHJldHVybnMgYSBib3VuZGluZyBib3ggb2JqZWN0IChbdywgcywgZSwgbl0pIGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcG9pbnQgYnVmZmVyZWQgYnkgYSBnaXZlbiBkaXN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcCBwb2ludCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGJveCBvYmplY3QgKFt3LCBzLCBlLCBuXSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBiYm94ID0gcnVsZXIuYnVmZmVyUG9pbnQoWzMwLjUsIDUwLjVdLCAwLjAxKTtcbiAgICAgKiAvLz1iYm94XG4gICAgICovXG4gICAgYnVmZmVyUG9pbnQ6IGZ1bmN0aW9uIChwLCBidWZmZXIpIHtcbiAgICAgICAgdmFyIHYgPSBidWZmZXIgLyB0aGlzLmt5O1xuICAgICAgICB2YXIgaCA9IGJ1ZmZlciAvIHRoaXMua3g7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwWzBdIC0gaCxcbiAgICAgICAgICAgIHBbMV0gLSB2LFxuICAgICAgICAgICAgcFswXSArIGgsXG4gICAgICAgICAgICBwWzFdICsgdlxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGJvdW5kaW5nIGJveCwgcmV0dXJucyB0aGUgYm94IGJ1ZmZlcmVkIGJ5IGEgZ2l2ZW4gZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJveCBvYmplY3QgKFt3LCBzLCBlLCBuXSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGJveCBvYmplY3QgKFt3LCBzLCBlLCBuXSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBiYm94ID0gcnVsZXIuYnVmZmVyQkJveChbMzAuNSwgNTAuNSwgMzEsIDUxXSwgMC4yKTtcbiAgICAgKiAvLz1iYm94XG4gICAgICovXG4gICAgYnVmZmVyQkJveDogZnVuY3Rpb24gKGJib3gsIGJ1ZmZlcikge1xuICAgICAgICB2YXIgdiA9IGJ1ZmZlciAvIHRoaXMua3k7XG4gICAgICAgIHZhciBoID0gYnVmZmVyIC8gdGhpcy5reDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGJib3hbMF0gLSBoLFxuICAgICAgICAgICAgYmJveFsxXSAtIHYsXG4gICAgICAgICAgICBiYm94WzJdICsgaCxcbiAgICAgICAgICAgIGJib3hbM10gKyB2XG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIGluIHRoZSBnaXZlbiBib3VuZGluZyBib3gsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcCBwb2ludCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJveCBvYmplY3QgKFt3LCBzLCBlLCBuXSlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBpbnNpZGUgPSBydWxlci5pbnNpZGVCQm94KFszMC41LCA1MC41XSwgWzMwLCA1MCwgMzEsIDUxXSk7XG4gICAgICogLy89aW5zaWRlXG4gICAgICovXG4gICAgaW5zaWRlQkJveDogZnVuY3Rpb24gKHAsIGJib3gpIHtcbiAgICAgICAgcmV0dXJuIHBbMF0gPj0gYmJveFswXSAmJlxuICAgICAgICAgICAgICAgcFswXSA8PSBiYm94WzJdICYmXG4gICAgICAgICAgICAgICBwWzFdID49IGJib3hbMV0gJiZcbiAgICAgICAgICAgICAgIHBbMV0gPD0gYmJveFszXTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIsIHQpIHtcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gW1xuICAgICAgICBhWzBdICsgZHggKiB0LFxuICAgICAgICBhWzFdICsgZHkgKiB0XG4gICAgXTtcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb252ZXhIdWxsMWQgPSByZXF1aXJlKCcuL2xpYi9jaDFkJylcbnZhciBjb252ZXhIdWxsMmQgPSByZXF1aXJlKCcuL2xpYi9jaDJkJylcbnZhciBjb252ZXhIdWxsbmQgPSByZXF1aXJlKCcuL2xpYi9jaG5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXhIdWxsXG5cbmZ1bmN0aW9uIGNvbnZleEh1bGwocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0gZWxzZSBpZihuID09PSAxKSB7XG4gICAgcmV0dXJuIFtbMF1dXG4gIH1cbiAgdmFyIGQgPSBwb2ludHNbMF0ubGVuZ3RoXG4gIGlmKGQgPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfSBlbHNlIGlmKGQgPT09IDEpIHtcbiAgICByZXR1cm4gY29udmV4SHVsbDFkKHBvaW50cylcbiAgfSBlbHNlIGlmKGQgPT09IDIpIHtcbiAgICByZXR1cm4gY29udmV4SHVsbDJkKHBvaW50cylcbiAgfVxuICByZXR1cm4gY29udmV4SHVsbG5kKHBvaW50cywgZClcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZleEh1bGwxZFxuXG5mdW5jdGlvbiBjb252ZXhIdWxsMWQocG9pbnRzKSB7XG4gIHZhciBsbyA9IDBcbiAgdmFyIGhpID0gMFxuICBmb3IodmFyIGk9MTsgaTxwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihwb2ludHNbaV1bMF0gPCBwb2ludHNbbG9dWzBdKSB7XG4gICAgICBsbyA9IGlcbiAgICB9XG4gICAgaWYocG9pbnRzW2ldWzBdID4gcG9pbnRzW2hpXVswXSkge1xuICAgICAgaGkgPSBpXG4gICAgfVxuICB9XG4gIGlmKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gW1tsb10sIFtoaV1dXG4gIH0gZWxzZSBpZihsbyA+IGhpKSB7XG4gICAgcmV0dXJuIFtbaGldLCBbbG9dXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbW2xvXV1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZleEh1bGwyRFxuXG52YXIgbW9ub3RvbmVIdWxsID0gcmVxdWlyZSgnbW9ub3RvbmUtY29udmV4LWh1bGwtMmQnKVxuXG5mdW5jdGlvbiBjb252ZXhIdWxsMkQocG9pbnRzKSB7XG4gIHZhciBodWxsID0gbW9ub3RvbmVIdWxsKHBvaW50cylcbiAgdmFyIGggPSBodWxsLmxlbmd0aFxuICBpZihoIDw9IDIpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgZWRnZXMgPSBuZXcgQXJyYXkoaClcbiAgdmFyIGEgPSBodWxsW2gtMV1cbiAgZm9yKHZhciBpPTA7IGk8aDsgKytpKSB7XG4gICAgdmFyIGIgPSBodWxsW2ldXG4gICAgZWRnZXNbaV0gPSBbYSxiXVxuICAgIGEgPSBiXG4gIH1cbiAgcmV0dXJuIGVkZ2VzXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXhIdWxsbkRcblxudmFyIGljaCA9IHJlcXVpcmUoJ2luY3JlbWVudGFsLWNvbnZleC1odWxsJylcbnZhciBhZmYgPSByZXF1aXJlKCdhZmZpbmUtaHVsbCcpXG5cbmZ1bmN0aW9uIHBlcm11dGUocG9pbnRzLCBmcm9udCkge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIG5wb2ludHMgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8ZnJvbnQubGVuZ3RoOyArK2kpIHtcbiAgICBucG9pbnRzW2ldID0gcG9pbnRzW2Zyb250W2ldXVxuICB9XG4gIHZhciBwdHIgPSBmcm9udC5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYoZnJvbnQuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgIG5wb2ludHNbcHRyKytdID0gcG9pbnRzW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBucG9pbnRzXG59XG5cbmZ1bmN0aW9uIGludlBlcm11dGUoY2VsbHMsIGZyb250KSB7XG4gIHZhciBuYyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgbmYgPSBmcm9udC5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgeCA9IGNbal1cbiAgICAgIGlmKHggPCBuZikge1xuICAgICAgICBjW2pdID0gZnJvbnRbeF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4IC0gbmZcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8bmY7ICsraykge1xuICAgICAgICAgIGlmKHggPj0gZnJvbnRba10pIHtcbiAgICAgICAgICAgIHggKz0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjW2pdID0geFxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2VsbHNcbn1cblxuZnVuY3Rpb24gY29udmV4SHVsbG5EKHBvaW50cywgZCkge1xuICB0cnkge1xuICAgIHJldHVybiBpY2gocG9pbnRzLCB0cnVlKVxuICB9IGNhdGNoKGUpIHtcbiAgICAvL0lmIHBvaW50IHNldCBpcyBkZWdlbmVyYXRlLCB0cnkgdG8gZmluZCBhIGJhc2lzIGFuZCByZXJ1biBpdFxuICAgIHZhciBhaCA9IGFmZihwb2ludHMpXG4gICAgaWYoYWgubGVuZ3RoIDw9IGQpIHtcbiAgICAgIC8vTm8gYmFzaXMsIG5vIHRyeVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIHZhciBucG9pbnRzID0gcGVybXV0ZShwb2ludHMsIGFoKVxuICAgIHZhciBuaHVsbCAgID0gaWNoKG5wb2ludHMsIHRydWUpXG4gICAgcmV0dXJuIGludlBlcm11dGUobmh1bGwsIGFoKVxuICB9XG59IiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQgJiYgJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlKSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBzaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKHNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB2YXIgcCA9IGVhci5uZXh0WjtcblxuICAgIHdoaWxlIChwICYmIHAueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICBwID0gZWFyLnByZXZaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgIH1cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGh4ID09PSBxeCkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFTaXplID09PSAwIHx8ICFxKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHAueiA8PSBxLnopIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIHNpemUgb2YgdGhlIGRhdGEgYm91bmRpbmcgYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpIC8gc2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LngpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIGlmICgoZXF1YWxzKHAxLCBxMSkgJiYgZXF1YWxzKHAyLCBxMikpIHx8XG4gICAgICAgIChlcXVhbHMocDEsIHEyKSAmJiBlcXVhbHMocDIsIHExKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gRXh0ZW50O1xuXG5mdW5jdGlvbiBFeHRlbnQoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbnQoKTtcbiAgICB9XG4gICAgdGhpcy5fYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICB0aGlzLl92YWxpZCA9IGZhbHNlO1xufVxuXG5FeHRlbnQucHJvdG90eXBlLmluY2x1ZGUgPSBmdW5jdGlvbihsbCkge1xuICAgIHRoaXMuX3ZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9iYm94WzBdID0gTWF0aC5taW4odGhpcy5fYmJveFswXSwgbGxbMF0pO1xuICAgIHRoaXMuX2Jib3hbMV0gPSBNYXRoLm1pbih0aGlzLl9iYm94WzFdLCBsbFsxXSk7XG4gICAgdGhpcy5fYmJveFsyXSA9IE1hdGgubWF4KHRoaXMuX2Jib3hbMl0sIGxsWzBdKTtcbiAgICB0aGlzLl9iYm94WzNdID0gTWF0aC5tYXgodGhpcy5fYmJveFszXSwgbGxbMV0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRXh0ZW50LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdGhpcy5fdmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX2Jib3hbMF0gPSBNYXRoLm1pbih0aGlzLl9iYm94WzBdLCBvdGhlclswXSk7XG4gICAgdGhpcy5fYmJveFsxXSA9IE1hdGgubWluKHRoaXMuX2Jib3hbMV0sIG90aGVyWzFdKTtcbiAgICB0aGlzLl9iYm94WzJdID0gTWF0aC5tYXgodGhpcy5fYmJveFsyXSwgb3RoZXJbMl0pO1xuICAgIHRoaXMuX2Jib3hbM10gPSBNYXRoLm1heCh0aGlzLl9iYm94WzNdLCBvdGhlclszXSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5FeHRlbnQucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3ZhbGlkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fYmJveDtcbn07XG5cbkV4dGVudC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihsbCkge1xuICAgIGlmICghdGhpcy5fdmFsaWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9iYm94WzBdIDw9IGxsWzBdICYmXG4gICAgICAgIHRoaXMuX2Jib3hbMV0gPD0gbGxbMV0gJiZcbiAgICAgICAgdGhpcy5fYmJveFsyXSA+PSBsbFswXSAmJlxuICAgICAgICB0aGlzLl9iYm94WzNdID49IGxsWzFdO1xufTtcblxuRXh0ZW50LnByb3RvdHlwZS5wb2x5Z29uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl92YWxpZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIFcsIFNcbiAgICAgICAgICAgICAgICBbdGhpcy5fYmJveFswXSwgdGhpcy5fYmJveFsxXV0sXG4gICAgICAgICAgICAgICAgLy8gRSwgU1xuICAgICAgICAgICAgICAgIFt0aGlzLl9iYm94WzJdLCB0aGlzLl9iYm94WzFdXSxcbiAgICAgICAgICAgICAgICAvLyBFLCBOXG4gICAgICAgICAgICAgICAgW3RoaXMuX2Jib3hbMl0sIHRoaXMuX2Jib3hbM11dLFxuICAgICAgICAgICAgICAgIC8vIFcsIE5cbiAgICAgICAgICAgICAgICBbdGhpcy5fYmJveFswXSwgdGhpcy5fYmJveFszXV0sXG4gICAgICAgICAgICAgICAgLy8gVywgU1xuICAgICAgICAgICAgICAgIFt0aGlzLl9iYm94WzBdLCB0aGlzLl9iYm94WzFdXVxuICAgICAgICAgICAgXVxuICAgICAgICBdXG4gICAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYXR0ZW4obGlzdCwgZGVwdGgpIHtcbiAgICByZXR1cm4gX2ZsYXR0ZW4obGlzdCk7XG5cbiAgICBmdW5jdGlvbiBfZmxhdHRlbihsaXN0KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3QpICYmIGxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0eXBlb2YgbGlzdFswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGlzdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pICYmIEFycmF5LmlzQXJyYXkoaXRlbVswXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChfZmxhdHRlbihpdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG59O1xuIiwidmFyIGdlb2pzb25Ob3JtYWxpemUgPSByZXF1aXJlKCdnZW9qc29uLW5vcm1hbGl6ZScpLFxuICAgIGdlb2pzb25GbGF0dGVuID0gcmVxdWlyZSgnZ2VvanNvbi1mbGF0dGVuJyksXG4gICAgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIV8pIHJldHVybiBbXTtcbiAgICB2YXIgbm9ybWFsaXplZCA9IGdlb2pzb25GbGF0dGVuKGdlb2pzb25Ob3JtYWxpemUoXykpLFxuICAgICAgICBjb29yZGluYXRlcyA9IFtdO1xuICAgIG5vcm1hbGl6ZWQuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSkgcmV0dXJuO1xuICAgICAgICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzLmNvbmNhdChmbGF0dGVuKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuIiwidmFyIGdlb2pzb25Db29yZHMgPSByZXF1aXJlKCdnZW9qc29uLWNvb3JkcycpLFxuICAgIHRyYXZlcnNlID0gcmVxdWlyZSgndHJhdmVyc2UnKSxcbiAgICBleHRlbnQgPSByZXF1aXJlKCdleHRlbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGdldEV4dGVudChfKS5iYm94KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBnZXRFeHRlbnQoXykucG9seWdvbigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuYmJveGlmeSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gdHJhdmVyc2UoXykubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlLmJib3ggPSBnZXRFeHRlbnQodmFsdWUpLmJib3goKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0RXh0ZW50KF8pIHtcbiAgICB2YXIgYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSxcbiAgICAgICAgZXh0ID0gZXh0ZW50KCksXG4gICAgICAgIGNvb3JkcyA9IGdlb2pzb25Db29yZHMoXyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIGV4dC5pbmNsdWRlKGNvb3Jkc1tpXSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcblxuZnVuY3Rpb24gZmxhdHRlbihnaiwgdXApIHtcbiAgICBzd2l0Y2ggKChnaiAmJiBnai50eXBlKSB8fCBudWxsKSB7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGdqLmZlYXR1cmVzID0gZ2ouZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uKG1lbSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW0uY29uY2F0KGZsYXR0ZW4oZmVhdHVyZSkpO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKGdqLmdlb21ldHJ5KS5tYXAoZnVuY3Rpb24oZ2VvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnai5wcm9wZXJ0aWVzKSksXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgICAgIHJldHVybiBnai5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBfIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIHJldHVybiBnai5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdQb2x5Z29uJywgY29vcmRpbmF0ZXM6IF8gfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGdqLmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogXyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gZ2ouZ2VvbWV0cmllcztcbiAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gW2dqXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG4iLCIvLyBGaW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBnZW9qc29uIHBvbHlnb24gKHBvc3NpYmx5IHdpdGggaW50ZXJpb3IgcmluZ3MpXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZlYXR1cmUsIGZpbHRlckZuLCB1c2VTcGF0aWFsSW5kZXgpIHtcbiAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSAhPSBcIlBvbHlnb25cIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGlucHV0IGZlYXR1cmUgbXVzdCBiZSBhIFBvbHlnb25cIik7XG4gIGlmICghdXNlU3BhdGlhbEluZGV4KSB1c2VTcGF0aWFsSW5kZXggPSAxO1xuXG4gIHZhciBjb29yZCA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgc2VlbiA9IHt9O1xuXG4gIGlmICh1c2VTcGF0aWFsSW5kZXgpIHtcbiAgICB2YXIgYWxsRWRnZXNBc1JidXNoVHJlZUl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgcmluZzAgPSAwOyByaW5nMCA8IGNvb3JkLmxlbmd0aDsgcmluZzArKykge1xuICAgICAgZm9yICh2YXIgZWRnZTAgPSAwOyBlZGdlMCA8IGNvb3JkW3JpbmcwXS5sZW5ndGgtMTsgZWRnZTArKykge1xuICAgICAgICBhbGxFZGdlc0FzUmJ1c2hUcmVlSXRlbXMucHVzaChyYnVzaFRyZWVJdGVtKHJpbmcwLCBlZGdlMCkpXG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0cmVlID0gcmJ1c2goKTtcbiAgICB0cmVlLmxvYWQoYWxsRWRnZXNBc1JidXNoVHJlZUl0ZW1zKTtcbiAgfVxuXG4gIGZvciAodmFyIHJpbmcwID0gMDsgcmluZzAgPCBjb29yZC5sZW5ndGg7IHJpbmcwKyspIHtcbiAgICBmb3IgKHZhciBlZGdlMCA9IDA7IGVkZ2UwIDwgY29vcmRbcmluZzBdLmxlbmd0aC0xOyBlZGdlMCsrKSB7XG4gICAgICBpZiAodXNlU3BhdGlhbEluZGV4KSB7XG4gICAgICAgIHZhciBiYm94T3ZlcmxhcHMgPSB0cmVlLnNlYXJjaChyYnVzaFRyZWVJdGVtKHJpbmcwLCBlZGdlMCkpO1xuICAgICAgICBiYm94T3ZlcmxhcHMuZm9yRWFjaChmdW5jdGlvbihiYm94SXNlY3QpIHtcbiAgICAgICAgICB2YXIgcmluZzEgPSBiYm94SXNlY3QucmluZztcbiAgICAgICAgICB2YXIgZWRnZTEgPSBiYm94SXNlY3QuZWRnZTtcbiAgICAgICAgICBpZklzZWN0QWRkVG9PdXRwdXQocmluZzAsIGVkZ2UwLCByaW5nMSwgZWRnZTEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciByaW5nMSA9IDA7IHJpbmcxIDwgY29vcmQubGVuZ3RoOyByaW5nMSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgZWRnZTEgPSAwIDsgZWRnZTEgPCBjb29yZFtyaW5nMV0ubGVuZ3RoLTE7IGVkZ2UxKyspIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHNwZWVkdXAgcG9zc2libGUgaWYgb25seSBpbnRlcmVzdGVkIGluIHVuaXF1ZTogc3RhcnQgbGFzdCB0d28gbG9vcHMgYXQgcmluZzAgYW5kIGVkZ2UwKzFcbiAgICAgICAgICAgIGlmSXNlY3RBZGRUb091dHB1dChyaW5nMCwgZWRnZTAsIHJpbmcxLCBlZGdlMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFmaWx0ZXJGbikgb3V0cHV0ID0ge3R5cGU6IFwiRmVhdHVyZVwiLCBnZW9tZXRyeToge3R5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogb3V0cHV0fX07XG4gIHJldHVybiBvdXRwdXQ7XG5cbiAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgaWYgdHdvIGVkZ2VzIGludGVyc2VjdCBhbmQgYWRkIHRoZSBpbnRlcnNlY3Rpb24gdG8gdGhlIG91dHB1dFxuICBmdW5jdGlvbiBpZklzZWN0QWRkVG9PdXRwdXQocmluZzAsIGVkZ2UwLCByaW5nMSwgZWRnZTEpIHtcbiAgICB2YXIgc3RhcnQwID0gY29vcmRbcmluZzBdW2VkZ2UwXTtcbiAgICB2YXIgZW5kMCA9IGNvb3JkW3JpbmcwXVtlZGdlMCsxXTtcbiAgICB2YXIgc3RhcnQxID0gY29vcmRbcmluZzFdW2VkZ2UxXTtcbiAgICB2YXIgZW5kMSA9IGNvb3JkW3JpbmcxXVtlZGdlMSsxXTtcblxuICAgIHZhciBpc2VjdCA9IGludGVyc2VjdChzdGFydDAsIGVuZDAsIHN0YXJ0MSwgZW5kMSk7XG5cbiAgICBpZiAoaXNlY3QgPT0gbnVsbCkgcmV0dXJuOyAvLyBkaXNjYXJkIHBhcmFsbGVscyBhbmQgY29pbmNpZGVuY2VcbiAgICB2YXIgZnJhYzAgPSAoaXNlY3RbMF0tc3RhcnQwWzBdKS8oZW5kMFswXS1zdGFydDBbMF0pO1xuICAgIHZhciBmcmFjMSA9IChpc2VjdFswXS1zdGFydDFbMF0pLyhlbmQxWzBdLXN0YXJ0MVswXSk7XG4gICAgaWYgKGZyYWMwID49IDEgfHwgZnJhYzAgPD0gMCB8fCBmcmFjMSA+PSAxIHx8IGZyYWMxIDw9IDApIHJldHVybjsgLy8gcmVxdWlyZSBzZWdtZW50IGludGVyc2VjdGlvblxuXG4gICAgdmFyIGtleSA9IGlzZWN0O1xuICAgIHZhciB1bmlxdWUgPSAhc2VlbltrZXldO1xuICAgIGlmICh1bmlxdWUpIHtcbiAgICAgIHNlZW5ba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlckZuKSB7XG4gICAgICBvdXRwdXQucHVzaChmaWx0ZXJGbihpc2VjdCwgcmluZzAsIGVkZ2UwLCBzdGFydDAsIGVuZDAsIGZyYWMwLCByaW5nMSwgZWRnZTEsIHN0YXJ0MSwgZW5kMSwgZnJhYzEsIHVuaXF1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChpc2VjdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gcmV0dXJuIGEgcmJ1c2ggdHJlZSBpdGVtIGdpdmVuIGFuIHJpbmcgYW5kIGVkZ2UgbnVtYmVyXG4gIGZ1bmN0aW9uIHJidXNoVHJlZUl0ZW0ocmluZywgZWRnZSkge1xuXG4gICAgdmFyIHN0YXJ0ID0gY29vcmRbcmluZ11bZWRnZV07XG4gICAgdmFyIGVuZCA9IGNvb3JkW3JpbmddW2VkZ2UrMV07XG5cbiAgICBpZiAoc3RhcnRbMF0gPCBlbmRbMF0pIHtcbiAgICAgIHZhciBtaW5YID0gc3RhcnRbMF0sIG1heFggPSBlbmRbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaW5YID0gZW5kWzBdLCBtYXhYID0gc3RhcnRbMF07XG4gICAgfTtcbiAgICBpZiAoc3RhcnRbMV0gPCBlbmRbMV0pIHtcbiAgICAgIHZhciBtaW5ZID0gc3RhcnRbMV0sIG1heFkgPSBlbmRbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaW5ZID0gZW5kWzFdLCBtYXhZID0gc3RhcnRbMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluWDogbWluWCwgbWluWTogbWluWSwgbWF4WDogbWF4WCwgbWF4WTogbWF4WSwgcmluZzogcmluZywgZWRnZTogZWRnZX07XG4gIH1cblxufVxuXG4vLyBGdW5jdGlvbiB0byBjb21wdXRlIHdoZXJlIHR3byBsaW5lcyAobm90IHNlZ21lbnRzKSBpbnRlcnNlY3QuIEZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M2xpbmVfaW50ZXJzZWN0aW9uXG5mdW5jdGlvbiBpbnRlcnNlY3Qoc3RhcnQwLCBlbmQwLCBzdGFydDEsIGVuZDEpIHtcbiAgaWYgKGVxdWFsQXJyYXlzKHN0YXJ0MCxzdGFydDEpIHx8IGVxdWFsQXJyYXlzKHN0YXJ0MCxlbmQxKSB8fCBlcXVhbEFycmF5cyhlbmQwLHN0YXJ0MSkgfHwgZXF1YWxBcnJheXMoZW5kMSxzdGFydDEpKSByZXR1cm4gbnVsbDtcbiAgdmFyIHgwID0gc3RhcnQwWzBdLFxuICAgICAgeTAgPSBzdGFydDBbMV0sXG4gICAgICB4MSA9IGVuZDBbMF0sXG4gICAgICB5MSA9IGVuZDBbMV0sXG4gICAgICB4MiA9IHN0YXJ0MVswXSxcbiAgICAgIHkyID0gc3RhcnQxWzFdLFxuICAgICAgeDMgPSBlbmQxWzBdLFxuICAgICAgeTMgPSBlbmQxWzFdO1xuICB2YXIgZGVub20gPSAoeDAgLSB4MSkgKiAoeTIgLSB5MykgLSAoeTAgLSB5MSkgKiAoeDIgLSB4Myk7XG4gIGlmIChkZW5vbSA9PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHg0ID0gKCh4MCAqIHkxIC0geTAgKiB4MSkgKiAoeDIgLSB4MykgLSAoeDAgLSB4MSkgKiAoeDIgKiB5MyAtIHkyICogeDMpKSAvIGRlbm9tO1xuICB2YXIgeTQgPSAoKHgwICogeTEgLSB5MCAqIHgxKSAqICh5MiAtIHkzKSAtICh5MCAtIHkxKSAqICh4MiAqIHkzIC0geTIgKiB4MykpIC8gZGVub207XG4gIHJldHVybiBbeDQsIHk0XTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY29tcGFyZSBBcnJheXMgb2YgbnVtYmVycy4gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4Mzc0NTYvaG93LXRvLWNvbXBhcmUtYXJyYXlzLWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgLy8gaWYgdGhlIG90aGVyIGFycmF5IGlzIGEgZmFsc3kgdmFsdWUsIHJldHVyblxuICAgIGlmICghYXJyYXkxIHx8ICFhcnJheTIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGNvbXBhcmUgbGVuZ3RocyAtIGNhbiBzYXZlIGEgbG90IG9mIHRpbWVcbiAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPSBhcnJheTIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbD1hcnJheTEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgbmVzdGVkIGFycmF5c1xuICAgICAgICBpZiAoYXJyYXkxW2ldIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXkyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byB0aGUgbmVzdGVkIGFycmF5c1xuICAgICAgICAgICAgaWYgKCFlcXVhbEFycmF5cyhhcnJheTFbaV0sYXJyYXkyW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJyYXkxW2ldICE9IGFycmF5MltpXSkge1xuICAgICAgICAgICAgLy8gV2FybmluZyAtIHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbCAucG9pbnQoKSBvciAucG9seWdvbigpIGluc3RlYWQnKTtcbn07XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKGJib3gpIHtcbiAgICBpZiAoYmJveCkgcmV0dXJuIGNvb3JkSW5CQkJPWChiYm94KTtcbiAgICBlbHNlIHJldHVybiBbbG9uKCksIGxhdCgpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMucG9zaXRpb24gPSBwb3NpdGlvbjtcblxubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBmdW5jdGlvbihjb3VudCwgYmJveCkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZShiYm94ID8gcG9pbnQocG9zaXRpb24oYmJveCkpIDogcG9pbnQoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbihmZWF0dXJlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gZnVuY3Rpb24oY291bnQsIG51bV92ZXJ0aWNlcywgbWF4X3JhZGlhbF9sZW5ndGgsIGJib3gpIHtcbiAgICBpZiAodHlwZW9mIG51bV92ZXJ0aWNlcyAhPT0gJ251bWJlcicpIG51bV92ZXJ0aWNlcyA9IDEwO1xuICAgIGlmICh0eXBlb2YgbWF4X3JhZGlhbF9sZW5ndGggIT09ICdudW1iZXInKSBtYXhfcmFkaWFsX2xlbmd0aCA9IDEwO1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICAgICAgY2lyY2xlX29mZnNldHMgPSBBcnJheS5hcHBseShudWxsLFxuICAgICAgICAgICAgICAgIG5ldyBBcnJheShudW1fdmVydGljZXMgKyAxKSkubWFwKE1hdGgucmFuZG9tKTtcblxuICAgICAgICBjaXJjbGVfb2Zmc2V0cy5mb3JFYWNoKHN1bU9mZnNldHMpO1xuICAgICAgICBjaXJjbGVfb2Zmc2V0cy5mb3JFYWNoKHNjYWxlT2Zmc2V0cyk7XG4gICAgICAgIHZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aCAtIDFdID0gdmVydGljZXNbMF07IC8vIGNsb3NlIHRoZSByaW5nXG5cbiAgICAgICAgLy8gY2VudGVyIHRoZSBwb2x5Z29uIGFyb3VuZCBzb21ldGhpbmdcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAodmVydGV4VG9Db29yZGluYXRlKHBvc2l0aW9uKGJib3gpKSk7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZShwb2x5Z29uKFt2ZXJ0aWNlc10pKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VtT2Zmc2V0cyhjdXIsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgYXJyW2luZGV4XSA9IChpbmRleCA+IDApID8gY3VyICsgYXJyW2luZGV4IC0gMV0gOiBjdXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVPZmZzZXRzKGN1ciwgaW5kZXgpIHtcbiAgICAgICAgY3VyID0gY3VyICogMiAqIE1hdGguUEkgLyBjaXJjbGVfb2Zmc2V0c1tjaXJjbGVfb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJhZGlhbF9zY2FsZXIgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgIHJhZGlhbF9zY2FsZXIgKiBtYXhfcmFkaWFsX2xlbmd0aCAqIE1hdGguc2luKGN1ciksXG4gICAgICAgICAgICByYWRpYWxfc2NhbGVyICogbWF4X3JhZGlhbF9sZW5ndGggKiBNYXRoLmNvcyhjdXIpXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uKGZlYXR1cmVzKTtcbn07XG5cblxuZnVuY3Rpb24gdmVydGV4VG9Db29yZGluYXRlKGh1Yikge1xuICAgIHJldHVybiBmdW5jdGlvbihjdXIsIGluZGV4KSB7IHJldHVybiBbY3VyWzBdICsgaHViWzBdLCBjdXJbMV0gKyBodWJbMV1dOyB9O1xufVxuXG5mdW5jdGlvbiBybmQoKSB7IHJldHVybiBNYXRoLnJhbmRvbSgpIC0gMC41OyB9XG5mdW5jdGlvbiBsb24oKSB7IHJldHVybiBybmQoKSAqIDM2MDsgfVxuZnVuY3Rpb24gbGF0KCkgeyByZXR1cm4gcm5kKCkgKiAxODA7IH1cblxuZnVuY3Rpb24gcG9pbnQoY29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfHwgW2xvbigpLCBsYXQoKV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb29yZEluQkJCT1goYmJveCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIChNYXRoLnJhbmRvbSgpICogKGJib3hbMl0gLSBiYm94WzBdKSkgKyBiYm94WzBdLFxuICAgICAgICAoTWF0aC5yYW5kb20oKSAqIChiYm94WzNdIC0gYmJveFsxXSkpICsgYmJveFsxXV07XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5CQkJPWCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogW2xvbigpLCBsYXQoKV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmZWF0dXJlKGdlb20pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb24oZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBmXG4gICAgfTtcbn1cbiIsInZhciB0dXJmQkJveCA9IHJlcXVpcmUoJ0B0dXJmL2Jib3gnKTtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBmZWF0dXJlRWFjaCA9IHJlcXVpcmUoJ0B0dXJmL21ldGEnKS5mZWF0dXJlRWFjaDtcbnZhciByYnVzaCA9IHJlcXVpcmUoJ3JidXNoJyk7XG5cbi8qKlxuICogR2VvSlNPTiBpbXBsZW1lbnRhdGlvbiBvZiBbUkJ1c2hdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoI3JidXNoKSBzcGF0aWFsIGluZGV4LlxuICpcbiAqIEBuYW1lIHJidXNoXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEVudHJpZXM9OV0gZGVmaW5lcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiBhIHRyZWUgbm9kZS4gOSAodXNlZCBieSBkZWZhdWx0KSBpcyBhXG4gKiByZWFzb25hYmxlIGNob2ljZSBmb3IgbW9zdCBhcHBsaWNhdGlvbnMuIEhpZ2hlciB2YWx1ZSBtZWFucyBmYXN0ZXIgaW5zZXJ0aW9uIGFuZCBzbG93ZXIgc2VhcmNoLCBhbmQgdmljZSB2ZXJzYS5cbiAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSQnVzaFxuICogQGV4YW1wbGVcbiAqIHZhciByYnVzaCA9IHJlcXVpcmUoJ2dlb2pzb24tcmJ1c2gnKVxuICogdmFyIHRyZWUgPSByYnVzaCgpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1heEVudHJpZXMpIHtcbiAgICB2YXIgdHJlZSA9IHJidXNoKG1heEVudHJpZXMpO1xuICAgIC8qKlxuICAgICAqIFtpbnNlcnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoI2RhdGEtZm9ybWF0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlPGFueT59IGZlYXR1cmUgaW5zZXJ0IHNpbmdsZSBHZW9KU09OIEZlYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5Z29uID0ge1xuICAgICAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICAgICAqICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAgICAgKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogdHJlZS5pbnNlcnQocG9seWdvbilcbiAgICAgKi9cbiAgICB0cmVlLmluc2VydCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGZlYXR1cmUuYmJveCA9IGZlYXR1cmUuYmJveCA/IGZlYXR1cmUuYmJveCA6IHR1cmZCQm94KGZlYXR1cmUpO1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLmluc2VydC5jYWxsKHRoaXMsIGZlYXR1cmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbbG9hZF0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjYnVsay1pbnNlcnRpbmctZGF0YSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248YW55Pn0gZmVhdHVyZXMgbG9hZCBlbnRpcmUgR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSQnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHlnb25zID0ge1xuICAgICAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgKiAgIFwiZmVhdHVyZXNcIjogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAgICAgKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAgICAgKiAgICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAgICAgKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tbLTc4LCA0MV0sIFstNjcsIDQxXSwgWy02NywgNDhdLCBbLTc4LCA0OF0sIFstNzgsIDQxXV1dXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9LFxuICAgICAqICAgICB7XG4gICAgICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAgICAgKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAgICAgKiAgICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAgICAgKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tbLTkzLCAzMl0sIFstODMsIDMyXSwgWy04MywgMzldLCBbLTkzLCAzOV0sIFstOTMsIDMyXV1dXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICBdXG4gICAgICogfVxuICAgICAqIHRyZWUubG9hZChwb2x5Z29ucylcbiAgICAgKi9cbiAgICB0cmVlLmxvYWQgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIGxvYWQgPSBbXTtcbiAgICAgICAgZmVhdHVyZUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBmZWF0dXJlLmJib3ggPSBmZWF0dXJlLmJib3ggPyBmZWF0dXJlLmJib3ggOiB0dXJmQkJveChmZWF0dXJlKTtcbiAgICAgICAgICAgIGxvYWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMsIGxvYWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbcmVtb3ZlXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyZW1vdmluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlPGFueT59IGZlYXR1cmUgcmVtb3ZlIHNpbmdsZSBHZW9KU09OIEZlYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5Z29uID0ge1xuICAgICAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICAgICAqICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAgICAgKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogdHJlZS5yZW1vdmUocG9seWdvbilcbiAgICAgKi9cbiAgICB0cmVlLnJlbW92ZSA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgZmVhdHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtjbGVhcl0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjcmVtb3ZpbmctZGF0YSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSYnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJlZS5jbGVhcigpXG4gICAgICovXG4gICAgdHJlZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJidXNoLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbc2VhcmNoXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNzZWFyY2gpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmU8YW55Pn0gZ2VvanNvbiBzZWFyY2ggd2l0aCBHZW9KU09OXG4gICAgICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPGFueT59IGFsbCBmZWF0dXJlcyB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gR2VvSlNPTi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5Z29uID0ge1xuICAgICAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICAgICAqICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAgICAgKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogdHJlZS5zZWFyY2gocG9seWdvbilcbiAgICAgKi9cbiAgICB0cmVlLnNlYXJjaCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSByYnVzaC5wcm90b3R5cGUuc2VhcmNoLmNhbGwodGhpcywgdGhpcy50b0JCb3goZ2VvanNvbikpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oc2VhcmNoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2NvbGxpZGVzXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNjb2xsaXNpb25zKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlPGFueT59IGdlb2pzb24gY29sbGlkZXMgd2l0aCBHZW9KU09OXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlcmUgYXJlIGFueSBpdGVtcyBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIEdlb0pTT04sIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5Z29uID0ge1xuICAgICAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICAgICAqICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAgICAgKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogdHJlZS5jb2xsaWRlcyhwb2x5Z29uKVxuICAgICAqL1xuICAgIHRyZWUuY29sbGlkZXMgPSBmdW5jdGlvbiAoZ2VvanNvbikge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLmNvbGxpZGVzLmNhbGwodGhpcywgdGhpcy50b0JCb3goZ2VvanNvbikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbYWxsXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNzZWFyY2gpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248YW55Pn0gYWxsIHRoZSBmZWF0dXJlcyBpbiBSQnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJlZS5hbGwoKVxuICAgICAqIC8vPUZlYXR1cmVDb2xsZWN0aW9uXG4gICAgICovXG4gICAgdHJlZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbGwgPSByYnVzaC5wcm90b3R5cGUuYWxsLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihhbGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbdG9KU09OXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNleHBvcnQtYW5kLWltcG9ydClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHthbnl9IGV4cG9ydCBkYXRhIGFzIEpTT04gb2JqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZXhwb3J0ZWQgPSB0cmVlLnRvSlNPTigpXG4gICAgICogLy89SlNPTiBvYmplY3RcbiAgICAgKi9cbiAgICB0cmVlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJidXNoLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2Zyb21KU09OXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNleHBvcnQtYW5kLWltcG9ydClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBqc29uIGltcG9ydCBwcmV2aW91c2x5IGV4cG9ydGVkIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBleHBvcnRlZCA9IHtcbiAgICAgKiAgIFwiY2hpbGRyZW5cIjogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICAgICAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAgICAgKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNTBdXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gICAgICogICAgICAgXCJiYm94XCI6IFsxMTAsIDUwLCAxMTAsIDUwXVxuICAgICAqICAgICB9XG4gICAgICogICBdLFxuICAgICAqICAgXCJoZWlnaHRcIjogMSxcbiAgICAgKiAgIFwibGVhZlwiOiB0cnVlLFxuICAgICAqICAgXCJtaW5YXCI6IDExMCxcbiAgICAgKiAgIFwibWluWVwiOiA1MCxcbiAgICAgKiAgIFwibWF4WFwiOiAxMTAsXG4gICAgICogICBcIm1heFlcIjogNTBcbiAgICAgKiB9XG4gICAgICogdHJlZS5mcm9tSlNPTihleHBvcnRlZClcbiAgICAgKi9cbiAgICB0cmVlLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIHJidXNoLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKHRoaXMsIGpzb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBHZW9KU09OIHRvIHttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZfSBzY2hlbWFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvfEZlYXR1cmU8YW55Pn0gZ2VvanNvbiBmZWF0dXJlKHMpIHRvIHJldHJpZXZlIEJCb3ggZnJvbVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbnZlcnRlZCB0byB7bWluWCwgbWluWSwgbWF4WCwgbWF4WX1cbiAgICAgKi9cbiAgICB0cmVlLnRvQkJveCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgICAgIHZhciBiYm94ID0gZ2VvanNvbi5iYm94ID8gZ2VvanNvbi5iYm94IDogdHVyZkJCb3goZ2VvanNvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBiYm94WzBdLFxuICAgICAgICAgICAgbWluWTogYmJveFsxXSxcbiAgICAgICAgICAgIG1heFg6IGJib3hbMl0sXG4gICAgICAgICAgICBtYXhZOiBiYm94WzNdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbn07XG4iLCIoZnVuY3Rpb24gKCkge1xuICB2YXIgZ2p1ID0gdGhpcy5nanUgPSB7fTtcblxuICAvLyBFeHBvcnQgdGhlIGdlb2pzb24gb2JqZWN0IGZvciAqKkNvbW1vbkpTKipcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnanU7XG4gIH1cblxuICAvLyBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5rZXZsaW5kZXYuY29tL2d1aS9tYXRoL2ludGVyc2VjdGlvbi9JbnRlcnNlY3Rpb24uanNcbiAgZ2p1LmxpbmVTdHJpbmdzSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGwxLCBsMikge1xuICAgIHZhciBpbnRlcnNlY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbDEuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBsMi5jb29yZGluYXRlcy5sZW5ndGggLSAyOyArK2opIHtcbiAgICAgICAgdmFyIGExID0ge1xuICAgICAgICAgIHg6IGwxLmNvb3JkaW5hdGVzW2ldWzFdLFxuICAgICAgICAgIHk6IGwxLmNvb3JkaW5hdGVzW2ldWzBdXG4gICAgICAgIH0sXG4gICAgICAgICAgYTIgPSB7XG4gICAgICAgICAgICB4OiBsMS5jb29yZGluYXRlc1tpICsgMV1bMV0sXG4gICAgICAgICAgICB5OiBsMS5jb29yZGluYXRlc1tpICsgMV1bMF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGIxID0ge1xuICAgICAgICAgICAgeDogbDIuY29vcmRpbmF0ZXNbal1bMV0sXG4gICAgICAgICAgICB5OiBsMi5jb29yZGluYXRlc1tqXVswXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYjIgPSB7XG4gICAgICAgICAgICB4OiBsMi5jb29yZGluYXRlc1tqICsgMV1bMV0sXG4gICAgICAgICAgICB5OiBsMi5jb29yZGluYXRlc1tqICsgMV1bMF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHVhX3QgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICAgIHViX3QgPSAoYTIueCAtIGExLngpICogKGExLnkgLSBiMS55KSAtIChhMi55IC0gYTEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICAgIHVfYiA9IChiMi55IC0gYjEueSkgKiAoYTIueCAtIGExLngpIC0gKGIyLnggLSBiMS54KSAqIChhMi55IC0gYTEueSk7XG4gICAgICAgIGlmICh1X2IgIT0gMCkge1xuICAgICAgICAgIHZhciB1YSA9IHVhX3QgLyB1X2IsXG4gICAgICAgICAgICB1YiA9IHViX3QgLyB1X2I7XG4gICAgICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCh7XG4gICAgICAgICAgICAgICd0eXBlJzogJ1BvaW50JyxcbiAgICAgICAgICAgICAgJ2Nvb3JkaW5hdGVzJzogW2ExLnggKyB1YSAqIChhMi54IC0gYTEueCksIGExLnkgKyB1YSAqIChhMi55IC0gYTEueSldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGludGVyc2VjdHMubGVuZ3RoID09IDApIGludGVyc2VjdHMgPSBmYWxzZTtcbiAgICByZXR1cm4gaW50ZXJzZWN0cztcbiAgfVxuXG4gIC8vIEJvdW5kaW5nIEJveFxuXG4gIGZ1bmN0aW9uIGJvdW5kaW5nQm94QXJvdW5kUG9seUNvb3JkcyAoY29vcmRzKSB7XG4gICAgdmFyIHhBbGwgPSBbXSwgeUFsbCA9IFtdXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgeEFsbC5wdXNoKGNvb3Jkc1swXVtpXVsxXSlcbiAgICAgIHlBbGwucHVzaChjb29yZHNbMF1baV1bMF0pXG4gICAgfVxuXG4gICAgeEFsbCA9IHhBbGwuc29ydChmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhIC0gYiB9KVxuICAgIHlBbGwgPSB5QWxsLnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSAtIGIgfSlcblxuICAgIHJldHVybiBbIFt4QWxsWzBdLCB5QWxsWzBdXSwgW3hBbGxbeEFsbC5sZW5ndGggLSAxXSwgeUFsbFt5QWxsLmxlbmd0aCAtIDFdXSBdXG4gIH1cblxuICBnanUucG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBvaW50LCBib3VuZHMpIHtcbiAgICByZXR1cm4gIShwb2ludC5jb29yZGluYXRlc1sxXSA8IGJvdW5kc1swXVswXSB8fCBwb2ludC5jb29yZGluYXRlc1sxXSA+IGJvdW5kc1sxXVswXSB8fCBwb2ludC5jb29yZGluYXRlc1swXSA8IGJvdW5kc1swXVsxXSB8fCBwb2ludC5jb29yZGluYXRlc1swXSA+IGJvdW5kc1sxXVsxXSkgXG4gIH1cblxuICAvLyBQb2ludCBpbiBQb2x5Z29uXG4gIC8vIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWwjTGlzdGluZyB0aGUgVmVydGljZXNcblxuICBmdW5jdGlvbiBwbnBvbHkgKHgseSxjb29yZHMpIHtcbiAgICB2YXIgdmVydCA9IFsgWzAsMF0gXVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZlcnQucHVzaChjb29yZHNbaV1bal0pXG4gICAgICB9XG5cdCAgdmVydC5wdXNoKGNvb3Jkc1tpXVswXSlcbiAgICAgIHZlcnQucHVzaChbMCwwXSlcbiAgICB9XG5cbiAgICB2YXIgaW5zaWRlID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHZlcnQubGVuZ3RoIC0gMTsgaSA8IHZlcnQubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICBpZiAoKCh2ZXJ0W2ldWzBdID4geSkgIT0gKHZlcnRbal1bMF0gPiB5KSkgJiYgKHggPCAodmVydFtqXVsxXSAtIHZlcnRbaV1bMV0pICogKHkgLSB2ZXJ0W2ldWzBdKSAvICh2ZXJ0W2pdWzBdIC0gdmVydFtpXVswXSkgKyB2ZXJ0W2ldWzFdKSkgaW5zaWRlID0gIWluc2lkZVxuICAgIH1cblxuICAgIHJldHVybiBpbnNpZGVcbiAgfVxuXG4gIGdqdS5wb2ludEluUG9seWdvbiA9IGZ1bmN0aW9uIChwLCBwb2x5KSB7XG4gICAgdmFyIGNvb3JkcyA9IChwb2x5LnR5cGUgPT0gXCJQb2x5Z29uXCIpID8gWyBwb2x5LmNvb3JkaW5hdGVzIF0gOiBwb2x5LmNvb3JkaW5hdGVzXG5cbiAgICB2YXIgaW5zaWRlQm94ID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGdqdS5wb2ludEluQm91bmRpbmdCb3gocCwgYm91bmRpbmdCb3hBcm91bmRQb2x5Q29vcmRzKGNvb3Jkc1tpXSkpKSBpbnNpZGVCb3ggPSB0cnVlXG4gICAgfVxuICAgIGlmICghaW5zaWRlQm94KSByZXR1cm4gZmFsc2VcblxuICAgIHZhciBpbnNpZGVQb2x5ID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBucG9seShwLmNvb3JkaW5hdGVzWzFdLCBwLmNvb3JkaW5hdGVzWzBdLCBjb29yZHNbaV0pKSBpbnNpZGVQb2x5ID0gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBpbnNpZGVQb2x5XG4gIH1cblxuICAvLyBzdXBwb3J0IG11bHRpIChidXQgbm90IGRvbnV0KSBwb2x5Z29uc1xuICBnanUucG9pbnRJbk11bHRpUG9seWdvbiA9IGZ1bmN0aW9uIChwLCBwb2x5KSB7XG4gICAgdmFyIGNvb3Jkc19hcnJheSA9IChwb2x5LnR5cGUgPT0gXCJNdWx0aVBvbHlnb25cIikgPyBbIHBvbHkuY29vcmRpbmF0ZXMgXSA6IHBvbHkuY29vcmRpbmF0ZXNcblxuICAgIHZhciBpbnNpZGVCb3ggPSBmYWxzZVxuICAgIHZhciBpbnNpZGVQb2x5ID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkc19hcnJheS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgY29vcmRzID0gY29vcmRzX2FycmF5W2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFpbnNpZGVCb3gpe1xuICAgICAgICAgIGlmIChnanUucG9pbnRJbkJvdW5kaW5nQm94KHAsIGJvdW5kaW5nQm94QXJvdW5kUG9seUNvb3Jkcyhjb29yZHNbal0pKSkge1xuICAgICAgICAgICAgaW5zaWRlQm94ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpbnNpZGVCb3gpIHJldHVybiBmYWxzZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFpbnNpZGVQb2x5KXtcbiAgICAgICAgICBpZiAocG5wb2x5KHAuY29vcmRpbmF0ZXNbMV0sIHAuY29vcmRpbmF0ZXNbMF0sIGNvb3Jkc1tqXSkpIHtcbiAgICAgICAgICAgIGluc2lkZVBvbHkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc2lkZVBvbHlcbiAgfVxuXG4gIGdqdS5udW1iZXJUb1JhZGl1cyA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICByZXR1cm4gbnVtYmVyICogTWF0aC5QSSAvIDE4MDtcbiAgfVxuXG4gIGdqdS5udW1iZXJUb0RlZ3JlZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICByZXR1cm4gbnVtYmVyICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuXG4gIC8vIHdyaXR0ZW4gd2l0aCBoZWxwIGZyb20gQHRhdXRvbG9nZVxuICBnanUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uIChyYWRpdXNJbk1ldGVycywgY2VudGVyUG9pbnQsIHN0ZXBzKSB7XG4gICAgdmFyIGNlbnRlciA9IFtjZW50ZXJQb2ludC5jb29yZGluYXRlc1sxXSwgY2VudGVyUG9pbnQuY29vcmRpbmF0ZXNbMF1dLFxuICAgICAgZGlzdCA9IChyYWRpdXNJbk1ldGVycyAvIDEwMDApIC8gNjM3MSxcbiAgICAgIC8vIGNvbnZlcnQgbWV0ZXJzIHRvIHJhZGlhbnRcbiAgICAgIHJhZENlbnRlciA9IFtnanUubnVtYmVyVG9SYWRpdXMoY2VudGVyWzBdKSwgZ2p1Lm51bWJlclRvUmFkaXVzKGNlbnRlclsxXSldLFxuICAgICAgc3RlcHMgPSBzdGVwcyB8fCAxNSxcbiAgICAgIC8vIDE1IHNpZGVkIGNpcmNsZVxuICAgICAgcG9seSA9IFtbY2VudGVyWzBdLCBjZW50ZXJbMV1dXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgIHZhciBicm5nID0gMiAqIE1hdGguUEkgKiBpIC8gc3RlcHM7XG4gICAgICB2YXIgbGF0ID0gTWF0aC5hc2luKE1hdGguc2luKHJhZENlbnRlclswXSkgKiBNYXRoLmNvcyhkaXN0KVxuICAgICAgICAgICAgICArIE1hdGguY29zKHJhZENlbnRlclswXSkgKiBNYXRoLnNpbihkaXN0KSAqIE1hdGguY29zKGJybmcpKTtcbiAgICAgIHZhciBsbmcgPSByYWRDZW50ZXJbMV0gKyBNYXRoLmF0YW4yKE1hdGguc2luKGJybmcpICogTWF0aC5zaW4oZGlzdCkgKiBNYXRoLmNvcyhyYWRDZW50ZXJbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3MoZGlzdCkgLSBNYXRoLnNpbihyYWRDZW50ZXJbMF0pICogTWF0aC5zaW4obGF0KSk7XG4gICAgICBwb2x5W2ldID0gW107XG4gICAgICBwb2x5W2ldWzFdID0gZ2p1Lm51bWJlclRvRGVncmVlKGxhdCk7XG4gICAgICBwb2x5W2ldWzBdID0gZ2p1Lm51bWJlclRvRGVncmVlKGxuZyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gICAgICBcImNvb3JkaW5hdGVzXCI6IFtwb2x5XVxuICAgIH07XG4gIH1cblxuICAvLyBhc3N1bWVzIHJlY3RhbmdsZSBzdGFydHMgYXQgbG93ZXIgbGVmdCBwb2ludFxuICBnanUucmVjdGFuZ2xlQ2VudHJvaWQgPSBmdW5jdGlvbiAocmVjdGFuZ2xlKSB7XG4gICAgdmFyIGJib3ggPSByZWN0YW5nbGUuY29vcmRpbmF0ZXNbMF07XG4gICAgdmFyIHhtaW4gPSBiYm94WzBdWzBdLFxuICAgICAgeW1pbiA9IGJib3hbMF1bMV0sXG4gICAgICB4bWF4ID0gYmJveFsyXVswXSxcbiAgICAgIHltYXggPSBiYm94WzJdWzFdO1xuICAgIHZhciB4d2lkdGggPSB4bWF4IC0geG1pbjtcbiAgICB2YXIgeXdpZHRoID0geW1heCAtIHltaW47XG4gICAgcmV0dXJuIHtcbiAgICAgICd0eXBlJzogJ1BvaW50JyxcbiAgICAgICdjb29yZGluYXRlcyc6IFt4bWluICsgeHdpZHRoIC8gMiwgeW1pbiArIHl3aWR0aCAvIDJdXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZyb20gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbiAgZ2p1LnBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiAocHQxLCBwdDIpIHtcbiAgICB2YXIgbG9uMSA9IHB0MS5jb29yZGluYXRlc1swXSxcbiAgICAgIGxhdDEgPSBwdDEuY29vcmRpbmF0ZXNbMV0sXG4gICAgICBsb24yID0gcHQyLmNvb3JkaW5hdGVzWzBdLFxuICAgICAgbGF0MiA9IHB0Mi5jb29yZGluYXRlc1sxXSxcbiAgICAgIGRMYXQgPSBnanUubnVtYmVyVG9SYWRpdXMobGF0MiAtIGxhdDEpLFxuICAgICAgZExvbiA9IGdqdS5udW1iZXJUb1JhZGl1cyhsb24yIC0gbG9uMSksXG4gICAgICBhID0gTWF0aC5wb3coTWF0aC5zaW4oZExhdCAvIDIpLCAyKSArIE1hdGguY29zKGdqdS5udW1iZXJUb1JhZGl1cyhsYXQxKSlcbiAgICAgICAgKiBNYXRoLmNvcyhnanUubnVtYmVyVG9SYWRpdXMobGF0MikpICogTWF0aC5wb3coTWF0aC5zaW4oZExvbiAvIDIpLCAyKSxcbiAgICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICAgIHJldHVybiAoNjM3MSAqIGMpICogMTAwMDsgLy8gcmV0dXJucyBtZXRlcnNcbiAgfSxcblxuICAvLyBjaGVja3MgaWYgZ2VvbWV0cnkgbGllcyBlbnRpcmVseSB3aXRoaW4gYSBjaXJjbGVcbiAgLy8gd29ya3Mgd2l0aCBQb2ludCwgTGluZVN0cmluZywgUG9seWdvblxuICBnanUuZ2VvbWV0cnlXaXRoaW5SYWRpdXMgPSBmdW5jdGlvbiAoZ2VvbWV0cnksIGNlbnRlciwgcmFkaXVzKSB7XG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT0gJ1BvaW50Jykge1xuICAgICAgcmV0dXJuIGdqdS5wb2ludERpc3RhbmNlKGdlb21ldHJ5LCBjZW50ZXIpIDw9IHJhZGl1cztcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT0gJ0xpbmVTdHJpbmcnIHx8IGdlb21ldHJ5LnR5cGUgPT0gJ1BvbHlnb24nKSB7XG4gICAgICB2YXIgcG9pbnQgPSB7fTtcbiAgICAgIHZhciBjb29yZGluYXRlcztcbiAgICAgIGlmIChnZW9tZXRyeS50eXBlID09ICdQb2x5Z29uJykge1xuICAgICAgICAvLyBpdCdzIGVub3VnaCB0byBjaGVjayB0aGUgZXh0ZXJpb3IgcmluZyBvZiB0aGUgUG9seWdvblxuICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgaW4gY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcG9pbnQuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgaWYgKGdqdS5wb2ludERpc3RhbmNlKHBvaW50LCBjZW50ZXIpID4gcmFkaXVzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9nZW9tZXRyeS9wb2x5YXJlYS9qYXZhc2NyaXB0LnR4dFxuICBnanUuYXJlYSA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIC8vIFRPRE86IHBvbHlnb24gaG9sZXMgYXQgY29vcmRpbmF0ZXNbMV1cbiAgICB2YXIgcG9pbnRzID0gcG9seWdvbi5jb29yZGluYXRlc1swXTtcbiAgICB2YXIgaiA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBwMSwgcDI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgeDogcG9pbnRzW2ldWzFdLFxuICAgICAgICB5OiBwb2ludHNbaV1bMF1cbiAgICAgIH07XG4gICAgICB2YXIgcDIgPSB7XG4gICAgICAgIHg6IHBvaW50c1tqXVsxXSxcbiAgICAgICAgeTogcG9pbnRzW2pdWzBdXG4gICAgICB9O1xuICAgICAgYXJlYSArPSBwMS54ICogcDIueTtcbiAgICAgIGFyZWEgLT0gcDEueSAqIHAyLng7XG4gICAgfVxuXG4gICAgYXJlYSAvPSAyO1xuICAgIHJldHVybiBhcmVhO1xuICB9LFxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZ2VvbWV0cnkvcG9seWFyZWEvamF2YXNjcmlwdC50eHRcbiAgZ2p1LmNlbnRyb2lkID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICB2YXIgZiwgeCA9IDAsXG4gICAgICB5ID0gMDtcbiAgICAvLyBUT0RPOiBwb2x5Z29uIGhvbGVzIGF0IGNvb3JkaW5hdGVzWzFdXG4gICAgdmFyIHBvaW50cyA9IHBvbHlnb24uY29vcmRpbmF0ZXNbMF07XG4gICAgdmFyIGogPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgcDEsIHAyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICB2YXIgcDEgPSB7XG4gICAgICAgIHg6IHBvaW50c1tpXVsxXSxcbiAgICAgICAgeTogcG9pbnRzW2ldWzBdXG4gICAgICB9O1xuICAgICAgdmFyIHAyID0ge1xuICAgICAgICB4OiBwb2ludHNbal1bMV0sXG4gICAgICAgIHk6IHBvaW50c1tqXVswXVxuICAgICAgfTtcbiAgICAgIGYgPSBwMS54ICogcDIueSAtIHAyLnggKiBwMS55O1xuICAgICAgeCArPSAocDEueCArIHAyLngpICogZjtcbiAgICAgIHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG4gICAgfVxuXG4gICAgZiA9IGdqdS5hcmVhKHBvbHlnb24pICogNjtcbiAgICByZXR1cm4ge1xuICAgICAgJ3R5cGUnOiAnUG9pbnQnLFxuICAgICAgJ2Nvb3JkaW5hdGVzJzogW3kgLyBmLCB4IC8gZl1cbiAgICB9O1xuICB9LFxuXG4gIGdqdS5zaW1wbGlmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGtpbmspIHsgLyogc291cmNlW10gYXJyYXkgb2YgZ2VvanNvbiBwb2ludHMgKi9cbiAgICAvKiBraW5rXHRpbiBtZXRyZXMsIGtpbmtzIGFib3ZlIHRoaXMgZGVwdGgga2VwdCAgKi9cbiAgICAvKiBraW5rIGRlcHRoIGlzIHRoZSBoZWlnaHQgb2YgdGhlIHRyaWFuZ2xlIGFiYyB3aGVyZSBhLWIgYW5kIGItYyBhcmUgdHdvIGNvbnNlY3V0aXZlIGxpbmUgc2VnbWVudHMgKi9cbiAgICBraW5rID0ga2luayB8fCAyMDtcbiAgICBzb3VyY2UgPSBzb3VyY2UubWFwKGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsbmc6IG8uY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIGxhdDogby5jb29yZGluYXRlc1sxXVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5fc291cmNlLCBuX3N0YWNrLCBuX2Rlc3QsIHN0YXJ0LCBlbmQsIGksIHNpZztcbiAgICB2YXIgZGV2X3NxciwgbWF4X2Rldl9zcXIsIGJhbmRfc3FyO1xuICAgIHZhciB4MTIsIHkxMiwgZDEyLCB4MTMsIHkxMywgZDEzLCB4MjMsIHkyMywgZDIzO1xuICAgIHZhciBGID0gKE1hdGguUEkgLyAxODAuMCkgKiAwLjU7XG4gICAgdmFyIGluZGV4ID0gbmV3IEFycmF5KCk7IC8qIGFyYXkgb2YgaW5kZXhlcyBvZiBzb3VyY2UgcG9pbnRzIHRvIGluY2x1ZGUgaW4gdGhlIHJlZHVjZWQgbGluZSAqL1xuICAgIHZhciBzaWdfc3RhcnQgPSBuZXcgQXJyYXkoKTsgLyogaW5kaWNlcyBvZiBzdGFydCAmIGVuZCBvZiB3b3JraW5nIHNlY3Rpb24gKi9cbiAgICB2YXIgc2lnX2VuZCA9IG5ldyBBcnJheSgpO1xuXG4gICAgLyogY2hlY2sgZm9yIHNpbXBsZSBjYXNlcyAqL1xuXG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPCAzKSByZXR1cm4gKHNvdXJjZSk7IC8qIG9uZSBvciB0d28gcG9pbnRzICovXG5cbiAgICAvKiBtb3JlIGNvbXBsZXggY2FzZS4gaW5pdGlhbGl6ZSBzdGFjayAqL1xuXG4gICAgbl9zb3VyY2UgPSBzb3VyY2UubGVuZ3RoO1xuICAgIGJhbmRfc3FyID0ga2luayAqIDM2MC4wIC8gKDIuMCAqIE1hdGguUEkgKiA2Mzc4MTM3LjApOyAvKiBOb3cgaW4gZGVncmVlcyAqL1xuICAgIGJhbmRfc3FyICo9IGJhbmRfc3FyO1xuICAgIG5fZGVzdCA9IDA7XG4gICAgc2lnX3N0YXJ0WzBdID0gMDtcbiAgICBzaWdfZW5kWzBdID0gbl9zb3VyY2UgLSAxO1xuICAgIG5fc3RhY2sgPSAxO1xuXG4gICAgLyogd2hpbGUgdGhlIHN0YWNrIGlzIG5vdCBlbXB0eSAgLi4uICovXG4gICAgd2hpbGUgKG5fc3RhY2sgPiAwKSB7XG5cbiAgICAgIC8qIC4uLiBwb3AgdGhlIHRvcC1tb3N0IGVudHJpZXMgb2ZmIHRoZSBzdGFja3MgKi9cblxuICAgICAgc3RhcnQgPSBzaWdfc3RhcnRbbl9zdGFjayAtIDFdO1xuICAgICAgZW5kID0gc2lnX2VuZFtuX3N0YWNrIC0gMV07XG4gICAgICBuX3N0YWNrLS07XG5cbiAgICAgIGlmICgoZW5kIC0gc3RhcnQpID4gMSkgeyAvKiBhbnkgaW50ZXJtZWRpYXRlIHBvaW50cyA/ICovXG5cbiAgICAgICAgLyogLi4uIHllcywgc28gZmluZCBtb3N0IGRldmlhbnQgaW50ZXJtZWRpYXRlIHBvaW50IHRvXG4gICAgICAgIGVpdGhlciBzaWRlIG9mIGxpbmUgam9pbmluZyBzdGFydCAmIGVuZCBwb2ludHMgKi9cblxuICAgICAgICB4MTIgPSAoc291cmNlW2VuZF0ubG5nKCkgLSBzb3VyY2Vbc3RhcnRdLmxuZygpKTtcbiAgICAgICAgeTEyID0gKHNvdXJjZVtlbmRdLmxhdCgpIC0gc291cmNlW3N0YXJ0XS5sYXQoKSk7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MTIpID4gMTgwLjApIHgxMiA9IDM2MC4wIC0gTWF0aC5hYnMoeDEyKTtcbiAgICAgICAgeDEyICo9IE1hdGguY29zKEYgKiAoc291cmNlW2VuZF0ubGF0KCkgKyBzb3VyY2Vbc3RhcnRdLmxhdCgpKSk7IC8qIHVzZSBhdmcgbGF0IHRvIHJlZHVjZSBsbmcgKi9cbiAgICAgICAgZDEyID0gKHgxMiAqIHgxMikgKyAoeTEyICogeTEyKTtcblxuICAgICAgICBmb3IgKGkgPSBzdGFydCArIDEsIHNpZyA9IHN0YXJ0LCBtYXhfZGV2X3NxciA9IC0xLjA7IGkgPCBlbmQ7IGkrKykge1xuXG4gICAgICAgICAgeDEzID0gc291cmNlW2ldLmxuZygpIC0gc291cmNlW3N0YXJ0XS5sbmcoKTtcbiAgICAgICAgICB5MTMgPSBzb3VyY2VbaV0ubGF0KCkgLSBzb3VyY2Vbc3RhcnRdLmxhdCgpO1xuICAgICAgICAgIGlmIChNYXRoLmFicyh4MTMpID4gMTgwLjApIHgxMyA9IDM2MC4wIC0gTWF0aC5hYnMoeDEzKTtcbiAgICAgICAgICB4MTMgKj0gTWF0aC5jb3MoRiAqIChzb3VyY2VbaV0ubGF0KCkgKyBzb3VyY2Vbc3RhcnRdLmxhdCgpKSk7XG4gICAgICAgICAgZDEzID0gKHgxMyAqIHgxMykgKyAoeTEzICogeTEzKTtcblxuICAgICAgICAgIHgyMyA9IHNvdXJjZVtpXS5sbmcoKSAtIHNvdXJjZVtlbmRdLmxuZygpO1xuICAgICAgICAgIHkyMyA9IHNvdXJjZVtpXS5sYXQoKSAtIHNvdXJjZVtlbmRdLmxhdCgpO1xuICAgICAgICAgIGlmIChNYXRoLmFicyh4MjMpID4gMTgwLjApIHgyMyA9IDM2MC4wIC0gTWF0aC5hYnMoeDIzKTtcbiAgICAgICAgICB4MjMgKj0gTWF0aC5jb3MoRiAqIChzb3VyY2VbaV0ubGF0KCkgKyBzb3VyY2VbZW5kXS5sYXQoKSkpO1xuICAgICAgICAgIGQyMyA9ICh4MjMgKiB4MjMpICsgKHkyMyAqIHkyMyk7XG5cbiAgICAgICAgICBpZiAoZDEzID49IChkMTIgKyBkMjMpKSBkZXZfc3FyID0gZDIzO1xuICAgICAgICAgIGVsc2UgaWYgKGQyMyA+PSAoZDEyICsgZDEzKSkgZGV2X3NxciA9IGQxMztcbiAgICAgICAgICBlbHNlIGRldl9zcXIgPSAoeDEzICogeTEyIC0geTEzICogeDEyKSAqICh4MTMgKiB5MTIgLSB5MTMgKiB4MTIpIC8gZDEyOyAvLyBzb2x2ZSB0cmlhbmdsZVxuICAgICAgICAgIGlmIChkZXZfc3FyID4gbWF4X2Rldl9zcXIpIHtcbiAgICAgICAgICAgIHNpZyA9IGk7XG4gICAgICAgICAgICBtYXhfZGV2X3NxciA9IGRldl9zcXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heF9kZXZfc3FyIDwgYmFuZF9zcXIpIHsgLyogaXMgdGhlcmUgYSBzaWcuIGludGVybWVkaWF0ZSBwb2ludCA/ICovXG4gICAgICAgICAgLyogLi4uIG5vLCBzbyB0cmFuc2ZlciBjdXJyZW50IHN0YXJ0IHBvaW50ICovXG4gICAgICAgICAgaW5kZXhbbl9kZXN0XSA9IHN0YXJ0O1xuICAgICAgICAgIG5fZGVzdCsrO1xuICAgICAgICB9IGVsc2UgeyAvKiAuLi4geWVzLCBzbyBwdXNoIHR3byBzdWItc2VjdGlvbnMgb24gc3RhY2sgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZyAqL1xuICAgICAgICAgIG5fc3RhY2srKztcbiAgICAgICAgICBzaWdfc3RhcnRbbl9zdGFjayAtIDFdID0gc2lnO1xuICAgICAgICAgIHNpZ19lbmRbbl9zdGFjayAtIDFdID0gZW5kO1xuICAgICAgICAgIG5fc3RhY2srKztcbiAgICAgICAgICBzaWdfc3RhcnRbbl9zdGFjayAtIDFdID0gc3RhcnQ7XG4gICAgICAgICAgc2lnX2VuZFtuX3N0YWNrIC0gMV0gPSBzaWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8qIC4uLiBubyBpbnRlcm1lZGlhdGUgcG9pbnRzLCBzbyB0cmFuc2ZlciBjdXJyZW50IHN0YXJ0IHBvaW50ICovXG4gICAgICAgIGluZGV4W25fZGVzdF0gPSBzdGFydDtcbiAgICAgICAgbl9kZXN0Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogdHJhbnNmZXIgbGFzdCBwb2ludCAqL1xuICAgIGluZGV4W25fZGVzdF0gPSBuX3NvdXJjZSAtIDE7XG4gICAgbl9kZXN0Kys7XG5cbiAgICAvKiBtYWtlIHJldHVybiBhcnJheSAqL1xuICAgIHZhciByID0gbmV3IEFycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2Rlc3Q7IGkrKylcbiAgICAgIHIucHVzaChzb3VyY2VbaW5kZXhbaV1dKTtcblxuICAgIHJldHVybiByLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogW28ubG5nLCBvLmxhdF1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sI2Rlc3RQb2ludFxuICBnanUuZGVzdGluYXRpb25Qb2ludCA9IGZ1bmN0aW9uIChwdCwgYnJuZywgZGlzdCkge1xuICAgIGRpc3QgPSBkaXN0LzYzNzE7ICAvLyBjb252ZXJ0IGRpc3QgdG8gYW5ndWxhciBkaXN0YW5jZSBpbiByYWRpYW5zXG4gICAgYnJuZyA9IGdqdS5udW1iZXJUb1JhZGl1cyhicm5nKTtcblxuICAgIHZhciBsb24xID0gZ2p1Lm51bWJlclRvUmFkaXVzKHB0LmNvb3JkaW5hdGVzWzBdKTtcbiAgICB2YXIgbGF0MSA9IGdqdS5udW1iZXJUb1JhZGl1cyhwdC5jb29yZGluYXRlc1sxXSk7XG5cbiAgICB2YXIgbGF0MiA9IE1hdGguYXNpbiggTWF0aC5zaW4obGF0MSkqTWF0aC5jb3MoZGlzdCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyhsYXQxKSpNYXRoLnNpbihkaXN0KSpNYXRoLmNvcyhicm5nKSApO1xuICAgIHZhciBsb24yID0gbG9uMSArIE1hdGguYXRhbjIoTWF0aC5zaW4oYnJuZykqTWF0aC5zaW4oZGlzdCkqTWF0aC5jb3MobGF0MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyhkaXN0KS1NYXRoLnNpbihsYXQxKSpNYXRoLnNpbihsYXQyKSk7XG4gICAgbG9uMiA9IChsb24yKzMqTWF0aC5QSSkgJSAoMipNYXRoLlBJKSAtIE1hdGguUEk7ICAvLyBub3JtYWxpc2UgdG8gLTE4MC4uKzE4MMK6XG5cbiAgICByZXR1cm4ge1xuICAgICAgJ3R5cGUnOiAnUG9pbnQnLFxuICAgICAgJ2Nvb3JkaW5hdGVzJzogW2dqdS5udW1iZXJUb0RlZ3JlZShsb24yKSwgZ2p1Lm51bWJlclRvRGVncmVlKGxhdDIpXVxuICAgIH07XG4gIH07XG5cbn0pKCk7XG4iLCIvKipcbiogQGxpY2Vuc2UgZ2V0LWNsb3Nlc3QgaHR0cHM6Ly9naXRodWIuY29tL2Nvc21vc2lvL2dldC1jbG9zZXN0XG4qXG4qIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNyBPbGl2aWVyIFNjaGVycmVyIDxwb2RlLmZyQGdtYWlsLmNvbT5cbiovXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZXQgdGhlIGNsb3Nlc3QgbnVtYmVyIGluIGFuIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gaXRlbSB0aGUgYmFzZSBudW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IHRoZSBhcnJheSB0byBzZWFyY2ggaW50b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0RGlmZiByZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGJhc2UgbnVtYmVyIGFuZFxuICogICBhbmQgdGhlIGN1cnJlbnRseSByZWFkIGl0ZW0gaW4gdGhlIGFycmF5LiBUaGUgaXRlbSB3aGljaCByZXR1cm5lZCB0aGUgc21hbGxlc3QgZGlmZmVyZW5jZSB3aW5zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldENsb3Nlc3QoaXRlbSwgYXJyYXksIGdldERpZmYpIHtcbiAgICB2YXIgY2xvc2VzdCxcbiAgICAgICAgZGlmZjtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2V0IGNsb3Nlc3QgZXhwZWN0cyBhbiBhcnJheSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gICAgfVxuXG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoY29tcGFyZWRJdGVtLCBjb21wYXJlZEl0ZW1JbmRleCkge1xuICAgICAgICB2YXIgdGhpc0RpZmYgPSBnZXREaWZmKGNvbXBhcmVkSXRlbSwgaXRlbSk7XG5cbiAgICAgICAgaWYgKHRoaXNEaWZmID49IDAgJiYgKHR5cGVvZiBkaWZmID09IFwidW5kZWZpbmVkXCIgfHwgdGhpc0RpZmYgPCBkaWZmKSkge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXNEaWZmO1xuICAgICAgICAgICAgY2xvc2VzdCA9IGNvbXBhcmVkSXRlbUluZGV4O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2xvc2VzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xvc2VzdCBudW1iZXIgaW4gYW4gYXJyYXkgZ2l2ZW4gYSBiYXNlIG51bWJlclxuICAgKiBFeGFtcGxlOiBjbG9zZXN0KDMwLCBbMjAsIDAsIDUwLCAyOV0pIHdpbGwgcmV0dXJuIDMgYXMgMjkgaXMgdGhlIGNsb3Nlc3QgaXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlbSB0aGUgYmFzZSBudW1iZXJcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgdGhlIGFycmF5IG9mIG51bWJlcnMgdG8gc2VhcmNoIGludG9cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGl0ZW0gaW4gdGhlIGFycmF5XG4gICAqL1xuICBudW1iZXI6IGZ1bmN0aW9uIGNsb3Nlc3ROdW1iZXIoaXRlbSwgYXJyYXkpIHtcbiAgICAgIHJldHVybiBfZ2V0Q2xvc2VzdChpdGVtLCBhcnJheSwgZnVuY3Rpb24gKGNvbXBhcmVkSXRlbSwgaXRlbSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhjb21wYXJlZEl0ZW0gLSBpdGVtKTtcbiAgICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsb3Nlc3QgZ3JlYXRlciBudW1iZXIgaW4gYW4gYXJyYXkgZ2l2ZW4gYSBiYXNlIG51bWJlclxuICAgKiBFeGFtcGxlOiBjbG9zZXN0KDMwLCBbMjAsIDAsIDUwLCAyOV0pIHdpbGwgcmV0dXJuIDIgYXMgNTAgaXMgdGhlIGNsb3Nlc3QgZ3JlYXRlciBpdGVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtIHRoZSBiYXNlIG51bWJlclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSB0aGUgYXJyYXkgb2YgbnVtYmVycyB0byBzZWFyY2ggaW50b1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgaXRlbSBpbiB0aGUgYXJyYXlcbiAgICovXG4gIGdyZWF0ZXJOdW1iZXI6IGZ1bmN0aW9uIGNsb3Nlc3RHcmVhdGVyTnVtYmVyKGl0ZW0sIGFycmF5KSB7XG4gICAgICByZXR1cm4gX2dldENsb3Nlc3QoaXRlbSwgYXJyYXksIGZ1bmN0aW9uIChjb21wYXJlZEl0ZW0sIGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyZWRJdGVtIC0gaXRlbTtcbiAgICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsb3Nlc3QgbG93ZXIgbnVtYmVyIGluIGFuIGFycmF5IGdpdmVuIGEgYmFzZSBudW1iZXJcbiAgICogRXhhbXBsZTogY2xvc2VzdCgzMCwgWzIwLCAwLCA1MCwgMjldKSB3aWxsIHJldHVybiAwIGFzIDIwIGlzIHRoZSBjbG9zZXN0IGxvd2VyIGl0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0gdGhlIGJhc2UgbnVtYmVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IHRoZSBhcnJheSBvZiBudW1iZXJzIHRvIHNlYXJjaCBpbnRvXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBpdGVtIGluIHRoZSBhcnJheVxuICAgKi9cbiAgbG93ZXJOdW1iZXI6IGZ1bmN0aW9uIGNsb3Nlc3RMb3dlck51bWJlcihpdGVtLCBhcnJheSkge1xuICAgIHJldHVybiBfZ2V0Q2xvc2VzdChpdGVtLCBhcnJheSwgZnVuY3Rpb24gKGNvbXBhcmVkSXRlbSwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAtIGNvbXBhcmVkSXRlbTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBjbG9zZXN0IGl0ZW0gaW4gYW4gYXJyYXkgZ2l2ZW4gYSBiYXNlIGl0ZW0gYW5kIGEgY29tcGFyYXRvciBmdW5jdGlvblxuICAgKiBFeGFtcGxlIChjbG9zZXN0KFwibHVuZGlcIiwgW1wibXVuZGlcIiwgXCJtYXJkaVwiXSwgZ2V0TGV2ZW5zaHRlaW5EaXN0YW5jZSkpIHdpbGwgcmV0dXJuIDAgZm9yIFwibHVuZGlcIlxuICAgKiBAcGFyYW0geyp9IGl0ZW0gdGhlIGJhc2UgaXRlbVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhbiBhcnJheSBvZiBpdGVtc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIGEgY29tcGFyYXRvZiBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBpdGVtc1xuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gbG9va3MgbGlrZTpcbiAgICpcbiAgICogLy8gY29tcGFyZWRJdGVtIGNvbWVzIGZyb20gdGhlIGFycmF5XG4gICAqIC8vIGJhc2VJdGVtIGlzIHRoZSBpdGVtIHRvIGNvbXBhcmUgdGhlIG90aGVycyB0b1xuICAgKiAvLyBJdCByZXR1cm5zIGEgbnVtYmVyXG4gICAqIGZ1bmN0aW9uIGNvbXBhcmF0b3IoY29tcGFyZWRJdGVtLCBiYXNlSXRlbSkge1xuICAgKiAgICAgcmV0dXJuIGNvbXBhcmVkSXRlbSAtIGJhc2VJdGVtO1xuICAgKiB9XG4gICAqL1xuICBjdXN0b206IGZ1bmN0aW9uIGNsb3Nlc3RDdXN0b20oaXRlbSwgYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gX2dldENsb3Nlc3QoaXRlbSwgYXJyYXksIGNvbXBhcmF0b3IpO1xuICB9XG5cbn07XG4iLCJ2YXIgaGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0cywgYmFzZSkge1xuICAgIGlmICghYmFzZSkgYmFzZSA9IDE2O1xuICAgIGlmIChiaXRzID09PSB1bmRlZmluZWQpIGJpdHMgPSAxMjg7XG4gICAgaWYgKGJpdHMgPD0gMCkgcmV0dXJuICcwJztcbiAgICBcbiAgICB2YXIgZGlnaXRzID0gTWF0aC5sb2coTWF0aC5wb3coMiwgYml0cykpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGRpZ2l0cyA9PT0gSW5maW5pdHk7IGkgKj0gMikge1xuICAgICAgICBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzIC8gaSkpIC8gTWF0aC5sb2coYmFzZSkgKiBpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcmVtID0gZGlnaXRzIC0gTWF0aC5mbG9vcihkaWdpdHMpO1xuICAgIFxuICAgIHZhciByZXMgPSAnJztcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGguZmxvb3IoZGlnaXRzKTsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZW0pIHtcbiAgICAgICAgdmFyIGIgPSBNYXRoLnBvdyhiYXNlLCByZW0pO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGIpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICByZXMgPSB4ICsgcmVzO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQocmVzLCBiYXNlKTtcbiAgICBpZiAocGFyc2VkICE9PSBJbmZpbml0eSAmJiBwYXJzZWQgPj0gTWF0aC5wb3coMiwgYml0cykpIHtcbiAgICAgICAgcmV0dXJuIGhhdChiaXRzLCBiYXNlKVxuICAgIH1cbiAgICBlbHNlIHJldHVybiByZXM7XG59O1xuXG5oYXQucmFjayA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlLCBleHBhbmRCeSkge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBpdGVycyA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpdGVycyArKyA+IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEJ5KSBiaXRzICs9IGV4cGFuZEJ5O1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSBJRCBjb2xsaXNpb25zLCB1c2UgbW9yZSBiaXRzJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGlkID0gaGF0KGJpdHMsIGJhc2UpO1xuICAgICAgICB9IHdoaWxlIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChoYXRzLCBpZCkpO1xuICAgICAgICBcbiAgICAgICAgaGF0c1tpZF0gPSBkYXRhO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICB2YXIgaGF0cyA9IGZuLmhhdHMgPSB7fTtcbiAgICBcbiAgICBmbi5nZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZuLmhhdHNbaWRdO1xuICAgIH07XG4gICAgXG4gICAgZm4uc2V0ID0gZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgICBmbi5oYXRzW2lkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBcbiAgICBmbi5iaXRzID0gYml0cyB8fCAxMjg7XG4gICAgZm4uYmFzZSA9IGJhc2UgfHwgMTY7XG4gICAgcmV0dXJuIGZuO1xufTtcbiIsIlwidXNlIHN0cmljdFwiXG5cbi8vSGlnaCBsZXZlbCBpZGVhOlxuLy8gMS4gVXNlIENsYXJrc29uJ3MgaW5jcmVtZW50YWwgY29uc3RydWN0aW9uIHRvIGZpbmQgY29udmV4IGh1bGxcbi8vIDIuIFBvaW50IGxvY2F0aW9uIGluIHRyaWFuZ3VsYXRpb24gYnkganVtcCBhbmQgd2Fsa1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluY3JlbWVudGFsQ29udmV4SHVsbFxuXG52YXIgb3JpZW50ID0gcmVxdWlyZShcInJvYnVzdC1vcmllbnRhdGlvblwiKVxudmFyIGNvbXBhcmVDZWxsID0gcmVxdWlyZShcInNpbXBsaWNpYWwtY29tcGxleFwiKS5jb21wYXJlQ2VsbHNcblxuZnVuY3Rpb24gY29tcGFyZUludChhLCBiKSB7XG4gIHJldHVybiBhIC0gYlxufVxuXG5mdW5jdGlvbiBTaW1wbGV4KHZlcnRpY2VzLCBhZGphY2VudCwgYm91bmRhcnkpIHtcbiAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzXG4gIHRoaXMuYWRqYWNlbnQgPSBhZGphY2VudFxuICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnlcbiAgdGhpcy5sYXN0VmlzaXRlZCA9IC0xXG59XG5cblNpbXBsZXgucHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLnZlcnRpY2VzWzBdXG4gIHRoaXMudmVydGljZXNbMF0gPSB0aGlzLnZlcnRpY2VzWzFdXG4gIHRoaXMudmVydGljZXNbMV0gPSB0XG4gIHZhciB1ID0gdGhpcy5hZGphY2VudFswXVxuICB0aGlzLmFkamFjZW50WzBdID0gdGhpcy5hZGphY2VudFsxXVxuICB0aGlzLmFkamFjZW50WzFdID0gdVxufVxuXG5mdW5jdGlvbiBHbHVlRmFjZXQodmVydGljZXMsIGNlbGwsIGluZGV4KSB7XG4gIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlc1xuICB0aGlzLmNlbGwgPSBjZWxsXG4gIHRoaXMuaW5kZXggPSBpbmRleFxufVxuXG5mdW5jdGlvbiBjb21wYXJlR2x1ZShhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlQ2VsbChhLnZlcnRpY2VzLCBiLnZlcnRpY2VzKVxufVxuXG5mdW5jdGlvbiBiYWtlT3JpZW50KGQpIHtcbiAgdmFyIGNvZGUgPSBbXCJmdW5jdGlvbiBvcmllbnQoKXt2YXIgdHVwbGU9dGhpcy50dXBsZTtyZXR1cm4gdGVzdChcIl1cbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIGlmKGkgPiAwKSB7XG4gICAgICBjb2RlLnB1c2goXCIsXCIpXG4gICAgfVxuICAgIGNvZGUucHVzaChcInR1cGxlW1wiLCBpLCBcIl1cIilcbiAgfVxuICBjb2RlLnB1c2goXCIpfXJldHVybiBvcmllbnRcIilcbiAgdmFyIHByb2MgPSBuZXcgRnVuY3Rpb24oXCJ0ZXN0XCIsIGNvZGUuam9pbihcIlwiKSlcbiAgdmFyIHRlc3QgPSBvcmllbnRbZCsxXVxuICBpZighdGVzdCkge1xuICAgIHRlc3QgPSBvcmllbnRcbiAgfVxuICByZXR1cm4gcHJvYyh0ZXN0KVxufVxuXG52YXIgQkFLRUQgPSBbXVxuXG5mdW5jdGlvbiBUcmlhbmd1bGF0aW9uKGRpbWVuc2lvbiwgdmVydGljZXMsIHNpbXBsaWNlcykge1xuICB0aGlzLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXNcbiAgdGhpcy5zaW1wbGljZXMgPSBzaW1wbGljZXNcbiAgdGhpcy5pbnRlcmlvciA9IHNpbXBsaWNlcy5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIHJldHVybiAhYy5ib3VuZGFyeVxuICB9KVxuXG4gIHRoaXMudHVwbGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKzEpXG4gIGZvcih2YXIgaT0wOyBpPD1kaW1lbnNpb247ICsraSkge1xuICAgIHRoaXMudHVwbGVbaV0gPSB0aGlzLnZlcnRpY2VzW2ldXG4gIH1cblxuICB2YXIgbyA9IEJBS0VEW2RpbWVuc2lvbl1cbiAgaWYoIW8pIHtcbiAgICBvID0gQkFLRURbZGltZW5zaW9uXSA9IGJha2VPcmllbnQoZGltZW5zaW9uKVxuICB9XG4gIHRoaXMub3JpZW50ID0gb1xufVxuXG52YXIgcHJvdG8gPSBUcmlhbmd1bGF0aW9uLnByb3RvdHlwZVxuXG4vL0RlZ2VuZXJhdGUgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSBvbiBib3VuZGFyeSwgYnV0IGNvcGxhbmFyIHRvIGZhY2VcbnByb3RvLmhhbmRsZUJvdW5kYXJ5RGVnZW5lcmFjeSA9IGZ1bmN0aW9uKGNlbGwsIHBvaW50KSB7XG4gIHZhciBkID0gdGhpcy5kaW1lbnNpb25cbiAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDFcbiAgdmFyIHR1cGxlID0gdGhpcy50dXBsZVxuICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzXG5cbiAgLy9EdW1iIHNvbHV0aW9uOiBKdXN0IGRvIGRmcyBmcm9tIGJvdW5kYXJ5IGNlbGwgdW50aWwgd2UgZmluZCBhbnkgcGVhaywgb3IgdGVybWluYXRlXG4gIHZhciB0b1Zpc2l0ID0gWyBjZWxsIF1cbiAgY2VsbC5sYXN0VmlzaXRlZCA9IC1uXG4gIHdoaWxlKHRvVmlzaXQubGVuZ3RoID4gMCkge1xuICAgIGNlbGwgPSB0b1Zpc2l0LnBvcCgpXG4gICAgdmFyIGNlbGxWZXJ0cyA9IGNlbGwudmVydGljZXNcbiAgICB2YXIgY2VsbEFkaiA9IGNlbGwuYWRqYWNlbnRcbiAgICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBjZWxsQWRqW2ldXG4gICAgICBpZighbmVpZ2hib3IuYm91bmRhcnkgfHwgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPD0gLW4pIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHZhciBudiA9IG5laWdoYm9yLnZlcnRpY2VzXG4gICAgICBmb3IodmFyIGo9MDsgajw9ZDsgKytqKSB7XG4gICAgICAgIHZhciB2diA9IG52W2pdXG4gICAgICAgIGlmKHZ2IDwgMCkge1xuICAgICAgICAgIHR1cGxlW2pdID0gcG9pbnRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0dXBsZVtqXSA9IHZlcnRzW3Z2XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbyA9IHRoaXMub3JpZW50KClcbiAgICAgIGlmKG8gPiAwKSB7XG4gICAgICAgIHJldHVybiBuZWlnaGJvclxuICAgICAgfVxuICAgICAgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPSAtblxuICAgICAgaWYobyA9PT0gMCkge1xuICAgICAgICB0b1Zpc2l0LnB1c2gobmVpZ2hib3IpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbnByb3RvLndhbGsgPSBmdW5jdGlvbihwb2ludCwgcmFuZG9tKSB7XG4gIC8vQWxpYXMgbG9jYWwgcHJvcGVydGllc1xuICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMVxuICB2YXIgZCA9IHRoaXMuZGltZW5zaW9uXG4gIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXNcbiAgdmFyIHR1cGxlID0gdGhpcy50dXBsZVxuXG4gIC8vQ29tcHV0ZSBpbml0aWFsIGp1bXAgY2VsbFxuICB2YXIgaW5pdEluZGV4ID0gcmFuZG9tID8gKHRoaXMuaW50ZXJpb3IubGVuZ3RoICogTWF0aC5yYW5kb20oKSl8MCA6ICh0aGlzLmludGVyaW9yLmxlbmd0aC0xKVxuICB2YXIgY2VsbCA9IHRoaXMuaW50ZXJpb3JbIGluaXRJbmRleCBdXG5cbiAgLy9TdGFydCB3YWxraW5nXG5vdXRlckxvb3A6XG4gIHdoaWxlKCFjZWxsLmJvdW5kYXJ5KSB7XG4gICAgdmFyIGNlbGxWZXJ0cyA9IGNlbGwudmVydGljZXNcbiAgICB2YXIgY2VsbEFkaiA9IGNlbGwuYWRqYWNlbnRcblxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIHR1cGxlW2ldID0gdmVydHNbY2VsbFZlcnRzW2ldXVxuICAgIH1cbiAgICBjZWxsLmxhc3RWaXNpdGVkID0gblxuXG4gICAgLy9GaW5kIGZhcnRoZXN0IGFkamFjZW50IGNlbGxcbiAgICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBjZWxsQWRqW2ldXG4gICAgICBpZihuZWlnaGJvci5sYXN0VmlzaXRlZCA+PSBuKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB2YXIgcHJldiA9IHR1cGxlW2ldXG4gICAgICB0dXBsZVtpXSA9IHBvaW50XG4gICAgICB2YXIgbyA9IHRoaXMub3JpZW50KClcbiAgICAgIHR1cGxlW2ldID0gcHJldlxuICAgICAgaWYobyA8IDApIHtcbiAgICAgICAgY2VsbCA9IG5laWdoYm9yXG4gICAgICAgIGNvbnRpbnVlIG91dGVyTG9vcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIW5laWdoYm9yLmJvdW5kYXJ5KSB7XG4gICAgICAgICAgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPSBuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPSAtblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgcmV0dXJuIGNlbGxcbn1cblxucHJvdG8uYWRkUGVha3MgPSBmdW5jdGlvbihwb2ludCwgY2VsbCkge1xuICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMVxuICB2YXIgZCA9IHRoaXMuZGltZW5zaW9uXG4gIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXNcbiAgdmFyIHR1cGxlID0gdGhpcy50dXBsZVxuICB2YXIgaW50ZXJpb3IgPSB0aGlzLmludGVyaW9yXG4gIHZhciBzaW1wbGljZXMgPSB0aGlzLnNpbXBsaWNlc1xuXG4gIC8vV2Fsa2luZyBmaW5pc2hlZCBhdCBib3VuZGFyeSwgdGltZSB0byBhZGQgcGVha3NcbiAgdmFyIHRvdmlzaXQgPSBbIGNlbGwgXVxuXG4gIC8vU3RyZXRjaCBpbml0aWFsIGJvdW5kYXJ5IGNlbGwgaW50byBhIHBlYWtcbiAgY2VsbC5sYXN0VmlzaXRlZCA9IG5cbiAgY2VsbC52ZXJ0aWNlc1tjZWxsLnZlcnRpY2VzLmluZGV4T2YoLTEpXSA9IG5cbiAgY2VsbC5ib3VuZGFyeSA9IGZhbHNlXG4gIGludGVyaW9yLnB1c2goY2VsbClcblxuICAvL1JlY29yZCBhIGxpc3Qgb2YgYWxsIG5ldyBib3VuZGFyaWVzIGNyZWF0ZWQgYnkgYWRkZWQgcGVha3Mgc28gd2UgY2FuIGdsdWUgdGhlbSB0b2dldGhlciB3aGVuIHdlIGFyZSBhbGwgZG9uZVxuICB2YXIgZ2x1ZUZhY2V0cyA9IFtdXG5cbiAgLy9EbyBhIHRyYXZlcnNhbCBvZiB0aGUgYm91bmRhcnkgd2Fsa2luZyBvdXR3YXJkIGZyb20gc3RhcnRpbmcgcGVha1xuICB3aGlsZSh0b3Zpc2l0Lmxlbmd0aCA+IDApIHtcbiAgICAvL1BvcCBvZmYgcGVhayBhbmQgd2FsayBvdmVyIGFkamFjZW50IGNlbGxzXG4gICAgdmFyIGNlbGwgPSB0b3Zpc2l0LnBvcCgpXG4gICAgdmFyIGNlbGxWZXJ0cyA9IGNlbGwudmVydGljZXNcbiAgICB2YXIgY2VsbEFkaiA9IGNlbGwuYWRqYWNlbnRcbiAgICB2YXIgaW5kZXhPZk4gPSBjZWxsVmVydHMuaW5kZXhPZihuKVxuICAgIGlmKGluZGV4T2ZOIDwgMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgICBpZihpID09PSBpbmRleE9mTikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvL0ZvciBlYWNoIGJvdW5kYXJ5IG5laWdoYm9yIG9mIHRoZSBjZWxsXG4gICAgICB2YXIgbmVpZ2hib3IgPSBjZWxsQWRqW2ldXG4gICAgICBpZighbmVpZ2hib3IuYm91bmRhcnkgfHwgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPj0gbikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgbnYgPSBuZWlnaGJvci52ZXJ0aWNlc1xuXG4gICAgICAvL1Rlc3QgaWYgbmVpZ2hib3IgaXMgYSBwZWFrXG4gICAgICBpZihuZWlnaGJvci5sYXN0VmlzaXRlZCAhPT0gLW4pIHsgICAgICBcbiAgICAgICAgLy9Db21wdXRlIG9yaWVudGF0aW9uIG9mIHAgcmVsYXRpdmUgdG8gZWFjaCBib3VuZGFyeSBwZWFrXG4gICAgICAgIHZhciBpbmRleE9mTmVnMSA9IDBcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgICAgIGlmKG52W2pdIDwgMCkge1xuICAgICAgICAgICAgaW5kZXhPZk5lZzEgPSBqXG4gICAgICAgICAgICB0dXBsZVtqXSA9IHBvaW50XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1cGxlW2pdID0gdmVydHNbbnZbal1dXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvID0gdGhpcy5vcmllbnQoKVxuXG4gICAgICAgIC8vVGVzdCBpZiBuZWlnaGJvciBjZWxsIGlzIGFsc28gYSBwZWFrXG4gICAgICAgIGlmKG8gPiAwKSB7XG4gICAgICAgICAgbnZbaW5kZXhPZk5lZzFdID0gblxuICAgICAgICAgIG5laWdoYm9yLmJvdW5kYXJ5ID0gZmFsc2VcbiAgICAgICAgICBpbnRlcmlvci5wdXNoKG5laWdoYm9yKVxuICAgICAgICAgIHRvdmlzaXQucHVzaChuZWlnaGJvcilcbiAgICAgICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5laWdoYm9yLmxhc3RWaXNpdGVkID0gLW5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmEgPSBuZWlnaGJvci5hZGphY2VudFxuXG4gICAgICAvL090aGVyd2lzZSwgcmVwbGFjZSBuZWlnaGJvciB3aXRoIG5ldyBmYWNlXG4gICAgICB2YXIgdnZlcnRzID0gY2VsbFZlcnRzLnNsaWNlKClcbiAgICAgIHZhciB2YWRqID0gY2VsbEFkai5zbGljZSgpXG4gICAgICB2YXIgbmNlbGwgPSBuZXcgU2ltcGxleCh2dmVydHMsIHZhZGosIHRydWUpXG4gICAgICBzaW1wbGljZXMucHVzaChuY2VsbClcblxuICAgICAgLy9Db25uZWN0IHRvIG5laWdoYm9yXG4gICAgICB2YXIgb3Bwb3NpdGUgPSBuYS5pbmRleE9mKGNlbGwpXG4gICAgICBpZihvcHBvc2l0ZSA8IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIG5hW29wcG9zaXRlXSA9IG5jZWxsXG4gICAgICB2YWRqW2luZGV4T2ZOXSA9IG5laWdoYm9yXG5cbiAgICAgIC8vQ29ubmVjdCB0byBjZWxsXG4gICAgICB2dmVydHNbaV0gPSAtMVxuICAgICAgdmFkaltpXSA9IGNlbGxcbiAgICAgIGNlbGxBZGpbaV0gPSBuY2VsbFxuXG4gICAgICAvL0ZsaXAgZmFjZXRcbiAgICAgIG5jZWxsLmZsaXAoKVxuXG4gICAgICAvL0FkZCB0byBnbHVlIGxpc3RcbiAgICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgICAgdmFyIHV1ID0gdnZlcnRzW2pdXG4gICAgICAgIGlmKHV1IDwgMCB8fCB1dSA9PT0gbikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5mYWNlID0gbmV3IEFycmF5KGQtMSlcbiAgICAgICAgdmFyIG5wdHIgPSAwXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPD1kOyArK2spIHtcbiAgICAgICAgICB2YXIgdnYgPSB2dmVydHNba11cbiAgICAgICAgICBpZih2diA8IDAgfHwgayA9PT0gaikge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgbmZhY2VbbnB0cisrXSA9IHZ2XG4gICAgICAgIH1cbiAgICAgICAgZ2x1ZUZhY2V0cy5wdXNoKG5ldyBHbHVlRmFjZXQobmZhY2UsIG5jZWxsLCBqKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL0dsdWUgYm91bmRhcnkgZmFjZXRzIHRvZ2V0aGVyXG4gIGdsdWVGYWNldHMuc29ydChjb21wYXJlR2x1ZSlcblxuICBmb3IodmFyIGk9MDsgaSsxPGdsdWVGYWNldHMubGVuZ3RoOyBpKz0yKSB7XG4gICAgdmFyIGEgPSBnbHVlRmFjZXRzW2ldXG4gICAgdmFyIGIgPSBnbHVlRmFjZXRzW2krMV1cbiAgICB2YXIgYWkgPSBhLmluZGV4XG4gICAgdmFyIGJpID0gYi5pbmRleFxuICAgIGlmKGFpIDwgMCB8fCBiaSA8IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGEuY2VsbC5hZGphY2VudFthLmluZGV4XSA9IGIuY2VsbFxuICAgIGIuY2VsbC5hZGphY2VudFtiLmluZGV4XSA9IGEuY2VsbFxuICB9XG59XG5cbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKHBvaW50LCByYW5kb20pIHtcbiAgLy9BZGQgcG9pbnRcbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlc1xuICB2ZXJ0cy5wdXNoKHBvaW50KVxuXG4gIHZhciBjZWxsID0gdGhpcy53YWxrKHBvaW50LCByYW5kb20pXG4gIGlmKCFjZWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL0FsaWFzIGxvY2FsIHByb3BlcnRpZXNcbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG5cbiAgLy9EZWdlbmVyYXRlIGNhc2U6IElmIHBvaW50IGlzIGNvcGxhbmFyIHRvIGNlbGwsIHRoZW4gd2FsayB1bnRpbCB3ZSBmaW5kIGEgbm9uLWRlZ2VuZXJhdGUgYm91bmRhcnlcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIHZhciB2diA9IGNlbGwudmVydGljZXNbaV1cbiAgICBpZih2diA8IDApIHtcbiAgICAgIHR1cGxlW2ldID0gcG9pbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdHVwbGVbaV0gPSB2ZXJ0c1t2dl1cbiAgICB9XG4gIH1cbiAgdmFyIG8gPSB0aGlzLm9yaWVudCh0dXBsZSlcbiAgaWYobyA8IDApIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmKG8gPT09IDApIHtcbiAgICBjZWxsID0gdGhpcy5oYW5kbGVCb3VuZGFyeURlZ2VuZXJhY3koY2VsbCwgcG9pbnQpXG4gICAgaWYoIWNlbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIC8vQWRkIHBlYWtzXG4gIHRoaXMuYWRkUGVha3MocG9pbnQsIGNlbGwpXG59XG5cbi8vRXh0cmFjdCBhbGwgYm91bmRhcnkgY2VsbHNcbnByb3RvLmJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gdGhpcy5kaW1lbnNpb25cbiAgdmFyIGJvdW5kYXJ5ID0gW11cbiAgdmFyIGNlbGxzID0gdGhpcy5zaW1wbGljZXNcbiAgdmFyIG5jID0gY2VsbHMubGVuZ3RoXG4gIGZvcih2YXIgaT0wOyBpPG5jOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgaWYoYy5ib3VuZGFyeSkge1xuICAgICAgdmFyIGJjZWxsID0gbmV3IEFycmF5KGQpXG4gICAgICB2YXIgY3YgPSBjLnZlcnRpY2VzXG4gICAgICB2YXIgcHRyID0gMFxuICAgICAgdmFyIHBhcml0eSA9IDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgICAgaWYoY3Zbal0gPj0gMCkge1xuICAgICAgICAgIGJjZWxsW3B0cisrXSA9IGN2W2pdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyaXR5ID0gaiYxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHBhcml0eSA9PT0gKGQmMSkpIHtcbiAgICAgICAgdmFyIHQgPSBiY2VsbFswXVxuICAgICAgICBiY2VsbFswXSA9IGJjZWxsWzFdXG4gICAgICAgIGJjZWxsWzFdID0gdFxuICAgICAgfVxuICAgICAgYm91bmRhcnkucHVzaChiY2VsbClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5XG59XG5cbmZ1bmN0aW9uIGluY3JlbWVudGFsQ29udmV4SHVsbChwb2ludHMsIHJhbmRvbVNlYXJjaCkge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcbiAgaWYobiA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgaGF2ZSBhdCBsZWFzdCBkKzEgcG9pbnRzXCIpXG4gIH1cbiAgdmFyIGQgPSBwb2ludHNbMF0ubGVuZ3RoXG4gIGlmKG4gPD0gZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgaW5wdXQgYXQgbGVhc3QgZCsxIHBvaW50c1wiKVxuICB9XG5cbiAgLy9GSVhNRTogVGhpcyBjb3VsZCBiZSBkZWdlbmVyYXRlLCBidXQgbmVlZCB0byBzZWxlY3QgZCsxIG5vbi1jb3BsYW5hciBwb2ludHMgdG8gYm9vdHN0cmFwIHByb2Nlc3NcbiAgdmFyIGluaXRpYWxTaW1wbGV4ID0gcG9pbnRzLnNsaWNlKDAsIGQrMSlcblxuICAvL01ha2Ugc3VyZSBpbml0aWFsIHNpbXBsZXggaXMgcG9zaXRpdmVseSBvcmllbnRlZFxuICB2YXIgbyA9IG9yaWVudC5hcHBseSh2b2lkIDAsIGluaXRpYWxTaW1wbGV4KVxuICBpZihvID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbm90IGluIGdlbmVyYWwgcG9zaXRpb25cIilcbiAgfVxuICB2YXIgaW5pdGlhbENvb3JkcyA9IG5ldyBBcnJheShkKzEpXG4gIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICBpbml0aWFsQ29vcmRzW2ldID0gaVxuICB9XG4gIGlmKG8gPCAwKSB7XG4gICAgaW5pdGlhbENvb3Jkc1swXSA9IDFcbiAgICBpbml0aWFsQ29vcmRzWzFdID0gMFxuICB9XG5cbiAgLy9DcmVhdGUgaW5pdGlhbCB0b3BvbG9naWNhbCBpbmRleCwgZ2x1ZSBwb2ludGVycyB0b2dldGhlciAoa2luZCBvZiBtZXNzeSlcbiAgdmFyIGluaXRpYWxDZWxsID0gbmV3IFNpbXBsZXgoaW5pdGlhbENvb3JkcywgbmV3IEFycmF5KGQrMSksIGZhbHNlKVxuICB2YXIgYm91bmRhcnkgPSBpbml0aWFsQ2VsbC5hZGphY2VudFxuICB2YXIgbGlzdCA9IG5ldyBBcnJheShkKzIpXG4gIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICB2YXIgdmVydHMgPSBpbml0aWFsQ29vcmRzLnNsaWNlKClcbiAgICBmb3IodmFyIGo9MDsgajw9ZDsgKytqKSB7XG4gICAgICBpZihqID09PSBpKSB7XG4gICAgICAgIHZlcnRzW2pdID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHQgPSB2ZXJ0c1swXVxuICAgIHZlcnRzWzBdID0gdmVydHNbMV1cbiAgICB2ZXJ0c1sxXSA9IHRcbiAgICB2YXIgY2VsbCA9IG5ldyBTaW1wbGV4KHZlcnRzLCBuZXcgQXJyYXkoZCsxKSwgdHJ1ZSlcbiAgICBib3VuZGFyeVtpXSA9IGNlbGxcbiAgICBsaXN0W2ldID0gY2VsbFxuICB9XG4gIGxpc3RbZCsxXSA9IGluaXRpYWxDZWxsXG4gIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICB2YXIgdmVydHMgPSBib3VuZGFyeVtpXS52ZXJ0aWNlc1xuICAgIHZhciBhZGogPSBib3VuZGFyeVtpXS5hZGphY2VudFxuICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgIHZhciB2ID0gdmVydHNbal1cbiAgICAgIGlmKHYgPCAwKSB7XG4gICAgICAgIGFkaltqXSA9IGluaXRpYWxDZWxsXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmb3IodmFyIGs9MDsgazw9ZDsgKytrKSB7XG4gICAgICAgIGlmKGJvdW5kYXJ5W2tdLnZlcnRpY2VzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgICAgYWRqW2pdID0gYm91bmRhcnlba11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vSW5pdGlhbGl6ZSB0cmlhbmdsZXNcbiAgdmFyIHRyaWFuZ2xlcyA9IG5ldyBUcmlhbmd1bGF0aW9uKGQsIGluaXRpYWxTaW1wbGV4LCBsaXN0KVxuXG4gIC8vSW5zZXJ0IHJlbWFpbmluZyBwb2ludHNcbiAgdmFyIHVzZVJhbmRvbSA9ICEhcmFuZG9tU2VhcmNoXG4gIGZvcih2YXIgaT1kKzE7IGk8bjsgKytpKSB7XG4gICAgdHJpYW5nbGVzLmluc2VydChwb2ludHNbaV0sIHVzZVJhbmRvbSlcbiAgfVxuICBcbiAgLy9FeHRyYWN0IGJvdW5kYXJ5IGNlbGxzXG4gIHJldHVybiB0cmlhbmdsZXMuYm91bmRhcnkoKVxufSIsIi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE3ICovXG4vKlxuICBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblxuICBQYXJzZXI6IHtcbiAgICB5eToge31cbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGU6IHtcbiAgICB5eToge30sXG4gICAgdHJhY2U6IGZ1bmN0aW9uKCksXG4gICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LFxuICAgIHByb2R1Y3Rpb25zXzogWy4uLl0sXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksXG4gICAgdGFibGU6IFsuLi5dLFxuICAgIGRlZmF1bHRBY3Rpb25zOiB7Li4ufSxcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksXG5cbiAgICBsZXhlcjoge1xuICAgICAgICBFT0Y6IDEsXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCksXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAgICAgICAgbW9yZTogZnVuY3Rpb24oKSxcbiAgICAgICAgbGVzczogZnVuY3Rpb24obiksXG4gICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxleDogZnVuY3Rpb24oKSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJhbmdlczogYm9vbGVhbiAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlcilcbiAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaClcbiAgICAgICAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhbiAgKG9wdGlvbmFsOiB0cnVlID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBlYWNoIG1hdGNoaW5nIHJlZ2V4IHRoZSBhY3Rpb24gY29kZSBpcyBpbnZva2VkOyB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlKVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSxcbiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAgICB9XG4gIH1cblxuXG4gIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAgICBmaXJzdF9saW5lOiBuLFxuICAgIGxhc3RfbGluZTogbixcbiAgICBmaXJzdF9jb2x1bW46IG4sXG4gICAgbGFzdF9jb2x1bW46IG4sXG4gICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHJlZ3VsYXIgemVyby1iYXNlZClcbiAgfVxuXG5cbiAgdGhlIHBhcnNlRXJyb3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgYW5kIHBhcnNlciBlcnJvcnM6IHtcbiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gIH1cbiAgd2hpbGUgcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgbWVtYmVycywgaS5lLiBwYXJzZXIgZXJyb3JzIGRlbGl2ZXIgYSBzdXBlcnNldCBvZiBhdHRyaWJ1dGVzOiB7XG4gICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucylcbiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIGhhcyBhIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gIH1cbiovXG52YXIganNvbmxpbnQgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSwxMl0sJFYxPVsxLDEzXSwkVjI9WzEsOV0sJFYzPVsxLDEwXSwkVjQ9WzEsMTFdLCRWNT1bMSwxNF0sJFY2PVsxLDE1XSwkVjc9WzE0LDE4LDIyLDI0XSwkVjg9WzE4LDIyXSwkVjk9WzIyLDI0XTtcbnZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LFxueXk6IHt9LFxuc3ltYm9sc186IHtcImVycm9yXCI6MixcIkpTT05TdHJpbmdcIjozLFwiU1RSSU5HXCI6NCxcIkpTT05OdW1iZXJcIjo1LFwiTlVNQkVSXCI6NixcIkpTT05OdWxsTGl0ZXJhbFwiOjcsXCJOVUxMXCI6OCxcIkpTT05Cb29sZWFuTGl0ZXJhbFwiOjksXCJUUlVFXCI6MTAsXCJGQUxTRVwiOjExLFwiSlNPTlRleHRcIjoxMixcIkpTT05WYWx1ZVwiOjEzLFwiRU9GXCI6MTQsXCJKU09OT2JqZWN0XCI6MTUsXCJKU09OQXJyYXlcIjoxNixcIntcIjoxNyxcIn1cIjoxOCxcIkpTT05NZW1iZXJMaXN0XCI6MTksXCJKU09OTWVtYmVyXCI6MjAsXCI6XCI6MjEsXCIsXCI6MjIsXCJbXCI6MjMsXCJdXCI6MjQsXCJKU09ORWxlbWVudExpc3RcIjoyNSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDQ6XCJTVFJJTkdcIiw2OlwiTlVNQkVSXCIsODpcIk5VTExcIiwxMDpcIlRSVUVcIiwxMTpcIkZBTFNFXCIsMTQ6XCJFT0ZcIiwxNzpcIntcIiwxODpcIn1cIiwyMTpcIjpcIiwyMjpcIixcIiwyMzpcIltcIiwyNDpcIl1cIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDFdLFs1LDFdLFs3LDFdLFs5LDFdLFs5LDFdLFsxMiwyXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTUsMl0sWzE1LDNdLFsyMCwzXSxbMTksMV0sWzE5LDNdLFsxNiwyXSxbMTYsM10sWzI1LDFdLFsyNSwzXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbiAvLyByZXBsYWNlIGVzY2FwZWQgY2hhcmFjdGVycyB3aXRoIGFjdHVhbCBjaGFyYWN0ZXJcbiAgICAgICAgICB0aGlzLiQgPSB5eXRleHQucmVwbGFjZSgvXFxcXChcXFxcfFwiKS9nLCBcIiRcIitcIjFcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcbi9nLCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxyL2csJ1xccicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHQvZywnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdi9nLCdcXHYnKVxuICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxmL2csJ1xcZicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXGIvZywnXFxiJyk7XG4gICAgICAgIFxuYnJlYWs7XG5jYXNlIDI6XG50aGlzLiQgPSBOdW1iZXIoeXl0ZXh0KTtcbmJyZWFrO1xuY2FzZSAzOlxudGhpcy4kID0gbnVsbDtcbmJyZWFrO1xuY2FzZSA0OlxudGhpcy4kID0gdHJ1ZTtcbmJyZWFrO1xuY2FzZSA1OlxudGhpcy4kID0gZmFsc2U7XG5icmVhaztcbmNhc2UgNjpcbnJldHVybiB0aGlzLiQgPSAkJFskMC0xXTtcbmJyZWFrO1xuY2FzZSAxMzpcbnRoaXMuJCA9IHt9OyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSlcbmJyZWFrO1xuY2FzZSAxNDogY2FzZSAxOTpcbnRoaXMuJCA9ICQkWyQwLTFdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSlcbmJyZWFrO1xuY2FzZSAxNTpcbnRoaXMuJCA9IFskJFskMC0yXSwgJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxNjpcbnRoaXMuJCA9IHt9OyB0aGlzLiRbJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbmJyZWFrO1xuY2FzZSAxNzpcblxuICAgICAgICAgICAgdGhpcy4kID0gJCRbJDAtMl07XG4gICAgICAgICAgICBpZiAoJCRbJDAtMl1bJCRbJDBdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiQuX19kdXBsaWNhdGVQcm9wZXJ0aWVzX18pIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fZHVwbGljYXRlUHJvcGVydGllc19fJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJC5fX2R1cGxpY2F0ZVByb3BlcnRpZXNfXy5wdXNoKCQkWyQwXVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkJFskMC0yXVskJFskMF1bMF1dID0gJCRbJDBdWzFdO1xuICAgICAgICBcbmJyZWFrO1xuY2FzZSAxODpcbnRoaXMuJCA9IFtdOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSlcbmJyZWFrO1xuY2FzZSAyMDpcbnRoaXMuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDIxOlxudGhpcy4kID0gJCRbJDAtMl07ICQkWyQwLTJdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEyOjEsMTM6MiwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sezE6WzNdfSx7MTQ6WzEsMTZdfSxvKCRWNyxbMiw3XSksbygkVjcsWzIsOF0pLG8oJFY3LFsyLDldKSxvKCRWNyxbMiwxMF0pLG8oJFY3LFsyLDExXSksbygkVjcsWzIsMTJdKSxvKCRWNyxbMiwzXSksbygkVjcsWzIsNF0pLG8oJFY3LFsyLDVdKSxvKFsxNCwxOCwyMSwyMiwyNF0sWzIsMV0pLG8oJFY3LFsyLDJdKSx7MzoyMCw0OiRWMCwxODpbMSwxN10sMTk6MTgsMjA6MTl9LHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzoyMywxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNiwyNDpbMSwyMV0sMjU6MjJ9LHsxOlsyLDZdfSxvKCRWNyxbMiwxM10pLHsxODpbMSwyNF0sMjI6WzEsMjVdfSxvKCRWOCxbMiwxNl0pLHsyMTpbMSwyNl19LG8oJFY3LFsyLDE4XSksezIyOlsxLDI4XSwyNDpbMSwyN119LG8oJFY5LFsyLDIwXSksbygkVjcsWzIsMTRdKSx7MzoyMCw0OiRWMCwyMDoyOX0sezM6NSw0OiRWMCw1OjYsNjokVjEsNzozLDg6JFYyLDk6NCwxMDokVjMsMTE6JFY0LDEzOjMwLDE1OjcsMTY6OCwxNzokVjUsMjM6JFY2fSxvKCRWNyxbMiwxOV0pLHszOjUsNDokVjAsNTo2LDY6JFYxLDc6Myw4OiRWMiw5OjQsMTA6JFYzLDExOiRWNCwxMzozMSwxNTo3LDE2OjgsMTc6JFY1LDIzOiRWNn0sbygkVjgsWzIsMTddKSxvKCRWOCxbMiwxNV0pLG8oJFY5LFsyLDIxXSldLFxuZGVmYXVsdEFjdGlvbnM6IHsxNjpbMiw2XX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBfcGFyc2VFcnJvciAobXNnLCBoYXNoKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG4gICAgICAgIHRocm93IG5ldyBfcGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHN0YWNrID0gWzBdLCB0c3RhY2sgPSBbXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSAnJywgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cbiAgICBfdG9rZW5fc3RhY2s6XG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfTtcbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goJ1xcJycgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOlxcbicgKyBsZXhlci5zaG93UG9zaXRpb24oKSArICdcXG5FeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzogVW5leHBlY3RlZCAnICsgKHN5bWJvbCA9PSBFT0YgPyAnZW5kIG9mIGlucHV0JyA6ICdcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHl5bG9jLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gcHJlRXJyb3JTeW1ib2w7XG4gICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xuICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2NvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbXG4gICAgICAgICAgICAgICAgeXl0ZXh0LFxuICAgICAgICAgICAgICAgIHl5bGVuZyxcbiAgICAgICAgICAgICAgICB5eWxpbmVubyxcbiAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSxcbiAgICAgICAgICAgICAgICBhY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgdnN0YWNrLFxuICAgICAgICAgICAgICAgIGxzdGFja1xuICAgICAgICAgICAgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe1xuXG5FT0Y6MSxcblxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuXG4vLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICAgIC8vdGhpcy55eWxlbmcgLT0gbGVuO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApXG4gICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOlxuICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbnJlamVjdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG5sZXNzOmZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xudXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnNob3dQb3NpdGlvbjpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XG4gICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgfSxcblxuLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuXG50ZXN0X21hdGNoOmZ1bmN0aW9uIChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgYmFja3VwO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICAgICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgYmFja3VwLnl5bGxvYy5yYW5nZSA9IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgdGVtcE1hdGNoLFxuICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbl9jdXJyZW50UnVsZXM6ZnVuY3Rpb24gX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG50b3BTdGF0ZTpmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG5wdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbnN0YXRlU3RhY2tTaXplOmZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcbm9wdGlvbnM6IHt9LFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG52YXIgWVlTVEFURT1ZWV9TVEFSVDtcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6Lyogc2tpcCB3aGl0ZXNwYWNlICovXG5icmVhaztcbmNhc2UgMTpyZXR1cm4gNlxuYnJlYWs7XG5jYXNlIDI6eXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDEseXlfLnl5bGVuZy0yKTsgcmV0dXJuIDRcbmJyZWFrO1xuY2FzZSAzOnJldHVybiAxN1xuYnJlYWs7XG5jYXNlIDQ6cmV0dXJuIDE4XG5icmVhaztcbmNhc2UgNTpyZXR1cm4gMjNcbmJyZWFrO1xuY2FzZSA2OnJldHVybiAyNFxuYnJlYWs7XG5jYXNlIDc6cmV0dXJuIDIyXG5icmVhaztcbmNhc2UgODpyZXR1cm4gMjFcbmJyZWFrO1xuY2FzZSA5OnJldHVybiAxMFxuYnJlYWs7XG5jYXNlIDEwOnJldHVybiAxMVxuYnJlYWs7XG5jYXNlIDExOnJldHVybiA4XG5icmVhaztcbmNhc2UgMTI6cmV0dXJuIDE0XG5icmVhaztcbmNhc2UgMTM6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59LFxucnVsZXM6IFsvXig/OlxccyspLywvXig/OigtPyhbMC05XXxbMS05XVswLTldKykpKFxcLlswLTldKyk/KFtlRV1bLStdP1swLTldKyk/XFxiKS8sL14oPzpcIig/OlxcXFxbXFxcXFwiYmZucnRcXC9dfFxcXFx1W2EtZkEtRjAtOV17NH18W15cXFxcXFwwLVxceDA5XFx4MGEtXFx4MWZcIl0pKlwiKS8sL14oPzpcXHspLywvXig/OlxcfSkvLC9eKD86XFxbKS8sL14oPzpcXF0pLywvXig/OiwpLywvXig/OjopLywvXig/OnRydWVcXGIpLywvXig/OmZhbHNlXFxiKS8sL14oPzpudWxsXFxiKS8sL14oPzokKS8sL14oPzouKS9dLFxuY29uZGl0aW9uczoge1wiSU5JVElBTFwiOntcInJ1bGVzXCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBqc29ubGludDtcbmV4cG9ydHMuUGFyc2VyID0ganNvbmxpbnQuUGFyc2VyO1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25saW50LnBhcnNlLmFwcGx5KGpzb25saW50LCBhcmd1bWVudHMpOyB9O1xuZXhwb3J0cy5tYWluID0gZnVuY3Rpb24gY29tbW9uanNNYWluKGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3NbMV0pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzYWdlOiAnK2FyZ3NbMF0rJyBGSUxFJyk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IHJlcXVpcmUoJ2ZzJykucmVhZEZpbGVTeW5jKHJlcXVpcmUoJ3BhdGgnKS5ub3JtYWxpemUoYXJnc1sxXSksIFwidXRmOFwiKTtcbiAgICByZXR1cm4gZXhwb3J0cy5wYXJzZXIucGFyc2Uoc291cmNlKTtcbn07XG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZS5tYWluID09PSBtb2R1bGUpIHtcbiAgZXhwb3J0cy5tYWluKHByb2Nlc3MuYXJndi5zbGljZSgxKSk7XG59XG59IiwiLy8gSlNUUy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbi8vIExpY2Vuc2VzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VETHYxLnR4dFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VQTHYxLnR4dFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0xJQ0VOU0VfRVM2X0NPTExFQ1RJT05TLnR4dFxuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSh0LmpzdHM9dC5qc3RzfHx7fSl9KHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pfWZ1bmN0aW9uIG4oKXt9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiByKCl7fWZ1bmN0aW9uIHMoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIHUoKXt9ZnVuY3Rpb24gbCh0KXt0aGlzLm5hbWU9XCJSdW50aW1lRXhjZXB0aW9uXCIsdGhpcy5tZXNzYWdlPXQsdGhpcy5zdGFjaz0obmV3IEVycm9yKS5zdGFjayxFcnJvci5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gaCh0LGUpe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR9ZnVuY3Rpb24gYygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWwuY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsdCl9fWZ1bmN0aW9uIGYoKXt9ZnVuY3Rpb24gZygpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuej1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWcuY2FsbCh0aGlzLDAsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2cuY2FsbCh0aGlzLHQueCx0LnksdC56KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07Zy5jYWxsKHRoaXMsZSxuLGcuTlVMTF9PUkRJTkFURSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMueD1pLHRoaXMueT1yLHRoaXMuej1zfX1mdW5jdGlvbiBkKCl7aWYodGhpcy5kaW1lbnNpb25zVG9UZXN0PTIsMD09PWFyZ3VtZW50cy5sZW5ndGgpZC5jYWxsKHRoaXMsMik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKDIhPT10JiYzIT09dCl0aHJvdyBuZXcgaShcIm9ubHkgMiBvciAzIGRpbWVuc2lvbnMgbWF5IGJlIHNwZWNpZmllZFwiKTt0aGlzLmRpbWVuc2lvbnNUb1Rlc3Q9dH19ZnVuY3Rpb24gcCgpe31mdW5jdGlvbiB2KCl7fWZ1bmN0aW9uIG0odCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24geSgpe31mdW5jdGlvbiB4KHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIEUodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gSSgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1mdW5jdGlvbiBOKCl7aWYoSS5hcHBseSh0aGlzKSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZW5zdXJlQ2FwYWNpdHkodC5sZW5ndGgpLHRoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVuc3VyZUNhcGFjaXR5KGUubGVuZ3RoKSx0aGlzLmFkZChlLG4pfX1mdW5jdGlvbiBDKCl7aWYodGhpcy5taW54PW51bGwsdGhpcy5tYXh4PW51bGwsdGhpcy5taW55PW51bGwsdGhpcy5tYXh5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmluaXQoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQobi54LGkueCxuLnksaS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107dGhpcy5pbml0KHIscyxvLGEpfX1mdW5jdGlvbiBTKCl7fWZ1bmN0aW9uIHcoKXtTLmNhbGwodGhpcyxcIlByb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS5cIil9ZnVuY3Rpb24gTCgpe31mdW5jdGlvbiBSKHQsZSl7cmV0dXJuIHQuaW50ZXJmYWNlc18mJnQuaW50ZXJmYWNlc18oKS5pbmRleE9mKGUpPi0xfWZ1bmN0aW9uIFQoKXt9ZnVuY3Rpb24gUCh0KXt0aGlzLnN0cj10fWZ1bmN0aW9uIGIodCl7dGhpcy52YWx1ZT10fWZ1bmN0aW9uIE8oKXt9ZnVuY3Rpb24gXygpe2lmKHRoaXMuaGk9MCx0aGlzLmxvPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmluaXQoZSl9ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgbj1hcmd1bWVudHNbMF07Xy5jYWxsKHRoaXMsXy5wYXJzZShuKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQoaSxyKX19ZnVuY3Rpb24gTSgpe31mdW5jdGlvbiBEKCl7fWZ1bmN0aW9uIEEoKXt9ZnVuY3Rpb24gRigpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMudz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMueD0wLHRoaXMueT0wLHRoaXMudz0xO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy53PTF9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMueD1lLHRoaXMueT1uLHRoaXMudz0xfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEYpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt0aGlzLng9aS55KnIudy1yLnkqaS53LHRoaXMueT1yLngqaS53LWkueCpyLncsdGhpcy53PWkueCpyLnktci54KmkueX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV07dGhpcy54PXMueS1vLnksdGhpcy55PW8ueC1zLngsdGhpcy53PXMueCpvLnktby54KnMueX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdO3RoaXMueD1hLHRoaXMueT11LHRoaXMudz1sfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxmPWFyZ3VtZW50c1syXSxkPWFyZ3VtZW50c1szXSxwPWgueS1jLnksdj1jLngtaC54LG09aC54KmMueS1jLngqaC55LHk9Zi55LWQueSx4PWQueC1mLngsRT1mLngqZC55LWQueCpmLnk7dGhpcy54PXYqRS14Km0sdGhpcy55PXkqbS1wKkUsdGhpcy53PXAqeC15KnZ9fWZ1bmN0aW9uIEcoKXt9ZnVuY3Rpb24gcSgpe31mdW5jdGlvbiBCKCl7dGhpcy5lbnZlbG9wZT1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuU1JJRD1udWxsLHRoaXMudXNlckRhdGE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXQsdGhpcy5TUklEPXQuZ2V0U1JJRCgpfWZ1bmN0aW9uIHooKXt9ZnVuY3Rpb24gVigpe31mdW5jdGlvbiBrKCl7fWZ1bmN0aW9uIFkoKXt9ZnVuY3Rpb24gVSgpe31mdW5jdGlvbiBYKCl7fWZ1bmN0aW9uIEgoKXt9ZnVuY3Rpb24gVygpe31mdW5jdGlvbiBqKCl7fWZ1bmN0aW9uIEsoKXt9ZnVuY3Rpb24gWigpe31mdW5jdGlvbiBRKCl7fWZ1bmN0aW9uIEooKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZnVuY3Rpb24gJCh0KXtyZXR1cm4gbnVsbD09dD8kczp0LmNvbG9yfWZ1bmN0aW9uIHR0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5wYXJlbnR9ZnVuY3Rpb24gZXQodCxlKXtudWxsIT09dCYmKHQuY29sb3I9ZSl9ZnVuY3Rpb24gbnQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmxlZnR9ZnVuY3Rpb24gaXQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnJpZ2h0fWZ1bmN0aW9uIHJ0KCl7dGhpcy5yb290Xz1udWxsLHRoaXMuc2l6ZV89MH1mdW5jdGlvbiBzdCgpe31mdW5jdGlvbiBvdCgpe31mdW5jdGlvbiBhdCgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1mdW5jdGlvbiB1dCgpe31mdW5jdGlvbiBsdCgpe31mdW5jdGlvbiBodCgpe31mdW5jdGlvbiBjdCgpe31mdW5jdGlvbiBmdCgpe3RoaXMuZ2VvbWV0cmllcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihCLmNhbGwodGhpcyxlKSxudWxsPT09dCYmKHQ9W10pLEIuaGFzTnVsbEVsZW1lbnRzKHQpKXRocm93IG5ldyBpKFwiZ2VvbWV0cmllcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7dGhpcy5nZW9tZXRyaWVzPXR9ZnVuY3Rpb24gZ3QoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZnQuY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gZHQoKXtpZih0aGlzLmdlb209bnVsbCx0aGlzLmdlb21GYWN0PW51bGwsdGhpcy5iblJ1bGU9bnVsbCx0aGlzLmVuZHBvaW50TWFwPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtkdC5jYWxsKHRoaXMsdCxWLk1PRDJfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZ2VvbT1lLHRoaXMuZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCksdGhpcy5iblJ1bGU9bn19ZnVuY3Rpb24gcHQoKXt0aGlzLmNvdW50PW51bGx9ZnVuY3Rpb24gdnQoKXt9ZnVuY3Rpb24gbXQoKXt9ZnVuY3Rpb24geXQoKXt9ZnVuY3Rpb24geHQoKXt9ZnVuY3Rpb24gRXQoKXt9ZnVuY3Rpb24gSXQoKXt9ZnVuY3Rpb24gTnQoKXt9ZnVuY3Rpb24gQ3QoKXt9ZnVuY3Rpb24gU3QoKXt0aGlzLnBvaW50cz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtCLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9ZnVuY3Rpb24gd3QoKXt9ZnVuY3Rpb24gTHQoKXt0aGlzLmNvb3JkaW5hdGVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0IuY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX1mdW5jdGlvbiBSdCgpe31mdW5jdGlvbiBUdCgpe3RoaXMuc2hlbGw9bnVsbCx0aGlzLmhvbGVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKEIuY2FsbCh0aGlzLG4pLG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCkpLG51bGw9PT1lJiYoZT1bXSksQi5oYXNOdWxsRWxlbWVudHMoZSkpdGhyb3cgbmV3IGkoXCJob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7aWYodC5pc0VtcHR5KCkmJkIuaGFzTm9uRW1wdHlFbGVtZW50cyhlKSl0aHJvdyBuZXcgaShcInNoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90XCIpO3RoaXMuc2hlbGw9dCx0aGlzLmhvbGVzPWV9ZnVuY3Rpb24gUHQoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZnQuY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gYnQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgaWUpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtidC5jYWxsKHRoaXMsZS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpLGUpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sRCkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgaWUpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtTdC5jYWxsKHRoaXMsbixpKSx0aGlzLnZhbGlkYXRlQ29uc3RydWN0aW9uKCl9fWZ1bmN0aW9uIE90KCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Z0LmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIF90KCl7aWYodGhpcy5mYWN0b3J5PW51bGwsdGhpcy5pc1VzZXJEYXRhQ29waWVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9fWZ1bmN0aW9uIE10KCl7fWZ1bmN0aW9uIER0KCl7fWZ1bmN0aW9uIEF0KCl7fWZ1bmN0aW9uIEZ0KCl7fWZ1bmN0aW9uIEd0KCl7aWYodGhpcy5kaW1lbnNpb249Myx0aGlzLmNvb3JkaW5hdGVzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtHdC5jYWxsKHRoaXMsdCwzKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7Zm9yKHZhciBuPTA7bjxlO24rKyl0aGlzLmNvb3JkaW5hdGVzW25dPW5ldyBnfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpZihudWxsPT09aSlyZXR1cm4gdGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO3RoaXMuZGltZW5zaW9uPWkuZ2V0RGltZW5zaW9uKCksdGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoaS5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKHZhciBuPTA7bjx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtuKyspdGhpcy5jb29yZGluYXRlc1tuXT1pLmdldENvb3JkaW5hdGVDb3B5KG4pfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdO3RoaXMuY29vcmRpbmF0ZXM9cix0aGlzLmRpbWVuc2lvbj1zLG51bGw9PT1yJiYodGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdO3RoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KG8pLmZpbGwobnVsbCksdGhpcy5kaW1lbnNpb249YTtmb3IodmFyIG49MDtuPG87bisrKXRoaXMuY29vcmRpbmF0ZXNbbl09bmV3IGd9fWZ1bmN0aW9uIHF0KCl7fWZ1bmN0aW9uIEJ0KHQsZSl7cmV0dXJuIHQ9PT1lfHx0IT09dCYmZSE9PWV9ZnVuY3Rpb24genQodCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiB0aGlzJiZ0aGlzLmNvbnN0cnVjdG9yPT09bj8odGhpcy5fa2V5cz1bXSx0aGlzLl92YWx1ZXM9W10sdGhpcy5faXRwPVtdLHRoaXMub2JqZWN0T25seT1lLHZvaWQodCYmVnQuY2FsbCh0aGlzLHQpKSk6bmV3IG4odCl9cmV0dXJuIGV8fGlvKHQsXCJzaXplXCIse2dldDpKdH0pLHQuY29uc3RydWN0b3I9bixuLnByb3RvdHlwZT10LG59ZnVuY3Rpb24gVnQodCl7dGhpcy5hZGQ/dC5mb3JFYWNoKHRoaXMuYWRkLHRoaXMpOnQuZm9yRWFjaChmdW5jdGlvbih0KXt0aGlzLnNldCh0WzBdLHRbMV0pfSx0aGlzKX1mdW5jdGlvbiBrdCh0KXtyZXR1cm4gdGhpcy5oYXModCkmJih0aGlzLl9rZXlzLnNwbGljZShubywxKSx0aGlzLl92YWx1ZXMuc3BsaWNlKG5vLDEpLHRoaXMuX2l0cC5mb3JFYWNoKGZ1bmN0aW9uKHQpe25vPHRbMF0mJnRbMF0tLX0pKSxubz4tMX1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gdGhpcy5oYXModCk/dGhpcy5fdmFsdWVzW25vXTp2b2lkIDB9ZnVuY3Rpb24gVXQodCxlKXtpZih0aGlzLm9iamVjdE9ubHkmJmUhPT1PYmplY3QoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdmFsdWUgdXNlZCBhcyB3ZWFrIGNvbGxlY3Rpb24ga2V5XCIpO2lmKGUhPT1lfHwwPT09ZSlmb3Iobm89dC5sZW5ndGg7bm8tLSYmIUJ0KHRbbm9dLGUpOyk7ZWxzZSBubz10LmluZGV4T2YoZSk7cmV0dXJuIG5vPi0xfWZ1bmN0aW9uIFh0KHQpe3JldHVybiBVdC5jYWxsKHRoaXMsdGhpcy5fa2V5cyx0KX1mdW5jdGlvbiBIdCh0LGUpe3JldHVybiB0aGlzLmhhcyh0KT90aGlzLl92YWx1ZXNbbm9dPWU6dGhpcy5fdmFsdWVzW3RoaXMuX2tleXMucHVzaCh0KS0xXT1lLHRoaXN9ZnVuY3Rpb24gV3QoKXsodGhpcy5fa2V5c3x8MCkubGVuZ3RoPXRoaXMuX3ZhbHVlcy5sZW5ndGg9MH1mdW5jdGlvbiBqdCgpe3JldHVybiBRdCh0aGlzLl9pdHAsdGhpcy5fa2V5cyl9ZnVuY3Rpb24gS3QoKXtyZXR1cm4gUXQodGhpcy5faXRwLHRoaXMuX3ZhbHVlcyl9ZnVuY3Rpb24gWnQoKXtyZXR1cm4gUXQodGhpcy5faXRwLHRoaXMuX2tleXMsdGhpcy5fdmFsdWVzKX1mdW5jdGlvbiBRdCh0LGUsbil7dmFyIGk9WzBdLHI9ITE7cmV0dXJuIHQucHVzaChpKSx7bmV4dDpmdW5jdGlvbigpe3ZhciBzLG89aVswXTtyZXR1cm4hciYmbzxlLmxlbmd0aD8ocz1uP1tlW29dLG5bb11dOmVbb10saVswXSsrKToocj0hMCx0LnNwbGljZSh0LmluZGV4T2YoaSksMSkpLHtkb25lOnIsdmFsdWU6c319fX1mdW5jdGlvbiBKdCgpe3JldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RofWZ1bmN0aW9uICR0KHQsZSl7Zm9yKHZhciBuPXRoaXMuZW50cmllcygpOzspe3ZhciBpPW4ubmV4dCgpO2lmKGkuZG9uZSlicmVhazt0LmNhbGwoZSxpLnZhbHVlWzFdLGkudmFsdWVbMF0sdGhpcyl9fWZ1bmN0aW9uIHRlKCl7dGhpcy5tYXBfPW5ldyBzb31mdW5jdGlvbiBlZSgpe2lmKHRoaXMubW9kZWxUeXBlPW51bGwsdGhpcy5zY2FsZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubW9kZWxUeXBlPWVlLkZMT0FUSU5HO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBuZSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubW9kZWxUeXBlPXQsdD09PWVlLkZJWEVEJiZ0aGlzLnNldFNjYWxlKDEpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMubW9kZWxUeXBlPWVlLkZJWEVELHRoaXMuc2V0U2NhbGUoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5tb2RlbFR5cGU9bi5tb2RlbFR5cGUsdGhpcy5zY2FsZT1uLnNjYWxlfX1mdW5jdGlvbiBuZSgpe3RoaXMubmFtZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5hbWU9dCxuZS5uYW1lVG9UeXBlTWFwLnB1dCh0LHRoaXMpfWZ1bmN0aW9uIGllKCl7aWYodGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsLHRoaXMuU1JJRD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWllLmNhbGwodGhpcyxuZXcgZWUsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sRykpe3ZhciB0PWFyZ3VtZW50c1swXTtpZS5jYWxsKHRoaXMsbmV3IGVlLDAsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXt2YXIgZT1hcmd1bWVudHNbMF07aWUuY2FsbCh0aGlzLGUsMCxpZS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2llLmNhbGwodGhpcyxuLGksaWUuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMucHJlY2lzaW9uTW9kZWw9cix0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9byx0aGlzLlNSSUQ9c319ZnVuY3Rpb24gcmUodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIHNlKHQpe3RoaXMucGFyc2VyPW5ldyByZSh0KX1mdW5jdGlvbiBvZSgpe3RoaXMucmVzdWx0PW51bGwsdGhpcy5pbnB1dExpbmVzPUFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMil9KSx0aGlzLmludFB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuaW50TGluZUluZGV4PW51bGwsdGhpcy5faXNQcm9wZXI9bnVsbCx0aGlzLnBhPW51bGwsdGhpcy5wYj1udWxsLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmludFB0WzBdPW5ldyBnLHRoaXMuaW50UHRbMV09bmV3IGcsdGhpcy5wYT10aGlzLmludFB0WzBdLHRoaXMucGI9dGhpcy5pbnRQdFsxXSx0aGlzLnJlc3VsdD0wfWZ1bmN0aW9uIGFlKCl7b2UuYXBwbHkodGhpcyl9ZnVuY3Rpb24gdWUoKXt9ZnVuY3Rpb24gbGUoKXt0aGlzLnA9bnVsbCx0aGlzLmNyb3NzaW5nQ291bnQ9MCx0aGlzLmlzUG9pbnRPblNlZ21lbnQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZ1bmN0aW9uIGhlKCl7fWZ1bmN0aW9uIGNlKCl7aWYodGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCljZS5jYWxsKHRoaXMsbmV3IGcsbmV3IGcpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtjZS5jYWxsKHRoaXMsdC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wMD1lLHRoaXMucDE9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM107Y2UuY2FsbCh0aGlzLG5ldyBnKGksciksbmV3IGcocyxvKSl9fWZ1bmN0aW9uIGZlKCl7aWYodGhpcy5tYXRyaXg9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm1hdHJpeD1BcnJheSgzKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDMpfSksdGhpcy5zZXRBbGwobHQuRkFMU0UpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO2ZlLmNhbGwodGhpcyksdGhpcy5zZXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZlKXt2YXIgZT1hcmd1bWVudHNbMF07ZmUuY2FsbCh0aGlzKSx0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXT1lLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSx0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXT1lLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSx0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT1lLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXT1lLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXT1lLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSx0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT1lLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXT1lLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSx0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXT1lLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXSx0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkVYVEVSSU9SXT1lLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkVYVEVSSU9SXX19ZnVuY3Rpb24gZ2UoKXt0aGlzLmFyZWFCYXNlUHQ9bnVsbCx0aGlzLnRyaWFuZ2xlQ2VudDM9bmV3IGcsdGhpcy5hcmVhc3VtMj0wLHRoaXMuY2czPW5ldyBnLHRoaXMubGluZUNlbnRTdW09bmV3IGcsdGhpcy50b3RhbExlbmd0aD0wLHRoaXMucHRDb3VudD0wLHRoaXMucHRDZW50U3VtPW5ldyBnO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFyZWFCYXNlUHQ9bnVsbCx0aGlzLmFkZCh0KX1mdW5jdGlvbiBkZSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBwZSgpe3RoaXMuYXJyYXlfPVtdfWZ1bmN0aW9uIHZlKCl7dGhpcy50cmVlU2V0PW5ldyBhdCx0aGlzLmxpc3Q9bmV3IEl9ZnVuY3Rpb24gbWUoKXtpZih0aGlzLmdlb21GYWN0b3J5PW51bGwsdGhpcy5pbnB1dFB0cz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bWUuY2FsbCh0aGlzLG1lLmV4dHJhY3RDb29yZGluYXRlcyh0KSx0LmdldEZhY3RvcnkoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuaW5wdXRQdHM9dmUuZmlsdGVyQ29vcmRpbmF0ZXMoZSksdGhpcy5nZW9tRmFjdG9yeT1ufX1mdW5jdGlvbiB5ZSgpe3RoaXMub3JpZ2luPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMub3JpZ2luPXR9ZnVuY3Rpb24geGUoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMucHJ1bmVFbXB0eUdlb21ldHJ5PSEwLHRoaXMucHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlPSEwLHRoaXMucHJlc2VydmVDb2xsZWN0aW9ucz0hMSx0aGlzLnByZXNlcnZlVHlwZT0hMX1mdW5jdGlvbiBFZSgpe2lmKHRoaXMuc25hcFRvbGVyYW5jZT0wLHRoaXMuc3JjUHRzPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMuYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9ITEsdGhpcy5faXNDbG9zZWQ9ITEsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0VlLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGVzKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5zcmNQdHM9bix0aGlzLl9pc0Nsb3NlZD1FZS5pc0Nsb3NlZChuKSx0aGlzLnNuYXBUb2xlcmFuY2U9aX19ZnVuY3Rpb24gSWUoKXt0aGlzLnNyY0dlb209bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zcmNHZW9tPXR9ZnVuY3Rpb24gTmUoKXtpZih4ZS5hcHBseSh0aGlzKSx0aGlzLnNuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLnNuYXBQdHM9bnVsbCx0aGlzLmlzU2VsZlNuYXA9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNuYXBUb2xlcmFuY2U9dCx0aGlzLnNuYXBQdHM9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5zbmFwVG9sZXJhbmNlPW4sdGhpcy5zbmFwUHRzPWksdGhpcy5pc1NlbGZTbmFwPXJ9fWZ1bmN0aW9uIENlKCl7dGhpcy5pc0ZpcnN0PSEwLHRoaXMuY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9NTMsdGhpcy5jb21tb25CaXRzPTAsdGhpcy5jb21tb25TaWduRXhwPW51bGx9ZnVuY3Rpb24gU2UoKXt0aGlzLmNvbW1vbkNvb3JkPW51bGwsdGhpcy5jY0ZpbHRlcj1uZXcgd2V9ZnVuY3Rpb24gd2UoKXt0aGlzLmNvbW1vbkJpdHNYPW5ldyBDZSx0aGlzLmNvbW1vbkJpdHNZPW5ldyBDZX1mdW5jdGlvbiBMZSgpe3RoaXMudHJhbnM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50cmFucz10fWZ1bmN0aW9uIFJlKCl7dGhpcy5wYXJlbnQ9bnVsbCx0aGlzLmF0U3RhcnQ9bnVsbCx0aGlzLm1heD1udWxsLHRoaXMuaW5kZXg9bnVsbCx0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBhcmVudD10LHRoaXMuYXRTdGFydD0hMCx0aGlzLmluZGV4PTAsdGhpcy5tYXg9dC5nZXROdW1HZW9tZXRyaWVzKCl9ZnVuY3Rpb24gVGUoKXtpZih0aGlzLmJvdW5kYXJ5UnVsZT1WLk9HQ19TRlNfQk9VTkRBUllfUlVMRSx0aGlzLmlzSW49bnVsbCx0aGlzLm51bUJvdW5kYXJpZXM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXRocm93IG5ldyBpKFwiUnVsZSBtdXN0IGJlIG5vbi1udWxsXCIpO3RoaXMuYm91bmRhcnlSdWxlPXR9fWZ1bmN0aW9uIFBlKCl7fWZ1bmN0aW9uIGJlKCl7fWZ1bmN0aW9uIE9lKCl7dGhpcy5wdHM9bnVsbCx0aGlzLmRhdGE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLmRhdGE9ZX1mdW5jdGlvbiBfZSgpe31mdW5jdGlvbiBNZSgpe3RoaXMuYm91bmRzPW51bGwsdGhpcy5pdGVtPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYm91bmRzPXQsdGhpcy5pdGVtPWV9ZnVuY3Rpb24gRGUoKXt0aGlzLl9zaXplPW51bGwsdGhpcy5pdGVtcz1udWxsLHRoaXMuX3NpemU9MCx0aGlzLml0ZW1zPW5ldyBJLHRoaXMuaXRlbXMuYWRkKG51bGwpfWZ1bmN0aW9uIEFlKCl7fWZ1bmN0aW9uIEZlKCl7fWZ1bmN0aW9uIEdlKCl7aWYodGhpcy5jaGlsZEJvdW5kYWJsZXM9bmV3IEksdGhpcy5ib3VuZHM9bnVsbCx0aGlzLmxldmVsPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxldmVsPXR9fWZ1bmN0aW9uIHFlKCl7dGhpcy5ib3VuZGFibGUxPW51bGwsdGhpcy5ib3VuZGFibGUyPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLml0ZW1EaXN0YW5jZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmJvdW5kYWJsZTE9dCx0aGlzLmJvdW5kYWJsZTI9ZSx0aGlzLml0ZW1EaXN0YW5jZT1uLHRoaXMuX2Rpc3RhbmNlPXRoaXMuZGlzdGFuY2UoKX1mdW5jdGlvbiBCZSgpe2lmKHRoaXMucm9vdD1udWxsLHRoaXMuYnVpbHQ9ITEsdGhpcy5pdGVtQm91bmRhYmxlcz1uZXcgSSx0aGlzLm5vZGVDYXBhY2l0eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKUJlLmNhbGwodGhpcyxCZS5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtmLmlzVHJ1ZSh0PjEsXCJOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5ub2RlQ2FwYWNpdHk9dH19ZnVuY3Rpb24gemUoKXt9ZnVuY3Rpb24gVmUoKXt9ZnVuY3Rpb24ga2UoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClrZS5jYWxsKHRoaXMsa2UuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07QmUuY2FsbCh0aGlzLHQpfX1mdW5jdGlvbiBZZSgpe3ZhciB0PWFyZ3VtZW50c1swXTtHZS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gVWUoKXt9ZnVuY3Rpb24gWGUoKXt0aGlzLnNlZ1N0cmluZz1udWxsLHRoaXMuY29vcmQ9bnVsbCx0aGlzLnNlZ21lbnRJbmRleD1udWxsLHRoaXMuc2VnbWVudE9jdGFudD1udWxsLHRoaXMuX2lzSW50ZXJpb3I9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5zZWdTdHJpbmc9dCx0aGlzLmNvb3JkPW5ldyBnKGUpLHRoaXMuc2VnbWVudEluZGV4PW4sdGhpcy5zZWdtZW50T2N0YW50PWksdGhpcy5faXNJbnRlcmlvcj0hZS5lcXVhbHMyRCh0LmdldENvb3JkaW5hdGUobikpfWZ1bmN0aW9uIEhlKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLmVkZ2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9ZnVuY3Rpb24gV2UoKXt0aGlzLm5vZGVMaXN0PW51bGwsdGhpcy5lZGdlPW51bGwsdGhpcy5ub2RlSXQ9bnVsbCx0aGlzLmN1cnJOb2RlPW51bGwsdGhpcy5uZXh0Tm9kZT1udWxsLHRoaXMuY3VyclNlZ0luZGV4PTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUxpc3Q9dCx0aGlzLmVkZ2U9dC5nZXRFZGdlKCksdGhpcy5ub2RlSXQ9dC5pdGVyYXRvcigpLHRoaXMucmVhZE5leHROb2RlKCl9ZnVuY3Rpb24gamUoKXt9ZnVuY3Rpb24gS2UoKXt0aGlzLm5vZGVMaXN0PW5ldyBIZSh0aGlzKSx0aGlzLnB0cz1udWxsLHRoaXMuZGF0YT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuZGF0YT1lfWZ1bmN0aW9uIFplKCl7dGhpcy50ZW1wRW52MT1uZXcgQyx0aGlzLnRlbXBFbnYyPW5ldyBDLHRoaXMub3ZlcmxhcFNlZzE9bmV3IGNlLHRoaXMub3ZlcmxhcFNlZzI9bmV3IGNlfWZ1bmN0aW9uIFFlKCl7dGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0PW51bGwsdGhpcy5lbmQ9bnVsbCx0aGlzLmVudj1udWxsLHRoaXMuY29udGV4dD1udWxsLHRoaXMuaWQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5wdHM9dCx0aGlzLnN0YXJ0PWUsdGhpcy5lbmQ9bix0aGlzLmNvbnRleHQ9aX1mdW5jdGlvbiBKZSgpe31mdW5jdGlvbiAkZSgpe31mdW5jdGlvbiB0bigpe31mdW5jdGlvbiBlbigpe2lmKHRoaXMuc2VnSW50PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KX19ZnVuY3Rpb24gbm4oKXtpZih0aGlzLm1vbm9DaGFpbnM9bmV3IEksdGhpcy5pbmRleD1uZXcga2UsdGhpcy5pZENvdW50ZXI9MCx0aGlzLm5vZGVkU2VnU3RyaW5ncz1udWxsLHRoaXMubk92ZXJsYXBzPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtlbi5jYWxsKHRoaXMsdCl9fWZ1bmN0aW9uIHJuKCl7WmUuYXBwbHkodGhpcyksdGhpcy5zaT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpPXR9ZnVuY3Rpb24gc24oKXtpZih0aGlzLnB0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07bC5jYWxsKHRoaXMsc24ubXNnV2l0aENvb3JkKGUsbikpLHRoaXMubmFtZT1cIlRvcG9sb2d5RXhjZXB0aW9uXCIsdGhpcy5wdD1uZXcgZyhuKX19ZnVuY3Rpb24gb24oKXt9ZnVuY3Rpb24gYW4oKXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLmxpPW51bGwsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbj1udWxsLHRoaXMuaW50U2VnbWVudHM9bnVsbCx0aGlzLmludGVyc2VjdGlvbnM9bmV3IEksdGhpcy5pbnRlcnNlY3Rpb25Db3VudD0wLHRoaXMua2VlcEludGVyc2VjdGlvbnM9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPW51bGx9ZnVuY3Rpb24gdW4oKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnNlZ1N0cmluZ3M9bnVsbCx0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuc2VnSW50PW51bGwsdGhpcy5faXNWYWxpZD0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWdTdHJpbmdzPXR9ZnVuY3Rpb24gbG4oKXt0aGlzLm52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubnY9bmV3IHVuKGxuLnRvU2VnbWVudFN0cmluZ3ModCkpfWZ1bmN0aW9uIGhuKCl7dGhpcy5tYXBPcD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1hcE9wPXR9ZnVuY3Rpb24gY24oKXt9ZnVuY3Rpb24gZm4oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5sZW5ndGgpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KDEpLHRoaXMubG9jYXRpb25bY24uT05dPWV9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZuKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KG4ubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09bilmb3IodmFyIGk9MDtpPHRoaXMubG9jYXRpb24ubGVuZ3RoO2krKyl0aGlzLmxvY2F0aW9uW2ldPW4ubG9jYXRpb25baV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLmluaXQoMyksdGhpcy5sb2NhdGlvbltjbi5PTl09cix0aGlzLmxvY2F0aW9uW2NuLkxFRlRdPXMsdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09b319ZnVuY3Rpb24gZ24oKXtpZih0aGlzLmVsdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IGZuKHQpLHRoaXMuZWx0WzFdPW5ldyBmbih0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ24pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgZm4oZS5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBmbihlLmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFswXT1uZXcgZm4oTC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgZm4oTC5OT05FKSx0aGlzLmVsdFtuXS5zZXRMb2NhdGlvbihpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IGZuKHIscyxvKSx0aGlzLmVsdFsxXT1uZXcgZm4ocixzLG8pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXSxoPWFyZ3VtZW50c1szXTt0aGlzLmVsdFswXT1uZXcgZm4oTC5OT05FLEwuTk9ORSxMLk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBmbihMLk5PTkUsTC5OT05FLEwuTk9ORSksdGhpcy5lbHRbYV0uc2V0TG9jYXRpb25zKHUsbCxoKX19ZnVuY3Rpb24gZG4oKXt0aGlzLnN0YXJ0RGU9bnVsbCx0aGlzLm1heE5vZGVEZWdyZWU9LTEsdGhpcy5lZGdlcz1uZXcgSSx0aGlzLnB0cz1uZXcgSSx0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpLHRoaXMucmluZz1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuc2hlbGw9bnVsbCx0aGlzLmhvbGVzPW5ldyBJLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5jb21wdXRlUG9pbnRzKHQpLHRoaXMuY29tcHV0ZVJpbmcoKX1mdW5jdGlvbiBwbigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtkbi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiB2bigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtkbi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBtbigpe2lmKHRoaXMubGFiZWw9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzQ292ZXJlZD0hMSx0aGlzLl9pc0NvdmVyZWRTZXQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sYWJlbD10fX1mdW5jdGlvbiB5bigpe21uLmFwcGx5KHRoaXMpLHRoaXMuY29vcmQ9bnVsbCx0aGlzLmVkZ2VzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuY29vcmQ9dCx0aGlzLmVkZ2VzPWUsdGhpcy5sYWJlbD1uZXcgZ24oMCxMLk5PTkUpfWZ1bmN0aW9uIHhuKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLm5vZGVGYWN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH1mdW5jdGlvbiBFbigpe2lmKHRoaXMuZWRnZT1udWxsLHRoaXMubGFiZWw9bnVsbCx0aGlzLm5vZGU9bnVsbCx0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMuZHg9bnVsbCx0aGlzLmR5PW51bGwsdGhpcy5xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO0VuLmNhbGwodGhpcyxlLG4saSxudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107RW4uY2FsbCh0aGlzLHIpLHRoaXMuaW5pdChzLG8pLHRoaXMubGFiZWw9YX19ZnVuY3Rpb24gSW4oKXt0aGlzLl9pc0ZvcndhcmQ9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLnN5bT1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMubmV4dE1pbj1udWxsLHRoaXMuZWRnZVJpbmc9bnVsbCx0aGlzLm1pbkVkZ2VSaW5nPW51bGwsdGhpcy5kZXB0aD1bMCwtOTk5LC05OTldO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihFbi5jYWxsKHRoaXMsdCksdGhpcy5faXNGb3J3YXJkPWUsZSl0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKDApLHQuZ2V0Q29vcmRpbmF0ZSgxKSk7ZWxzZXt2YXIgbj10LmdldE51bVBvaW50cygpLTE7dGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZShuKSx0LmdldENvb3JkaW5hdGUobi0xKSl9dGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpfWZ1bmN0aW9uIE5uKCl7fWZ1bmN0aW9uIENuKCl7aWYodGhpcy5lZGdlcz1uZXcgSSx0aGlzLm5vZGVzPW51bGwsdGhpcy5lZGdlRW5kTGlzdD1uZXcgSSwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm5vZGVzPW5ldyB4bihuZXcgTm4pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVzPW5ldyB4bih0KX19ZnVuY3Rpb24gU24oKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuc2hlbGxMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fWZ1bmN0aW9uIHduKCl7dGhpcy5vcD1udWxsLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5wdExvY2F0b3I9bnVsbCx0aGlzLmxpbmVFZGdlc0xpc3Q9bmV3IEksdGhpcy5yZXN1bHRMaW5lTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5vcD10LHRoaXMuZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5wdExvY2F0b3I9bn1mdW5jdGlvbiBMbigpe3RoaXMub3A9bnVsbCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMucmVzdWx0UG9pbnRMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl07dGhpcy5vcD10LHRoaXMuZ2VvbWV0cnlGYWN0b3J5PWV9ZnVuY3Rpb24gUm4oKXt9ZnVuY3Rpb24gVG4oKXt0aGlzLmdlb209bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tPXR9ZnVuY3Rpb24gUG4oKXt0aGlzLmVkZ2VNYXA9bmV3IHJ0LHRoaXMuZWRnZUxpc3Q9bnVsbCx0aGlzLnB0SW5BcmVhTG9jYXRpb249W0wuTk9ORSxMLk5PTkVdfWZ1bmN0aW9uIGJuKCl7UG4uYXBwbHkodGhpcyksdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q9bnVsbCx0aGlzLmxhYmVsPW51bGwsdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLkxJTktJTkdfVE9fT1VUR09JTkc9Mn1mdW5jdGlvbiBPbigpe05uLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIF9uKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY2U9dCx0aGlzLmNoYWluSW5kZXg9ZX1mdW5jdGlvbiBNbigpe2lmKHRoaXMubGFiZWw9bnVsbCx0aGlzLnhWYWx1ZT1udWxsLHRoaXMuZXZlbnRUeXBlPW51bGwsdGhpcy5pbnNlcnRFdmVudD1udWxsLHRoaXMuZGVsZXRlRXZlbnRJbmRleD1udWxsLHRoaXMub2JqPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmV2ZW50VHlwZT1Nbi5ERUxFVEUsdGhpcy54VmFsdWU9dCx0aGlzLmluc2VydEV2ZW50PWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuZXZlbnRUeXBlPU1uLklOU0VSVCx0aGlzLmxhYmVsPW4sdGhpcy54VmFsdWU9aSx0aGlzLm9iaj1yfX1mdW5jdGlvbiBEbigpe31mdW5jdGlvbiBBbigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLmhhc1Byb3Blcj0hMSx0aGlzLmhhc1Byb3BlckludGVyaW9yPSExLHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5pbmNsdWRlUHJvcGVyPW51bGwsdGhpcy5yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuaXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wLHRoaXMuYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5pc0RvbmVXaGVuUHJvcGVySW50PSExO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmxpPXQsdGhpcy5pbmNsdWRlUHJvcGVyPWUsdGhpcy5yZWNvcmRJc29sYXRlZD1ufWZ1bmN0aW9uIEZuKCl7RG4uYXBwbHkodGhpcyksdGhpcy5ldmVudHM9bmV3IEksdGhpcy5uT3ZlcmxhcHM9bnVsbH1mdW5jdGlvbiBHbigpe3RoaXMubWluPXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5tYXg9ci5ORUdBVElWRV9JTkZJTklUWX1mdW5jdGlvbiBxbigpe31mdW5jdGlvbiBCbigpe0duLmFwcGx5KHRoaXMpLHRoaXMuaXRlbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLm1pbj10LHRoaXMubWF4PWUsdGhpcy5pdGVtPW59ZnVuY3Rpb24gem4oKXtHbi5hcHBseSh0aGlzKSx0aGlzLm5vZGUxPW51bGwsdGhpcy5ub2RlMj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm5vZGUxPXQsdGhpcy5ub2RlMj1lLHRoaXMuYnVpbGRFeHRlbnQodGhpcy5ub2RlMSx0aGlzLm5vZGUyKX1mdW5jdGlvbiBWbigpe3RoaXMubGVhdmVzPW5ldyBJLHRoaXMucm9vdD1udWxsLHRoaXMubGV2ZWw9MH1mdW5jdGlvbiBrbigpe2lmKHRoaXMubGluZXM9bnVsbCx0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nPSExLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lcz10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmxpbmVzPWUsdGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz1ufX1mdW5jdGlvbiBZbigpe3RoaXMuaXRlbXM9bmV3IEl9ZnVuY3Rpb24gVW4oKXt0aGlzLmluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKCFSKHQsUnQpKXRocm93IG5ldyBpKFwiQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWxcIik7dGhpcy5pbmRleD1uZXcgSG4odCl9ZnVuY3Rpb24gWG4oKXt0aGlzLmNvdW50ZXI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudGVyPXR9ZnVuY3Rpb24gSG4oKXt0aGlzLmluZGV4PW5ldyBWbjt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWZ1bmN0aW9uIFduKCl7dGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5kaXN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuY29vcmQ9bmV3IGcodCksdGhpcy5zZWdtZW50SW5kZXg9ZSx0aGlzLmRpc3Q9bn1mdW5jdGlvbiBqbigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5lZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWZ1bmN0aW9uIEtuKCl7fWZ1bmN0aW9uIFpuKCl7dGhpcy5lPW51bGwsdGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0SW5kZXg9bnVsbCx0aGlzLmVudjE9bmV3IEMsdGhpcy5lbnYyPW5ldyBDO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmU9dCx0aGlzLnB0cz10LmdldENvb3JkaW5hdGVzKCk7dmFyIGU9bmV3IEtuO3RoaXMuc3RhcnRJbmRleD1lLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKX1mdW5jdGlvbiBRbigpe3RoaXMuZGVwdGg9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgzKX0pO2Zvcih2YXIgdD0wO3Q8Mjt0KyspZm9yKHZhciBlPTA7ZTwzO2UrKyl0aGlzLmRlcHRoW3RdW2VdPVFuLk5VTExfVkFMVUV9ZnVuY3Rpb24gSm4oKXtpZihtbi5hcHBseSh0aGlzKSx0aGlzLnB0cz1udWxsLHRoaXMuZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IGpuKHRoaXMpLHRoaXMubmFtZT1udWxsLHRoaXMubWNlPW51bGwsdGhpcy5faXNJc29sYXRlZD0hMCx0aGlzLmRlcHRoPW5ldyBRbix0aGlzLmRlcHRoRGVsdGE9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0puLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz1lLHRoaXMubGFiZWw9bn19ZnVuY3Rpb24gJG4oKXtpZihDbi5hcHBseSh0aGlzKSx0aGlzLnBhcmVudEdlb209bnVsbCx0aGlzLmxpbmVFZGdlTWFwPW5ldyB0ZSx0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGU9bnVsbCx0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITAsdGhpcy5hcmdJbmRleD1udWxsLHRoaXMuYm91bmRhcnlOb2Rlcz1udWxsLHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMSx0aGlzLmludmFsaWRQb2ludD1udWxsLHRoaXMuYXJlYVB0TG9jYXRvcj1udWxsLHRoaXMucHRMb2NhdG9yPW5ldyBUZSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdOyRuLmNhbGwodGhpcyx0LGUsVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmFyZ0luZGV4PW4sdGhpcy5wYXJlbnRHZW9tPWksdGhpcy5ib3VuZGFyeU5vZGVSdWxlPXIsbnVsbCE9PWkmJnRoaXMuYWRkKGkpfX1mdW5jdGlvbiB0aSgpe2lmKHRoaXMubGk9bmV3IGFlLHRoaXMucmVzdWx0UHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmFyZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuYXJnPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHRoaXMuYXJnWzBdPW5ldyAkbigwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsZSxuLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07aS5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhyLmdldFByZWNpc2lvbk1vZGVsKCkpPj0wP3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oaS5nZXRQcmVjaXNpb25Nb2RlbCgpKTp0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHIuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5hcmdbMF09bmV3ICRuKDAsaSxzKSx0aGlzLmFyZ1sxXT1uZXcgJG4oMSxyLHMpfX1mdW5jdGlvbiBlaSgpe3RoaXMucHRzPW51bGwsdGhpcy5fb3JpZW50YXRpb249bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9dCx0aGlzLl9vcmllbnRhdGlvbj1laS5vcmllbnRhdGlvbih0KX1mdW5jdGlvbiBuaSgpe3RoaXMuZWRnZXM9bmV3IEksdGhpcy5vY2FNYXA9bmV3IHJ0fWZ1bmN0aW9uIGlpKCl7dGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLnJlc3VsdEdlb209bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5lZGdlTGlzdD1uZXcgbmksdGhpcy5yZXN1bHRQb2x5TGlzdD1uZXcgSSx0aGlzLnJlc3VsdExpbmVMaXN0PW5ldyBJLHRoaXMucmVzdWx0UG9pbnRMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsdCxlKSx0aGlzLmdyYXBoPW5ldyBDbihuZXcgT24pLHRoaXMuZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCl9ZnVuY3Rpb24gcmkoKXt0aGlzLmdlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5jYnI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5nZW9tWzBdPXQsdGhpcy5nZW9tWzFdPWUsdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpfWZ1bmN0aW9uIHNpKCl7dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21bMF09dCx0aGlzLmdlb21bMV09ZX1mdW5jdGlvbiBvaSgpe3RoaXMuZmFjdG9yeT1udWxsLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsLHRoaXMubWF4V2lkdGg9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHRoaXMuYWRkKHQpfWZ1bmN0aW9uIGFpKCl7dGhpcy5wb2x5PW51bGwsdGhpcy5jZW50cmVZPW51bGwsdGhpcy5oaVk9ci5NQVhfVkFMVUUsdGhpcy5sb1k9LXIuTUFYX1ZBTFVFO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBvbHk9dCx0aGlzLmhpWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNYXhZKCksdGhpcy5sb1k9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWluWSgpLHRoaXMuY2VudHJlWT1vaS5hdmcodGhpcy5sb1ksdGhpcy5oaVkpfWZ1bmN0aW9uIHVpKCl7dGhpcy5jZW50cm9pZD1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5pbnRlcmlvclBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZEludGVyaW9yKHQpLG51bGw9PT10aGlzLmludGVyaW9yUG9pbnQmJnRoaXMuYWRkRW5kcG9pbnRzKHQpfWZ1bmN0aW9uIGxpKCl7dGhpcy5jZW50cm9pZD1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5pbnRlcmlvclBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZCh0KX1mdW5jdGlvbiBoaSgpe3RoaXMudGVtcEVudjE9bmV3IEMsdGhpcy5zZWxlY3RlZFNlZ21lbnQ9bmV3IGNlfWZ1bmN0aW9uIGNpKCl7dGhpcy5pdGVtcz1uZXcgSSx0aGlzLnN1Ym5vZGU9W251bGwsbnVsbF19ZnVuY3Rpb24gZmkoKXtpZih0aGlzLm1pbj1udWxsLHRoaXMubWF4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5taW49MCx0aGlzLm1heD0wO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5taW4sdC5tYXgpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQoZSxuKX19ZnVuY3Rpb24gZ2koKXt9ZnVuY3Rpb24gZGkodCxlKXt2YXIgbixpLHIscyxvPXszMjp7ZDoxMjcsYzoxMjgsYjowLGE6MH0sNjQ6e2Q6MzI3NTIsYzowLGI6MCxhOjB9fSxhPXszMjo4LDY0OjExfVt0XTtpZihzfHwobj1lPDB8fDEvZTwwLGlzRmluaXRlKGUpfHwocz1vW3RdLG4mJihzLmQrPTE8PHQvNC0xKSxpPU1hdGgucG93KDIsYSktMSxyPTApKSwhcyl7Zm9yKGk9ezMyOjEyNyw2NDoxMDIzfVt0XSxyPU1hdGguYWJzKGUpO3I+PTI7KWkrKyxyLz0yO2Zvcig7cjwxJiZpPjA7KWktLSxyKj0yO2k8PTAmJihyLz0yKSwzMj09PXQmJmk+MjU0JiYocz17ZDpuPzI1NToxMjcsYzoxMjgsYjowLGE6MH0saT1NYXRoLnBvdygyLGEpLTEscj0wKX1yZXR1cm4gaX1mdW5jdGlvbiBwaSgpe3RoaXMucHQ9MCx0aGlzLmxldmVsPTAsdGhpcy5pbnRlcnZhbD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9ZnVuY3Rpb24gdmkoKXtjaS5hcHBseSh0aGlzKSx0aGlzLmludGVydmFsPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLmxldmVsPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW50ZXJ2YWw9dCx0aGlzLmxldmVsPWUsdGhpcy5jZW50cmU9KHQuZ2V0TWluKCkrdC5nZXRNYXgoKSkvMn1mdW5jdGlvbiBtaSgpe31mdW5jdGlvbiB5aSgpe2NpLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIHhpKCl7dGhpcy5yb290PW51bGwsdGhpcy5taW5FeHRlbnQ9MSx0aGlzLnJvb3Q9bmV3IHlpfWZ1bmN0aW9uIEVpKCl7fWZ1bmN0aW9uIElpKCl7dGhpcy5yaW5nPW51bGwsdGhpcy50cmVlPW51bGwsdGhpcy5jcm9zc2luZ3M9MCx0aGlzLmludGVydmFsPW5ldyBmaTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yaW5nPXQsdGhpcy5idWlsZEluZGV4KCl9ZnVuY3Rpb24gTmkoKXtoaS5hcHBseSh0aGlzKSx0aGlzLm1jcD1udWxsLHRoaXMucD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jcD10LHRoaXMucD1lfWZ1bmN0aW9uIENpKCl7fWZ1bmN0aW9uIFNpKCl7dGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnAyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5wMj1ufWZ1bmN0aW9uIHdpKCl7dGhpcy5pbnB1dD1udWxsLHRoaXMuZXh0cmVtYWxQdHM9bnVsbCx0aGlzLmNlbnRyZT1udWxsLHRoaXMucmFkaXVzPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXQ9dH1mdW5jdGlvbiBMaSgpe2lmKHRoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5pc0NvbnZleD1udWxsLHRoaXMuY29udmV4SHVsbFB0cz1udWxsLHRoaXMubWluQmFzZVNlZz1uZXcgY2UsdGhpcy5taW5XaWR0aFB0PW51bGwsdGhpcy5taW5QdEluZGV4PW51bGwsdGhpcy5taW5XaWR0aD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07TGkuY2FsbCh0aGlzLHQsITEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0R2VvbT1lLHRoaXMuaXNDb252ZXg9bn19ZnVuY3Rpb24gUmkoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1mdW5jdGlvbiBUaSgpe3hlLmFwcGx5KHRoaXMpLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fWZ1bmN0aW9uIFBpKCl7dGhpcy5fb3JpZz1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZz10fWZ1bmN0aW9uIGJpKCl7dGhpcy5faXNNYXJrZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO1BpLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBPaSgpe3RoaXMudmVydGV4TWFwPW5ldyB0ZX1mdW5jdGlvbiBfaSgpe3RoaXMuX2lzU3RhcnQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO2JpLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBNaSgpe09pLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIERpKCl7dGhpcy5yZXN1bHQ9bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5saW5lcz1uZXcgSSx0aGlzLm5vZGVFZGdlU3RhY2s9bmV3IHBlLHRoaXMucmluZ1N0YXJ0RWRnZT1udWxsLHRoaXMuZ3JhcGg9bmV3IE1pfWZ1bmN0aW9uIEFpKCl7dGhpcy5pdGVtcz1uZXcgSSx0aGlzLnN1Ym5vZGU9bmV3IEFycmF5KDQpLmZpbGwobnVsbCl9ZnVuY3Rpb24gRmkoKXt0aGlzLnB0PW5ldyBnLHRoaXMubGV2ZWw9MCx0aGlzLmVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9ZnVuY3Rpb24gR2koKXtBaS5hcHBseSh0aGlzKSx0aGlzLmVudj1udWxsLHRoaXMuY2VudHJleD1udWxsLHRoaXMuY2VudHJleT1udWxsLHRoaXMubGV2ZWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbnY9dCx0aGlzLmxldmVsPWUsdGhpcy5jZW50cmV4PSh0LmdldE1pblgoKSt0LmdldE1heFgoKSkvMix0aGlzLmNlbnRyZXk9KHQuZ2V0TWluWSgpK3QuZ2V0TWF4WSgpKS8yfWZ1bmN0aW9uIHFpKCl7QWkuYXBwbHkodGhpcyl9ZnVuY3Rpb24gQmkoKXt0aGlzLnJvb3Q9bnVsbCx0aGlzLm1pbkV4dGVudD0xLHRoaXMucm9vdD1uZXcgcWl9ZnVuY3Rpb24gemkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIFZpKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZSx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCksdGhpcy5wYXJzZXI9bmV3IHppKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX1mdW5jdGlvbiBraSgpe3RoaXMucGFyc2VyPW5ldyB6aSh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9ZnVuY3Rpb24gWWkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllLHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKSx0aGlzLnBhcnNlcj1uZXcgcmUodGhpcy5nZW9tZXRyeUZhY3RvcnkpfWZ1bmN0aW9uIFVpKHQpe3JldHVyblt0LngsdC55XX1mdW5jdGlvbiBYaSh0LGUpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZSx0aGlzLm9sPWV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBvbCYmb2x9ZnVuY3Rpb24gSGkoKXtpZih0aGlzLm5vZGVyPW51bGwsdGhpcy5zY2FsZUZhY3Rvcj1udWxsLHRoaXMub2Zmc2V0WD1udWxsLHRoaXMub2Zmc2V0WT1udWxsLHRoaXMuaXNTY2FsZWQ9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtIaS5jYWxsKHRoaXMsdCxlLDAsMCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXSxhcmd1bWVudHNbM107dGhpcy5ub2Rlcj1uLHRoaXMuc2NhbGVGYWN0b3I9aSx0aGlzLmlzU2NhbGVkPSF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpfX1mdW5jdGlvbiBXaSgpe2lmKHRoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9ITAsdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07XG50aGlzLmlucHV0R2VvbT1lLHRoaXMuaXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSFuLmlzSW5Cb3VuZGFyeSgyKX19ZnVuY3Rpb24gamkoKXt0aGlzLnB0PW51bGwsdGhpcy5pc0Nsb3NlZD1udWxsLHRoaXMuZGVncmVlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHQ9dCx0aGlzLmlzQ2xvc2VkPSExLHRoaXMuZGVncmVlPTB9ZnVuY3Rpb24gS2koKXtpZih0aGlzLnF1YWRyYW50U2VnbWVudHM9S2kuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyx0aGlzLmVuZENhcFN0eWxlPUtpLkNBUF9ST1VORCx0aGlzLmpvaW5TdHlsZT1LaS5KT0lOX1JPVU5ELHRoaXMubWl0cmVMaW1pdD1LaS5ERUZBVUxUX01JVFJFX0xJTUlULHRoaXMuX2lzU2luZ2xlU2lkZWQ9ITEsdGhpcy5zaW1wbGlmeUZhY3Rvcj1LaS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUiwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKGUpLHRoaXMuc2V0RW5kQ2FwU3R5bGUobil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhpKSx0aGlzLnNldEVuZENhcFN0eWxlKHIpLHRoaXMuc2V0Sm9pblN0eWxlKHMpLHRoaXMuc2V0TWl0cmVMaW1pdChvKX19ZnVuY3Rpb24gWmkoKXt0aGlzLm1pbkluZGV4PS0xLHRoaXMubWluQ29vcmQ9bnVsbCx0aGlzLm1pbkRlPW51bGwsdGhpcy5vcmllbnRlZERlPW51bGx9ZnVuY3Rpb24gUWkoKXt0aGlzLmFycmF5Xz1bXX1mdW5jdGlvbiBKaSgpe3RoaXMuZmluZGVyPW51bGwsdGhpcy5kaXJFZGdlTGlzdD1uZXcgSSx0aGlzLm5vZGVzPW5ldyBJLHRoaXMucmlnaHRNb3N0Q29vcmQ9bnVsbCx0aGlzLmVudj1udWxsLHRoaXMuZmluZGVyPW5ldyBaaX1mdW5jdGlvbiAkaSgpe3RoaXMuaW5wdXRMaW5lPW51bGwsdGhpcy5kaXN0YW5jZVRvbD1udWxsLHRoaXMuaXNEZWxldGVkPW51bGwsdGhpcy5hbmdsZU9yaWVudGF0aW9uPWhlLkNPVU5URVJDTE9DS1dJU0U7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRMaW5lPXR9ZnVuY3Rpb24gdHIoKXt0aGlzLnB0TGlzdD1udWxsLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLm1pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMucHRMaXN0PW5ldyBJfWZ1bmN0aW9uIGVyKCl7dGhpcy5tYXhDdXJ2ZVNlZ21lbnRFcnJvcj0wLHRoaXMuZmlsbGV0QW5nbGVRdWFudHVtPW51bGwsdGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5zZWdMaXN0PW51bGwsdGhpcy5kaXN0YW5jZT0wLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1udWxsLHRoaXMubGk9bnVsbCx0aGlzLnMwPW51bGwsdGhpcy5zMT1udWxsLHRoaXMuczI9bnVsbCx0aGlzLnNlZzA9bmV3IGNlLHRoaXMuc2VnMT1uZXcgY2UsdGhpcy5vZmZzZXQwPW5ldyBjZSx0aGlzLm9mZnNldDE9bmV3IGNlLHRoaXMuc2lkZT0wLHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wcmVjaXNpb25Nb2RlbD10LHRoaXMuYnVmUGFyYW1zPWUsdGhpcy5saT1uZXcgYWUsdGhpcy5maWxsZXRBbmdsZVF1YW50dW09TWF0aC5QSS8yL2UuZ2V0UXVhZHJhbnRTZWdtZW50cygpLGUuZ2V0UXVhZHJhbnRTZWdtZW50cygpPj04JiZlLmdldEpvaW5TdHlsZSgpPT09S2kuSk9JTl9ST1VORCYmKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj1lci5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUiksdGhpcy5pbml0KG4pfWZ1bmN0aW9uIG5yKCl7dGhpcy5kaXN0YW5jZT0wLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnByZWNpc2lvbk1vZGVsPXQsdGhpcy5idWZQYXJhbXM9ZX1mdW5jdGlvbiBpcigpe3RoaXMuc3ViZ3JhcGhzPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMuY2dhPW5ldyBoZTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJncmFwaHM9dH1mdW5jdGlvbiBycigpe3RoaXMudXB3YXJkU2VnPW51bGwsdGhpcy5sZWZ0RGVwdGg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy51cHdhcmRTZWc9bmV3IGNlKHQpLHRoaXMubGVmdERlcHRoPWV9ZnVuY3Rpb24gc3IoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2U9bnVsbCx0aGlzLmN1cnZlQnVpbGRlcj1udWxsLHRoaXMuY3VydmVMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmlucHV0R2VvbT10LHRoaXMuZGlzdGFuY2U9ZSx0aGlzLmN1cnZlQnVpbGRlcj1ufWZ1bmN0aW9uIG9yKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuaGFzUHJvcGVyPSExLHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5oYXNJbnRlcmlvcj0hMSx0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5saT1udWxsLHRoaXMuaXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dH1mdW5jdGlvbiBhcigpe3RoaXMuYnVmUGFyYW1zPW51bGwsdGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLndvcmtpbmdOb2Rlcj1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5lZGdlTGlzdD1uZXcgbmk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVmUGFyYW1zPXR9ZnVuY3Rpb24gdXIoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnNlZ1N0cmluZ3M9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWdTdHJpbmdzPXR9ZnVuY3Rpb24gbHIoKXt0aGlzLmxpPW51bGwsdGhpcy5wdD1udWxsLHRoaXMub3JpZ2luYWxQdD1udWxsLHRoaXMucHRTY2FsZWQ9bnVsbCx0aGlzLnAwU2NhbGVkPW51bGwsdGhpcy5wMVNjYWxlZD1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm1pbng9bnVsbCx0aGlzLm1heHg9bnVsbCx0aGlzLm1pbnk9bnVsbCx0aGlzLm1heHk9bnVsbCx0aGlzLmNvcm5lcj1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLnNhZmVFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5vcmlnaW5hbFB0PXQsdGhpcy5wdD10LHRoaXMuc2NhbGVGYWN0b3I9ZSx0aGlzLmxpPW4sZTw9MCl0aHJvdyBuZXcgaShcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5wdD1uZXcgZyh0aGlzLnNjYWxlKHQueCksdGhpcy5zY2FsZSh0LnkpKSx0aGlzLnAwU2NhbGVkPW5ldyBnLHRoaXMucDFTY2FsZWQ9bmV3IGcpLHRoaXMuaW5pdENvcm5lcnModGhpcy5wdCl9ZnVuY3Rpb24gaHIoKXt0aGlzLmluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5kZXg9dH1mdW5jdGlvbiBjcigpe2hpLmFwcGx5KHRoaXMpLHRoaXMuaG90UGl4ZWw9bnVsbCx0aGlzLnBhcmVudEVkZ2U9bnVsbCx0aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg9bnVsbCx0aGlzLl9pc05vZGVBZGRlZD0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5ob3RQaXhlbD10LHRoaXMucGFyZW50RWRnZT1lLHRoaXMuaG90UGl4ZWxWZXJ0ZXhJbmRleD1ufWZ1bmN0aW9uIGZyKCl7dGhpcy5saT1udWxsLHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ucz1uZXcgSX1mdW5jdGlvbiBncigpe3RoaXMucG09bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5zY2FsZUZhY3Rvcj1udWxsLHRoaXMubm9kZXI9bnVsbCx0aGlzLnBvaW50U25hcHBlcj1udWxsLHRoaXMubm9kZWRTZWdTdHJpbmdzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucG09dCx0aGlzLmxpPW5ldyBhZSx0aGlzLmxpLnNldFByZWNpc2lvbk1vZGVsKHQpLHRoaXMuc2NhbGVGYWN0b3I9dC5nZXRTY2FsZSgpfWZ1bmN0aW9uIGRyKCl7aWYodGhpcy5hcmdHZW9tPW51bGwsdGhpcy5kaXN0YW5jZT1udWxsLHRoaXMuYnVmUGFyYW1zPW5ldyBLaSx0aGlzLnJlc3VsdEdlb21ldHJ5PW51bGwsdGhpcy5zYXZlRXhjZXB0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFyZ0dlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5hcmdHZW9tPWUsdGhpcy5idWZQYXJhbXM9bn19ZnVuY3Rpb24gcHIoKXt0aGlzLmNvbXBzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHM9dH1mdW5jdGlvbiB2cigpe2lmKHRoaXMuY29tcG9uZW50PW51bGwsdGhpcy5zZWdJbmRleD1udWxsLHRoaXMucHQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3ZyLmNhbGwodGhpcyx0LHZyLklOU0lERV9BUkVBLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmNvbXBvbmVudD1uLHRoaXMuc2VnSW5kZXg9aSx0aGlzLnB0PXJ9fWZ1bmN0aW9uIG1yKCl7dGhpcy5wdHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9dH1mdW5jdGlvbiB5cigpe3RoaXMubG9jYXRpb25zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubG9jYXRpb25zPXR9ZnVuY3Rpb24geHIoKXtpZih0aGlzLmdlb209bnVsbCx0aGlzLnRlcm1pbmF0ZURpc3RhbmNlPTAsdGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbj1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt4ci5jYWxsKHRoaXMsdCxlLDApfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmdlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5nZW9tWzBdPW4sdGhpcy5nZW9tWzFdPWksdGhpcy50ZXJtaW5hdGVEaXN0YW5jZT1zfX1mdW5jdGlvbiBFcigpe3RoaXMuZmFjdG9yeT1udWxsLHRoaXMuZGlyZWN0ZWRFZGdlcz1uZXcgSSx0aGlzLmNvb3JkaW5hdGVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIElyKCl7dGhpcy5faXNNYXJrZWQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuZGF0YT1udWxsfWZ1bmN0aW9uIE5yKCl7SXIuYXBwbHkodGhpcyksdGhpcy5wYXJlbnRFZGdlPW51bGwsdGhpcy5mcm9tPW51bGwsdGhpcy50bz1udWxsLHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5zeW09bnVsbCx0aGlzLmVkZ2VEaXJlY3Rpb249bnVsbCx0aGlzLnF1YWRyYW50PW51bGwsdGhpcy5hbmdsZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLmZyb209dCx0aGlzLnRvPWUsdGhpcy5lZGdlRGlyZWN0aW9uPWksdGhpcy5wMD10LmdldENvb3JkaW5hdGUoKSx0aGlzLnAxPW47dmFyIHI9dGhpcy5wMS54LXRoaXMucDAueCxzPXRoaXMucDEueS10aGlzLnAwLnk7dGhpcy5xdWFkcmFudD1KZS5xdWFkcmFudChyLHMpLHRoaXMuYW5nbGU9TWF0aC5hdGFuMihzLHIpfWZ1bmN0aW9uIENyKCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO05yLmNhbGwodGhpcyx0LGUsbixpKX1mdW5jdGlvbiBTcigpe2lmKElyLmFwcGx5KHRoaXMpLHRoaXMuZGlyRWRnZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXREaXJlY3RlZEVkZ2VzKHQsZSl9fWZ1bmN0aW9uIHdyKCl7dGhpcy5vdXRFZGdlcz1uZXcgSSx0aGlzLnNvcnRlZD0hMX1mdW5jdGlvbiBMcigpe2lmKElyLmFwcGx5KHRoaXMpLHRoaXMucHQ9bnVsbCx0aGlzLmRlU3Rhcj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07THIuY2FsbCh0aGlzLHQsbmV3IHdyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wdD1lLHRoaXMuZGVTdGFyPW59fWZ1bmN0aW9uIFJyKCl7U3IuYXBwbHkodGhpcyksdGhpcy5saW5lPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZT10fWZ1bmN0aW9uIFRyKCl7dGhpcy5ub2RlTWFwPW5ldyBydH1mdW5jdGlvbiBQcigpe3RoaXMuZWRnZXM9bmV3IEosdGhpcy5kaXJFZGdlcz1uZXcgSix0aGlzLm5vZGVNYXA9bmV3IFRyfWZ1bmN0aW9uIGJyKCl7UHIuYXBwbHkodGhpcyl9ZnVuY3Rpb24gT3IoKXt0aGlzLmdyYXBoPW5ldyBicix0aGlzLm1lcmdlZExpbmVTdHJpbmdzPW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5lZGdlU3RyaW5ncz1udWxsfWZ1bmN0aW9uIF9yKCl7dGhpcy5lZGdlUmluZz1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMubGFiZWw9LTE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO05yLmNhbGwodGhpcyx0LGUsbixpKX1mdW5jdGlvbiBNcigpe1NyLmFwcGx5KHRoaXMpLHRoaXMubGluZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpbmU9dH1mdW5jdGlvbiBEcigpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PW5ldyBpZSx0aGlzLmdlb21HcmFwaD1udWxsLHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUdyYXBoPXR9ZnVuY3Rpb24gQXIoKXt9ZnVuY3Rpb24gRnIoKXtpZih0aGlzLmVkZ2VFbmRzPW5ldyBJLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07RnIuY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9KGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pO0VuLmNhbGwodGhpcyxlLmdldEVkZ2UoKSxlLmdldENvb3JkaW5hdGUoKSxlLmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBnbihlLmdldExhYmVsKCkpKSx0aGlzLmluc2VydChlKX19ZnVuY3Rpb24gR3IoKXtQbi5hcHBseSh0aGlzKX1mdW5jdGlvbiBxcigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt5bi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBCcigpe05uLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIHpyKCl7dGhpcy5ub2Rlcz1uZXcgeG4obmV3IEJyKX1mdW5jdGlvbiBWcigpe3RoaXMubGk9bmV3IGFlLHRoaXMuZ2VvbUdyYXBoPW51bGwsdGhpcy5ub2RlR3JhcGg9bmV3IHpyLHRoaXMuaW52YWxpZFBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUdyYXBoPXR9ZnVuY3Rpb24ga3IoKXt0aGlzLmdyYXBoPW51bGwsdGhpcy5yaW5ncz1uZXcgSSx0aGlzLnRvdGFsRW52PW5ldyBDLHRoaXMuaW5kZXg9bnVsbCx0aGlzLm5lc3RlZFB0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ3JhcGg9dH1mdW5jdGlvbiBZcigpe2lmKHRoaXMuZXJyb3JUeXBlPW51bGwsdGhpcy5wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07WXIuY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZXJyb3JUeXBlPWUsbnVsbCE9PW4mJih0aGlzLnB0PW4uY29weSgpKX19ZnVuY3Rpb24gVXIoKXt0aGlzLnBhcmVudEdlb21ldHJ5PW51bGwsdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPSExLHRoaXMudmFsaWRFcnI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wYXJlbnRHZW9tZXRyeT10fWZ1bmN0aW9uIFhyKCl7dGhpcy5mYWN0b3J5PW51bGwsdGhpcy5kZUxpc3Q9bmV3IEksdGhpcy5sb3dlc3RFZGdlPW51bGwsdGhpcy5yaW5nPW51bGwsdGhpcy5yaW5nUHRzPW51bGwsdGhpcy5ob2xlcz1udWxsLHRoaXMuc2hlbGw9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9pc1Byb2Nlc3NlZD0hMSx0aGlzLl9pc0luY2x1ZGVkU2V0PSExLHRoaXMuX2lzSW5jbHVkZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIEhyKCl7fWZ1bmN0aW9uIFdyKCl7UHIuYXBwbHkodGhpcyksdGhpcy5mYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIGpyKCl7aWYodGhpcy5saW5lU3RyaW5nQWRkZXI9bmV3IEtyKHRoaXMpLHRoaXMuZ3JhcGg9bnVsbCx0aGlzLmRhbmdsZXM9bmV3IEksdGhpcy5jdXRFZGdlcz1uZXcgSSx0aGlzLmludmFsaWRSaW5nTGluZXM9bmV3IEksdGhpcy5ob2xlTGlzdD1udWxsLHRoaXMuc2hlbGxMaXN0PW51bGwsdGhpcy5wb2x5TGlzdD1udWxsLHRoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ9ITAsdGhpcy5leHRyYWN0T25seVBvbHlnb25hbD1udWxsLHRoaXMuZ2VvbUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClqci5jYWxsKHRoaXMsITEpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsPXR9fWZ1bmN0aW9uIEtyKCl7dGhpcy5wPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZ1bmN0aW9uIFpyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMuYXJnPW51bGwsdGhpcy5ub2Rlcz1uZXcgeG4obmV3IEJyKSx0aGlzLmltPW51bGwsdGhpcy5pc29sYXRlZEVkZ2VzPW5ldyBJLHRoaXMuaW52YWxpZFBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJnPXR9ZnVuY3Rpb24gUXIoKXt0aGlzLnJlY3RFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIEpyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5yZWN0RW52PW51bGwsdGhpcy5kaWFnVXAwPW51bGwsdGhpcy5kaWFnVXAxPW51bGwsdGhpcy5kaWFnRG93bjA9bnVsbCx0aGlzLmRpYWdEb3duMT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RFbnY9dCx0aGlzLmRpYWdVcDA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuZGlhZ1VwMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksdGhpcy5kaWFnRG93bjA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLHRoaXMuZGlhZ0Rvd24xPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKX1mdW5jdGlvbiAkcigpe3RoaXMuX2lzRG9uZT0hMX1mdW5jdGlvbiB0cygpe3RoaXMucmVjdGFuZ2xlPW51bGwsdGhpcy5yZWN0RW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdGFuZ2xlPXQsdGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIGVzKCl7JHIuYXBwbHkodGhpcyksdGhpcy5yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXR9ZnVuY3Rpb24gbnMoKXskci5hcHBseSh0aGlzKSx0aGlzLnJlY3RTZXE9bnVsbCx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLl9jb250YWluc1BvaW50PSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RTZXE9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0aGlzLnJlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9ZnVuY3Rpb24gaXMoKXskci5hcHBseSh0aGlzKSx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLnJlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuaGFzSW50ZXJzZWN0aW9uPSExLHRoaXMucDA9bmV3IGcsdGhpcy5wMT1uZXcgZzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMucmVjdEludGVyc2VjdG9yPW5ldyBKcih0aGlzLnJlY3RFbnYpfWZ1bmN0aW9uIHJzKCl7aWYodGhpcy5fcmVsYXRlPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsdCxlKSx0aGlzLl9yZWxhdGU9bmV3IFpyKHRoaXMuYXJnKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGkuY2FsbCh0aGlzLG4saSxyKSx0aGlzLl9yZWxhdGU9bmV3IFpyKHRoaXMuYXJnKX19ZnVuY3Rpb24gc3MoKXt0aGlzLmdlb21GYWN0b3J5PW51bGwsdGhpcy5za2lwRW1wdHk9ITEsdGhpcy5pbnB1dEdlb21zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUZhY3Rvcnk9c3MuZXh0cmFjdEZhY3RvcnkodCksdGhpcy5pbnB1dEdlb21zPXR9ZnVuY3Rpb24gb3MoKXt0aGlzLnBvaW50R2VvbT1udWxsLHRoaXMub3RoZXJHZW9tPW51bGwsdGhpcy5nZW9tRmFjdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnBvaW50R2VvbT10LHRoaXMub3RoZXJHZW9tPWUsdGhpcy5nZW9tRmFjdD1lLmdldEZhY3RvcnkoKX1mdW5jdGlvbiBhcygpe3RoaXMuc29ydEluZGV4PS0xLHRoaXMuY29tcHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zb3J0SW5kZXg9dCx0aGlzLmNvbXBzPWV9ZnVuY3Rpb24gdXMoKXt0aGlzLmlucHV0UG9seXM9bnVsbCx0aGlzLmdlb21GYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRQb2x5cz10LG51bGw9PT10aGlzLmlucHV0UG9seXMmJih0aGlzLmlucHV0UG9seXM9bmV3IEkpfWZ1bmN0aW9uIGxzKCl7aWYodGhpcy5wb2x5Z29ucz1uZXcgSSx0aGlzLmxpbmVzPW5ldyBJLHRoaXMucG9pbnRzPW5ldyBJLHRoaXMuZ2VvbUZhY3Q9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21GYWN0PWksdGhpcy5leHRyYWN0KG4pfX1mdW5jdGlvbiBocygpe190LkNvb3JkaW5hdGVPcGVyYXRpb24uYXBwbHkodGhpcyksdGhpcy50YXJnZXRQTT1udWxsLHRoaXMucmVtb3ZlQ29sbGFwc2VkPSEwO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnRhcmdldFBNPXQsdGhpcy5yZW1vdmVDb2xsYXBzZWQ9ZX1mdW5jdGlvbiBjcygpe3RoaXMudGFyZ2V0UE09bnVsbCx0aGlzLnJlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsPSExLHRoaXMuaXNQb2ludHdpc2U9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudGFyZ2V0UE09dH1mdW5jdGlvbiBmcygpe3RoaXMucHRzPW51bGwsdGhpcy51c2VQdD1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLnNlZz1uZXcgY2U7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXR9ZnVuY3Rpb24gZ3MoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1mdW5jdGlvbiBkcygpe3hlLmFwcGx5KHRoaXMpLHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPWV9ZnVuY3Rpb24gcHMoKXtpZih0aGlzLnBhcmVudD1udWxsLHRoaXMuaW5kZXg9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3BzLmNhbGwodGhpcyx0LGUsbnVsbCwtMSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2NlLmNhbGwodGhpcyxuLGkpLHRoaXMucGFyZW50PXIsdGhpcy5pbmRleD1zfX1mdW5jdGlvbiB2cygpe2lmKHRoaXMucGFyZW50TGluZT1udWxsLHRoaXMuc2Vncz1udWxsLHRoaXMucmVzdWx0U2Vncz1uZXcgSSx0aGlzLm1pbmltdW1TaXplPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt2cy5jYWxsKHRoaXMsdCwyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wYXJlbnRMaW5lPWUsdGhpcy5taW5pbXVtU2l6ZT1uLHRoaXMuaW5pdCgpfX1mdW5jdGlvbiBtcygpe3RoaXMuaW5kZXg9bmV3IEJpfWZ1bmN0aW9uIHlzKCl7dGhpcy5xdWVyeVNlZz1udWxsLHRoaXMuaXRlbXM9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucXVlcnlTZWc9dH1mdW5jdGlvbiB4cygpe3RoaXMubGk9bmV3IGFlLHRoaXMuaW5wdXRJbmRleD1uZXcgbXMsdGhpcy5vdXRwdXRJbmRleD1uZXcgbXMsdGhpcy5saW5lPW51bGwsdGhpcy5saW5lUHRzPW51bGwsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT0wO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0SW5kZXg9dCx0aGlzLm91dHB1dEluZGV4PWV9ZnVuY3Rpb24gRXMoKXt0aGlzLmlucHV0SW5kZXg9bmV3IG1zLHRoaXMub3V0cHV0SW5kZXg9bmV3IG1zLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9MH1mdW5jdGlvbiBJcygpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5saW5lU2ltcGxpZmllcj1uZXcgRXMsdGhpcy5saW5lc3RyaW5nTWFwPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gTnMoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmxpbmVzdHJpbmdNYXA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lc3RyaW5nTWFwPXR9ZnVuY3Rpb24gQ3MoKXt0aGlzLnRwcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fWZ1bmN0aW9uIFNzKCl7dGhpcy5zZWc9bnVsbCx0aGlzLnNlZ0xlbj1udWxsLHRoaXMuc3BsaXRQdD1udWxsLHRoaXMubWluaW11bUxlbj0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNlZz10LHRoaXMuc2VnTGVuPXQuZ2V0TGVuZ3RoKCl9ZnVuY3Rpb24gd3MoKXt9ZnVuY3Rpb24gTHMoKXt9ZnVuY3Rpb24gUnMoKXt9ZnVuY3Rpb24gVHMoKXtpZih0aGlzLnA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD1uZXcgZyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wPW5ldyBnKGUsbil9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMucD1uZXcgZyhpLHIscyl9fWZ1bmN0aW9uIFBzKCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9bnVsbCx0aGlzLmNvbnN0cmFpbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07VHMuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIGJzKCl7dGhpcy5fcm90PW51bGwsdGhpcy52ZXJ0ZXg9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLmRhdGE9bnVsbH1mdW5jdGlvbiBPcygpe3RoaXMuc3ViZGl2PW51bGwsdGhpcy5pc1VzaW5nVG9sZXJhbmNlPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnN1YmRpdj10LHRoaXMuaXNVc2luZ1RvbGVyYW5jZT10LmdldFRvbGVyYW5jZSgpPjB9ZnVuY3Rpb24gX3MoKXt9ZnVuY3Rpb24gTXMoKXt0aGlzLnN1YmRpdj1udWxsLHRoaXMubGFzdEVkZ2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJkaXY9dCx0aGlzLmluaXQoKX1mdW5jdGlvbiBEcygpe2lmKHRoaXMuc2VnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciBlPWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyxcIkxvY2F0ZSBmYWlsZWQgdG8gY29udmVyZ2UgKGF0IGVkZ2U6IFwiK2UrXCIpLiAgUG9zc2libGUgY2F1c2VzIGluY2x1ZGUgaW52YWxpZCBTdWJkaXZpc2lvbiB0b3BvbG9neSBvciB2ZXJ5IGNsb3NlIHNpdGVzXCIpLHRoaXMuc2VnPW5ldyBjZShlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2wuY2FsbCh0aGlzLERzLm1zZ1dpdGhTcGF0aWFsKG4saSkpLHRoaXMuc2VnPW5ldyBjZShpKX19ZnVuY3Rpb24gQXMoKXt9ZnVuY3Rpb24gRnMoKXt0aGlzLnZpc2l0ZWRLZXk9MCx0aGlzLnF1YWRFZGdlcz1uZXcgSSx0aGlzLnN0YXJ0aW5nRWRnZT1udWxsLHRoaXMudG9sZXJhbmNlPW51bGwsdGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLmZyYW1lVmVydGV4PW5ldyBBcnJheSgzKS5maWxsKG51bGwpLHRoaXMuZnJhbWVFbnY9bnVsbCx0aGlzLmxvY2F0b3I9bnVsbCx0aGlzLnNlZz1uZXcgY2UsdGhpcy50cmlFZGdlcz1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy50b2xlcmFuY2U9ZSx0aGlzLmVkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1lL0ZzLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUix0aGlzLmNyZWF0ZUZyYW1lKHQpLHRoaXMuc3RhcnRpbmdFZGdlPXRoaXMuaW5pdFN1YmRpdigpLHRoaXMubG9jYXRvcj1uZXcgTXModGhpcyl9ZnVuY3Rpb24gR3MoKXt9ZnVuY3Rpb24gcXMoKXt0aGlzLnRyaUxpc3Q9bmV3IEl9ZnVuY3Rpb24gQnMoKXt0aGlzLnRyaUxpc3Q9bmV3IEl9ZnVuY3Rpb24genMoKXt0aGlzLmNvb3JkTGlzdD1uZXcgTix0aGlzLnRyaUNvb3Jkcz1uZXcgSX1mdW5jdGlvbiBWcygpe2lmKHRoaXMubHM9bnVsbCx0aGlzLmRhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubHM9bmV3IGNlKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMubHM9bmV3IGNlKG4saSksdGhpcy5kYXRhPXJ9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9YXJndW1lbnRzWzJdLHU9YXJndW1lbnRzWzNdLGw9YXJndW1lbnRzWzRdLGg9YXJndW1lbnRzWzVdO1ZzLmNhbGwodGhpcyxuZXcgZyhzLG8sYSksbmV3IGcodSxsLGgpKX1lbHNlIGlmKDc9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1hcmd1bWVudHNbMF0sZj1hcmd1bWVudHNbMV0sZD1hcmd1bWVudHNbMl0scD1hcmd1bWVudHNbM10sdj1hcmd1bWVudHNbNF0sbT1hcmd1bWVudHNbNV0seT1hcmd1bWVudHNbNl07VnMuY2FsbCh0aGlzLG5ldyBnKGMsZixkKSxuZXcgZyhwLHYsbSkseSl9fWZ1bmN0aW9uIGtzKCl7fWZ1bmN0aW9uIFlzKCl7aWYodGhpcy5wPW51bGwsdGhpcy5kYXRhPW51bGwsdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucD1uZXcgZyh0KSx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD0xLHRoaXMuZGF0YT1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLnA9bmV3IGcobixpKSx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD0xLHRoaXMuZGF0YT1yfX1mdW5jdGlvbiBVcygpe2lmKHRoaXMucm9vdD1udWxsLHRoaXMubnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMudG9sZXJhbmNlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVXMuY2FsbCh0aGlzLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRvbGVyYW5jZT10fX1mdW5jdGlvbiBYcygpe3RoaXMudG9sZXJhbmNlPW51bGwsdGhpcy5tYXRjaE5vZGU9bnVsbCx0aGlzLm1hdGNoRGlzdD0wLHRoaXMucD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnA9dCx0aGlzLnRvbGVyYW5jZT1lfWZ1bmN0aW9uIEhzKCl7dGhpcy5pbml0aWFsVmVydGljZXM9bnVsbCx0aGlzLnNlZ1ZlcnRpY2VzPW51bGwsdGhpcy5zZWdtZW50cz1uZXcgSSx0aGlzLnN1YmRpdj1udWxsLHRoaXMuaW5jRGVsPW51bGwsdGhpcy5jb252ZXhIdWxsPW51bGwsdGhpcy5zcGxpdEZpbmRlcj1uZXcgTHMsdGhpcy5rZHQ9bnVsbCx0aGlzLnZlcnRleEZhY3Rvcnk9bnVsbCx0aGlzLmNvbXB1dGVBcmVhRW52PW51bGwsdGhpcy5zcGxpdFB0PW51bGwsdGhpcy50b2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0aWFsVmVydGljZXM9bmV3IEkodCksdGhpcy50b2xlcmFuY2U9ZSx0aGlzLmtkdD1uZXcgVXMoZSl9ZnVuY3Rpb24gV3MoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLnRvbGVyYW5jZT0wLHRoaXMuc3ViZGl2PW51bGx9ZnVuY3Rpb24ganMoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLmNvbnN0cmFpbnRMaW5lcz1udWxsLHRoaXMudG9sZXJhbmNlPTAsdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXA9bmV3IHJ0fWZ1bmN0aW9uIEtzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy50b2xlcmFuY2U9MCx0aGlzLnN1YmRpdj1udWxsLHRoaXMuY2xpcEVudj1udWxsLHRoaXMuZGlhZ3JhbUVudj1udWxsfWZ1bmN0aW9uIFpzKCl7fVwiZmlsbFwiaW4gQXJyYXkucHJvdG90eXBlfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLFwiZmlsbFwiLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dGhpc3x8bnVsbD09PXRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcih0aGlzK1wiIGlzIG5vdCBhbiBvYmplY3RcIik7dmFyIGU9T2JqZWN0KHRoaXMpLG49TWF0aC5tYXgoTWF0aC5taW4oZS5sZW5ndGgsOTAwNzE5OTI1NDc0MDk5MSksMCl8fDAsaT0xIGluIGFyZ3VtZW50cz9wYXJzZUludChOdW1iZXIoYXJndW1lbnRzWzFdKSwxMCl8fDA6MDtpPWk8MD9NYXRoLm1heChuK2ksMCk6TWF0aC5taW4oaSxuKTt2YXIgcj0yIGluIGFyZ3VtZW50cyYmdm9pZCAwIT09YXJndW1lbnRzWzJdP3BhcnNlSW50KE51bWJlcihhcmd1bWVudHNbMl0pLDEwKXx8MDpuO2ZvcihyPXI8MD9NYXRoLm1heChuK2FyZ3VtZW50c1syXSwwKTpNYXRoLm1pbihyLG4pO2k8cjspZVtpXT10LCsraTtyZXR1cm4gZX0sd3JpdGFibGU6ITB9KSxOdW1iZXIuaXNGaW5pdGU9TnVtYmVyLmlzRmluaXRlfHxmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCl9LE51bWJlci5pc0ludGVnZXI9TnVtYmVyLmlzSW50ZWdlcnx8ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJmlzRmluaXRlKHQpJiZNYXRoLmZsb29yKHQpPT09dH0sTnVtYmVyLnBhcnNlRmxvYXQ9TnVtYmVyLnBhcnNlRmxvYXR8fHBhcnNlRmxvYXQsTnVtYmVyLmlzTmFOPU51bWJlci5pc05hTnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQhPT10fSxNYXRoLnRydW5jPU1hdGgudHJ1bmN8fGZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpOk1hdGguZmxvb3IodCl9LGUobi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG59fSksbi5lcXVhbHNXaXRoVG9sZXJhbmNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn0sci5pc05hTj1mdW5jdGlvbih0KXtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpfSxyLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5pc0luZmluaXRlPWZ1bmN0aW9uKHQpe3JldHVybiFOdW1iZXIuaXNGaW5pdGUodCl9LHIuTUFYX1ZBTFVFPU51bWJlci5NQVhfVkFMVUUsbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpLGwucHJvdG90eXBlLmNvbnN0cnVjdG9yPUVycm9yLGgoYyxsKSxlKGMucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjfX0pLGUoZi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9fSksZi5zaG91bGROZXZlclJlYWNoSGVyZT1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3Rocm93IG5ldyBjKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIisobnVsbCE9PXQ/XCI6IFwiK3Q6XCJcIikpfX0sZi5pc1RydWU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2YuaXNUcnVlKHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKCFlKXRocm93IG51bGw9PT1uP25ldyBjOm5ldyBjKG4pfX0sZi5lcXVhbHM9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2YuZXF1YWxzKHQsZSxudWxsKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07aWYoIWkuZXF1YWxzKG4pKXRocm93IG5ldyBjKFwiRXhwZWN0ZWQgXCIrbitcIiBidXQgZW5jb3VudGVyZWQgXCIraSsobnVsbCE9PXI/XCI6IFwiK3I6XCJcIikpfX0sZShnLnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godCl7Y2FzZSBnLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBnLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBnLlo6dGhpcy56PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgaShcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX0sZXF1YWxzMkQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiEhbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueCxlLngsaSkmJiEhbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSxlLnksaSl9fSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSBnLlg6cmV0dXJuIHRoaXMueDtjYXNlIGcuWTpyZXR1cm4gdGhpcy55O2Nhc2UgZy5aOnJldHVybiB0aGlzLnp9dGhyb3cgbmV3IGkoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX0sZXF1YWxzM0Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55JiYodGhpcy56PT09dC56fHxyLmlzTmFOKHRoaXMueikmJnIuaXNOYU4odC56KSl9LGVxdWFsczpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGcmJnRoaXMuZXF1YWxzMkQodCl9LGVxdWFsSW5aOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnosdC56LGUpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy54PGUueD8tMTp0aGlzLng+ZS54PzE6dGhpcy55PGUueT8tMTp0aGlzLnk+ZS55PzE6MH0sY2xvbmU6ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9bnVsbDtyZXR1cm4gdH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJ0aGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIENsb25lYWJsZVwiKSxudWxsO3Rocm93IHR9ZmluYWxseXt9fSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKHRoaXMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLnorXCIpXCJ9LGRpc3RhbmNlM0Q6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy54LXQueCxuPXRoaXMueS10LnksaT10aGlzLnotdC56O3JldHVybiBNYXRoLnNxcnQoZSplK24qbitpKmkpfSxkaXN0YW5jZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLngtdC54LG49dGhpcy55LXQueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfSxoYXNoQ29kZTpmdW5jdGlvbigpe3ZhciB0PTE3O3JldHVybiB0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLngpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMueSl9LHNldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10Lnp9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3Msbyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ319KSxnLmhhc2hDb2RlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtyZXR1cm4gTWF0aC50cnVuYyhlXmU+Pj4zMil9fSxlKGQucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWUscj1kLmNvbXBhcmUobi54LGkueCk7aWYoMCE9PXIpcmV0dXJuIHI7dmFyIHM9ZC5jb21wYXJlKG4ueSxpLnkpO2lmKDAhPT1zKXJldHVybiBzO2lmKHRoaXMuZGltZW5zaW9uc1RvVGVzdDw9MilyZXR1cm4gMDt2YXIgbz1kLmNvbXBhcmUobi56LGkueik7cmV0dXJuIG99LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkfX0pLGQuY29tcGFyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6ci5pc05hTih0KT9yLmlzTmFOKGUpPzA6LTE6ci5pc05hTihlKT8xOjB9LGcuRGltZW5zaW9uYWxDb21wYXJhdG9yPWQsZy5zZXJpYWxWZXJzaW9uVUlEPTB4NWNiZjJjMjM1YzdlNTgwMCxnLk5VTExfT1JESU5BVEU9ci5OYU4sZy5YPTAsZy5ZPTEsZy5aPTIscC5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe30scC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe30scC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe30sbS5wcm90b3R5cGU9bmV3IEVycm9yLG0ucHJvdG90eXBlLm5hbWU9XCJJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIseS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh2LnByb3RvdHlwZSkseS5wcm90b3R5cGUuY29uc3RydWN0b3I9eSx5LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LHkucHJvdG90eXBlLnNldD1mdW5jdGlvbigpe30seS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe30seC5wcm90b3R5cGU9bmV3IEVycm9yLHgucHJvdG90eXBlLm5hbWU9XCJOb1N1Y2hFbGVtZW50RXhjZXB0aW9uXCIsRS5wcm90b3R5cGU9bmV3IEVycm9yLEUucHJvdG90eXBlLm5hbWU9XCJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRcIixJLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHkucHJvdG90eXBlKSxJLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1JLEkucHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5PWZ1bmN0aW9uKCl7fSxJLnByb3RvdHlwZS5pbnRlcmZhY2VzXz1mdW5jdGlvbigpe3JldHVyblt5LHZdfSxJLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMuYXJyYXlfLnB1c2godCk6dGhpcy5hcnJheV8uc3BsaWNlKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pLCEwfSxJLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuYXJyYXlfPVtdfSxJLnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSxJLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFycmF5X1t0XTtyZXR1cm4gdGhpcy5hcnJheV9bdF09ZSxufSxJLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgUXModGhpcyl9LEkucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBtO3JldHVybiB0aGlzLmFycmF5X1t0XX0sSS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxJLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxJLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSExLG49MCxpPXRoaXMuYXJyYXlfLmxlbmd0aDtuPGk7bisrKWlmKHRoaXMuYXJyYXlfW25dPT09dCl7dGhpcy5hcnJheV8uc3BsaWNlKG4sMSksZT0hMDticmVha31yZXR1cm4gZX07dmFyIFFzPWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlMaXN0Xz10LHRoaXMucG9zaXRpb25fPTB9O1FzLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLmFycmF5TGlzdF8uc2l6ZSgpKXRocm93IG5ldyB4O3JldHVybiB0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKyspfSxRcy5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmFycmF5TGlzdF8uc2l6ZSgpfSxRcy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5TGlzdF8uc2V0KHRoaXMucG9zaXRpb25fLTEsdCl9LFFzLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aGlzLmFycmF5TGlzdF8ucmVtb3ZlKHRoaXMuYXJyYXlMaXN0Xy5nZXQodGhpcy5wb3NpdGlvbl8pKX0saChOLEkpLGUoTi5wcm90b3R5cGUse2dldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSxhZGRBbGw6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPSExLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl0aGlzLmFkZChpLm5leHQoKSxlKSxuPSEwO3JldHVybiBufXJldHVybiBJLnByb3RvdHlwZS5hZGRBbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjbG9uZTpmdW5jdGlvbiB0KCl7Zm9yKHZhciB0PUkucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyksZT0wO2U8dGhpcy5zaXplKCk7ZSsrKXQuYWRkKGUsdGhpcy5nZXQoZSkuY29weSgpKTtyZXR1cm4gdH0sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0FycmF5KE4uY29vcmRBcnJheVR5cGUpfSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0kucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQoZSxuLCEwKSwhMH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07aWYoIXImJnRoaXMuc2l6ZSgpPj0xKXt2YXIgcz10aGlzLmdldCh0aGlzLnNpemUoKS0xKTtpZihzLmVxdWFsczJEKGkpKXJldHVybiBudWxsfUkucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQobyxhKSwhMH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV0saD1hcmd1bWVudHNbMl07aWYoaClmb3IodmFyIGM9MDtjPHUubGVuZ3RoO2MrKyl0aGlzLmFkZCh1W2NdLGwpO2Vsc2UgZm9yKHZhciBjPXUubGVuZ3RoLTE7Yz49MDtjLS0pdGhpcy5hZGQodVtjXSxsKTtyZXR1cm4hMH1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBmPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXTtpZighcCl7dmFyIHY9dGhpcy5zaXplKCk7aWYodj4wKXtpZihmPjApe3ZhciBtPXRoaXMuZ2V0KGYtMSk7aWYobS5lcXVhbHMyRChkKSlyZXR1cm4gbnVsbH1pZihmPHYpe3ZhciB5PXRoaXMuZ2V0KGYpO2lmKHkuZXF1YWxzMkQoZCkpcmV0dXJuIG51bGx9fX1JLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLGYsZCl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB4PWFyZ3VtZW50c1swXSxFPWFyZ3VtZW50c1sxXSxOPWFyZ3VtZW50c1syXSxDPWFyZ3VtZW50c1szXSxTPTE7Tj5DJiYoUz0tMSk7Zm9yKHZhciBjPU47YyE9PUM7Yys9Uyl0aGlzLmFkZCh4W2NdLEUpO3JldHVybiEwfX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7dGhpcy5zaXplKCk+MCYmdGhpcy5hZGQobmV3IGcodGhpcy5nZXQoMCkpLCExKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTn19KSxOLmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLGUoQy5wcm90b3R5cGUse2dldEFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRXaWR0aCgpKnRoaXMuZ2V0SGVpZ2h0KCl9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBDKSlyZXR1cm4hMTt2YXIgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk6dGhpcy5tYXh4PT09ZS5nZXRNYXhYKCkmJnRoaXMubWF4eT09PWUuZ2V0TWF4WSgpJiZ0aGlzLm1pbng9PT1lLmdldE1pblgoKSYmdGhpcy5taW55PT09ZS5nZXRNaW5ZKCl9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtpZih0aGlzLmlzTnVsbCgpfHx0LmlzTnVsbCgpfHwhdGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiBuZXcgQzt2YXIgZT10aGlzLm1pbng+dC5taW54P3RoaXMubWlueDp0Lm1pbngsbj10aGlzLm1pbnk+dC5taW55P3RoaXMubWlueTp0Lm1pbnksaT10aGlzLm1heHg8dC5tYXh4P3RoaXMubWF4eDp0Lm1heHgscj10aGlzLm1heHk8dC5tYXh5P3RoaXMubWF4eTp0Lm1heHk7cmV0dXJuIG5ldyBDKGUsaSxuLHIpfSxpc051bGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh4PHRoaXMubWlueH0sZ2V0TWF4WDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heHh9LGNvdmVyczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModC54LHQueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiFlLmlzTnVsbCgpJiYoZS5nZXRNaW5YKCk+PXRoaXMubWlueCYmZS5nZXRNYXhYKCk8PXRoaXMubWF4eCYmZS5nZXRNaW5ZKCk+PXRoaXMubWlueSYmZS5nZXRNYXhZKCk8PXRoaXMubWF4eSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmKG4+PXRoaXMubWlueCYmbjw9dGhpcy5tYXh4JiZpPj10aGlzLm1pbnkmJmk8PXRoaXMubWF4eSl9fSxpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiF0aGlzLmlzTnVsbCgpJiYhdC5pc051bGwoKSYmISh0Lm1pbng+dGhpcy5tYXh4fHx0Lm1heHg8dGhpcy5taW54fHx0Lm1pbnk+dGhpcy5tYXh5fHx0Lm1heHk8dGhpcy5taW55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKGUueCxlLnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiEobj50aGlzLm1heHh8fG48dGhpcy5taW54fHxpPnRoaXMubWF4eXx8aTx0aGlzLm1pbnkpfX0sZ2V0TWluWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbnl9LGdldE1pblg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW54fSxleHBhbmRUb0luY2x1ZGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRUb0luY2x1ZGUodC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTtpZihlLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaXNOdWxsKCk/KHRoaXMubWlueD1lLmdldE1pblgoKSx0aGlzLm1heHg9ZS5nZXRNYXhYKCksdGhpcy5taW55PWUuZ2V0TWluWSgpLHRoaXMubWF4eT1lLmdldE1heFkoKSk6KGUubWlueDx0aGlzLm1pbngmJih0aGlzLm1pbng9ZS5taW54KSxlLm1heHg+dGhpcy5tYXh4JiYodGhpcy5tYXh4PWUubWF4eCksZS5taW55PHRoaXMubWlueSYmKHRoaXMubWlueT1lLm1pbnkpLGUubWF4eT50aGlzLm1heHkmJih0aGlzLm1heHk9ZS5tYXh5KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmlzTnVsbCgpPyh0aGlzLm1pbng9bix0aGlzLm1heHg9bix0aGlzLm1pbnk9aSx0aGlzLm1heHk9aSk6KG48dGhpcy5taW54JiYodGhpcy5taW54PW4pLG4+dGhpcy5tYXh4JiYodGhpcy5tYXh4PW4pLGk8dGhpcy5taW55JiYodGhpcy5taW55PWkpLGk+dGhpcy5tYXh5JiYodGhpcy5tYXh5PWkpKX19LG1pbkV4dGVudDpmdW5jdGlvbigpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7dmFyIHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdDxlP3Q6ZX0sZ2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMubWF4eC10aGlzLm1pbnh9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk/MDotMTplLmlzTnVsbCgpPzE6dGhpcy5taW54PGUubWlueD8tMTp0aGlzLm1pbng+ZS5taW54PzE6dGhpcy5taW55PGUubWlueT8tMTp0aGlzLm1pbnk+ZS5taW55PzE6dGhpcy5tYXh4PGUubWF4eD8tMTp0aGlzLm1heHg+ZS5tYXh4PzE6dGhpcy5tYXh5PGUubWF4eT8tMTp0aGlzLm1heHk+ZS5tYXh5PzE6MH0sdHJhbnNsYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDp2b2lkIHRoaXMuaW5pdCh0aGlzLmdldE1pblgoKSt0LHRoaXMuZ2V0TWF4WCgpK3QsdGhpcy5nZXRNaW5ZKCkrZSx0aGlzLmdldE1heFkoKStlKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkVudltcIit0aGlzLm1pbngrXCIgOiBcIit0aGlzLm1heHgrXCIsIFwiK3RoaXMubWlueStcIiA6IFwiK3RoaXMubWF4eStcIl1cIn0sc2V0VG9OdWxsOmZ1bmN0aW9uKCl7dGhpcy5taW54PTAsdGhpcy5tYXh4PS0xLHRoaXMubWlueT0wLHRoaXMubWF4eT0tMX0sZ2V0SGVpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLm1heHktdGhpcy5taW55fSxtYXhFeHRlbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO3ZhciB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9LGV4cGFuZEJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZEJ5KHQsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5taW54LT1lLHRoaXMubWF4eCs9ZSx0aGlzLm1pbnktPW4sdGhpcy5tYXh5Kz1uLCh0aGlzLm1pbng+dGhpcy5tYXh4fHx0aGlzLm1pbnk+dGhpcy5tYXh5KSYmdGhpcy5zZXRUb051bGwoKX19LGNvbnRhaW5zOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnMoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb3ZlcnMobixpKX19LGNlbnRyZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IGcoKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9LGluaXQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvTnVsbCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5taW54PWUubWlueCx0aGlzLm1heHg9ZS5tYXh4LHRoaXMubWlueT1lLm1pbnksdGhpcy5tYXh5PWUubWF4eX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChuLngsaS54LG4ueSxpLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXTtyPHM/KHRoaXMubWlueD1yLHRoaXMubWF4eD1zKToodGhpcy5taW54PXMsdGhpcy5tYXh4PXIpLG88YT8odGhpcy5taW55PW8sdGhpcy5tYXh5PWEpOih0aGlzLm1pbnk9YSx0aGlzLm1heHk9byl9fSxnZXRNYXhZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7aWYodGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiAwO3ZhciBlPTA7dGhpcy5tYXh4PHQubWlueD9lPXQubWlueC10aGlzLm1heHg6dGhpcy5taW54PnQubWF4eCYmKGU9dGhpcy5taW54LXQubWF4eCk7dmFyIG49MDtyZXR1cm4gdGhpcy5tYXh5PHQubWlueT9uPXQubWlueS10aGlzLm1heHk6dGhpcy5taW55PnQubWF4eSYmKG49dGhpcy5taW55LXQubWF4eSksMD09PWU/bjowPT09bj9lOk1hdGguc3FydChlKmUrbipuKX0saGFzaENvZGU6ZnVuY3Rpb24oKXt2YXIgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy5taW54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1heHgpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWlueSksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5tYXh5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ319KSxDLmludGVyc2VjdHM9ZnVuY3Rpb24oKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuLng+PSh0Lng8ZS54P3QueDplLngpJiZuLng8PSh0Lng+ZS54P3QueDplLngpJiZuLnk+PSh0Lnk8ZS55P3QueTplLnkpJiZuLnk8PSh0Lnk+ZS55P3QueTplLnkpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM10sYT1NYXRoLm1pbihzLngsby54KSx1PU1hdGgubWF4KHMueCxvLngpLGw9TWF0aC5taW4oaS54LHIueCksaD1NYXRoLm1heChpLngsci54KTtyZXR1cm4hKGw+dSkmJighKGg8YSkmJihhPU1hdGgubWluKHMueSxvLnkpLHU9TWF0aC5tYXgocy55LG8ueSksbD1NYXRoLm1pbihpLnksci55KSxoPU1hdGgubWF4KGkueSxyLnkpLCEobD51KSYmIShoPGEpKSl9fSxDLnNlcmlhbFZlcnNpb25VSUQ9MHg1MTg0NWNkNTUyMTg5ODAwLGgodyxTKSxlKHcucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3fX0pLGUoTC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEx9fSksTC50b0xvY2F0aW9uU3ltYm9sPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIEwuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBMLkJPVU5EQVJZOnJldHVyblwiYlwiO2Nhc2UgTC5JTlRFUklPUjpyZXR1cm5cImlcIjtjYXNlIEwuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgaShcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfSxMLklOVEVSSU9SPTAsTC5CT1VOREFSWT0xLEwuRVhURVJJT1I9MixMLk5PTkU9LTEsZShULnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVH19KSxULmxvZzEwPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGgubG9nKHQpO3JldHVybiByLmlzSW5maW5pdGUoZSk/ZTpyLmlzTmFOKGUpP2U6ZS9ULkxPR18xMH0sVC5taW49ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dDtyZXR1cm4gZTxyJiYocj1lKSxuPHImJihyPW4pLGk8ciYmKHI9aSkscn0sVC5jbGFtcD1mdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtcbnJldHVybiB0PGU/ZTp0Pm4/bjp0fWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtyZXR1cm4gaTxyP3I6aT5zP3M6aX19LFQud3JhcD1mdW5jdGlvbih0LGUpe3JldHVybiB0PDA/ZS0gLXQlZTp0JWV9LFQubWF4PWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPXQ7cmV0dXJuIGU+aSYmKGk9ZSksbj5pJiYoaT1uKSxpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10saT1yO3JldHVybiBzPmkmJihpPXMpLG8+aSYmKGk9byksYT5pJiYoaT1hKSxpfX0sVC5hdmVyYWdlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQrZSkvMn0sVC5MT0dfMTA9TWF0aC5sb2coMTApLFAucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sUC5wcm90b3R5cGUuc2V0Q2hhckF0PWZ1bmN0aW9uKHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX0sUC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RyfSxiLnByb3RvdHlwZS5pbnRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxiLnByb3RvdHlwZS5jb21wYXJlVG89ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfSxiLmlzTmFOPWZ1bmN0aW9uKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9LE8uaXNXaGl0ZXNwYWNlPWZ1bmN0aW9uKHQpe3JldHVybiB0PD0zMiYmdD49MHx8MTI3PT10fSxPLnRvVXBwZXJDYXNlPWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9LGUoXy5wcm90b3R5cGUse2xlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPHQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPD10LmxvfSxleHRyYWN0U2lnbmlmaWNhbnREaWdpdHM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFicygpLGk9Xy5tYWduaXR1ZGUobi5oaSkscj1fLlRFTi5wb3coaSk7bj1uLmRpdmlkZShyKSxuLmd0KF8uVEVOKT8obj1uLmRpdmlkZShfLlRFTiksaSs9MSk6bi5sdChfLk9ORSkmJihuPW4ubXVsdGlwbHkoXy5URU4pLGktPTEpO2Zvcih2YXIgcz1pKzEsbz1uZXcgUCxhPV8uTUFYX1BSSU5UX0RJR0lUUy0xLHU9MDt1PD1hO3UrKyl7dCYmdT09PXMmJm8uYXBwZW5kKFwiLlwiKTt2YXIgbD1NYXRoLnRydW5jKG4uaGkpO2lmKGw8MClicmVhazt2YXIgaD0hMSxjPTA7bD45PyhoPSEwLGM9XCI5XCIpOmM9XCIwXCIrbCxvLmFwcGVuZChjKSxuPW4uc3VidHJhY3QoXy52YWx1ZU9mKGwpKS5tdWx0aXBseShfLlRFTiksaCYmbi5zZWxmQWRkKF8uVEVOKTt2YXIgZj0hMCxnPV8ubWFnbml0dWRlKG4uaGkpO2lmKGc8MCYmTWF0aC5hYnMoZyk+PWEtdSYmKGY9ITEpLCFmKWJyZWFrfXJldHVybiBlWzBdPWksby50b1N0cmluZygpfSxzcXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKX0sZG91YmxlVmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaSt0aGlzLmxvfSxzdWJ0cmFjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCh0Lm5lZ2F0ZSgpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKC1lKX19LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPT09dC5sb319LGlzWmVybzpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5oaSYmMD09PXRoaXMubG99LHNlbGZTdWJ0cmFjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQuaGksLXQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC1lLDApfX0sZ2V0U3BlY2lhbE51bWJlclN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzWmVybygpP1wiMC4wXCI6dGhpcy5pc05hTigpP1wiTmFOIFwiOm51bGx9LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sZSh0KT90aGlzOnR9LHNlbGZEaXZpZGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKGUsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbCxoPW51bGwsYz1udWxsO3JldHVybiB1PXRoaXMuaGkvbixsPV8uU1BMSVQqdSxyPWwtdSxjPV8uU1BMSVQqbixyPWwtcixzPXUtcixvPWMtbixoPXUqbixvPWMtbyxhPW4tbyxjPXIqby1oK3IqYStzKm8rcyphLGw9KHRoaXMuaGktaC1jK3RoaXMubG8tdSppKS9uLGM9dStsLHRoaXMuaGk9Yyx0aGlzLmxvPXUtYytsLHRoaXN9fSxkdW1wOmZ1bmN0aW9uKCl7cmV0dXJuXCJERDxcIit0aGlzLmhpK1wiLCBcIit0aGlzLmxvK1wiPlwifSxkaXZpZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXSxlPW51bGwsbj1udWxsLGk9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsO289dGhpcy5oaS90LmhpLGE9Xy5TUExJVCpvLGU9YS1vLGw9Xy5TUExJVCp0LmhpLGU9YS1lLG49by1lLGk9bC10LmhpLHU9byp0LmhpLGk9bC1pLHM9dC5oaS1pLGw9ZSppLXUrZSpzK24qaStuKnMsYT0odGhpcy5oaS11LWwrdGhpcy5sby1vKnQubG8pL3QuaGksbD1vK2E7dmFyIGg9bCxjPW8tbCthO3JldHVybiBuZXcgXyhoLGMpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBmPWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTihmKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmRGl2aWRlKGYsMCl9fSxnZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaT50LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz49dC5sb30scG93OmZ1bmN0aW9uKHQpe2lmKDA9PT10KXJldHVybiBfLnZhbHVlT2YoMSk7dmFyIGU9bmV3IF8odGhpcyksbj1fLnZhbHVlT2YoMSksaT1NYXRoLmFicyh0KTtpZihpPjEpZm9yKDtpPjA7KWklMj09PTEmJm4uc2VsZk11bHRpcGx5KGUpLGkvPTIsaT4wJiYoZT1lLnNxcigpKTtlbHNlIG49ZTtyZXR1cm4gdDwwP24ucmVjaXByb2NhbCgpOm59LGNlaWw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIF8uTmFOO3ZhciB0PU1hdGguY2VpbCh0aGlzLmhpKSxlPTA7cmV0dXJuIHQ9PT10aGlzLmhpJiYoZT1NYXRoLmNlaWwodGhpcy5sbykpLG5ldyBfKHQsZSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmhpPGUuaGk/LTE6dGhpcy5oaT5lLmhpPzE6dGhpcy5sbzxlLmxvPy0xOnRoaXMubG8+ZS5sbz8xOjB9LHJpbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIHRoaXM7dmFyIHQ9dGhpcy5hZGQoLjUpO3JldHVybiB0LmZsb29yKCl9LHNldFZhbHVlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KGUpLHRoaXN9fSxtYXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2UodCk/dGhpczp0fSxzcXJ0OmZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gXy52YWx1ZU9mKDApO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBfLk5hTjt2YXIgdD0xL01hdGguc3FydCh0aGlzLmhpKSxlPXRoaXMuaGkqdCxuPV8udmFsdWVPZihlKSxpPXRoaXMuc3VidHJhY3Qobi5zcXIoKSkscj1pLmhpKiguNSp0KTtyZXR1cm4gbi5hZGQocil9LHNlbGZBZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkFkZCh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyZXR1cm4gcj10aGlzLmhpK2Usbz1yLXRoaXMuaGkscz1yLW8scz1lLW8rKHRoaXMuaGktcyksYT1zK3RoaXMubG8sbj1yK2EsaT1hKyhyLW4pLHRoaXMuaGk9bitpLHRoaXMubG89aSsobi10aGlzLmhpKSx0aGlzfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV0sbj1udWxsLGk9bnVsbCxoPW51bGwsYz1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyPXRoaXMuaGkrdSxoPXRoaXMubG8rbCxvPXItdGhpcy5oaSxhPWgtdGhpcy5sbyxzPXItbyxjPWgtYSxzPXUtbysodGhpcy5oaS1zKSxjPWwtYSsodGhpcy5sby1jKSxvPXMraCxuPXIrbyxpPW8rKHItbiksbz1jK2k7dmFyIGY9bitvLGc9bysobi1mKTtyZXR1cm4gdGhpcy5oaT1mLHRoaXMubG89Zyx0aGlzfX0sc2VsZk11bHRpcGx5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoZSwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsO3U9Xy5TUExJVCp0aGlzLmhpLHI9dS10aGlzLmhpLGw9Xy5TUExJVCpuLHI9dS1yLHM9dGhpcy5oaS1yLG89bC1uLHU9dGhpcy5oaSpuLG89bC1vLGE9bi1vLGw9cipvLXUrciphK3MqbytzKmErKHRoaXMuaGkqaSt0aGlzLmxvKm4pO3ZhciBoPXUrbDtyPXUtaDt2YXIgYz1sK3I7cmV0dXJuIHRoaXMuaGk9aCx0aGlzLmxvPWMsdGhpc319LHNlbGZTcXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcyl9LGZsb29yOmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBfLk5hTjt2YXIgdD1NYXRoLmZsb29yKHRoaXMuaGkpLGU9MDtyZXR1cm4gdD09PXRoaXMuaGkmJihlPU1hdGguZmxvb3IodGhpcy5sbykpLG5ldyBfKHQsZSl9LG5lZ2F0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczpuZXcgXygoLXRoaXMuaGkpLCgtdGhpcy5sbykpfSxjbG9uZTpmdW5jdGlvbigpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIG51bGw7dGhyb3cgdH1maW5hbGx5e319LG11bHRpcGx5OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuaXNOYU4oKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmTXVsdGlwbHkodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKGUpP18uY3JlYXRlTmFOKCk6Xy5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseShlLDApfX0saXNOYU46ZnVuY3Rpb24oKXtyZXR1cm4gci5pc05hTih0aGlzLmhpKX0saW50VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC50cnVuYyh0aGlzLmhpKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1fLm1hZ25pdHVkZSh0aGlzLmhpKTtyZXR1cm4gdD49LTMmJnQ8PTIwP3RoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCk6dGhpcy50b1NjaU5vdGF0aW9uKCl9LHRvU3RhbmRhcmROb3RhdGlvbjpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O3ZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITAsZSksaT1lWzBdKzEscj1uO2lmKFwiLlwiPT09bi5jaGFyQXQoMCkpcj1cIjBcIituO2Vsc2UgaWYoaTwwKXI9XCIwLlwiK18uc3RyaW5nT2ZDaGFyKFwiMFwiLC1pKStuO2Vsc2UgaWYobi5pbmRleE9mKFwiLlwiKT09PS0xKXt2YXIgcz1pLW4ubGVuZ3RoLG89Xy5zdHJpbmdPZkNoYXIoXCIwXCIscyk7cj1uK28rXCIuMFwifXJldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIityOnJ9LHJlY2lwcm9jYWw6ZnVuY3Rpb24oKXt2YXIgdD1udWxsLGU9bnVsbCxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyPTEvdGhpcy5oaSxzPV8uU1BMSVQqcix0PXMtcixhPV8uU1BMSVQqdGhpcy5oaSx0PXMtdCxlPXItdCxuPWEtdGhpcy5oaSxvPXIqdGhpcy5oaSxuPWEtbixpPXRoaXMuaGktbixhPXQqbi1vK3QqaStlKm4rZSppLHM9KDEtby1hLXIqdGhpcy5sbykvdGhpcy5oaTt2YXIgdT1yK3MsbD1yLXUrcztyZXR1cm4gbmV3IF8odSxsKX0sdG9TY2lOb3RhdGlvbjpmdW5jdGlvbigpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIF8uU0NJX05PVF9aRVJPO3ZhciB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O3ZhciBlPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLG49dGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoITEsZSksaT1fLlNDSV9OT1RfRVhQT05FTlRfQ0hBUitlWzBdO2lmKFwiMFwiPT09bi5jaGFyQXQoMCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkZvdW5kIGxlYWRpbmcgemVybzogXCIrbik7dmFyIHI9XCJcIjtuLmxlbmd0aD4xJiYocj1uLnN1YnN0cmluZygxKSk7dmFyIHM9bi5jaGFyQXQoMCkrXCIuXCIrcjtyZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcytpOnMraX0sYWJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9fLk5hTjp0aGlzLmlzTmVnYXRpdmUoKT90aGlzLm5lZ2F0ZSgpOm5ldyBfKHRoaXMpfSxpc1Bvc2l0aXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk+MHx8MD09PXRoaXMuaGkmJnRoaXMubG8+MH0sbHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk8dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG88dC5sb30sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIF8uY29weSh0aGlzKS5zZWxmQWRkKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gXy5jb3B5KHRoaXMpLnNlbGZBZGQoZSl9fSxpbml0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmhpPXQsdGhpcy5sbz0wfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5oaT1lLmhpLHRoaXMubG89ZS5sb319ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaGk9bix0aGlzLmxvPWl9fSxndDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaT50LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz50LmxvfSxpc05lZ2F0aXZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk8MHx8MD09PXRoaXMuaGkmJnRoaXMubG88MH0sdHJ1bmM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP18uTmFOOnRoaXMuaXNQb3NpdGl2ZSgpP3RoaXMuZmxvb3IoKTp0aGlzLmNlaWwoKX0sc2lnbnVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGk+MD8xOnRoaXMuaGk8MD8tMTp0aGlzLmxvPjA/MTp0aGlzLmxvPDA/LTE6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdSxzLG9dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBffX0pLF8uc3FyPWZ1bmN0aW9uKHQpe3JldHVybiBfLnZhbHVlT2YodCkuc2VsZk11bHRpcGx5KHQpfSxfLnZhbHVlT2Y9ZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIF8ucGFyc2UodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgXyhlKX19LF8uc3FydD1mdW5jdGlvbih0KXtyZXR1cm4gXy52YWx1ZU9mKHQpLnNxcnQoKX0sXy5wYXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXQubGVuZ3RoO08uaXNXaGl0ZXNwYWNlKHQuY2hhckF0KGUpKTspZSsrO3ZhciBpPSExO2lmKGU8bil7dmFyIHI9dC5jaGFyQXQoZSk7XCItXCIhPT1yJiZcIitcIiE9PXJ8fChlKyssXCItXCI9PT1yJiYoaT0hMCkpfWZvcih2YXIgcz1uZXcgXyxvPTAsYT0wLHU9MDs7KXtpZihlPj1uKWJyZWFrO3ZhciBsPXQuY2hhckF0KGUpO2lmKGUrKyxPLmlzRGlnaXQobCkpe3ZhciBoPWwtXCIwXCI7cy5zZWxmTXVsdGlwbHkoXy5URU4pLHMuc2VsZkFkZChoKSxvKyt9ZWxzZXtpZihcIi5cIiE9PWwpe2lmKFwiZVwiPT09bHx8XCJFXCI9PT1sKXt2YXIgYz10LnN1YnN0cmluZyhlKTt0cnl7dT1iLnBhcnNlSW50KGMpfWNhdGNoKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrYytcIiBpbiBzdHJpbmcgXCIrdCk6ZX1maW5hbGx5e31icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK2wrXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfWE9b319dmFyIGY9cyxnPW8tYS11O2lmKDA9PT1nKWY9cztlbHNlIGlmKGc+MCl7dmFyIGQ9Xy5URU4ucG93KGcpO2Y9cy5kaXZpZGUoZCl9ZWxzZSBpZihnPDApe3ZhciBkPV8uVEVOLnBvdygtZyk7Zj1zLm11bHRpcGx5KGQpfXJldHVybiBpP2YubmVnYXRlKCk6Zn0sXy5jcmVhdGVOYU49ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IF8oci5OYU4sci5OYU4pfSxfLmNvcHk9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBfKHQpfSxfLm1hZ25pdHVkZT1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLmFicyh0KSxuPU1hdGgubG9nKGUpL01hdGgubG9nKDEwKSxpPU1hdGgudHJ1bmMoTWF0aC5mbG9vcihuKSkscj1NYXRoLnBvdygxMCxpKTtyZXR1cm4gMTAqcjw9ZSYmKGkrPTEpLGl9LF8uc3RyaW5nT2ZDaGFyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBQLGk9MDtpPGU7aSsrKW4uYXBwZW5kKHQpO3JldHVybiBuLnRvU3RyaW5nKCl9LF8uUEk9bmV3IF8oMy4xNDE1OTI2NTM1ODk3OTMsMS4yMjQ2NDY3OTkxNDczNTMyZS0xNiksXy5UV09fUEk9bmV3IF8oNi4yODMxODUzMDcxNzk1ODYsMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiksXy5QSV8yPW5ldyBfKDEuNTcwNzk2MzI2Nzk0ODk2Niw2LjEyMzIzMzk5NTczNjc2NmUtMTcpLF8uRT1uZXcgXygyLjcxODI4MTgyODQ1OTA0NSwxLjQ0NTY0Njg5MTcyOTI1MDJlLTE2KSxfLk5hTj1uZXcgXyhyLk5hTixyLk5hTiksXy5FUFM9MS4yMzI1OTUxNjQ0MDc4M2UtMzIsXy5TUExJVD0xMzQyMTc3MjksXy5NQVhfUFJJTlRfRElHSVRTPTMyLF8uVEVOPV8udmFsdWVPZigxMCksXy5PTkU9Xy52YWx1ZU9mKDEpLF8uU0NJX05PVF9FWFBPTkVOVF9DSEFSPVwiRVwiLF8uU0NJX05PVF9aRVJPPVwiMC4wRTBcIixlKE0ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNfX0pLE0ub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9TS5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHQsZSxuKTtpZihpPD0xKXJldHVybiBpO3ZhciByPV8udmFsdWVPZihlLngpLnNlbGZBZGQoLXQueCkscz1fLnZhbHVlT2YoZS55KS5zZWxmQWRkKC10LnkpLG89Xy52YWx1ZU9mKG4ueCkuc2VsZkFkZCgtZS54KSxhPV8udmFsdWVPZihuLnkpLnNlbGZBZGQoLWUueSk7cmV0dXJuIHIuc2VsZk11bHRpcGx5KGEpLnNlbGZTdWJ0cmFjdChzLnNlbGZNdWx0aXBseShvKSkuc2lnbnVtKCl9LE0uc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQubXVsdGlwbHkoaSkuc2VsZlN1YnRyYWN0KGUubXVsdGlwbHkobikpO3JldHVybiByLnNpZ251bSgpfSxNLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnZhbHVlT2YoaS55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkpLHM9Xy52YWx1ZU9mKGkueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxvPXIuc3VidHJhY3QocyksYT1fLnZhbHVlT2YoaS54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLHU9Xy52YWx1ZU9mKGkueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxsPWEuc3VidHJhY3QodSksaD1sLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxjPV8udmFsdWVPZih0LngpLnNlbGZBZGQoXy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KGgpKS5kb3VibGVWYWx1ZSgpLGY9Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChuLnkpKSxkPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qobi54KSkscD1mLnN1YnRyYWN0KGQpLHY9cC5zZWxmRGl2aWRlKG8pLmRvdWJsZVZhbHVlKCksbT1fLnZhbHVlT2Yobi55KS5zZWxmQWRkKF8udmFsdWVPZihpLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseSh2KSkuZG91YmxlVmFsdWUoKTtyZXR1cm4gbmV3IGcoYyxtKX0sTS5vcmllbnRhdGlvbkluZGV4RmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1udWxsLHI9KHQueC1uLngpKihlLnktbi55KSxzPSh0Lnktbi55KSooZS54LW4ueCksbz1yLXM7aWYocj4wKXtpZihzPD0wKXJldHVybiBNLnNpZ251bShvKTtpPXIrc31lbHNle2lmKCEocjwwKSlyZXR1cm4gTS5zaWdudW0obyk7aWYocz49MClyZXR1cm4gTS5zaWdudW0obyk7aT0tci1zfXZhciBhPU0uRFBfU0FGRV9FUFNJTE9OKmk7cmV0dXJuIG8+PWF8fC1vPj1hP00uc2lnbnVtKG8pOjJ9LE0uc2lnbnVtPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/MTp0PDA/LTE6MH0sTS5EUF9TQUZFX0VQU0lMT049MWUtMTUsZShELnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlLG4pe30sc2l6ZTpmdW5jdGlvbigpe30sZ2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxnZXRDb29yZGluYXRlQ29weTpmdW5jdGlvbih0KXt9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe30sZ2V0WDpmdW5jdGlvbih0KXt9LGNsb25lOmZ1bmN0aW9uKCl7fSxleHBhbmRFbnZlbG9wZTpmdW5jdGlvbih0KXt9LGNvcHk6ZnVuY3Rpb24oKXt9LGdldFk6ZnVuY3Rpb24odCl7fSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIER9fSksRC5YPTAsRC5ZPTEsRC5aPTIsRC5NPTMsQS5hcnJheWNvcHk9ZnVuY3Rpb24odCxlLG4saSxyKXtmb3IodmFyIHM9MCxvPWU7bzxlK3I7bysrKW5baStzXT10W29dLHMrK30sQS5nZXRQcm9wZXJ0eT1mdW5jdGlvbih0KXtyZXR1cm57XCJsaW5lLnNlcGFyYXRvclwiOlwiXFxuXCJ9W3RdfSxlKEYucHJvdG90eXBlLHtnZXRZOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy55L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHc7cmV0dXJuIHR9LGdldFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLngvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdztyZXR1cm4gdH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBnO3JldHVybiB0Lng9dGhpcy5nZXRYKCksdC55PXRoaXMuZ2V0WSgpLHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZ9fSksRi5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlLG4saSl7dmFyIHM9dC55LWUueSxvPWUueC10LngsYT10LngqZS55LWUueCp0LnksdT1uLnktaS55LGw9aS54LW4ueCxoPW4ueCppLnktaS54Km4ueSxjPW8qaC1sKmEsZj11KmEtcypoLGQ9cypsLXUqbyxwPWMvZCx2PWYvZDtpZihyLmlzTmFOKHApfHxyLmlzSW5maW5pdGUocCl8fHIuaXNOYU4odil8fHIuaXNJbmZpbml0ZSh2KSl0aHJvdyBuZXcgdztyZXR1cm4gbmV3IGcocCx2KX0sZShHLnByb3RvdHlwZSx7Y3JlYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2FyZ3VtZW50c1swXX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpKXthcmd1bWVudHNbMF19fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHfX0pLGUocS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHF9fSksZShCLnByb3RvdHlwZSx7aXNHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTn0sZ2V0RmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY3Rvcnl9LGdldEdlb21ldHJ5TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpc30sZ2V0QXJlYTpmdW5jdGlvbigpe3JldHVybiAwfSxpc1JlY3RhbmdsZTpmdW5jdGlvbigpe3JldHVybiExfSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG51bGwhPT10JiZ0aGlzLmVxdWFsc1RvcG8odCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3Qpe3ZhciBlPWFyZ3VtZW50c1swXTtpZighKGUgaW5zdGFuY2VvZiBCKSlyZXR1cm4hMTt2YXIgbj1lO3JldHVybiB0aGlzLmVxdWFsc0V4YWN0KG4pfX19LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzPT09dHx8dGhpcy5lcXVhbHNFeGFjdCh0LDApfSxnZW9tZXRyeUNoYW5nZWQ6ZnVuY3Rpb24oKXt0aGlzLmFwcGx5KEIuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKX0sZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uOmZ1bmN0aW9uKCl7dGhpcy5lbnZlbG9wZT1udWxsfSxlcXVhbHNOb3JtOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QodC5ub3JtKCkpfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZ2V0TnVtR2VvbWV0cmllczpmdW5jdGlvbigpe3JldHVybiAxfSxjb21wYXJlVG86ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dDtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSE9PWUuZ2V0U29ydEluZGV4KCk/dGhpcy5nZXRTb3J0SW5kZXgoKS1lLmdldFNvcnRJbmRleCgpOnRoaXMuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOmUuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3ModCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW47cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkhPT1lLmdldFNvcnRJbmRleCgpP3RoaXMuZ2V0U29ydEluZGV4KCktZS5nZXRTb3J0SW5kZXgoKTp0aGlzLmlzRW1wdHkoKSYmZS5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTplLmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKG4saSl9fSxnZXRVc2VyRGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVzZXJEYXRhfSxnZXRTUklEOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuU1JJRH0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9LGNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHQuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04pdGhyb3cgbmV3IGkoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIil9LGVxdWFsOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gMD09PW4/dC5lcXVhbHMoZSk6dC5kaXN0YW5jZShlKTw9bn0sbm9ybTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29weSgpO3JldHVybiB0Lm5vcm1hbGl6ZSgpLHR9LGdldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfSxnZXRFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmVudmVsb3BlJiYodGhpcy5lbnZlbG9wZT10aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCkpLG5ldyBDKHRoaXMuZW52ZWxvcGUpfSxzZXRTUklEOmZ1bmN0aW9uKHQpe3RoaXMuU1JJRD10fSxzZXRVc2VyRGF0YTpmdW5jdGlvbih0KXt0aGlzLnVzZXJEYXRhPXR9LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpLGk9ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpJiZpLmhhc05leHQoKTspe3ZhciByPW4ubmV4dCgpLHM9aS5uZXh0KCksbz1yLmNvbXBhcmVUbyhzKTtpZigwIT09bylyZXR1cm4gb31yZXR1cm4gbi5oYXNOZXh0KCk/MTppLmhhc05leHQoKT8tMTowfSxoYXNoQ29kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfSxpc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfHx0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfTVVMVElQT0lOVHx8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJTElORVNUUklOR3x8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJUE9MWUdPTn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bbyxzLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCfX0pLEIuaGFzTm9uRW1wdHlFbGVtZW50cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylpZighdFtlXS5pc0VtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9LEIuaGFzTnVsbEVsZW1lbnRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKG51bGw9PT10W2VdKXJldHVybiEwO3JldHVybiExfSxCLnNlcmlhbFZlcnNpb25VSUQ9MHg3OTllYTQ2NTIyODU0YzAwLEIuU09SVElOREVYX1BPSU5UPTAsQi5TT1JUSU5ERVhfTVVMVElQT0lOVD0xLEIuU09SVElOREVYX0xJTkVTVFJJTkc9MixCLlNPUlRJTkRFWF9MSU5FQVJSSU5HPTMsQi5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HPTQsQi5TT1JUSU5ERVhfUE9MWUdPTj01LEIuU09SVElOREVYX01VTFRJUE9MWUdPTj02LEIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTj03LEIuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZmlsdGVyOmZ1bmN0aW9uKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fSxlKHoucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6fX0pLGUoVi5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZ9fSksZShrLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0JTI9PT0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga319KSxlKFkucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFl9fSksZShVLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0PjF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVfX0pLGUoWC5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gMT09PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYfX0pLFYuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU9ayxWLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1ZLFYuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9VSxWLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WCxWLk1PRDJfQk9VTkRBUllfUlVMRT1uZXcgayxWLkVORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFksVi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBVLFYuTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBYLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFPVYuTU9EMl9CT1VOREFSWV9SVUxFLGUoSC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEh9fSksSC5pc1Jpbmc9ZnVuY3Rpb24odCl7cmV0dXJuISh0Lmxlbmd0aDw0KSYmISF0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfSxILnB0Tm90SW5MaXN0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aWYoSC5pbmRleE9mKGksZSk8MClyZXR1cm4gaX1yZXR1cm4gbnVsbH0sSC5zY3JvbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj1ILmluZGV4T2YoZSx0KTtpZihuPDApcmV0dXJuIG51bGw7dmFyIGk9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO0EuYXJyYXljb3B5KHQsbixpLDAsdC5sZW5ndGgtbiksQS5hcnJheWNvcHkodCwwLGksdC5sZW5ndGgtbixuKSxBLmFycmF5Y29weShpLDAsdCwwLHQubGVuZ3RoKX0sSC5lcXVhbHM9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2lmKGk9PT1yKXJldHVybiEwO2lmKG51bGw9PT1pfHxudWxsPT09cilyZXR1cm4hMTtpZihpLmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248aS5sZW5ndGg7bisrKWlmKDAhPT1zLmNvbXBhcmUoaVtuXSxyW25dKSlyZXR1cm4hMTtyZXR1cm4hMH19LEguaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBOLGk9MDtpPHQubGVuZ3RoO2krKyllLmludGVyc2VjdHModFtpXSkmJm4uYWRkKHRbaV0sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9LEguaGFzUmVwZWF0ZWRQb2ludHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTx0Lmxlbmd0aDtlKyspaWYodFtlLTFdLmVxdWFscyh0W2VdKSlyZXR1cm4hMDtyZXR1cm4hMX0sSC5yZW1vdmVSZXBlYXRlZFBvaW50cz1mdW5jdGlvbih0KXtpZighSC5oYXNSZXBlYXRlZFBvaW50cyh0KSlyZXR1cm4gdDt2YXIgZT1uZXcgTih0LCghMSkpO3JldHVybiBlLnRvQ29vcmRpbmF0ZUFycmF5KCl9LEgucmV2ZXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgtMSxuPU1hdGgudHJ1bmMoZS8yKSxpPTA7aTw9bjtpKyspe3ZhciByPXRbaV07dFtpXT10W2UtaV0sdFtlLWldPXJ9fSxILnJlbW92ZU51bGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiZlKys7dmFyIGk9bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7aWYoMD09PWUpcmV0dXJuIGk7Zm9yKHZhciByPTAsbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiYoaVtyKytdPXRbbl0pO3JldHVybiBpfSxILmNvcHlEZWVwPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCksbj0wO248dC5sZW5ndGg7bisrKWVbbl09bmV3IGcodFtuXSk7cmV0dXJuIGV9aWYoNT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXSxhPWFyZ3VtZW50c1s0XSxuPTA7bjxhO24rKylzW28rbl09bmV3IGcoaVtyK25dKX0sSC5pc0VxdWFsUmV2ZXJzZWQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXSxyPWVbdC5sZW5ndGgtbi0xXTtpZigwIT09aS5jb21wYXJlVG8ocikpcmV0dXJuITF9cmV0dXJuITB9LEguZW52ZWxvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBDLG49MDtuPHQubGVuZ3RoO24rKyllLmV4cGFuZFRvSW5jbHVkZSh0W25dKTtyZXR1cm4gZX0sSC50b0Nvb3JkaW5hdGVBcnJheT1mdW5jdGlvbih0KXtyZXR1cm4gdC50b0FycmF5KEguY29vcmRBcnJheVR5cGUpfSxILmF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5sZW5ndGg+PXQ/ZTpbXX0sSC5pbmRleE9mPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspaWYodC5lcXVhbHMoZVtuXSkpcmV0dXJuIG47cmV0dXJuLTF9LEguaW5jcmVhc2luZ0RpcmVjdGlvbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPE1hdGgudHJ1bmModC5sZW5ndGgvMik7ZSsrKXt2YXIgbj10Lmxlbmd0aC0xLWUsaT10W2VdLmNvbXBhcmVUbyh0W25dKTtpZigwIT09aSlyZXR1cm4gaX1yZXR1cm4gMX0sSC5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aCYmbjxlLmxlbmd0aDspe3ZhciBpPXRbbl0uY29tcGFyZVRvKGVbbl0pO2lmKDAhPT1pKXJldHVybiBpO24rK31yZXR1cm4gbjxlLmxlbmd0aD8tMTpuPHQubGVuZ3RoPzE6MH0sSC5taW5Db29yZGluYXRlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49MDtuPHQubGVuZ3RoO24rKykobnVsbD09PWV8fGUuY29tcGFyZVRvKHRbbl0pPjApJiYoZT10W25dKTtyZXR1cm4gZX0sSC5leHRyYWN0PWZ1bmN0aW9uKHQsZSxuKXtlPVQuY2xhbXAoZSwwLHQubGVuZ3RoKSxuPVQuY2xhbXAobiwtMSx0Lmxlbmd0aCk7dmFyIGk9bi1lKzE7bjwwJiYoaT0wKSxlPj10Lmxlbmd0aCYmKGk9MCksbjxlJiYoaT0wKTt2YXIgcj1uZXcgQXJyYXkoaSkuZmlsbChudWxsKTtpZigwPT09aSlyZXR1cm4gcjtmb3IodmFyIHM9MCxvPWU7bzw9bjtvKyspcltzKytdPXRbb107cmV0dXJuIHJ9LGUoVy5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4gSC5jb21wYXJlKG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXfX0pLGUoai5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtpZihuLmxlbmd0aDxpLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5pLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7dmFyIHI9SC5jb21wYXJlKG4saSkscz1ILmlzRXF1YWxSZXZlcnNlZChuLGkpO3JldHVybiBzPzA6cn0sT0xEY29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO2lmKG4ubGVuZ3RoPGkubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPmkubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtmb3IodmFyIHI9SC5pbmNyZWFzaW5nRGlyZWN0aW9uKG4pLHM9SC5pbmNyZWFzaW5nRGlyZWN0aW9uKGkpLG89cj4wPzA6bi5sZW5ndGgtMSxhPXM+MD8wOm4ubGVuZ3RoLTEsdT0wO3U8bi5sZW5ndGg7dSsrKXt2YXIgbD1uW29dLmNvbXBhcmVUbyhpW2FdKTtpZigwIT09bClyZXR1cm4gbDtvKz1yLGErPXN9cmV0dXJuIDB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqfX0pLEguRm9yd2FyZENvbXBhcmF0b3I9VyxILkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yPWosSC5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxLLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLnB1dD1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe30sWi5wcm90b3R5cGU9bmV3IEssUS5wcm90b3R5cGU9bmV3IHYsUS5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24oKXt9LEoucHJvdG90eXBlPW5ldyBRLEoucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspe3ZhciBpPXRoaXMuYXJyYXlfW2VdO2lmKGk9PT10KXJldHVybiEwfXJldHVybiExfSxKLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIXRoaXMuY29udGFpbnModCkmJih0aGlzLmFycmF5Xy5wdXNoKHQpLCEwKX0sSi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBqYXZhc2NyaXB0LnV0aWwuT3BlcmF0aW9uTm90U3VwcG9ydGVkfSxKLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LEoucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBKcyh0aGlzKX07dmFyIEpzPWZ1bmN0aW9uKHQpe3RoaXMuaGFzaFNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTtKcy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5oYXNoU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHg7cmV0dXJuIHRoaXMuaGFzaFNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSxKcy5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmhhc2hTZXRfLnNpemUoKX0sSnMucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFfTt2YXIgJHM9MCx0bz0xO3J0LnByb3RvdHlwZT1uZXcgWixydC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfSxydC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXRoaXMucm9vdF8pcmV0dXJuIHRoaXMucm9vdF89e2tleTp0LHZhbHVlOmUsbGVmdDpudWxsLHJpZ2h0Om51bGwscGFyZW50Om51bGwsY29sb3I6JHMsZ2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fX0sdGhpcy5zaXplXz0xLG51bGw7dmFyIG4saSxyPXRoaXMucm9vdF87ZG8gaWYobj1yLGk9dC5jb21wYXJlVG8oci5rZXkpLGk8MClyPXIubGVmdDtlbHNle2lmKCEoaT4wKSl7dmFyIHM9ci52YWx1ZTtyZXR1cm4gci52YWx1ZT1lLHN9cj1yLnJpZ2h0fXdoaWxlKG51bGwhPT1yKTt2YXIgbz17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjokcyxnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9fTtyZXR1cm4gaTwwP24ubGVmdD1vOm4ucmlnaHQ9byx0aGlzLmZpeEFmdGVySW5zZXJ0aW9uKG8pLHRoaXMuc2l6ZV8rKyxudWxsfSxydC5wcm90b3R5cGUuZml4QWZ0ZXJJbnNlcnRpb249ZnVuY3Rpb24odCl7Zm9yKHQuY29sb3I9dG87bnVsbCE9dCYmdCE9dGhpcy5yb290XyYmdC5wYXJlbnQuY29sb3I9PXRvOylpZih0dCh0KT09bnQodHQodHQodCkpKSl7dmFyIGU9aXQodHQodHQodCkpKTskKGUpPT10bz8oZXQodHQodCksJHMpLGV0KGUsJHMpLGV0KHR0KHR0KHQpKSx0byksdD10dCh0dCh0KSkpOih0PT1pdCh0dCh0KSkmJih0PXR0KHQpLHRoaXMucm90YXRlTGVmdCh0KSksZXQodHQodCksJHMpLGV0KHR0KHR0KHQpKSx0byksdGhpcy5yb3RhdGVSaWdodCh0dCh0dCh0KSkpKX1lbHNle3ZhciBlPW50KHR0KHR0KHQpKSk7JChlKT09dG8/KGV0KHR0KHQpLCRzKSxldChlLCRzKSxldCh0dCh0dCh0KSksdG8pLHQ9dHQodHQodCkpKToodD09bnQodHQodCkpJiYodD10dCh0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxldCh0dCh0KSwkcyksZXQodHQodHQodCkpLHRvKSx0aGlzLnJvdGF0ZUxlZnQodHQodHQodCkpKSl9dGhpcy5yb290Xy5jb2xvcj0kc30scnQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe3ZhciB0PW5ldyBJLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUudmFsdWUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlLnZhbHVlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEosZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZSk7bnVsbCE9PShlPXJ0LnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUpO3JldHVybiB0fSxydC5wcm90b3R5cGUucm90YXRlTGVmdD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LnJpZ2h0O3QucmlnaHQ9ZS5sZWZ0LG51bGwhPWUubGVmdCYmKGUubGVmdC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LmxlZnQ9PXQ/dC5wYXJlbnQubGVmdD1lOnQucGFyZW50LnJpZ2h0PWUsZS5sZWZ0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5yb3RhdGVSaWdodD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LmxlZnQ7dC5sZWZ0PWUucmlnaHQsbnVsbCE9ZS5yaWdodCYmKGUucmlnaHQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5yaWdodD09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5nZXRGaXJzdEVudHJ5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yb290XztpZihudWxsIT10KWZvcig7bnVsbCE9dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdH0scnQuc3VjY2Vzc29yPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2lmKG51bGwhPT10LnJpZ2h0KXtmb3IodmFyIGU9dC5yaWdodDtudWxsIT09ZS5sZWZ0OyllPWUubGVmdDtyZXR1cm4gZX1mb3IodmFyIGU9dC5wYXJlbnQsbj10O251bGwhPT1lJiZuPT09ZS5yaWdodDspbj1lLGU9ZS5wYXJlbnQ7cmV0dXJuIGV9LHJ0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV99LGUoc3QucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzdH19KSxvdC5wcm90b3R5cGU9bmV3IFEsYXQucHJvdG90eXBlPW5ldyBvdCxhdC5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoMD09PWkuY29tcGFyZVRvKHQpKXJldHVybiEwfXJldHVybiExfSxhdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY29udGFpbnModCkpcmV0dXJuITE7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoMT09PWkuY29tcGFyZVRvKHQpKXJldHVybiB0aGlzLmFycmF5Xy5zcGxpY2UoZSwwLHQpLCEwfXJldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxhdC5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sYXQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRX0sYXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxhdC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGVvKHRoaXMpfTt2YXIgZW89ZnVuY3Rpb24odCl7dGhpcy50cmVlU2V0Xz10LHRoaXMucG9zaXRpb25fPTB9O2VvLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLnRyZWVTZXRfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy50cmVlU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LGVvLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMudHJlZVNldF8uc2l6ZSgpfSxlby5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9LHV0LnNvcnQ9ZnVuY3Rpb24oKXt2YXIgdCxlLG4saSxyPWFyZ3VtZW50c1swXTtpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKX0sdm9pZCByLnNvcnQoaSk7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpbj1hcmd1bWVudHNbMV0saT1mdW5jdGlvbih0LGUpe3JldHVybiBuLmNvbXBhcmUodCxlKX0sci5zb3J0KGkpO2Vsc2V7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2U9ci5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxlLnNvcnQoKTt2YXIgcz1yLnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSxyLnNsaWNlKGFyZ3VtZW50c1syXSxyLmxlbmd0aCkpO2ZvcihyLnNwbGljZSgwLHIubGVuZ3RoKSx0PTA7dDxzLmxlbmd0aDt0Kyspci5wdXNoKHNbdF0pO3JldHVybn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGU9ci5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxuPWFyZ3VtZW50c1szXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY29tcGFyZSh0LGUpfSxlLnNvcnQoaSkscz1yLnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSxyLnNsaWNlKGFyZ3VtZW50c1syXSxyLmxlbmd0aCkpLHIuc3BsaWNlKDAsci5sZW5ndGgpLHQ9MDt0PHMubGVuZ3RoO3QrKylyLnB1c2goc1t0XSk7cmV0dXJufX19LHV0LmFzTGlzdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wLGk9dC5sZW5ndGg7bjxpO24rKyllLmFkZCh0W25dKTtyZXR1cm4gZX0sZShsdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGx0fX0pLGx0LnRvRGltZW5zaW9uU3ltYm9sPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIGx0LkZBTFNFOnJldHVybiBsdC5TWU1fRkFMU0U7Y2FzZSBsdC5UUlVFOnJldHVybiBsdC5TWU1fVFJVRTtjYXNlIGx0LkRPTlRDQVJFOnJldHVybiBsdC5TWU1fRE9OVENBUkU7Y2FzZSBsdC5QOnJldHVybiBsdC5TWU1fUDtjYXNlIGx0Lkw6cmV0dXJuIGx0LlNZTV9MO2Nhc2UgbHQuQTpyZXR1cm4gbHQuU1lNX0F9dGhyb3cgbmV3IGkoXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9LGx0LnRvRGltZW5zaW9uVmFsdWU9ZnVuY3Rpb24odCl7c3dpdGNoKE8udG9VcHBlckNhc2UodCkpe2Nhc2UgbHQuU1lNX0ZBTFNFOnJldHVybiBsdC5GQUxTRTtjYXNlIGx0LlNZTV9UUlVFOnJldHVybiBsdC5UUlVFO2Nhc2UgbHQuU1lNX0RPTlRDQVJFOnJldHVybiBsdC5ET05UQ0FSRTtjYXNlIGx0LlNZTV9QOnJldHVybiBsdC5QO2Nhc2UgbHQuU1lNX0w6cmV0dXJuIGx0Lkw7Y2FzZSBsdC5TWU1fQTpyZXR1cm4gbHQuQX10aHJvdyBuZXcgaShcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9LGx0LlA9MCxsdC5MPTEsbHQuQT0yLGx0LkZBTFNFPS0xLGx0LlRSVUU9LTIsbHQuRE9OVENBUkU9LTMsbHQuU1lNX0ZBTFNFPVwiRlwiLGx0LlNZTV9UUlVFPVwiVFwiLGx0LlNZTV9ET05UQ0FSRT1cIipcIixsdC5TWU1fUD1cIjBcIixsdC5TWU1fTD1cIjFcIixsdC5TWU1fQT1cIjJcIixlKGh0LnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHR9fSksZShjdC5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0LGUpe30saXNEb25lOmZ1bmN0aW9uKCl7fSxpc0dlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3R9fSksaChmdCxCKSxlKGZ0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEMsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5nZW9tZXRyaWVzW2VdLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHR9LGdldEdlb21ldHJ5TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyaWVzW3RdfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKSxlPS0xLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWZvcih2YXIgaT10aGlzLmdlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aDtyKyspZSsrLHRbZV09aVtyXTtyZXR1cm4gdH0sZ2V0QXJlYTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXRBcmVhKCk7cmV0dXJuIHR9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10O2lmKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGghPT1uLmdlb21ldHJpZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgaT0wO2k8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtpKyspaWYoIXRoaXMuZ2VvbWV0cmllc1tpXS5lcXVhbHNFeGFjdChuLmdlb21ldHJpZXNbaV0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO3QrKyl0aGlzLmdlb21ldHJpZXNbdF0ubm9ybWFsaXplKCk7dXQuc29ydCh0aGlzLmdlb21ldHJpZXMpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bHQuRkFMU0UsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtyZXR1cm4gdH0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWx0LkZBTFNFLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLmdlb21ldHJpZXNbZV0uZ2V0RGltZW5zaW9uKCkpO3JldHVybiB0fSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9LGdldE51bVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH0sZ2V0TnVtR2VvbWV0cmllczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb21ldHJpZXMubGVuZ3RofSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW25dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBhdCh1dC5hc0xpc3QodGhpcy5nZW9tZXRyaWVzKSksbj1uZXcgYXQodXQuYXNMaXN0KHQuZ2VvbWV0cmllcykpO3JldHVybiB0aGlzLmNvbXBhcmUoZSxuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWksbz10aGlzLmdldE51bUdlb21ldHJpZXMoKSxhPXMuZ2V0TnVtR2VvbWV0cmllcygpLHU9MDt1PG8mJnU8YTspe3ZhciBsPXRoaXMuZ2V0R2VvbWV0cnlOKHUpLGg9cy5nZXRHZW9tZXRyeU4odSksYz1sLmNvbXBhcmVUb1NhbWVDbGFzcyhoLHIpO2lmKDAhPT1jKXJldHVybiBjO3UrK31yZXR1cm4gdTxvPzE6dTxhPy0xOjB9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KHQpO2Vsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoJiYodGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KG4pLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KGkpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKTtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShyKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksZi5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTt0Lmdlb21ldHJpZXM9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Lmdlb21ldHJpZXNbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNsb25lKCk7cmV0dXJuIHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiR2VvbWV0cnlDb2xsZWN0aW9uXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGZ0KHQsdGhpcy5mYWN0b3J5KX0saXNFbXB0eTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuZ2VvbWV0cmllc1t0XS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ0fX0pLGZ0LnNlcmlhbFZlcnNpb25VSUQ9LTB4NGYwN2JjYjFmODU3ZDgwMCxoKGd0LGZ0KSxlKGd0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJTElORVNUUklOR30sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBmdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/bHQuRkFMU0U6MH0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4hMTtmb3IodmFyIHQ9MDt0PHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLmdlb21ldHJpZXNbdF0uaXNDbG9zZWQoKSlyZXR1cm4hMTtyZXR1cm4hMDtcbn0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LHJldmVyc2U6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWVbdC0xLW5dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGR0KHRoaXMpLmdldEJvdW5kYXJ5KCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTXVsdGlMaW5lU3RyaW5nXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGd0KHQsdGhpcy5mYWN0b3J5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBndH19KSxndC5zZXJpYWxWZXJzaW9uVUlEPTB4NzE1NWQyYWI0YWZhODAwMCxlKGR0LnByb3RvdHlwZSx7Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7aWYodGhpcy5nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTt2YXIgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludChlWzBdKTp0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGUpfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb20gaW5zdGFuY2VvZiBTdD90aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLmdlb20pOnRoaXMuZ2VvbSBpbnN0YW5jZW9mIGd0P3RoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5nZW9tKTp0aGlzLmdlb20uZ2V0Qm91bmRhcnkoKX0sYm91bmRhcnlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7aWYodC5pc0Nsb3NlZCgpKXt2YXIgZT10aGlzLmJuUnVsZS5pc0luQm91bmRhcnkoMik7cmV0dXJuIGU/dC5nZXRTdGFydFBvaW50KCk6dGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9cmV0dXJuIHRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbdC5nZXRTdGFydFBvaW50KCksdC5nZXRFbmRQb2ludCgpXSl9LGdldEVtcHR5TXVsdGlQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX0sY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7dGhpcy5lbmRwb2ludE1hcD1uZXcgcnQ7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pOzAhPT1pLmdldE51bVBvaW50cygpJiYodGhpcy5hZGRFbmRwb2ludChpLmdldENvb3JkaW5hdGVOKDApKSx0aGlzLmFkZEVuZHBvaW50KGkuZ2V0Q29vcmRpbmF0ZU4oaS5nZXROdW1Qb2ludHMoKS0xKSkpfWZvcih2YXIgcj10aGlzLmVuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRWYWx1ZSgpLGE9by5jb3VudDt0aGlzLmJuUnVsZS5pc0luQm91bmRhcnkoYSkmJmUuYWRkKHMuZ2V0S2V5KCkpfXJldHVybiBILnRvQ29vcmRpbmF0ZUFycmF5KGUpfSxhZGRFbmRwb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVuZHBvaW50TWFwLmdldCh0KTtudWxsPT09ZSYmKGU9bmV3IHB0LHRoaXMuZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHR9fSksZHQuZ2V0Qm91bmRhcnk9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGR0KHQpO3JldHVybiBlLmdldEJvdW5kYXJ5KCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW5ldyBkdChuLGkpO3JldHVybiBlLmdldEJvdW5kYXJ5KCl9fSxlKHB0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHR9fSksZShOdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE50fX0pLE50LmNoYXJzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpLGk9MDtpPGU7aSsrKW5baV09dDtyZXR1cm4gbmV3IFN0cmluZyhuKX0sTnQuZ2V0U3RhY2tUcmFjZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgeHQsbj1uZXcgdnQoZSk7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPVwiXCIsbz1uZXcgbXQoTnQuZ2V0U3RhY2tUcmFjZShpKSksYT1uZXcgSXQobyksdT0wO3U8cjt1KyspdHJ5e3MrPWEucmVhZExpbmUoKStOdC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIEV0KSl0aHJvdyB0O2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1maW5hbGx5e31yZXR1cm4gc319LE50LnNwbGl0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUubGVuZ3RoLGk9bmV3IEkscj1cIlwiK3Qscz1yLmluZGV4T2YoZSk7cz49MDspe3ZhciBvPXIuc3Vic3RyaW5nKDAscyk7aS5hZGQobykscj1yLnN1YnN0cmluZyhzK24pLHM9ci5pbmRleE9mKGUpfXIubGVuZ3RoPjAmJmkuYWRkKHIpO2Zvcih2YXIgYT1uZXcgQXJyYXkoaS5zaXplKCkpLmZpbGwobnVsbCksdT0wO3U8YS5sZW5ndGg7dSsrKWFbdV09aS5nZXQodSk7cmV0dXJuIGF9LE50LnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTnQuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5mb3JtYXQodCl9fSxOdC5zcGFjZXM9ZnVuY3Rpb24odCl7cmV0dXJuIE50LmNoYXJzKFwiIFwiLHQpfSxOdC5ORVdMSU5FPUEuZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKSxOdC5TSU1QTEVfT1JESU5BVEVfRk9STUFUPW5ldyB5dChcIjAuI1wiKSxlKEN0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3R9fSksQ3QuY29weUNvb3JkPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLG4uZ2V0RGltZW5zaW9uKCkpLHM9MDtzPHI7cysrKW4uc2V0T3JkaW5hdGUoaSxzLHQuZ2V0T3JkaW5hdGUoZSxzKSl9LEN0LmlzUmluZz1mdW5jdGlvbih0KXt2YXIgZT10LnNpemUoKTtyZXR1cm4gMD09PWV8fCEoZTw9MykmJih0LmdldE9yZGluYXRlKDAsRC5YKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEQuWCkmJnQuZ2V0T3JkaW5hdGUoMCxELlkpPT09dC5nZXRPcmRpbmF0ZShlLTEsRC5ZKSl9LEN0LmlzRXF1YWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10LnNpemUoKSxpPWUuc2l6ZSgpO2lmKG4hPT1pKXJldHVybiExO2Zvcih2YXIgcz1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpLG89MDtvPG47bysrKWZvcih2YXIgYT0wO2E8czthKyspe3ZhciB1PXQuZ2V0T3JkaW5hdGUobyxhKSxsPWUuZ2V0T3JkaW5hdGUobyxhKTtpZighKHQuZ2V0T3JkaW5hdGUobyxhKT09PWUuZ2V0T3JkaW5hdGUobyxhKXx8ci5pc05hTih1KSYmci5pc05hTihsKSkpcmV0dXJuITF9cmV0dXJuITB9LEN0LmV4dGVuZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxyPWUuc2l6ZSgpO2lmKEN0LmNvcHkoZSwwLGksMCxyKSxyPjApZm9yKHZhciBzPXI7czxuO3MrKylDdC5jb3B5KGUsci0xLGkscywxKTtyZXR1cm4gaX0sQ3QucmV2ZXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKSxpPTA7aTw9bjtpKyspQ3Quc3dhcCh0LGksZS1pKX0sQ3Quc3dhcD1mdW5jdGlvbih0LGUsbil7aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKHZhciBpPTA7aTx0LmdldERpbWVuc2lvbigpO2krKyl7dmFyIHI9dC5nZXRPcmRpbmF0ZShlLGkpO3Quc2V0T3JkaW5hdGUoZSxpLHQuZ2V0T3JkaW5hdGUobixpKSksdC5zZXRPcmRpbmF0ZShuLGkscil9fSxDdC5jb3B5PWZ1bmN0aW9uKHQsZSxuLGkscil7Zm9yKHZhciBzPTA7czxyO3MrKylDdC5jb3B5Q29vcmQodCxlK3MsbixpK3MpfSxDdC50b1N0cmluZz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LnNpemUoKTtpZigwPT09ZSlyZXR1cm5cIigpXCI7dmFyIG49dC5nZXREaW1lbnNpb24oKSxpPW5ldyBQO2kuYXBwZW5kKFwiKFwiKTtmb3IodmFyIHI9MDtyPGU7cisrKXtyPjAmJmkuYXBwZW5kKFwiIFwiKTtmb3IodmFyIHM9MDtzPG47cysrKXM+MCYmaS5hcHBlbmQoXCIsXCIpLGkuYXBwZW5kKE50LnRvU3RyaW5nKHQuZ2V0T3JkaW5hdGUocixzKSkpfXJldHVybiBpLmFwcGVuZChcIilcIiksaS50b1N0cmluZygpfX0sQ3QuZW5zdXJlVmFsaWRSaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zaXplKCk7aWYoMD09PW4pcmV0dXJuIGU7aWYobjw9MylyZXR1cm4gQ3QuY3JlYXRlQ2xvc2VkUmluZyh0LGUsNCk7dmFyIGk9ZS5nZXRPcmRpbmF0ZSgwLEQuWCk9PT1lLmdldE9yZGluYXRlKG4tMSxELlgpJiZlLmdldE9yZGluYXRlKDAsRC5ZKT09PWUuZ2V0T3JkaW5hdGUobi0xLEQuWSk7cmV0dXJuIGk/ZTpDdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSxuKzEpfSxDdC5jcmVhdGVDbG9zZWRSaW5nPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLHI9ZS5zaXplKCk7Q3QuY29weShlLDAsaSwwLHIpO2Zvcih2YXIgcz1yO3M8bjtzKyspQ3QuY29weShlLDAsaSxzLDEpO3JldHVybiBpfSxoKFN0LEIpLGUoU3QucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9uZXcgQzp0aGlzLnBvaW50cy5leHBhbmRFbnZlbG9wZShuZXcgQyl9LGlzUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCkmJnRoaXMuaXNTaW1wbGUoKX0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX0xJTkVTVFJJTkd9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10O2lmKHRoaXMucG9pbnRzLnNpemUoKSE9PW4ucG9pbnRzLnNpemUoKSlyZXR1cm4hMTtmb3IodmFyIGk9MDtpPHRoaXMucG9pbnRzLnNpemUoKTtpKyspaWYoIXRoaXMuZXF1YWwodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSxuLnBvaW50cy5nZXRDb29yZGluYXRlKGkpLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLnBvaW50cy5zaXplKCkvMik7dCsrKXt2YXIgZT10aGlzLnBvaW50cy5zaXplKCktMS10O2lmKCF0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpLmVxdWFscyh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKSlyZXR1cm4gdGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5jb21wYXJlVG8odGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk+MCYmQ3QucmV2ZXJzZSh0aGlzLnBvaW50cyksbnVsbH19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKDApfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/bHQuRkFMU0U6MH0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0VtcHR5KCkmJnRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpLTEpKX0sZ2V0RW5kUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50Tih0aGlzLmdldE51bVBvaW50cygpLTEpfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIGhlLmNvbXB1dGVMZW5ndGgodGhpcy5wb2ludHMpfSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludHMuc2l6ZSgpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb2ludHMuY29weSgpO0N0LnJldmVyc2UodCk7dmFyIGU9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0KTtyZXR1cm4gZX0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10LG49MCxpPTA7bjx0aGlzLnBvaW50cy5zaXplKCkmJmk8ZS5wb2ludHMuc2l6ZSgpOyl7dmFyIHI9dGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKS5jb21wYXJlVG8oZS5wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSk7aWYoMCE9PXIpcmV0dXJuIHI7bisrLGkrK31yZXR1cm4gbjx0aGlzLnBvaW50cy5zaXplKCk/MTppPGUucG9pbnRzLnNpemUoKT8tMTowfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sZT1zO3JldHVybiBvLmNvbXBhcmUodGhpcy5wb2ludHMsZS5wb2ludHMpfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHRoaXMucG9pbnRzLnNpemUoKTtlKyspdC5maWx0ZXIodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk7ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxjdCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5wb2ludHMuc2l6ZSgpKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5wb2ludHMuc2l6ZSgpJiYobi5maWx0ZXIodGhpcy5wb2ludHMsZSksIW4uaXNEb25lKCkpO2UrKyk7bi5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgaT1hcmd1bWVudHNbMF07aS5maWx0ZXIodGhpcyl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIHI9YXJndW1lbnRzWzBdO3IuZmlsdGVyKHRoaXMpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGR0KHRoaXMpLmdldEJvdW5kYXJ5KCl9LGlzRXF1aXZhbGVudENsYXNzOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgU3R9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5wb2ludHM9dGhpcy5wb2ludHMuY2xvbmUoKSx0fSxnZXRDb29yZGluYXRlTjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJMaW5lU3RyaW5nXCJ9LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFN0KHRoaXMucG9pbnRzLmNvcHkoKSx0aGlzLmZhY3RvcnkpfSxnZXRDb29yZGluYXRlU2VxdWVuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludHN9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMucG9pbnRzLnNpemUoKX0saW5pdDpmdW5jdGlvbih0KXtpZihudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLDE9PT10LnNpemUoKSl0aHJvdyBuZXcgaShcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lU3RyaW5nIChmb3VuZCBcIit0LnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSAyKVwiKTt0aGlzLnBvaW50cz10fSxpc0Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLnBvaW50cy5zaXplKCk7ZSsrKWlmKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkuZXF1YWxzKHQpKXJldHVybiEwO3JldHVybiExfSxnZXRTdGFydFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4oMCl9LGdldFBvaW50TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3N0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU3R9fSksU3Quc2VyaWFsVmVyc2lvblVJRD0weDJiMmI1MWJhNDM1YzhlMDAsZSh3dC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHd0fX0pLGgoTHQsQiksZShMdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG5ldyBDO3ZhciB0PW5ldyBDO3JldHVybiB0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmNvb3JkaW5hdGVzLmdldFgoMCksdGhpcy5jb29yZGluYXRlcy5nZXRZKDApKSx0fSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfUE9JTlR9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP1tdOlt0aGlzLmdldENvb3JkaW5hdGUoKV19LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJighKCF0aGlzLmlzRW1wdHkoKXx8IXQuaXNFbXB0eSgpKXx8dGhpcy5pc0VtcHR5KCk9PT10LmlzRW1wdHkoKSYmdGhpcy5lcXVhbCh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmdldENvb3JkaW5hdGUoKSxlKSl9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLmNvb3JkaW5hdGVzLnNpemUoKT90aGlzLmNvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCk6bnVsbH0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAwfSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoxfSxyZXZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29weSgpfSxnZXRYOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueH0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQ7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyhlLmdldENvb3JkaW5hdGUoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW47cmV0dXJuIGkuY29tcGFyZSh0aGlzLmNvb3JkaW5hdGVzLGUuY29vcmRpbmF0ZXMpfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO2UuZmlsdGVyKHRoaXMuY29vcmRpbmF0ZXMsMCksZS5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgbj1hcmd1bWVudHNbMF07bi5maWx0ZXIodGhpcyl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuY29vcmRpbmF0ZXM9dGhpcy5jb29yZGluYXRlcy5jbG9uZSgpLHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiUG9pbnRcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgTHQodGhpcy5jb29yZGluYXRlcy5jb3B5KCksdGhpcy5mYWN0b3J5KX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXN9LGdldFk6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55fSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmNvb3JkaW5hdGVzLnNpemUoKX0saW5pdDpmdW5jdGlvbih0KXtudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLGYuaXNUcnVlKHQuc2l6ZSgpPD0xKSx0aGlzLmNvb3JkaW5hdGVzPXR9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3d0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHR9fSksTHQuc2VyaWFsVmVyc2lvblVJRD0weDQ0MDc3YmFkMTYxY2JjMDAsZShSdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJ0fX0pLGgoVHQsQiksZShUdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfUE9MWUdPTn0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm5bXTtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCksZT0tMSxuPXRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKSxpPTA7aTxuLmxlbmd0aDtpKyspZSsrLHRbZV09bltpXTtmb3IodmFyIHI9MDtyPHRoaXMuaG9sZXMubGVuZ3RoO3IrKylmb3IodmFyIHM9dGhpcy5ob2xlc1tyXS5nZXRDb29yZGluYXRlcygpLG89MDtvPHMubGVuZ3RoO28rKyllKyssdFtlXT1zW29dO3JldHVybiB0fSxnZXRBcmVhOmZ1bmN0aW9uKCl7dmFyIHQ9MDt0Kz1NYXRoLmFicyhoZS5zaWduZWRBcmVhKHRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0LT1NYXRoLmFicyhoZS5zaWduZWRBcmVhKHRoaXMuaG9sZXNbZV0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtyZXR1cm4gdH0saXNSZWN0YW5nbGU6ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSlyZXR1cm4hMTtpZihudWxsPT09dGhpcy5zaGVsbClyZXR1cm4hMTtpZig1IT09dGhpcy5zaGVsbC5nZXROdW1Qb2ludHMoKSlyZXR1cm4hMTtmb3IodmFyIHQ9dGhpcy5zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxlPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49MDtuPDU7bisrKXt2YXIgaT10LmdldFgobik7aWYoaSE9PWUuZ2V0TWluWCgpJiZpIT09ZS5nZXRNYXhYKCkpcmV0dXJuITE7dmFyIHI9dC5nZXRZKG4pO2lmKHIhPT1lLmdldE1pblkoKSYmciE9PWUuZ2V0TWF4WSgpKXJldHVybiExfWZvcih2YXIgcz10LmdldFgoMCksbz10LmdldFkoMCksbj0xO248PTQ7bisrKXt2YXIgaT10LmdldFgobikscj10LmdldFkobiksYT1pIT09cyx1PXIhPT1vO2lmKGE9PT11KXJldHVybiExO3M9aSxvPXJ9cmV0dXJuITB9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10LGk9dGhpcy5zaGVsbCxyPW4uc2hlbGw7aWYoIWkuZXF1YWxzRXhhY3QocixlKSlyZXR1cm4hMTtpZih0aGlzLmhvbGVzLmxlbmd0aCE9PW4uaG9sZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgcz0wO3M8dGhpcy5ob2xlcy5sZW5ndGg7cysrKWlmKCF0aGlzLmhvbGVzW3NdLmVxdWFsc0V4YWN0KG4uaG9sZXNbc10sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMubm9ybWFsaXplKHRoaXMuc2hlbGwsITApO2Zvcih2YXIgdD0wO3Q8dGhpcy5ob2xlcy5sZW5ndGg7dCsrKXRoaXMubm9ybWFsaXplKHRoaXMuaG9sZXNbdF0sITEpO3V0LnNvcnQodGhpcy5ob2xlcyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBpPW5ldyBBcnJheShlLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoLTEpLmZpbGwobnVsbCk7QS5hcnJheWNvcHkoZS5nZXRDb29yZGluYXRlcygpLDAsaSwwLGkubGVuZ3RoKTt2YXIgcj1ILm1pbkNvb3JkaW5hdGUoZS5nZXRDb29yZGluYXRlcygpKTtILnNjcm9sbChpLHIpLEEuYXJyYXljb3B5KGksMCxlLmdldENvb3JkaW5hdGVzKCksMCxpLmxlbmd0aCksZS5nZXRDb29yZGluYXRlcygpW2kubGVuZ3RoXT1pWzBdLGhlLmlzQ0NXKGUuZ2V0Q29vcmRpbmF0ZXMoKSk9PT1uJiZILnJldmVyc2UoZS5nZXRDb29yZGluYXRlcygpKX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbC5nZXRDb29yZGluYXRlKCl9LGdldE51bUludGVyaW9yUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhvbGVzLmxlbmd0aH0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDJ9LGdldExlbmd0aDpmdW5jdGlvbigpe3ZhciB0PTA7dCs9dGhpcy5zaGVsbC5nZXRMZW5ndGgoKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmhvbGVzW2VdLmdldExlbmd0aCgpO3JldHVybiB0fSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5zaGVsbC5nZXROdW1Qb2ludHMoKSxlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5ob2xlc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29weSgpO3Quc2hlbGw9dGhpcy5zaGVsbC5jb3B5KCkucmV2ZXJzZSgpLHQuaG9sZXM9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQuaG9sZXNbZV09dGhpcy5ob2xlc1tlXS5jb3B5KCkucmV2ZXJzZSgpO3JldHVybiB0fSxjb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpfSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5zaGVsbCxuPXQuc2hlbGw7cmV0dXJuIGUuY29tcGFyZVRvU2FtZUNsYXNzKG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1pLGU9dGhpcy5zaGVsbCxuPXMuc2hlbGwsbz1lLmNvbXBhcmVUb1NhbWVDbGFzcyhuLHIpO2lmKDAhPT1vKXJldHVybiBvO2Zvcih2YXIgYT10aGlzLmdldE51bUludGVyaW9yUmluZygpLHU9cy5nZXROdW1JbnRlcmlvclJpbmcoKSxsPTA7bDxhJiZsPHU7KXt2YXIgaD10aGlzLmdldEludGVyaW9yUmluZ04obCksYz1zLmdldEludGVyaW9yUmluZ04obCksZj1oLmNvbXBhcmVUb1NhbWVDbGFzcyhjLHIpO2lmKDAhPT1mKXJldHVybiBmO2wrK31yZXR1cm4gbDxhPzE6bDx1Py0xOjB9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaGVsbC5hcHBseSh0KTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0aGlzLmhvbGVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5zaGVsbC5hcHBseShuKSwhbi5pc0RvbmUoKSlmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoJiYodGhpcy5ob2xlc1tlXS5hcHBseShuKSwhbi5pc0RvbmUoKSk7ZSsrKTtuLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgcj1hcmd1bWVudHNbMF07ci5maWx0ZXIodGhpcyksdGhpcy5zaGVsbC5hcHBseShyKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0aGlzLmhvbGVzW2VdLmFwcGx5KHIpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7dmFyIHQ9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKzEpLmZpbGwobnVsbCk7dFswXT10aGlzLnNoZWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRbZSsxXT10aGlzLmhvbGVzW2VdO3JldHVybiB0Lmxlbmd0aDw9MT90aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHRbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpOnRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3Quc2hlbGw9dGhpcy5zaGVsbC5jbG9uZSgpLHQuaG9sZXM9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQuaG9sZXNbZV09dGhpcy5ob2xlc1tlXS5jbG9uZSgpO3JldHVybiB0fSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIlBvbHlnb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLnNoZWxsLmNvcHkoKSxlPW5ldyBBcnJheSh0aGlzLmhvbGVzLmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10aGlzLmhvbGVzW25dLmNvcHkoKTtyZXR1cm4gbmV3IFR0KHQsZSx0aGlzLmZhY3RvcnkpfSxnZXRFeHRlcmlvclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsLmlzRW1wdHkoKX0sZ2V0SW50ZXJpb3JSaW5nTjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ob2xlc1t0XX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUnRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUdH19KSxUdC5zZXJpYWxWZXJzaW9uVUlEPS0weDMwN2ZmZWZkOGRjOTcyMDAsaChQdCxmdCksZShQdC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSVBPSU5UfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJmZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIGZ0LnByb3RvdHlwZS5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAwfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTXVsdGlQb2ludFwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBQdCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3d0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHR9fSksUHQuc2VyaWFsVmVyc2lvblVJRD0tMHg2ZmIxZWQ0MTYyZTBmYzAwLGgoYnQsU3QpLGUoYnQucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTElORUFSUklOR30sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmlzRW1wdHkoKXx8U3QucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcyl9LHJldmVyc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvaW50cy5jb3B5KCk7Q3QucmV2ZXJzZSh0KTt2YXIgZT10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiBlfSx2YWxpZGF0ZUNvbnN0cnVjdGlvbjpmdW5jdGlvbigpe2lmKCF0aGlzLmlzRW1wdHkoKSYmIVN0LnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpKXRocm93IG5ldyBpKFwiUG9pbnRzIG9mIExpbmVhclJpbmcgZG8gbm90IGZvcm0gYSBjbG9zZWQgbGluZXN0cmluZ1wiKTtpZih0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKT49MSYmdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk8YnQuTUlOSU1VTV9WQUxJRF9TSVpFKXRocm93IG5ldyBpKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDQpXCIpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIkxpbmVhclJpbmdcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgYnQodGhpcy5wb2ludHMuY29weSgpLHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJ0fX0pLGJ0Lk1JTklNVU1fVkFMSURfU0laRT00LGJ0LnNlcmlhbFZlcnNpb25VSUQ9LTB4M2IyMjllMjYyMzY3YTYwMCxoKE90LGZ0KSxlKE90LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJUE9MWUdPTn0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpfXJldHVybiBmdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMn0scmV2ZXJzZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCksbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZVtuXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2Zvcih2YXIgdD1uZXcgSSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKylmb3IodmFyIG49dGhpcy5nZW9tZXRyaWVzW2VdLGk9bi5nZXRCb3VuZGFyeSgpLHI9MDtyPGkuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl0LmFkZChpLmdldEdlb21ldHJ5TihyKSk7dmFyIHM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodC50b0FycmF5KHMpKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJNdWx0aVBvbHlnb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgT3QodCx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE90fX0pLE90LnNlcmlhbFZlcnNpb25VSUQ9LTB4N2E1YWExMzY5MTcxOTgwLGUoX3QucHJvdG90eXBlLHtzZXRDb3B5VXNlckRhdGE6ZnVuY3Rpb24odCl7dGhpcy5pc1VzZXJEYXRhQ29waWVkPXR9LGVkaXQ6ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgbj10aGlzLmVkaXRJbnRlcm5hbCh0LGUpO3JldHVybiB0aGlzLmlzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufSxlZGl0SW50ZXJuYWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXRoaXMuZmFjdG9yeSYmKHRoaXMuZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdCBpbnN0YW5jZW9mIGZ0P3RoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbih0LGUpOnQgaW5zdGFuY2VvZiBUdD90aGlzLmVkaXRQb2x5Z29uKHQsZSk6dCBpbnN0YW5jZW9mIEx0P2UuZWRpdCh0LHRoaXMuZmFjdG9yeSk6dCBpbnN0YW5jZW9mIFN0P2UuZWRpdCh0LHRoaXMuZmFjdG9yeSk6KGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbnN1cHBvcnRlZCBHZW9tZXRyeSBjbGFzczogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSksbnVsbCl9LGVkaXRHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KSxpPW5ldyBJLHI9MDtyPG4uZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHIpLGUpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8aS5hZGQocyl9cmV0dXJuIG4uZ2V0Q2xhc3MoKT09PVB0P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGkudG9BcnJheShbXSkpOm4uZ2V0Q2xhc3MoKT09PWd0P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaS50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09T3Q/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihpLnRvQXJyYXkoW10pKTp0aGlzLmZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGkudG9BcnJheShbXSkpfSxlZGl0UG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPWUuZWRpdCh0LHRoaXMuZmFjdG9yeSk7aWYobnVsbD09PW4mJihuPXRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKG51bGwpKSxuLmlzRW1wdHkoKSlyZXR1cm4gbjt2YXIgaT10aGlzLmVkaXQobi5nZXRFeHRlcmlvclJpbmcoKSxlKTtpZihudWxsPT09aXx8aS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Zm9yKHZhciByPW5ldyBJLHM9MDtzPG4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10aGlzLmVkaXQobi5nZXRJbnRlcmlvclJpbmdOKHMpLGUpO251bGw9PT1vfHxvLmlzRW1wdHkoKXx8ci5hZGQobyl9cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKGksci50b0FycmF5KFtdKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF90fX0pLF90Lkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uPU10LGUoRHQucHJvdG90eXBlLHtlZGl0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHR9fSksZShBdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmVkaXRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCksdCk7cmV0dXJuIG51bGw9PT1uP3Q6dCBpbnN0YW5jZW9mIGJ0P2UuY3JlYXRlTGluZWFyUmluZyhuKTp0IGluc3RhbmNlb2YgU3Q/ZS5jcmVhdGVMaW5lU3RyaW5nKG4pOnQgaW5zdGFuY2VvZiBMdD9uLmxlbmd0aD4wP2UuY3JlYXRlUG9pbnQoblswXSk6ZS5jcmVhdGVQb2ludCgpOnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQXR9fSksZShGdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIGJ0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFN0P2UuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIEx0P2UuY3JlYXRlUG9pbnQodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW010XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRnR9fSksX3QuTm9PcEdlb21ldHJ5T3BlcmF0aW9uPUR0LF90LkNvb3JkaW5hdGVPcGVyYXRpb249QXQsX3QuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uPUZ0LGUoR3QucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUsbil7c3dpdGNoKGUpe2Nhc2UgRC5YOnRoaXMuY29vcmRpbmF0ZXNbdF0ueD1uO2JyZWFrO2Nhc2UgRC5ZOnRoaXMuY29vcmRpbmF0ZXNbdF0ueT1uO2JyZWFrO2Nhc2UgRC5aOnRoaXMuY29vcmRpbmF0ZXNbdF0uej1uO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IGkoXCJpbnZhbGlkIG9yZGluYXRlSW5kZXhcIil9fSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RofSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe3N3aXRjaChlKXtjYXNlIEQuWDpyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS54O2Nhc2UgRC5ZOnJldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnk7Y2FzZSBELlo6cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0uen1yZXR1cm4gci5OYU59LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07bi54PXRoaXMuY29vcmRpbmF0ZXNbZV0ueCxuLnk9dGhpcy5jb29yZGluYXRlc1tlXS55LG4uej10aGlzLmNvb3JkaW5hdGVzW2VdLnp9fSxnZXRDb29yZGluYXRlQ29weTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodGhpcy5jb29yZGluYXRlc1t0XSl9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpbWVuc2lvbn0sZ2V0WDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS54fSxjbG9uZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCksZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRbZV09dGhpcy5jb29yZGluYXRlc1tlXS5jbG9uZSgpO3JldHVybiBuZXcgR3QodCx0aGlzLmRpbWVuc2lvbil9LGV4cGFuZEVudmVsb3BlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0fSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdFtlXT10aGlzLmNvb3JkaW5hdGVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IEd0KHQsdGhpcy5kaW1lbnNpb24pfSx0b1N0cmluZzpmdW5jdGlvbigpe2lmKHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoPjApe3ZhciB0PW5ldyBQKDE3KnRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKTt0LmFwcGVuZChcIihcIiksdC5hcHBlbmQodGhpcy5jb29yZGluYXRlc1swXSk7Zm9yKHZhciBlPTE7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5hcHBlbmQoXCIsIFwiKSx0LmFwcGVuZCh0aGlzLmNvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdC5hcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX1yZXR1cm5cIigpXCJ9LGdldFk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueX0sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRCx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3R9fSksR3Quc2VyaWFsVmVyc2lvblVJRD0tMHhjYjQ0YTc3OGRiMThlMDAsZShxdC5wcm90b3R5cGUse3JlYWRSZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuIHF0Lmluc3RhbmNlKCl9LGNyZWF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBHdCh0KX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgR3QoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gaT4zJiYoaT0zKSxpPDI/bmV3IEd0KG4pOm5ldyBHdChuLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXR9fSkscXQuaW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2VPYmplY3R9LHF0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzhlNDlmYTZjZjZmMmUwMCxxdC5pbnN0YW5jZU9iamVjdD1uZXcgcXQ7dmFyIG5vLGlvPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxybz16dCh7ZGVsZXRlOmt0LGhhczpYdCxnZXQ6WXQsc2V0Okh0LGtleXM6anQsdmFsdWVzOkt0LGVudHJpZXM6WnQsZm9yRWFjaDokdCxjbGVhcjpXdH0pLHNvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBNYXAmJk1hcC5wcm90b3R5cGUudmFsdWVzP01hcDpybzt0ZS5wcm90b3R5cGU9bmV3IEssdGUucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5tYXBfLmdldCh0KXx8bnVsbH0sdGUucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLm1hcF8uc2V0KHQsZSksZX0sdGUucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMubWFwXy52YWx1ZXMoKSxuPWUubmV4dCgpOyFuLmRvbmU7KXQuYWRkKG4udmFsdWUpLG49ZS5uZXh0KCk7cmV0dXJuIHR9LHRlLnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe3ZhciB0PW5ldyBKO3JldHVybiB0aGlzLm1hcF8uZW50cmllcygpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWRkKGUpfSksdH0sdGUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfLnNpemUoKX0sZShlZS5wcm90b3R5cGUse2VxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBlZSkpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lLm1vZGVsVHlwZSYmdGhpcy5zY2FsZT09PWUuc2NhbGV9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10LG49dGhpcy5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKSxpPWUuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7cmV0dXJuIG5ldyBiKG4pLmNvbXBhcmVUbyhuZXcgYihpKSl9LGdldFNjYWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2NhbGV9LGlzRmxvYXRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR3x8dGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEV9LGdldFR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbFR5cGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9XCJVTktOT1dOXCI7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkc/dD1cIkZsb2F0aW5nXCI6dGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEU/dD1cIkZsb2F0aW5nLVNpbmdsZVwiOnRoaXMubW9kZWxUeXBlPT09ZWUuRklYRUQmJih0PVwiRml4ZWQgKFNjYWxlPVwiK3RoaXMuZ2V0U2NhbGUoKStcIilcIiksdH0sbWFrZVByZWNpc2U6ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07aWYoci5pc05hTih0KSlyZXR1cm4gdDtpZih0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRSl7dmFyIGU9dDtyZXR1cm4gZX1yZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GSVhFRD9NYXRoLnJvdW5kKHQqdGhpcy5zY2FsZSkvdGhpcy5zY2FsZTp0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkcpcmV0dXJuIG51bGw7bi54PXRoaXMubWFrZVByZWNpc2Uobi54KSxuLnk9dGhpcy5tYWtlUHJlY2lzZShuLnkpfX0sZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzOmZ1bmN0aW9uKCl7dmFyIHQ9MTY7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkc/dD0xNjp0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRT90PTY6dGhpcy5tb2RlbFR5cGU9PT1lZS5GSVhFRCYmKHQ9MStNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLmxvZyh0aGlzLmdldFNjYWxlKCkpL01hdGgubG9nKDEwKSkpKSx0fSxzZXRTY2FsZTpmdW5jdGlvbih0KXt0aGlzLnNjYWxlPU1hdGguYWJzKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1LHNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlZX19KSxlZS5tb3N0UHJlY2lzZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKT49MD90OmV9LGUobmUucHJvdG90eXBlLHtyZWFkUmVzb2x2ZTpmdW5jdGlvbigpe3JldHVybiBuZS5uYW1lVG9UeXBlTWFwLmdldCh0aGlzLm5hbWUpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBuZX19KSxuZS5zZXJpYWxWZXJzaW9uVUlEPS01NTI4NjAyNjMxNzMxNTllNCxuZS5uYW1lVG9UeXBlTWFwPW5ldyB0ZSxlZS5UeXBlPW5lLGVlLnNlcmlhbFZlcnNpb25VSUQ9MHg2YmVlNjQwNGU5YTI1YzAwLGVlLkZJWEVEPW5ldyBuZShcIkZJWEVEXCIpLGVlLkZMT0FUSU5HPW5ldyBuZShcIkZMT0FUSU5HXCIpLGVlLkZMT0FUSU5HX1NJTkdMRT1uZXcgbmUoXCJGTE9BVElORyBTSU5HTEVcIiksZWUubWF4aW11bVByZWNpc2VWYWx1ZT05MDA3MTk5MjU0NzQwOTkyLGUoaWUucHJvdG90eXBlLHt0b0dlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmlzTnVsbCgpP3RoaXMuY3JlYXRlUG9pbnQobnVsbCk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKSYmdC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZVBvaW50KG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSk6dC5nZXRNaW5YKCk9PT10LmdldE1heFgoKXx8dC5nZXRNaW5ZKCk9PT10LmdldE1heFkoKT90aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSldKTp0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpXSksbnVsbCl9LGNyZWF0ZUxpbmVTdHJpbmc6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFN0KGUsdGhpcyl9fX0sY3JlYXRlTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBndChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBndCh0LHRoaXMpfX0sYnVpbGRHZW9tZXRyeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPSExLGk9ITEscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0Q2xhc3MoKTtudWxsPT09ZSYmKGU9byksbyE9PWUmJihuPSEwKSxzLmlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkKCkmJihpPSEwKX1pZihudWxsPT09ZSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTtpZihufHxpKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkodCkpO3ZhciBhPXQuaXRlcmF0b3IoKS5uZXh0KCksdT10LnNpemUoKT4xO2lmKHUpe2lmKGEgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvbHlnb24oaWUudG9Qb2x5Z29uQXJyYXkodCkpO2lmKGEgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaWUudG9MaW5lU3RyaW5nQXJyYXkodCkpO2lmKGEgaW5zdGFuY2VvZiBMdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGllLnRvUG9pbnRBcnJheSh0KSk7Zi5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBjbGFzczogXCIrYS5nZXRDbGFzcygpLmdldE5hbWUoKSl9cmV0dXJuIGF9LGNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfSxjcmVhdGVQb2ludDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZVBvaW50KHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW3RdKTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgTHQoZSx0aGlzKX19fSxnZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeX0sY3JlYXRlUG9seWdvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgVHQobnVsbCxudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoZSkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKG4sbnVsbCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IFR0KGkscix0aGlzKX19LGdldFNSSUQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5TUklEfSxjcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGZ0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGZ0KHQsdGhpcyl9fSxjcmVhdGVHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgX3QodGhpcyk7cmV0dXJuIGUuZWRpdCh0LHtlZGl0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTthcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5jcmVhdGUodCl9fX0pfSxnZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsfSxjcmVhdGVMaW5lYXJSaW5nOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBidChlLHRoaXMpfX19LGNyZWF0ZU11bHRpUG9seWdvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgT3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgT3QodCx0aGlzKX19LGNyZWF0ZU11bHRpUG9pbnQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IFB0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFB0KHQsdGhpcyl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobnVsbCE9PWU/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGUpOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7Zm9yKHZhciBpPW5ldyBBcnJheShuLnNpemUoKSkuZmlsbChudWxsKSxyPTA7cjxuLnNpemUoKTtyKyspe3ZhciBzPXRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLG4uZ2V0RGltZW5zaW9uKCkpO0N0LmNvcHkobixyLHMsMCwxKSxpW3JdPXRoaXMuY3JlYXRlUG9pbnQocyl9cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChpKX19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaWV9fSksaWUudG9NdWx0aVBvbHlnb25BcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9HZW9tZXRyeUFycmF5PWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1mdW5jdGlvbigpe3JldHVybiBxdC5pbnN0YW5jZSgpfSxpZS50b011bHRpTGluZVN0cmluZ0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b0xpbmVTdHJpbmdBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9NdWx0aVBvaW50QXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvTGluZWFyUmluZ0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b1BvaW50QXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvUG9seWdvbkFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0saWUuc2VyaWFsVmVyc2lvblVJRD0tMHg1ZWE3NWYyMDUxZWViNDAwO3ZhciBvbz17dHlwZVN0cjovXlxccyooXFx3KylcXHMqXFwoXFxzKiguKilcXHMqXFwpXFxzKiQvLGVtcHR5VHlwZVN0cjovXlxccyooXFx3KylcXHMqRU1QVFlcXHMqJC8sc3BhY2VzOi9cXHMrLyxwYXJlbkNvbW1hOi9cXClcXHMqLFxccypcXCgvLGRvdWJsZVBhcmVuQ29tbWE6L1xcKVxccypcXClcXHMqLFxccypcXChcXHMqXFwoLyx0cmltUGFyZW5zOi9eXFxzKlxcKD8oLio/KVxcKT9cXHMqJC99O2UocmUucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3ZhciBlLG4saTt0PXQucmVwbGFjZSgvW1xcblxccl0vZyxcIiBcIik7dmFyIHI9b28udHlwZVN0ci5leGVjKHQpO2lmKHQuc2VhcmNoKFwiRU1QVFlcIikhPT0tMSYmKHI9b28uZW1wdHlUeXBlU3RyLmV4ZWModCksclsyXT12b2lkIDApLHImJihuPXJbMV0udG9Mb3dlckNhc2UoKSxcbmk9clsyXSx1b1tuXSYmKGU9dW9bbl0uYXBwbHkodGhpcyxbaV0pKSksdm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgV0tUIFwiK3QpO3JldHVybiBlfSx3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leHRyYWN0R2VvbWV0cnkodCl9LGV4dHJhY3RHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT10LmdldEdlb21ldHJ5VHlwZSgpLnRvTG93ZXJDYXNlKCk7aWYoIWFvW2VdKXJldHVybiBudWxsO3ZhciBuLGk9ZS50b1VwcGVyQ2FzZSgpO3JldHVybiBuPXQuaXNFbXB0eSgpP2krXCIgRU1QVFlcIjppK1wiKFwiK2FvW2VdLmFwcGx5KHRoaXMsW3RdKStcIilcIn19KTt2YXIgYW89e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQueCtcIiBcIit0Lnl9LHBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBhby5jb29yZGluYXRlLmNhbGwodGhpcyx0LmNvb3JkaW5hdGVzLmNvb3JkaW5hdGVzWzBdKX0sbXVsdGlwb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5nZW9tZXRyaWVzLmxlbmd0aDtuPGk7KytuKWUucHVzaChcIihcIithby5wb2ludC5hcHBseSh0aGlzLFt0Lmdlb21ldHJpZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQucG9pbnRzLmNvb3JkaW5hdGVzLmxlbmd0aDtuPGk7KytuKWUucHVzaChhby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QucG9pbnRzLmNvb3JkaW5hdGVzW25dXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lYXJyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10LnBvaW50cy5jb29yZGluYXRlcy5sZW5ndGg7bjxpOysrbillLnB1c2goYW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFt0LnBvaW50cy5jb29yZGluYXRlc1tuXV0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlsaW5lc3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO248aTsrK24pZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5nZW9tZXRyaWVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxwb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPVtdO2UucHVzaChcIihcIithby5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW3Quc2hlbGxdKStcIilcIik7Zm9yKHZhciBuPTAsaT10LmhvbGVzLmxlbmd0aDtuPGk7KytuKWUucHVzaChcIihcIithby5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW3QuaG9sZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LG11bHRpcG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5nZW9tZXRyaWVzLmxlbmd0aDtuPGk7KytuKWUucHVzaChcIihcIithby5wb2x5Z29uLmFwcGx5KHRoaXMsW3QuZ2VvbWV0cmllc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sZ2VvbWV0cnljb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO248aTsrK24pZS5wdXNoKHRoaXMuZXh0cmFjdEdlb21ldHJ5KHQuZ2VvbWV0cmllc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfX0sdW89e3BvaW50OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KCk7dmFyIGU9dC50cmltKCkuc3BsaXQob28uc3BhY2VzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IGcoTnVtYmVyLnBhcnNlRmxvYXQoZVswXSksTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSkpKX0sbXVsdGlwb2ludDpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLGk9W10scj0wLHM9bi5sZW5ndGg7cjxzOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLnBvaW50LmFwcGx5KHRoaXMsW2VdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoaSl9LGxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3I8czsrK3IpZT1uW3JdLnRyaW0oKS5zcGxpdChvby5zcGFjZXMpLGkucHVzaChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGkpfSxsaW5lYXJyaW5nOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIiksaT1bXSxyPTAscz1uLmxlbmd0aDtyPHM7KytyKWU9bltyXS50cmltKCkuc3BsaXQob28uc3BhY2VzKSxpLnB1c2gobmV3IGcoTnVtYmVyLnBhcnNlRmxvYXQoZVswXSksTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSkpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhpKX0sbXVsdGlsaW5lc3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KG9vLnBhcmVuQ29tbWEpLGk9W10scj0wLHM9bi5sZW5ndGg7cjxzOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGkpfSxwb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtmb3IodmFyIGUsbixpLHIscz10LnRyaW0oKS5zcGxpdChvby5wYXJlbkNvbW1hKSxvPVtdLGE9MCx1PXMubGVuZ3RoO2E8dTsrK2EpZT1zW2FdLnJlcGxhY2Uob28udHJpbVBhcmVucyxcIiQxXCIpLG49dW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFtlXSksaT10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4ucG9pbnRzKSwwPT09YT9yPWk6by5wdXNoKGkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHIsbyl9LG11bHRpcG9seWdvbjpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChvby5kb3VibGVQYXJlbkNvbW1hKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3I8czsrK3IpZT1uW3JdLnJlcGxhY2Uob28udHJpbVBhcmVucyxcIiQxXCIpLGkucHVzaCh1by5wb2x5Z29uLmFwcGx5KHRoaXMsW2VdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihpKX0sZ2VvbWV0cnljb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO3Q9dC5yZXBsYWNlKC8sXFxzKihbQS1aYS16XSkvZyxcInwkMVwiKTtmb3IodmFyIGU9dC50cmltKCkuc3BsaXQoXCJ8XCIpLG49W10saT0wLHI9ZS5sZW5ndGg7aTxyOysraSluLnB1c2godGhpcy5yZWFkKGVbaV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfX07ZShzZS5wcm90b3R5cGUse3dyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19KSxlKHNlLHt0b0xpbmVTdHJpbmc6ZnVuY3Rpb24odCxlKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7cmV0dXJuXCJMSU5FU1RSSU5HICggXCIrdC54K1wiIFwiK3QueStcIiwgXCIrZS54K1wiIFwiK2UueStcIiApXCJ9fSksZShvZS5wcm90b3R5cGUse2dldEluZGV4QWxvbmdTZWdtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpLHRoaXMuaW50TGluZUluZGV4W3RdW2VdfSxnZXRUb3BvbG9neVN1bW1hcnk6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDtyZXR1cm4gdGhpcy5pc0VuZFBvaW50KCkmJnQuYXBwZW5kKFwiIGVuZHBvaW50XCIpLHRoaXMuX2lzUHJvcGVyJiZ0LmFwcGVuZChcIiBwcm9wZXJcIiksdGhpcy5pc0NvbGxpbmVhcigpJiZ0LmFwcGVuZChcIiBjb2xsaW5lYXJcIiksdC50b1N0cmluZygpfSxjb21wdXRlSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3RoaXMuaW5wdXRMaW5lc1swXVswXT10LHRoaXMuaW5wdXRMaW5lc1swXVsxXT1lLHRoaXMuaW5wdXRMaW5lc1sxXVswXT1uLHRoaXMuaW5wdXRMaW5lc1sxXVsxXT1pLHRoaXMucmVzdWx0PXRoaXMuY29tcHV0ZUludGVyc2VjdCh0LGUsbixpKX0sZ2V0SW50ZXJzZWN0aW9uTnVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzdWx0fSxjb21wdXRlSW50TGluZUluZGV4OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbnVsbD09PXRoaXMuaW50TGluZUluZGV4JiYodGhpcy5pbnRMaW5lSW5kZXg9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgyKX0pLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMCksbj10aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDEpO2U+bj8odGhpcy5pbnRMaW5lSW5kZXhbdF1bMF09MCx0aGlzLmludExpbmVJbmRleFt0XVsxXT0xKToodGhpcy5pbnRMaW5lSW5kZXhbdF1bMF09MSx0aGlzLmludExpbmVJbmRleFt0XVsxXT0wKX19LGlzUHJvcGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2lzUHJvcGVyfSxzZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLnByZWNpc2lvbk1vZGVsPXR9LGlzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4hIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigwKXx8ISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5yZXN1bHQ7ZSsrKWlmKCF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVswXSkmJiF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fSxnZXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW50UHRbdF19LGlzRW5kUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQhPT1vZS5OT19JTlRFUlNFQ1RJT059LGdldEVkZ2VEaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBuPW9lLmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5pbnRQdFtlXSx0aGlzLmlucHV0TGluZXNbdF1bMF0sdGhpcy5pbnB1dExpbmVzW3RdWzFdKTtyZXR1cm4gbn0saXNDb2xsaW5lYXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQ9PT1vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzFdWzBdLHRoaXMuaW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX0sZ2V0RW5kcG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5pbnB1dExpbmVzW3RdW2VdfSxpc0ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMucmVzdWx0O2UrKylpZih0aGlzLmludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfSxnZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRQdFt0aGlzLmludExpbmVJbmRleFt0XVtlXV19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfX0pLG9lLmNvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPU1hdGguYWJzKG4ueC1lLngpLHI9TWF0aC5hYnMobi55LWUueSkscz0tMTtpZih0LmVxdWFscyhlKSlzPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlzPWk+cj9pOnI7ZWxzZXt2YXIgbz1NYXRoLmFicyh0LngtZS54KSxhPU1hdGguYWJzKHQueS1lLnkpO3M9aT5yP286YSwwIT09c3x8dC5lcXVhbHMoZSl8fChzPU1hdGgubWF4KG8sYSkpfXJldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHN9LG9lLm5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9TWF0aC5zcXJ0KGkqaStyKnIpO3JldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxzfSxvZS5ET05UX0lOVEVSU0VDVD0wLG9lLkRPX0lOVEVSU0VDVD0xLG9lLkNPTExJTkVBUj0yLG9lLk5PX0lOVEVSU0VDVElPTj0wLG9lLlBPSU5UX0lOVEVSU0VDVElPTj0xLG9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MixoKGFlLG9lKSxlKGFlLnByb3RvdHlwZSx7aXNJblNlZ21lbnRFbnZlbG9wZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEModGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSksbj1uZXcgQyh0aGlzLmlucHV0TGluZXNbMV1bMF0sdGhpcy5pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX0sY29tcHV0ZUludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDMhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBvZS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLl9pc1Byb3Blcj0hMSxDLmludGVyc2VjdHMoZSxuLHQpJiYwPT09aGUub3JpZW50YXRpb25JbmRleChlLG4sdCkmJjA9PT1oZS5vcmllbnRhdGlvbkluZGV4KG4sZSx0KT8odGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5yZXN1bHQ9b2UuUE9JTlRfSU5URVJTRUNUSU9OLG51bGwpOnZvaWQodGhpcy5yZXN1bHQ9b2UuTk9fSU5URVJTRUNUSU9OKX0sbm9ybWFsaXplVG9NaW5pbXVtOmZ1bmN0aW9uKHQsZSxuLGkscil7ci54PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueCxlLngsbi54LGkueCksci55PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueSxlLnksbi55LGkueSksdC54LT1yLngsdC55LT1yLnksZS54LT1yLngsZS55LT1yLnksbi54LT1yLngsbi55LT1yLnksaS54LT1yLngsaS55LT1yLnl9LHNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3RyeXtyPUYuaW50ZXJzZWN0aW9uKHQsZSxuLGkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIHcpKXRocm93IHM7cj1hZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSl9ZmluYWxseXt9cmV0dXJuIHJ9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHQsZSxuLGkpO3JldHVybiB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHIpfHwocj1uZXcgZyhhZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSkpKSxudWxsIT09dGhpcy5wcmVjaXNpb25Nb2RlbCYmdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShyKSxyfSxzbWFsbGVzdEluQWJzVmFsdWU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPU1hdGguYWJzKHIpO3JldHVybiBNYXRoLmFicyhlKTxzJiYocj1lLHM9TWF0aC5hYnMoZSkpLE1hdGguYWJzKG4pPHMmJihyPW4scz1NYXRoLmFicyhuKSksTWF0aC5hYnMoaSk8cyYmKHI9aSkscn0sY2hlY2tERDpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPU0uaW50ZXJzZWN0aW9uKHQsZSxuLGkpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhzKTtBLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3MpLHIuZGlzdGFuY2Uocyk+MWUtNCYmQS5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIrci5kaXN0YW5jZShzKSl9LGludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBnKHQpLHM9bmV3IGcoZSksbz1uZXcgZyhuKSxhPW5ldyBnKGkpLHU9bmV3IGc7dGhpcy5ub3JtYWxpemVUb0VudkNlbnRyZShyLHMsbyxhLHUpO3ZhciBsPXRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpO3JldHVybiBsLngrPXUueCxsLnkrPXUueSxsfSxjb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPUMuaW50ZXJzZWN0cyh0LGUsbikscz1DLmludGVyc2VjdHModCxlLGkpLG89Qy5pbnRlcnNlY3RzKG4saSx0KSxhPUMuaW50ZXJzZWN0cyhuLGksZSk7cmV0dXJuIHImJnM/KHRoaXMuaW50UHRbMF09bix0aGlzLmludFB0WzFdPWksb2UuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmYT8odGhpcy5pbnRQdFswXT10LHRoaXMuaW50UHRbMV09ZSxvZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLmludFB0WzBdPW4sdGhpcy5pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8c3x8YT9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6ciYmYT8odGhpcy5pbnRQdFswXT1uLHRoaXMuaW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHN8fG8/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOnMmJm8/KHRoaXMuaW50UHRbMF09aSx0aGlzLmludFB0WzFdPXQsIWkuZXF1YWxzKHQpfHxyfHxhP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpzJiZhPyh0aGlzLmludFB0WzBdPWksdGhpcy5pbnRQdFsxXT1lLCFpLmVxdWFscyhlKXx8cnx8bz9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6b2UuTk9fSU5URVJTRUNUSU9OfSxub3JtYWxpemVUb0VudkNlbnRyZTpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPXQueDxlLng/dC54OmUueCxvPXQueTxlLnk/dC55OmUueSxhPXQueD5lLng/dC54OmUueCx1PXQueT5lLnk/dC55OmUueSxsPW4ueDxpLng/bi54OmkueCxoPW4ueTxpLnk/bi55OmkueSxjPW4ueD5pLng/bi54OmkueCxmPW4ueT5pLnk/bi55OmkueSxnPXM+bD9zOmwsZD1hPGM/YTpjLHA9bz5oP286aCx2PXU8Zj91OmYsbT0oZytkKS8yLHk9KHArdikvMjtyLng9bSxyLnk9eSx0LngtPXIueCx0LnktPXIueSxlLngtPXIueCxlLnktPXIueSxuLngtPXIueCxuLnktPXIueSxpLngtPXIueCxpLnktPXIueX0sY29tcHV0ZUludGVyc2VjdDpmdW5jdGlvbih0LGUsbixpKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXJldHVybiBvZS5OT19JTlRFUlNFQ1RJT047dmFyIHI9aGUub3JpZW50YXRpb25JbmRleCh0LGUsbikscz1oZS5vcmllbnRhdGlvbkluZGV4KHQsZSxpKTtpZihyPjAmJnM+MHx8cjwwJiZzPDApcmV0dXJuIG9lLk5PX0lOVEVSU0VDVElPTjt2YXIgbz1oZS5vcmllbnRhdGlvbkluZGV4KG4saSx0KSxhPWhlLm9yaWVudGF0aW9uSW5kZXgobixpLGUpO2lmKG8+MCYmYT4wfHxvPDAmJmE8MClyZXR1cm4gb2UuTk9fSU5URVJTRUNUSU9OO3ZhciB1PTA9PT1yJiYwPT09cyYmMD09PW8mJjA9PT1hO3JldHVybiB1P3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixpKTooMD09PXJ8fDA9PT1zfHwwPT09b3x8MD09PWE/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT1lOjA9PT1yP3RoaXMuaW50UHRbMF09bmV3IGcobik6MD09PXM/dGhpcy5pbnRQdFswXT1uZXcgZyhpKTowPT09bz90aGlzLmludFB0WzBdPW5ldyBnKHQpOjA9PT1hJiYodGhpcy5pbnRQdFswXT1uZXcgZyhlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLmludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLGkpKSxvZS5QT0lOVF9JTlRFUlNFQ1RJT04pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhZX19KSxhZS5uZWFyZXN0RW5kcG9pbnQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsbixpKSxvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKTtyZXR1cm4gbzxzJiYocz1vLHI9ZSksbz1oZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSksbzxzJiYocz1vLHI9biksbz1oZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSksbzxzJiYocz1vLHI9aSkscn0sZSh1ZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVlfX0pLHVlLm9yaWVudGF0aW9uSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9bi54LWUueCxvPW4ueS1lLnk7cmV0dXJuIHVlLnNpZ25PZkRldDJ4MihpLHIscyxvKX0sdWUuc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW51bGwscz1udWxsLG89bnVsbCxhPTA7aWYocj0xLDA9PT10fHwwPT09aSlyZXR1cm4gMD09PWV8fDA9PT1uPzA6ZT4wP24+MD8tcjpyOm4+MD9yOi1yO2lmKDA9PT1lfHwwPT09bilyZXR1cm4gaT4wP3Q+MD9yOi1yOnQ+MD8tcjpyO2lmKDA8ZT8wPGk/ZTw9aXx8KHI9LXIscz10LHQ9bixuPXMscz1lLGU9aSxpPXMpOmU8PS1pPyhyPS1yLG49LW4saT0taSk6KHM9dCx0PS1uLG49cyxzPWUsZT0taSxpPXMpOjA8aT8tZTw9aT8ocj0tcix0PS10LGU9LWUpOihzPS10LHQ9bixuPXMscz0tZSxlPWksaT1zKTplPj1pPyh0PS10LGU9LWUsbj0tbixpPS1pKToocj0tcixzPS10LHQ9LW4sbj1zLHM9LWUsZT0taSxpPXMpLDA8dCl7aWYoISgwPG4pKXJldHVybiByO2lmKCEodDw9bikpcmV0dXJuIHJ9ZWxzZXtpZigwPG4pcmV0dXJuLXI7aWYoISh0Pj1uKSlyZXR1cm4tcjtyPS1yLHQ9LXQsbj0tbn1mb3IoOzspe2lmKGErPTEsbz1NYXRoLmZsb29yKG4vdCksbi09byp0LGktPW8qZSxpPDApcmV0dXJuLXI7aWYoaT5lKXJldHVybiByO2lmKHQ+bituKXtpZihlPGkraSlyZXR1cm4gcn1lbHNle2lmKGU+aStpKXJldHVybi1yO249dC1uLGk9ZS1pLHI9LXJ9aWYoMD09PWkpcmV0dXJuIDA9PT1uPzA6LXI7aWYoMD09PW4pcmV0dXJuIHI7aWYobz1NYXRoLmZsb29yKHQvbiksdC09bypuLGUtPW8qaSxlPDApcmV0dXJuIHI7aWYoZT5pKXJldHVybi1yO2lmKG4+dCt0KXtpZihpPGUrZSlyZXR1cm4tcn1lbHNle2lmKGk+ZStlKXJldHVybiByO3Q9bi10LGU9aS1lLHI9LXJ9aWYoMD09PWUpcmV0dXJuIDA9PT10PzA6cjtpZigwPT09dClyZXR1cm4tcn19LGUobGUucHJvdG90eXBlLHtjb3VudFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZih0Lng8dGhpcy5wLngmJmUueDx0aGlzLnAueClyZXR1cm4gbnVsbDtpZih0aGlzLnAueD09PWUueCYmdGhpcy5wLnk9PT1lLnkpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMucC55JiZlLnk9PT10aGlzLnAueSl7dmFyIG49dC54LGk9ZS54O3JldHVybiBuPmkmJihuPWUueCxpPXQueCksdGhpcy5wLng+PW4mJnRoaXMucC54PD1pJiYodGhpcy5pc1BvaW50T25TZWdtZW50PSEwKSxudWxsfWlmKHQueT50aGlzLnAueSYmZS55PD10aGlzLnAueXx8ZS55PnRoaXMucC55JiZ0Lnk8PXRoaXMucC55KXt2YXIgcj10LngtdGhpcy5wLngscz10LnktdGhpcy5wLnksbz1lLngtdGhpcy5wLngsYT1lLnktdGhpcy5wLnksdT11ZS5zaWduT2ZEZXQyeDIocixzLG8sYSk7aWYoMD09PXUpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2E8cyYmKHU9LXUpLHU+MCYmdGhpcy5jcm9zc2luZ0NvdW50Kyt9fSxpc1BvaW50SW5Qb2x5Z29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PUwuRVhURVJJT1J9LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD9MLkJPVU5EQVJZOnRoaXMuY3Jvc3NpbmdDb3VudCUyPT09MT9MLklOVEVSSU9SOkwuRVhURVJJT1J9LGlzT25TZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbGV9fSksbGUubG9jYXRlUG9pbnRJblJpbmc9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlIoYXJndW1lbnRzWzFdLEQpKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlKHQpLGk9bmV3IGcscj1uZXcgZyxzPTE7czxlLnNpemUoKTtzKyspaWYoZS5nZXRDb29yZGluYXRlKHMsaSksZS5nZXRDb29yZGluYXRlKHMtMSxyKSxuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpO3JldHVybiBuLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLG49bmV3IGxlKG8pLHM9MTtzPGEubGVuZ3RoO3MrKyl7dmFyIGk9YVtzXSxyPWFbcy0xXTtpZihuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpfXJldHVybiBuLmdldExvY2F0aW9uKCl9fSxlKGhlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGV9fSksaGUub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE0ub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLnNpZ25lZEFyZWE9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtmb3IodmFyIGU9MCxuPXRbMF0ueCxpPTE7aTx0Lmxlbmd0aC0xO2krKyl7dmFyIHI9dFtpXS54LW4scz10W2krMV0ueSxvPXRbaS0xXS55O2UrPXIqKG8tcyl9cmV0dXJuIGUvMn1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YS5zaXplKCk7aWYodTwzKXJldHVybiAwO3ZhciBsPW5ldyBnLGg9bmV3IGcsYz1uZXcgZzthLmdldENvb3JkaW5hdGUoMCxoKSxhLmdldENvb3JkaW5hdGUoMSxjKTt2YXIgbj1oLng7Yy54LT1uO2Zvcih2YXIgZT0wLGk9MTtpPHUtMTtpKyspbC55PWgueSxoLng9Yy54LGgueT1jLnksYS5nZXRDb29yZGluYXRlKGkrMSxjKSxjLngtPW4sZSs9aC54KihsLnktYy55KTtyZXR1cm4gZS8yfX0saGUuZGlzdGFuY2VMaW5lTGluZT1mdW5jdGlvbih0LGUsbixpKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpO2lmKG4uZXF1YWxzKGkpKXJldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSk7dmFyIHI9ITE7aWYoQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXt2YXIgcz0oZS54LXQueCkqKGkueS1uLnkpLShlLnktdC55KSooaS54LW4ueCk7aWYoMD09PXMpcj0hMDtlbHNle3ZhciBvPSh0Lnktbi55KSooaS54LW4ueCktKHQueC1uLngpKihpLnktbi55KSxhPSh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSx1PWEvcyxsPW8vczsobDwwfHxsPjF8fHU8MHx8dT4xKSYmKHI9ITApfX1lbHNlIHI9ITA7cmV0dXJuIHI/VC5taW4oaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpLGhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKSxoZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSksaGUuZGlzdGFuY2VQb2ludExpbmUoaSx0LGUpKTowfSxoZS5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSkhPT1MLkVYVEVSSU9SfSxoZS5jb21wdXRlTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc2l6ZSgpO2lmKGU8PTEpcmV0dXJuIDA7dmFyIG49MCxpPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLGkpO2Zvcih2YXIgcj1pLngscz1pLnksbz0xO288ZTtvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLGkpO3ZhciBhPWkueCx1PWkueSxsPWEtcixoPXUtcztuKz1NYXRoLnNxcnQobCpsK2gqaCkscj1hLHM9dX1yZXR1cm4gbn0saGUuaXNDQ1c9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGgtMTtpZihlPDMpdGhyb3cgbmV3IGkoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtmb3IodmFyIG49dFswXSxyPTAscz0xO3M8PWU7cysrKXt2YXIgbz10W3NdO28ueT5uLnkmJihuPW8scj1zKX12YXIgYT1yO2RvIGEtPTEsYTwwJiYoYT1lKTt3aGlsZSh0W2FdLmVxdWFsczJEKG4pJiZhIT09cik7dmFyIHU9cjtkbyB1PSh1KzEpJWU7d2hpbGUodFt1XS5lcXVhbHMyRChuKSYmdSE9PXIpO3ZhciBsPXRbYV0saD10W3VdO2lmKGwuZXF1YWxzMkQobil8fGguZXF1YWxzMkQobil8fGwuZXF1YWxzMkQoaCkpcmV0dXJuITE7dmFyIGM9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGwsbixoKSxmPSExO3JldHVybiBmPTA9PT1jP2wueD5oLng6Yz4wfSxoZS5sb2NhdGVQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBsZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfSxoZS5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXI9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxyPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL2k7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChpKX0saGUuY29tcHV0ZU9yaWVudGF0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGUub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLmRpc3RhbmNlUG9pbnRMaW5lPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IGkoXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2Zvcih2YXIgbj10LmRpc3RhbmNlKGVbMF0pLHI9MDtyPGUubGVuZ3RoLTE7cisrKXt2YXIgcz1oZS5kaXN0YW5jZVBvaW50TGluZSh0LGVbcl0sZVtyKzFdKTtzPG4mJihuPXMpfXJldHVybiBufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl07aWYoYS54PT09dS54JiZhLnk9PT11LnkpcmV0dXJuIG8uZGlzdGFuY2UoYSk7dmFyIGw9KHUueC1hLngpKih1LngtYS54KSsodS55LWEueSkqKHUueS1hLnkpLGg9KChvLngtYS54KSoodS54LWEueCkrKG8ueS1hLnkpKih1LnktYS55KSkvbDtpZihoPD0wKXJldHVybiBvLmRpc3RhbmNlKGEpO2lmKGg+PTEpcmV0dXJuIG8uZGlzdGFuY2UodSk7dmFyIGM9KChhLnktby55KSoodS54LWEueCktKGEueC1vLngpKih1LnktYS55KSkvbDtyZXR1cm4gTWF0aC5hYnMoYykqTWF0aC5zcXJ0KGwpfX0saGUuaXNPbkxpbmU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGFlLGk9MTtpPGUubGVuZ3RoO2krKyl7dmFyIHI9ZVtpLTFdLHM9ZVtpXTtpZihuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxyLHMpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITB9cmV0dXJuITF9LGhlLkNMT0NLV0lTRT0tMSxoZS5SSUdIVD1oZS5DTE9DS1dJU0UsaGUuQ09VTlRFUkNMT0NLV0lTRT0xLGhlLkxFRlQ9aGUuQ09VTlRFUkNMT0NLV0lTRSxoZS5DT0xMSU5FQVI9MCxoZS5TVFJBSUdIVD1oZS5DT0xMSU5FQVIsZShjZS5wcm90b3R5cGUse21pblg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9LG9yaWVudGF0aW9uSW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1oZS5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAwKSxuPWhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDEpO3JldHVybiBlPj0wJiZuPj0wP01hdGgubWF4KGUsbik6ZTw9MCYmbjw9MD9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07cmV0dXJuIGhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLGkpfX0sdG9HZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLHRoaXMucDFdKX0saXNWZXJ0aWNhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBjZSkpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5wMC5lcXVhbHMoZS5wMCkmJnRoaXMucDEuZXF1YWxzKGUucDEpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFlO3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfSxwcm9qZWN0OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgZyh0KTt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgZztyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDApLHM9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDEpO2lmKHI+PTEmJnM+PTEpcmV0dXJuIG51bGw7aWYocjw9MCYmczw9MClyZXR1cm4gbnVsbDt2YXIgbz10aGlzLnByb2plY3QoaS5wMCk7cjwwJiYobz10aGlzLnAwKSxyPjEmJihvPXRoaXMucDEpO3ZhciBhPXRoaXMucHJvamVjdChpLnAxKTtyZXR1cm4gczwwJiYoYT10aGlzLnAwKSxzPjEmJihhPXRoaXMucDEpLG5ldyBjZShvLGEpfX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9LGFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dGhpcy5wMDp0aGlzLnAxfSxkaXN0YW5jZVBlcnBlbmRpY3VsYXI6ZnVuY3Rpb24odCl7cmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9LG1pblk6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LHRoaXMucDEueSl9LG1pZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIGNlLm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9LHByb2plY3Rpb25GYWN0b3I6ZnVuY3Rpb24odCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7dmFyIGU9dGhpcy5wMS54LXRoaXMucDAueCxuPXRoaXMucDEueS10aGlzLnAwLnksaT1lKmUrbipuO2lmKGk8PTApcmV0dXJuIHIuTmFOO3ZhciBzPSgodC54LXRoaXMucDAueCkqZSsodC55LXRoaXMucDAueSkqbikvaTtyZXR1cm4gc30sY2xvc2VzdFBvaW50czpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTt2YXIgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxpPXIuTUFYX1ZBTFVFLHM9bnVsbCxvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO2k9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO3ZhciBhPXRoaXMuY2xvc2VzdFBvaW50KHQucDEpO3M9YS5kaXN0YW5jZSh0LnAxKSxzPGkmJihpPXMsblswXT1hLG5bMV09dC5wMSk7dmFyIHU9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7cz11LmRpc3RhbmNlKHRoaXMucDApLHM8aSYmKGk9cyxuWzBdPXRoaXMucDAsblsxXT11KTt2YXIgbD10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gcz1sLmRpc3RhbmNlKHRoaXMucDEpLHM8aSYmKGk9cyxuWzBdPXRoaXMucDEsblsxXT1sKSxufSxjbG9zZXN0UG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO2lmKGU+MCYmZTwxKXJldHVybiB0aGlzLnByb2plY3QodCk7dmFyIG49dGhpcy5wMC5kaXN0YW5jZSh0KSxpPXRoaXMucDEuZGlzdGFuY2UodCk7cmV0dXJuIG48aT90aGlzLnAwOnRoaXMucDF9LG1heFg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fSxlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX0sbGluZUludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt0cnl7dmFyIGU9Ri5pbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSk7cmV0dXJuIGV9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgdykpdGhyb3cgdH1maW5hbGx5e31yZXR1cm4gbnVsbH0sbWF4WTpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLnksdGhpcy5wMS55KX0scG9pbnRBbG9uZ09mZnNldDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxpPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxyPXRoaXMucDEueC10aGlzLnAwLngscz10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KHIqcitzKnMpLGE9MCx1PTA7aWYoMCE9PWUpe2lmKG88PTApdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTthPWUqci9vLHU9ZSpzL299dmFyIGw9bi11LGg9aSthLGM9bmV3IGcobCxoKTtyZXR1cm4gY30sc2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wMC54PWUueCx0aGlzLnAwLnk9ZS55LHRoaXMucDEueD1uLngsdGhpcy5wMS55PW4ueX19LHNlZ21lbnRGcmFjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIGU8MD9lPTA6KGU+MXx8ci5pc05hTihlKSkmJihlPTEpLGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifSxpc0hvcml6b250YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VMaW5lTGluZSh0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUoZSx0aGlzLnAwLHRoaXMucDEpfX0scG9pbnRBbG9uZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZztyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7dmFyIGU9TWF0aC50cnVuYyh0KV5NYXRoLnRydW5jKHQ+PjMyKSxuPWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO25ePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpO3ZhciBpPU1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMik7cmV0dXJuIGVeaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY2V9fSksY2UubWlkUG9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IGcoKHQueCtlLngpLzIsKHQueStlLnkpLzIpfSxjZS5zZXJpYWxWZXJzaW9uVUlEPTB4MmQyMTcyMTM1ZjQxMWMwMCxlKGZlLnByb3RvdHlwZSx7aXNJbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNEaXNqb2ludCgpfSxpc0NvdmVyczpmdW5jdGlvbigpe3ZhciB0PWZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSk7cmV0dXJuIHQmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ292ZXJlZEJ5OmZ1bmN0aW9uKCl7dmFyIHQ9ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldKTtyZXR1cm4gdCYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRX0sc2V0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPU1hdGgudHJ1bmMoZS8zKSxpPWUlMzt0aGlzLm1hdHJpeFtuXVtpXT1sdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5tYXRyaXhbcl1bc109b319LGlzQ29udGFpbnM6ZnVuY3Rpb24oKXtyZXR1cm4gZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sc2V0QXRMZWFzdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj1NYXRoLnRydW5jKGUvMyksaT1lJTM7dGhpcy5zZXRBdExlYXN0KG4saSxsdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMubWF0cml4W3JdW3NdPG8mJih0aGlzLm1hdHJpeFtyXVtzXT1vKX19LHNldEF0TGVhc3RJZlZhbGlkOmZ1bmN0aW9uKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfSxpc1dpdGhpbjpmdW5jdGlvbigpe3JldHVybiBmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFfSxpc1RvdWNoZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6KHQ9PT1sdC5BJiZlPT09bHQuQXx8dD09PWx0LkwmJmU9PT1sdC5MfHx0PT09bHQuTCYmZT09PWx0LkF8fHQ9PT1sdC5QJiZlPT09bHQuQXx8dD09PWx0LlAmJmU9PT1sdC5MKSYmKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJihmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV0pKSl9LGlzT3ZlcmxhcHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWx0LlAmJmU9PT1sdC5QfHx0PT09bHQuQSYmZT09PWx0LkE/ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdKTp0PT09bHQuTCYmZT09PWx0LkwmJigxPT09dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0mJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSkpfSxpc0VxdWFsczpmdW5jdGlvbih0LGUpe3JldHVybiB0PT09ZSYmKGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0UpfSx0b1N0cmluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgUChcIjEyMzQ1Njc4OVwiKSxlPTA7ZTwzO2UrKylmb3IodmFyIG49MDtuPDM7bisrKXQuc2V0Q2hhckF0KDMqZStuLGx0LnRvRGltZW5zaW9uU3ltYm9sKHRoaXMubWF0cml4W2VdW25dKSk7cmV0dXJuIHQudG9TdHJpbmcoKX0sc2V0QWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8MztlKyspZm9yKHZhciBuPTA7bjwzO24rKyl0aGlzLm1hdHJpeFtlXVtuXT10fSxnZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5tYXRyaXhbdF1bZV19LHRyYW5zcG9zZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWF0cml4WzFdWzBdO3JldHVybiB0aGlzLm1hdHJpeFsxXVswXT10aGlzLm1hdHJpeFswXVsxXSx0aGlzLm1hdHJpeFswXVsxXT10LHQ9dGhpcy5tYXRyaXhbMl1bMF0sdGhpcy5tYXRyaXhbMl1bMF09dGhpcy5tYXRyaXhbMF1bMl0sdGhpcy5tYXRyaXhbMF1bMl09dCx0PXRoaXMubWF0cml4WzJdWzFdLHRoaXMubWF0cml4WzJdWzFdPXRoaXMubWF0cml4WzFdWzJdLHRoaXMubWF0cml4WzFdWzJdPXQsdGhpc30sbWF0Y2hlczpmdW5jdGlvbih0KXtpZig5IT09dC5sZW5ndGgpdGhyb3cgbmV3IGkoXCJTaG91bGQgYmUgbGVuZ3RoIDk6IFwiK3QpO2Zvcih2YXIgZT0wO2U8MztlKyspZm9yKHZhciBuPTA7bjwzO24rKylpZighZmUubWF0Y2hlcyh0aGlzLm1hdHJpeFtlXVtuXSx0LmNoYXJBdCgzKmUrbikpKXJldHVybiExO3JldHVybiEwfSxhZGQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTwzO2UrKylmb3IodmFyIG49MDtuPDM7bisrKXRoaXMuc2V0QXRMZWFzdChlLG4sdC5nZXQoZSxuKSl9LGlzRGlzam9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0saXNDcm9zc2VzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1sdC5QJiZlPT09bHQuTHx8dD09PWx0LlAmJmU9PT1sdC5BfHx0PT09bHQuTCYmZT09PWx0LkE/ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKTp0PT09bHQuTCYmZT09PWx0LlB8fHQ9PT1sdC5BJiZlPT09bHQuUHx8dD09PWx0LkEmJmU9PT1sdC5MP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5MJiYwPT09dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmZX19KSxmZS5tYXRjaGVzPWZ1bmN0aW9uKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT1sdC5TWU1fRE9OVENBUkV8fChlPT09bHQuU1lNX1RSVUUmJih0Pj0wfHx0PT09bHQuVFJVRSl8fChlPT09bHQuU1lNX0ZBTFNFJiZ0PT09bHQuRkFMU0V8fChlPT09bHQuU1lNX1AmJnQ9PT1sdC5QfHwoZT09PWx0LlNZTV9MJiZ0PT09bHQuTHx8ZT09PWx0LlNZTV9BJiZ0PT09bHQuQSkpKSl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bmV3IGZlKG4pO3JldHVybiByLm1hdGNoZXMoaSl9fSxmZS5pc1RydWU9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTB8fHQ9PT1sdC5UUlVFfTt2YXIgbG89T2JqZWN0LmZyZWV6ZSh7Q29vcmRpbmF0ZTpnLENvb3JkaW5hdGVMaXN0Ok4sRW52ZWxvcGU6QyxMaW5lU2VnbWVudDpjZSxHZW9tZXRyeUZhY3Rvcnk6aWUsR2VvbWV0cnk6QixQb2ludDpMdCxMaW5lU3RyaW5nOlN0LExpbmVhclJpbmc6YnQsUG9seWdvbjpUdCxHZW9tZXRyeUNvbGxlY3Rpb246ZnQsTXVsdGlQb2ludDpQdCxNdWx0aUxpbmVTdHJpbmc6Z3QsTXVsdGlQb2x5Z29uOk90LERpbWVuc2lvbjpsdCxJbnRlcnNlY3Rpb25NYXRyaXg6ZmUsUHJlY2lzaW9uTW9kZWw6ZWV9KTtlKGdlLnByb3RvdHlwZSx7YWRkUG9pbnQ6ZnVuY3Rpb24odCl7dGhpcy5wdENvdW50Kz0xLHRoaXMucHRDZW50U3VtLngrPXQueCx0aGlzLnB0Q2VudFN1bS55Kz10Lnl9LHNldEJhc2VQb2ludDpmdW5jdGlvbih0KXtudWxsPT09dGhpcy5hcmVhQmFzZVB0JiYodGhpcy5hcmVhQmFzZVB0PXQpfSxhZGRMaW5lU2VnbWVudHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGgtMTtuKyspe3ZhciBpPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtpZigwIT09aSl7ZSs9aTt2YXIgcj0odFtuXS54K3RbbisxXS54KS8yO3RoaXMubGluZUNlbnRTdW0ueCs9aSpyO3ZhciBzPSh0W25dLnkrdFtuKzFdLnkpLzI7dGhpcy5saW5lQ2VudFN1bS55Kz1pKnN9fXRoaXMudG90YWxMZW5ndGgrPWUsMD09PWUmJnQubGVuZ3RoPjAmJnRoaXMuYWRkUG9pbnQodFswXSl9LGFkZEhvbGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWhlLmlzQ0NXKHQpLG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfSxnZXRDZW50cm9pZDpmdW5jdGlvbigpe3ZhciB0PW5ldyBnO2lmKE1hdGguYWJzKHRoaXMuYXJlYXN1bTIpPjApdC54PXRoaXMuY2czLngvMy90aGlzLmFyZWFzdW0yLHQueT10aGlzLmNnMy55LzMvdGhpcy5hcmVhc3VtMjtlbHNlIGlmKHRoaXMudG90YWxMZW5ndGg+MCl0Lng9dGhpcy5saW5lQ2VudFN1bS54L3RoaXMudG90YWxMZW5ndGgsdC55PXRoaXMubGluZUNlbnRTdW0ueS90aGlzLnRvdGFsTGVuZ3RoO2Vsc2V7aWYoISh0aGlzLnB0Q291bnQ+MCkpcmV0dXJuIG51bGw7dC54PXRoaXMucHRDZW50U3VtLngvdGhpcy5wdENvdW50LHQueT10aGlzLnB0Q2VudFN1bS55L3RoaXMucHRDb3VudH1yZXR1cm4gdH0sYWRkU2hlbGw6ZnVuY3Rpb24odCl7dC5sZW5ndGg+MCYmdGhpcy5zZXRCYXNlUG9pbnQodFswXSk7Zm9yKHZhciBlPSFoZS5pc0NDVyh0KSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX0sYWRkVHJpYW5nbGU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9aT8xOi0xO2dlLmNlbnRyb2lkMyh0LGUsbix0aGlzLnRyaWFuZ2xlQ2VudDMpO3ZhciBzPWdlLmFyZWEyKHQsZSxuKTt0aGlzLmNnMy54Kz1yKnMqdGhpcy50cmlhbmdsZUNlbnQzLngsdGhpcy5jZzMueSs9cipzKnRoaXMudHJpYW5nbGVDZW50My55LHRoaXMuYXJlYXN1bTIrPXIqc30sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkU2hlbGwodC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuYWRkSG9sZSh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBuPWFyZ3VtZW50c1swXTtpZihuLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZihuIGluc3RhbmNlb2YgTHQpdGhpcy5hZGRQb2ludChuLmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZihuIGluc3RhbmNlb2YgU3QpdGhpcy5hZGRMaW5lU2VnbWVudHMobi5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBUdCl7dmFyIGk9bjt0aGlzLmFkZChpKX1lbHNlIGlmKG4gaW5zdGFuY2VvZiBmdClmb3IodmFyIHI9bixlPTA7ZTxyLmdldE51bUdlb21ldHJpZXMoKTtlKyspdGhpcy5hZGQoci5nZXRHZW9tZXRyeU4oZSkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ2V9fSksZ2UuYXJlYTI9ZnVuY3Rpb24odCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKG4ueC10LngpKihlLnktdC55KX0sZ2UuY2VudHJvaWQzPWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiBpLng9dC54K2UueCtuLngsaS55PXQueStlLnkrbi55LG51bGx9LGdlLmdldENlbnRyb2lkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBnZSh0KTtyZXR1cm4gZS5nZXRDZW50cm9pZCgpfSxkZS5wcm90b3R5cGU9bmV3IEVycm9yLGRlLnByb3RvdHlwZS5uYW1lPVwiRW1wdHlTdGFja0V4Y2VwdGlvblwiLHBlLnByb3RvdHlwZT1uZXcgeSxwZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxwZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb247cmV0dXJuIHRoaXMuYXJyYXlfW3RdfSxwZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSx0fSxwZS5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IGRlO3JldHVybiB0aGlzLmFycmF5Xy5wb3AoKX0scGUucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5hcnJheV8ubGVuZ3RoKXRocm93IG5ldyBkZTtyZXR1cm4gdGhpcy5hcnJheV9bdGhpcy5hcnJheV8ubGVuZ3RoLTFdfSxwZS5wcm90b3R5cGUuZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0scGUucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbXB0eSgpfSxwZS5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5pbmRleE9mKHQpfSxwZS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LHBlLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LGUodmUucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dGhpcy50cmVlU2V0LmNvbnRhaW5zKHQpfHwodGhpcy5saXN0LmFkZCh0KSx0aGlzLnRyZWVTZXQuYWRkKHQpKX0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkodGhpcy5saXN0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5saXN0LnRvQXJyYXkodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3pdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2ZX19KSx2ZS5maWx0ZXJDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IHZlLG49MDtuPHQubGVuZ3RoO24rKyllLmZpbHRlcih0W25dKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlcygpfSxlKG1lLnByb3RvdHlwZSx7cHJlU29ydDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPTE7bjx0Lmxlbmd0aDtuKyspKHRbbl0ueTx0WzBdLnl8fHRbbl0ueT09PXRbMF0ueSYmdFtuXS54PHRbMF0ueCkmJihlPXRbMF0sdFswXT10W25dLHRbbl09ZSk7cmV0dXJuIHV0LnNvcnQodCwxLHQubGVuZ3RoLG5ldyB5ZSh0WzBdKSksdH0sY29tcHV0ZU9jdFJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb21wdXRlT2N0UHRzKHQpLG49bmV3IE47cmV0dXJuIG4uYWRkKGUsITEpLG4uc2l6ZSgpPDM/bnVsbDoobi5jbG9zZVJpbmcoKSxuLnRvQ29vcmRpbmF0ZUFycmF5KCkpfSxsaW5lT3JQb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHQ9dGhpcy5jbGVhblJpbmcodCksMz09PXQubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW3RbMF0sdFsxXV0pO3ZhciBlPXRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVQb2x5Z29uKGUsbnVsbCl9LGNsZWFuUmluZzpmdW5jdGlvbih0KXtmLmVxdWFscyh0WzBdLHRbdC5sZW5ndGgtMV0pO2Zvcih2YXIgZT1uZXcgSSxuPW51bGwsaT0wO2k8PXQubGVuZ3RoLTI7aSsrKXt2YXIgcj10W2ldLHM9dFtpKzFdO3IuZXF1YWxzKHMpfHxudWxsIT09biYmdGhpcy5pc0JldHdlZW4obixyLHMpfHwoZS5hZGQociksbj1yKX1lLmFkZCh0W3QubGVuZ3RoLTFdKTt2YXIgbz1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIGUudG9BcnJheShvKX0saXNCZXR3ZWVuOmZ1bmN0aW9uKHQsZSxuKXtpZigwIT09aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQsZSxuKSlyZXR1cm4hMTtpZih0LnghPT1uLngpe2lmKHQueDw9ZS54JiZlLng8PW4ueClyZXR1cm4hMDtpZihuLng8PWUueCYmZS54PD10LngpcmV0dXJuITB9aWYodC55IT09bi55KXtpZih0Lnk8PWUueSYmZS55PD1uLnkpcmV0dXJuITA7aWYobi55PD1lLnkmJmUueTw9dC55KXJldHVybiEwfXJldHVybiExfSxyZWR1Y2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb21wdXRlT2N0UmluZyh0KTtpZihudWxsPT09ZSlyZXR1cm4gdDtmb3IodmFyIG49bmV3IGF0LGk9MDtpPGUubGVuZ3RoO2krKyluLmFkZChlW2ldKTtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyloZS5pc1BvaW50SW5SaW5nKHRbaV0sZSl8fG4uYWRkKHRbaV0pO3ZhciByPUgudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHIubGVuZ3RoPDM/dGhpcy5wYWRBcnJheTMocik6cn0sZ2V0Q29udmV4SHVsbDpmdW5jdGlvbigpe2lmKDA9PT10aGlzLmlucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCk7aWYoMT09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuaW5wdXRQdHNbMF0pO2lmKDI9PT10aGlzLmlucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuaW5wdXRQdHMpO3ZhciB0PXRoaXMuaW5wdXRQdHM7dGhpcy5pbnB1dFB0cy5sZW5ndGg+NTAmJih0PXRoaXMucmVkdWNlKHRoaXMuaW5wdXRQdHMpKTt2YXIgZT10aGlzLnByZVNvcnQodCksbj10aGlzLmdyYWhhbVNjYW4oZSksaT10aGlzLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiB0aGlzLmxpbmVPclBvbHlnb24oaSl9LHBhZEFycmF5MzpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKW48dC5sZW5ndGg/ZVtuXT10W25dOmVbbl09dFswXTtyZXR1cm4gZX0sY29tcHV0ZU9jdFB0czpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDgpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dFswXTtmb3IodmFyIGk9MTtpPHQubGVuZ3RoO2krKyl0W2ldLng8ZVswXS54JiYoZVswXT10W2ldKSx0W2ldLngtdFtpXS55PGVbMV0ueC1lWzFdLnkmJihlWzFdPXRbaV0pLHRbaV0ueT5lWzJdLnkmJihlWzJdPXRbaV0pLHRbaV0ueCt0W2ldLnk+ZVszXS54K2VbM10ueSYmKGVbM109dFtpXSksdFtpXS54PmVbNF0ueCYmKGVbNF09dFtpXSksdFtpXS54LXRbaV0ueT5lWzVdLngtZVs1XS55JiYoZVs1XT10W2ldKSx0W2ldLnk8ZVs2XS55JiYoZVs2XT10W2ldKSx0W2ldLngrdFtpXS55PGVbN10ueCtlWzddLnkmJihlWzddPXRbaV0pO3JldHVybiBlfSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPHQuc2l6ZSgpO24rKyl7dmFyIGk9dC5nZXQobik7ZVtuXT1pfXJldHVybiBlfSxncmFoYW1TY2FuOmZ1bmN0aW9uKHQpe3ZhciBlPW51bGwsbj1uZXcgcGU7ZT1uLnB1c2godFswXSksZT1uLnB1c2godFsxXSksZT1uLnB1c2godFsyXSk7Zm9yKHZhciBpPTM7aTx0Lmxlbmd0aDtpKyspe2ZvcihlPW4ucG9wKCk7IW4uZW1wdHkoKSYmaGUuY29tcHV0ZU9yaWVudGF0aW9uKG4ucGVlaygpLGUsdFtpXSk+MDspZT1uLnBvcCgpO2U9bi5wdXNoKGUpLGU9bi5wdXNoKHRbaV0pO1xufXJldHVybiBlPW4ucHVzaCh0WzBdKSxufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtZX19KSxtZS5leHRyYWN0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHZlO3JldHVybiB0LmFwcGx5KGUpLGUuZ2V0Q29vcmRpbmF0ZXMoKX0sZSh5ZS5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4geWUucG9sYXJDb21wYXJlKHRoaXMub3JpZ2luLG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5ZX19KSx5ZS5wb2xhckNvbXBhcmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9bi54LXQueCxvPW4ueS10LnksYT1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pO2lmKGE9PT1oZS5DT1VOVEVSQ0xPQ0tXSVNFKXJldHVybiAxO2lmKGE9PT1oZS5DTE9DS1dJU0UpcmV0dXJuLTE7dmFyIHU9aSppK3IqcixsPXMqcytvKm87cmV0dXJuIHU8bD8tMTp1Pmw/MTowfSxtZS5SYWRpYWxDb21wYXJhdG9yPXllLGUoeGUucHJvdG90eXBlLHt0cmFuc2Zvcm1Qb2ludDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX0sdHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPSEwLGk9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksdCk7bnVsbCE9PWkmJmkgaW5zdGFuY2VvZiBidCYmIWkuaXNFbXB0eSgpfHwobj0hMSk7Zm9yKHZhciByPW5ldyBJLHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRJbnRlcmlvclJpbmdOKHMpLHQpO251bGw9PT1vfHxvLmlzRW1wdHkoKXx8KG8gaW5zdGFuY2VvZiBidHx8KG49ITEpLHIuYWRkKG8pKX1pZihuKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9seWdvbihpLHIudG9BcnJheShbXSkpO3ZhciBhPW5ldyBJO3JldHVybiBudWxsIT09aSYmYS5hZGQoaSksYS5hZGRBbGwociksdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkoYSl9LGNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCl9LGdldElucHV0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnB1dEdlb219LHRyYW5zZm9ybU11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LmdldEdlb21ldHJ5TihpKSx0KTtudWxsIT09ciYmKHIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvcHkodCl9LHRyYW5zZm9ybUxpbmVTdHJpbmc6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX0sdHJhbnNmb3JtTXVsdGlQb2ludDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtUG9pbnQodC5nZXRHZW9tZXRyeU4oaSksdCk7bnVsbCE9PXImJihyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sdHJhbnNmb3JtTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQuZ2V0R2VvbWV0cnlOKGkpLHQpO251bGwhPT1yJiYoci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LGNvcHk6ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29weSgpfSx0cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybSh0LmdldEdlb21ldHJ5TihpKSk7bnVsbCE9PXImJih0aGlzLnBydW5lRW1wdHlHZW9tZXRyeSYmci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU/dGhpcy5mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkobikpOnRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSx0cmFuc2Zvcm06ZnVuY3Rpb24odCl7aWYodGhpcy5pbnB1dEdlb209dCx0aGlzLmZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdCBpbnN0YW5jZW9mIEx0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFB0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgYnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGd0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIE90KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBmdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxudWxsKTt0aHJvdyBuZXcgaShcIlVua25vd24gR2VvbWV0cnkgc3VidHlwZTogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSl9LHRyYW5zZm9ybUxpbmVhclJpbmc6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCk7aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG51bGwpO3ZhciBpPW4uc2l6ZSgpO3JldHVybiBpPjAmJmk8NCYmIXRoaXMucHJlc2VydmVUeXBlP3RoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pOnRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4ZX19KSxlKEVlLnByb3RvdHlwZSx7c25hcFZlcnRpY2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX2lzQ2xvc2VkP3Quc2l6ZSgpLTE6dC5zaXplKCksaT0wO2k8bjtpKyspe3ZhciByPXQuZ2V0KGkpLHM9dGhpcy5maW5kU25hcEZvclZlcnRleChyLGUpO251bGwhPT1zJiYodC5zZXQoaSxuZXcgZyhzKSksMD09PWkmJnRoaXMuX2lzQ2xvc2VkJiZ0LnNldCh0LnNpemUoKS0xLG5ldyBnKHMpKSl9fSxmaW5kU25hcEZvclZlcnRleDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXtpZih0LmVxdWFsczJEKGVbbl0pKXJldHVybiBudWxsO2lmKHQuZGlzdGFuY2UoZVtuXSk8dGhpcy5zbmFwVG9sZXJhbmNlKXJldHVybiBlW25dfXJldHVybiBudWxsfSxzbmFwVG86ZnVuY3Rpb24odCl7dmFyIGU9bmV3IE4odGhpcy5zcmNQdHMpO3RoaXMuc25hcFZlcnRpY2VzKGUsdCksdGhpcy5zbmFwU2VnbWVudHMoZSx0KTt2YXIgbj1lLnRvQ29vcmRpbmF0ZUFycmF5KCk7cmV0dXJuIG59LHNuYXBTZWdtZW50czpmdW5jdGlvbih0LGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgbj1lLmxlbmd0aDtlWzBdLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pJiYobj1lLmxlbmd0aC0xKTtmb3IodmFyIGk9MDtpPG47aSsrKXt2YXIgcj1lW2ldLHM9dGhpcy5maW5kU2VnbWVudEluZGV4VG9TbmFwKHIsdCk7cz49MCYmdC5hZGQocysxLG5ldyBnKHIpLCExKX19LGZpbmRTZWdtZW50SW5kZXhUb1NuYXA6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ci5NQVhfVkFMVUUsaT0tMSxzPTA7czxlLnNpemUoKS0xO3MrKyl7aWYodGhpcy5zZWcucDA9ZS5nZXQocyksdGhpcy5zZWcucDE9ZS5nZXQocysxKSx0aGlzLnNlZy5wMC5lcXVhbHMyRCh0KXx8dGhpcy5zZWcucDEuZXF1YWxzMkQodCkpe2lmKHRoaXMuYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpY29udGludWU7cmV0dXJuLTF9dmFyIG89dGhpcy5zZWcuZGlzdGFuY2UodCk7bzx0aGlzLnNuYXBUb2xlcmFuY2UmJm88biYmKG49byxpPXMpfXJldHVybiBpfSxzZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlczpmdW5jdGlvbih0KXt0aGlzLmFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVlfX0pLEVlLmlzQ2xvc2VkPWZ1bmN0aW9uKHQpe3JldHVybiEodC5sZW5ndGg8PTEpJiZ0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfSxlKEllLnByb3RvdHlwZSx7c25hcFRvOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCksaT1uZXcgTmUoZSxuKTtyZXR1cm4gaS50cmFuc2Zvcm0odGhpcy5zcmNHZW9tKX0sc25hcFRvU2VsZjpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHRoaXMuc3JjR2VvbSksaT1uZXcgTmUodCxuLCghMCkpLHI9aS50cmFuc2Zvcm0odGhpcy5zcmNHZW9tKSxzPXI7cmV0dXJuIGUmJlIocyxSdCkmJihzPXIuYnVmZmVyKDApKSxzfSxjb21wdXRlU25hcFRvbGVyYW5jZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCh0KSxuPWUvMTA7cmV0dXJuIG59LGV4dHJhY3RUYXJnZXRDb29yZGluYXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGF0LG49dC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoO2krKyllLmFkZChuW2ldKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX0sY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1yLk1BWF9WQUxVRSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2k8ZSYmKGU9aSl9cmV0dXJuIGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEllfX0pLEllLnNuYXA9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHI9bmV3IEllKHQpO2lbMF09ci5zbmFwVG8oZSxuKTt2YXIgcz1uZXcgSWUoZSk7cmV0dXJuIGlbMV09cy5zbmFwVG8oaVswXSxuKSxpfSxJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2U9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9SWUuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UodCksbj10LmdldFByZWNpc2lvbk1vZGVsKCk7aWYobi5nZXRUeXBlKCk9PT1lZS5GSVhFRCl7dmFyIGk9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTtpPmUmJihlPWkpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07cmV0dXJuIE1hdGgubWluKEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShyKSxJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UocykpfX0sSWUuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2U9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj1NYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSksaT1uKkllLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUjtyZXR1cm4gaX0sSWUuc25hcFRvU2VsZj1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEllKHQpO3JldHVybiBpLnNuYXBUb1NlbGYoZSxuKX0sSWUuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTksaChOZSx4ZSksZShOZS5wcm90b3R5cGUse3NuYXBMaW5lOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEVlKHQsdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbi5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0aGlzLmlzU2VsZlNuYXApLG4uc25hcFRvKGUpfSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPXRoaXMuc25hcExpbmUobix0aGlzLnNuYXBQdHMpO3JldHVybiB0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTmV9fSksZShDZS5wcm90b3R5cGUse2dldENvbW1vbjpmdW5jdGlvbigpe3JldHVybiByLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5jb21tb25CaXRzKX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXIuZG91YmxlVG9Mb25nQml0cyh0KTtpZih0aGlzLmlzRmlyc3QpcmV0dXJuIHRoaXMuY29tbW9uQml0cz1lLHRoaXMuY29tbW9uU2lnbkV4cD1DZS5zaWduRXhwQml0cyh0aGlzLmNvbW1vbkJpdHMpLHRoaXMuaXNGaXJzdD0hMSxudWxsO3ZhciBuPUNlLnNpZ25FeHBCaXRzKGUpO3JldHVybiBuIT09dGhpcy5jb21tb25TaWduRXhwPyh0aGlzLmNvbW1vbkJpdHM9MCxudWxsKToodGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudD1DZS5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuY29tbW9uQml0cyxlKSx2b2lkKHRoaXMuY29tbW9uQml0cz1DZS56ZXJvTG93ZXJCaXRzKHRoaXMuY29tbW9uQml0cyw2NC0oMTIrdGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudCkpKSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXIubG9uZ0JpdHNUb0RvdWJsZSh0KSxuPUxvbmcudG9CaW5hcnlTdHJpbmcodCksaT1cIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIituLHM9aS5zdWJzdHJpbmcoaS5sZW5ndGgtNjQpLG89cy5zdWJzdHJpbmcoMCwxKStcIiAgXCIrcy5zdWJzdHJpbmcoMSwxMikrXCIoZXhwKSBcIitzLnN1YnN0cmluZygxMikrXCIgWyBcIitlK1wiIF1cIjtyZXR1cm4gb319LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENlfX0pLENlLmdldEJpdD1mdW5jdGlvbih0LGUpe3ZhciBuPTE8PGU7cmV0dXJuIDAhPT0odCZuKT8xOjB9LENlLnNpZ25FeHBCaXRzPWZ1bmN0aW9uKHQpe3JldHVybiB0Pj41Mn0sQ2UuemVyb0xvd2VyQml0cz1mdW5jdGlvbih0LGUpe3ZhciBuPSgxPDxlKS0xLGk9fm4scj10Jmk7cmV0dXJuIHJ9LENlLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPTUyO2k+PTA7aS0tKXtpZihDZS5nZXRCaXQodCxpKSE9PUNlLmdldEJpdChlLGkpKXJldHVybiBuO24rK31yZXR1cm4gNTJ9LGUoU2UucHJvdG90eXBlLHthZGRDb21tb25CaXRzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBMZSh0aGlzLmNvbW1vbkNvb3JkKTt0LmFwcGx5KGUpLHQuZ2VvbWV0cnlDaGFuZ2VkKCl9LHJlbW92ZUNvbW1vbkJpdHM6ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuY29tbW9uQ29vcmQueCYmMD09PXRoaXMuY29tbW9uQ29vcmQueSlyZXR1cm4gdDt2YXIgZT1uZXcgZyh0aGlzLmNvbW1vbkNvb3JkKTtlLng9LWUueCxlLnk9LWUueTt2YXIgbj1uZXcgTGUoZSk7cmV0dXJuIHQuYXBwbHkobiksdC5nZW9tZXRyeUNoYW5nZWQoKSx0fSxnZXRDb21tb25Db29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tbW9uQ29vcmR9LGFkZDpmdW5jdGlvbih0KXt0LmFwcGx5KHRoaXMuY2NGaWx0ZXIpLHRoaXMuY29tbW9uQ29vcmQ9dGhpcy5jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNlfX0pLGUod2UucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dGhpcy5jb21tb25CaXRzWC5hZGQodC54KSx0aGlzLmNvbW1vbkJpdHNZLmFkZCh0LnkpfSxnZXRDb21tb25Db29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKHRoaXMuY29tbW9uQml0c1guZ2V0Q29tbW9uKCksdGhpcy5jb21tb25CaXRzWS5nZXRDb21tb24oKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3pdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3ZX19KSxlKExlLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRPcmRpbmF0ZShlLDApK3RoaXMudHJhbnMueCxpPXQuZ2V0T3JkaW5hdGUoZSwxKSt0aGlzLnRyYW5zLnk7dC5zZXRPcmRpbmF0ZShlLDAsbiksdC5zZXRPcmRpbmF0ZShlLDEsaSl9LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiExfSxpc0dlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltjdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExlfX0pLFNlLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXI9d2UsU2UuVHJhbnNsYXRlcj1MZSxlKFJlLnByb3RvdHlwZSx7bmV4dDpmdW5jdGlvbigpe2lmKHRoaXMuYXRTdGFydClyZXR1cm4gdGhpcy5hdFN0YXJ0PSExLFJlLmlzQXRvbWljKHRoaXMucGFyZW50KSYmdGhpcy5pbmRleCsrLHRoaXMucGFyZW50O2lmKG51bGwhPT10aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCk7dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1pZih0aGlzLmluZGV4Pj10aGlzLm1heCl0aHJvdyBuZXcgeDt2YXIgdD10aGlzLnBhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5pbmRleCsrKTtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0Pyh0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgUmUodCksdGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpKTp0fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9LGhhc05leHQ6ZnVuY3Rpb24oKXtpZih0aGlzLmF0U3RhcnQpcmV0dXJuITA7aWYobnVsbCE9PXRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuITA7dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbH1yZXR1cm4hKHRoaXMuaW5kZXg+PXRoaXMubWF4KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJlfX0pLFJlLmlzQXRvbWljPWZ1bmN0aW9uKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIGZ0KX0sZShUZS5wcm90b3R5cGUse2xvY2F0ZUludGVybmFsOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIEwuRVhURVJJT1I7dmFyIG49ZS5nZXRFeHRlcmlvclJpbmcoKSxpPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LG4pO2lmKGk9PT1MLkVYVEVSSU9SKXJldHVybiBMLkVYVEVSSU9SO2lmKGk9PT1MLkJPVU5EQVJZKXJldHVybiBMLkJPVU5EQVJZO2Zvcih2YXIgcj0wO3I8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe3ZhciBzPWUuZ2V0SW50ZXJpb3JSaW5nTihyKSxvPXRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyh0LHMpO2lmKG89PT1MLklOVEVSSU9SKXJldHVybiBMLkVYVEVSSU9SO2lmKG89PT1MLkJPVU5EQVJZKXJldHVybiBMLkJPVU5EQVJZfXJldHVybiBMLklOVEVSSU9SfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBTdCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdO2lmKCF1LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGEpKXJldHVybiBMLkVYVEVSSU9SO3ZhciBsPXUuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdS5pc0Nsb3NlZCgpfHwhYS5lcXVhbHMobFswXSkmJiFhLmVxdWFscyhsW2wubGVuZ3RoLTFdKT9oZS5pc09uTGluZShhLGwpP0wuSU5URVJJT1I6TC5FWFRFUklPUjpMLkJPVU5EQVJZfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBMdCl7dmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGY9Yy5nZXRDb29yZGluYXRlKCk7cmV0dXJuIGYuZXF1YWxzMkQoaCk/TC5JTlRFUklPUjpMLkVYVEVSSU9SfX0sbG9jYXRlSW5Qb2x5Z29uUmluZzpmdW5jdGlvbih0LGUpe3JldHVybiBlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2hlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTpMLkVYVEVSSU9SfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRlKHQsZSkhPT1MLkVYVEVSSU9SfSx1cGRhdGVMb2NhdGlvbkluZm86ZnVuY3Rpb24odCl7dD09PUwuSU5URVJJT1ImJih0aGlzLmlzSW49ITApLHQ9PT1MLkJPVU5EQVJZJiZ0aGlzLm51bUJvdW5kYXJpZXMrK30sY29tcHV0ZUxvY2F0aW9uOmZ1bmN0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIEx0JiZ0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpLGUgaW5zdGFuY2VvZiBTdCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFR0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgZ3QpZm9yKHZhciBuPWUsaT0wO2k8bi5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj1uLmdldEdlb21ldHJ5TihpKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQscikpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIE90KWZvcih2YXIgcz1lLGk9MDtpPHMuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIG89cy5nZXRHZW9tZXRyeU4oaSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LG8pKX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBmdClmb3IodmFyIGE9bmV3IFJlKGUpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCk7dSE9PWUmJnRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsdSl9fSxsb2NhdGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/TC5FWFRFUklPUjplIGluc3RhbmNlb2YgU3Q/dGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpOmUgaW5zdGFuY2VvZiBUdD90aGlzLmxvY2F0ZUludGVybmFsKHQsZSk6KHRoaXMuaXNJbj0hMSx0aGlzLm51bUJvdW5kYXJpZXM9MCx0aGlzLmNvbXB1dGVMb2NhdGlvbih0LGUpLHRoaXMuYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLm51bUJvdW5kYXJpZXMpP0wuQk9VTkRBUlk6dGhpcy5udW1Cb3VuZGFyaWVzPjB8fHRoaXMuaXNJbj9MLklOVEVSSU9SOkwuRVhURVJJT1IpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUZX19KSxlKFBlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUGV9fSksUGUub2N0YW50PWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO3ZhciBuPU1hdGguYWJzKHQpLHI9TWF0aC5hYnMoZSk7cmV0dXJuIHQ+PTA/ZT49MD9uPj1yPzA6MTpuPj1yPzc6NjplPj0wP24+PXI/MzoyOm4+PXI/NDo1fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1vLngtcy54LHU9by55LXMueTtpZigwPT09YSYmMD09PXUpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIitzKTtyZXR1cm4gUGUub2N0YW50KGEsdSl9fSxlKGJlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt9LHNpemU6ZnVuY3Rpb24oKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7fSxpc0Nsb3NlZDpmdW5jdGlvbigpe30sc2V0RGF0YTpmdW5jdGlvbih0KXt9LGdldERhdGE6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJlfX0pLGUoT2UucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzW3RdfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0U2VnbWVudE9jdGFudDpmdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXMucHRzLmxlbmd0aC0xPy0xOlBlLm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLnB0cykpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltiZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9lfX0pLGUoX2UucHJvdG90eXBlLHtnZXRCb3VuZHM6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9lfX0pLGUoTWUucHJvdG90eXBlLHtnZXRJdGVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTWV9fSksZShEZS5wcm90b3R5cGUse3BvbGw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLml0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5pdGVtcy5zZXQoMSx0aGlzLml0ZW1zLmdldCh0aGlzLl9zaXplKSksdGhpcy5fc2l6ZS09MSx0aGlzLnJlb3JkZXIoMSksdH0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaXplfSxyZW9yZGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dGhpcy5pdGVtcy5nZXQodCk7Mip0PD10aGlzLl9zaXplJiYoZT0yKnQsZSE9PXRoaXMuX3NpemUmJnRoaXMuaXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuaXRlbXMuZ2V0KGUpKTwwJiZlKyssdGhpcy5pdGVtcy5nZXQoZSkuY29tcGFyZVRvKG4pPDApO3Q9ZSl0aGlzLml0ZW1zLnNldCh0LHRoaXMuaXRlbXMuZ2V0KGUpKTt0aGlzLml0ZW1zLnNldCh0LG4pfSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuX3NpemU9MCx0aGlzLml0ZW1zLmNsZWFyKCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuX3NpemV9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZChudWxsKSx0aGlzLl9zaXplKz0xO3ZhciBlPXRoaXMuX3NpemU7Zm9yKHRoaXMuaXRlbXMuc2V0KDAsdCk7dC5jb21wYXJlVG8odGhpcy5pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuaXRlbXMuc2V0KGUsdGhpcy5pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk7dGhpcy5pdGVtcy5zZXQoZSx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRGV9fSksZShBZS5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFlfX0pLGUoRmUucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt9LHJlbW92ZTpmdW5jdGlvbih0LGUpe30scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXSxhcmd1bWVudHNbMV19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGZX19KSxlKEdlLnByb3RvdHlwZSx7Z2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlcy5zaXplKCl9LGdldENoaWxkQm91bmRhYmxlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlc30sYWRkQ2hpbGRCb3VuZGFibGU6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuYm91bmRzKSx0aGlzLmNoaWxkQm91bmRhYmxlcy5hZGQodCl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuYm91bmRzJiYodGhpcy5ib3VuZHM9dGhpcy5jb21wdXRlQm91bmRzKCkpLHRoaXMuYm91bmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR2V9fSksR2Uuc2VyaWFsVmVyc2lvblVJRD0weDVhMWU1NWVjNDEzNjk4MDA7dmFyIGhvPXtyZXZlcnNlT3JkZXI6ZnVuY3Rpb24oKXtyZXR1cm57Y29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBlLmNvbXBhcmVUbyh0KX19fSxtaW46ZnVuY3Rpb24odCl7cmV0dXJuIGhvLnNvcnQodCksdC5nZXQoMCl9LHNvcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQXJyYXkoKTtlP3V0LnNvcnQobixlKTp1dC5zb3J0KG4pO2Zvcih2YXIgaT10Lml0ZXJhdG9yKCkscj0wLHM9bi5sZW5ndGg7cjxzO3IrKylpLm5leHQoKSxpLnNldChuW3JdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSTtyZXR1cm4gZS5hZGQodCksZX19O2UocWUucHJvdG90eXBlLHtleHBhbmRUb1F1ZXVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49cWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUxKSxyPXFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMik7aWYobiYmcilyZXR1cm4gcWUuYXJlYSh0aGlzLmJvdW5kYWJsZTEpPnFlLmFyZWEodGhpcy5ib3VuZGFibGUyKT8odGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMix0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTIsdGhpcy5ib3VuZGFibGUxLHQsZSksbnVsbCk7aWYobilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMix0LGUpLG51bGw7aWYocilyZXR1cm4gdGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUyLHRoaXMuYm91bmRhYmxlMSx0LGUpLG51bGw7dGhyb3cgbmV3IGkoXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9LGlzTGVhdmVzOmZ1bmN0aW9uKCl7cmV0dXJuIShxZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTEpfHxxZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTIpKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlPGUuX2Rpc3RhbmNlPy0xOnRoaXMuX2Rpc3RhbmNlPmUuX2Rpc3RhbmNlPzE6MH0sZXhwYW5kOmZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj10LmdldENoaWxkQm91bmRhYmxlcygpLHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT1uZXcgcWUobyxlLHRoaXMuaXRlbURpc3RhbmNlKTthLmdldERpc3RhbmNlKCk8aSYmbi5hZGQoYSl9fSxnZXRCb3VuZGFibGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10P3RoaXMuYm91bmRhYmxlMTp0aGlzLmJvdW5kYWJsZTJ9LGdldERpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfSxkaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTGVhdmVzKCk/dGhpcy5pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5ib3VuZGFibGUxLHRoaXMuYm91bmRhYmxlMik6dGhpcy5ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuYm91bmRhYmxlMi5nZXRCb3VuZHMoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxZX19KSxxZS5hcmVhPWZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEJvdW5kcygpLmdldEFyZWEoKX0scWUuaXNDb21wb3NpdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBHZX0sZShCZS5wcm90b3R5cGUse2dldE5vZGVDYXBhY2l0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVDYXBhY2l0eX0sbGFzdE5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0KHQuc2l6ZSgpLTEpfSxzaXplOmZ1bmN0aW9uIHQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuc2l6ZSh0aGlzLnJvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSx0PTAsbj1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpIGluc3RhbmNlb2YgR2U/dCs9dGhpcy5zaXplKGkpOmkgaW5zdGFuY2VvZiBNZSYmKHQrPTEpfXJldHVybiB0fX0scmVtb3ZlSXRlbTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1udWxsLGk9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ciBpbnN0YW5jZW9mIE1lJiZyLmdldEl0ZW0oKT09PWUmJihuPXIpfXJldHVybiBudWxsIT09biYmKHQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG4pLCEwKX0saXRlbXNUcmVlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuYnVpbGQoKTt2YXIgdD10aGlzLml0ZW1zVHJlZSh0aGlzLnJvb3QpO3JldHVybiBudWxsPT09dD9uZXcgSTp0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49bmV3IEksaT1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtpZihyIGluc3RhbmNlb2YgR2Upe3ZhciBzPXRoaXMuaXRlbXNUcmVlKHIpO251bGwhPT1zJiZuLmFkZChzKX1lbHNlIHIgaW5zdGFuY2VvZiBNZT9uLmFkZChyLmdldEl0ZW0oKSk6Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBuLnNpemUoKTw9MD9udWxsOm59fSxpbnNlcnQ6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdGhpcy5idWlsdCxcIkNhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC5cIiksdGhpcy5pdGVtQm91bmRhYmxlcy5hZGQobmV3IE1lKHQsZSkpfSxib3VuZGFibGVzQXRMZXZlbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSTtyZXR1cm4gdGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LHRoaXMucm9vdCxlKSxlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07aWYoZi5pc1RydWUobj4tMiksaS5nZXRMZXZlbCgpPT09bilyZXR1cm4gci5hZGQoaSksbnVsbDtmb3IodmFyIHM9aS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7byBpbnN0YW5jZW9mIEdlP3RoaXMuYm91bmRhYmxlc0F0TGV2ZWwobixvLHIpOihmLmlzVHJ1ZShvIGluc3RhbmNlb2YgTWUpLG49PT0tMSYmci5hZGQobykpfXJldHVybiBudWxsfX0scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVpbGQoKTt2YXIgZT1uZXcgSTtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ZToodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeSh0LHRoaXMucm9vdCxlKSxlKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2lmKHRoaXMuYnVpbGQoKSx0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5yb290LmdldEJvdW5kcygpLG4pJiZ0aGlzLnF1ZXJ5KG4sdGhpcy5yb290LGkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoUihhcmd1bWVudHNbMl0sQWUpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSlmb3IodmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9cy5nZXRDaGlsZEJvdW5kYWJsZXMoKSx1PTA7dTxhLnNpemUoKTt1Kyspe3ZhciBsPWEuZ2V0KHUpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhsLmdldEJvdW5kcygpLHIpJiYobCBpbnN0YW5jZW9mIEdlP3RoaXMucXVlcnkocixsLG8pOmwgaW5zdGFuY2VvZiBNZT9vLnZpc2l0SXRlbShsLmdldEl0ZW0oKSk6Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSlmb3IodmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGE9Yy5nZXRDaGlsZEJvdW5kYWJsZXMoKSx1PTA7dTxhLnNpemUoKTt1Kyspe3ZhciBsPWEuZ2V0KHUpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhsLmdldEJvdW5kcygpLGgpJiYobCBpbnN0YW5jZW9mIEdlP3RoaXMucXVlcnkoaCxsLGcpOmwgaW5zdGFuY2VvZiBNZT9nLmFkZChsLmdldEl0ZW0oKSk6Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19LGJ1aWxkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbHQ/bnVsbDoodGhpcy5yb290PXRoaXMuaXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpP3RoaXMuY3JlYXRlTm9kZSgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyh0aGlzLml0ZW1Cb3VuZGFibGVzLC0xKSx0aGlzLml0ZW1Cb3VuZGFibGVzPW51bGwsdm9pZCh0aGlzLmJ1aWx0PSEwKSl9LGdldFJvb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsZCgpLHRoaXMucm9vdH0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5idWlsZCgpLCEhdGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5yZW1vdmUodCx0aGlzLnJvb3QsZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXSxzPXRoaXMucmVtb3ZlSXRlbShpLHIpO2lmKHMpcmV0dXJuITA7Zm9yKHZhciBvPW51bGwsYT1pLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKTtpZih0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModS5nZXRCb3VuZHMoKSxuKSYmdSBpbnN0YW5jZW9mIEdlJiYocz10aGlzLnJlbW92ZShuLHUscikpKXtvPXU7YnJlYWt9fXJldHVybiBudWxsIT09byYmby5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pc0VtcHR5KCkmJmkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG8pLHN9fSxjcmVhdGVIaWdoZXJMZXZlbHM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPXRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUrMSk7cmV0dXJuIDE9PT1uLnNpemUoKT9uLmdldCgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyhuLGUrMSl9LGRlcHRoOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLmRlcHRoKHRoaXMucm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MCxuPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkgaW5zdGFuY2VvZiBHZSl7dmFyIHI9dGhpcy5kZXB0aChpKTtyPmUmJihlPXIpfX1yZXR1cm4gZSsxfX0sY3JlYXRlUGFyZW50Qm91bmRhYmxlczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKCF0LmlzRW1wdHkoKSk7dmFyIG49bmV3IEk7bi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKTt2YXIgaT1uZXcgSSh0KTtoby5zb3J0KGksdGhpcy5nZXRDb21wYXJhdG9yKCkpO2Zvcih2YXIgcj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTt0aGlzLmxhc3ROb2RlKG4pLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKT09PXRoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkmJm4uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSksdGhpcy5sYXN0Tm9kZShuKS5hZGRDaGlsZEJvdW5kYWJsZShzKX1yZXR1cm4gbn0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWx0P3RoaXMucm9vdC5pc0VtcHR5KCk6dGhpcy5pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCZX19KSxCZS5jb21wYXJlRG91Ymxlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0PmU/MTp0PGU/LTE6MH0sQmUuSW50ZXJzZWN0c09wPXplLEJlLnNlcmlhbFZlcnNpb25VSUQ9LTB4MzVlZjY0YzgyZDRjNTQwMCxCZS5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTAsZShWZS5wcm90b3R5cGUse2Rpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWZX19KSxoKGtlLEJlKSxlKGtlLnByb3RvdHlwZSx7Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKHQubGVuZ3RoPjApO2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0Lmxlbmd0aDtpKyspbi5hZGRBbGwodGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodFtpXSxlKSk7cmV0dXJuIG59LGNyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBZZSh0KX0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9CZS5wcm90b3R5cGUuc2l6ZS5jYWxsKHRoaXMpOkJlLnByb3RvdHlwZS5zaXplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0saW5zZXJ0OmZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIEJlLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5pc051bGwoKT9udWxsOnZvaWQgQmUucHJvdG90eXBlLmluc2VydC5jYWxsKHRoaXMsdCxlKX0sZ2V0SW50ZXJzZWN0c09wOmZ1bmN0aW9uKCl7cmV0dXJuIGtlLmludGVyc2VjdHNPcH0sdmVydGljYWxTbGljZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvZSkpLGk9bmV3IEFycmF5KGUpLmZpbGwobnVsbCkscj10Lml0ZXJhdG9yKCkscz0wO3M8ZTtzKyspe2lbc109bmV3IEk7Zm9yKHZhciBvPTA7ci5oYXNOZXh0KCkmJm88bjspe3ZhciBhPXIubmV4dCgpO2lbc10uYWRkKGEpLG8rK319cmV0dXJuIGl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gQmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO0JlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsZSxuKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLEFlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2Upe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLGkscixzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdO0JlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsbyxhLHUpfX0sZ2V0Q29tcGFyYXRvcjpmdW5jdGlvbigpe3JldHVybiBrZS55Q29tcGFyYXRvcn0sY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEJlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcyx0LGUpfSxyZW1vdmU6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBCZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyx0LGUpfXJldHVybiBCZS5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/QmUucHJvdG90eXBlLmRlcHRoLmNhbGwodGhpcyk6QmUucHJvdG90eXBlLmRlcHRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY3JlYXRlUGFyZW50Qm91bmRhYmxlczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKCF0LmlzRW1wdHkoKSk7dmFyIG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpLGk9bmV3IEkodCk7aG8uc29ydChpLGtlLnhDb21wYXJhdG9yKTt2YXIgcj10aGlzLnZlcnRpY2FsU2xpY2VzKGksTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKSkpO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMocixlKX0sbmVhcmVzdE5laWdoYm91cjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSxWZSkpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBxZSh0aGlzLmdldFJvb3QoKSx0aGlzLmdldFJvb3QoKSx0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcWUpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKG4sci5QT1NJVElWRV9JTkZJTklUWSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga2UmJlIoYXJndW1lbnRzWzFdLFZlKSl7dmFyIGk9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLGU9bmV3IHFlKHRoaXMuZ2V0Um9vdCgpLGkuZ2V0Um9vdCgpLHMpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoZSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxZSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YSxsPW51bGwsaD1uZXcgRGU7Zm9yKGguYWRkKG8pOyFoLmlzRW1wdHkoKSYmdT4wOyl7dmFyIGM9aC5wb2xsKCksZj1jLmdldERpc3RhbmNlKCk7aWYoZj49dSlicmVhaztjLmlzTGVhdmVzKCk/KHU9ZixsPWMpOmMuZXhwYW5kVG9RdWV1ZShoLHUpfXJldHVybltsLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbC5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGc9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdLHY9bmV3IE1lKGcsZCksZT1uZXcgcWUodGhpcy5nZXRSb290KCksdixwKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpWzBdfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRmUsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtlfX0pLGtlLmNlbnRyZVg9ZnVuY3Rpb24odCl7cmV0dXJuIGtlLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSl9LGtlLmF2Zz1mdW5jdGlvbih0LGUpe3JldHVybih0K2UpLzJ9LGtlLmNlbnRyZVk9ZnVuY3Rpb24odCl7cmV0dXJuIGtlLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSl9LGgoWWUsR2UpLGUoWWUucHJvdG90eXBlLHtjb21wdXRlQm91bmRzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW51bGwsZT10aGlzLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtudWxsPT09dD90PW5ldyBDKG4uZ2V0Qm91bmRzKCkpOnQuZXhwYW5kVG9JbmNsdWRlKG4uZ2V0Qm91bmRzKCkpfXJldHVybiB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZZX19KSxrZS5TVFJ0cmVlTm9kZT1ZZSxrZS5zZXJpYWxWZXJzaW9uVUlEPTB4Mzk5MjBmN2Q1ZjI2MWUwLGtlLnhDb21wYXJhdG9yPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5jb21wYXJlRG91YmxlcyhrZS5jZW50cmVYKHQuZ2V0Qm91bmRzKCkpLGtlLmNlbnRyZVgoZS5nZXRCb3VuZHMoKSkpfX0sa2UueUNvbXBhcmF0b3I9e2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEJlLmNvbXBhcmVEb3VibGVzKGtlLmNlbnRyZVkodC5nZXRCb3VuZHMoKSksa2UuY2VudHJlWShlLmdldEJvdW5kcygpKSl9fSxrZS5pbnRlcnNlY3RzT3A9e2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0ludGVyc2VjdHNPcF19LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pbnRlcnNlY3RzKGUpfX0sa2UuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwLGUoVWUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVZX19KSxVZS5yZWxhdGl2ZVNpZ249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOjB9LFVlLmNvbXBhcmU9ZnVuY3Rpb24odCxlLG4pe2lmKGUuZXF1YWxzMkQobikpcmV0dXJuIDA7dmFyIGk9VWUucmVsYXRpdmVTaWduKGUueCxuLngpLHI9VWUucmVsYXRpdmVTaWduKGUueSxuLnkpO3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShpLHIpO2Nhc2UgMTpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKHIsaSk7Y2FzZSAyOnJldHVybiBVZS5jb21wYXJlVmFsdWUociwtaSk7Y2FzZSAzOnJldHVybiBVZS5jb21wYXJlVmFsdWUoLWkscik7Y2FzZSA0OnJldHVybiBVZS5jb21wYXJlVmFsdWUoLWksLXIpO2Nhc2UgNTpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1yLC1pKTtjYXNlIDY6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtcixpKTtjYXNlIDc6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShpLC1yKX1yZXR1cm4gZi5zaG91bGROZXZlclJlYWNoSGVyZShcImludmFsaWQgb2N0YW50IHZhbHVlXCIpLDB9LFVlLmNvbXBhcmVWYWx1ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0PDA/LTE6dD4wPzE6ZTwwPy0xOmU+MD8xOjB9LGUoWGUucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PGUuc2VnbWVudEluZGV4Py0xOnRoaXMuc2VnbWVudEluZGV4PmUuc2VnbWVudEluZGV4PzE6dGhpcy5jb29yZC5lcXVhbHMyRChlLmNvb3JkKT8wOlVlLmNvbXBhcmUodGhpcy5zZWdtZW50T2N0YW50LHRoaXMuY29vcmQsZS5jb29yZCl9LGlzRW5kUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmIXRoaXMuX2lzSW50ZXJpb3J8fHRoaXMuc2VnbWVudEluZGV4PT09dH0saXNJbnRlcmlvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0ludGVyaW9yfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWGV9fSksZShIZS5wcm90b3R5cGUse2dldFNwbGl0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgTjt0aGlzLmFkZEVuZHBvaW50cygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpO3RoaXMuYWRkRWRnZUNvb3JkaW5hdGVzKG4saSx0KSxuPWl9cmV0dXJuIHQudG9Db29yZGluYXRlQXJyYXkoKX0sYWRkQ29sbGFwc2VkTm9kZXM6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTt0aGlzLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyh0KSx0aGlzLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCkuaW50VmFsdWUoKTt0aGlzLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShuKSxuKX19LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0sZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlLnNpemUoKS0yO2UrKyl7dmFyIG49dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZSksaT0odGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZSsxKSx0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKzIpKTtuLmVxdWFsczJEKGkpJiZ0LmFkZChuZXcgYihlKzEpKX19LGFkZEVkZ2VDb29yZGluYXRlczpmdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMixyPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxzPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChyKTtzfHxpLS07bi5hZGQobmV3IGcodC5jb29yZCksITEpO2Zvcih2YXIgbz10LnNlZ21lbnRJbmRleCsxO288PWUuc2VnbWVudEluZGV4O28rKyluLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShvKSk7cyYmbi5hZGQobmV3IGcoZS5jb29yZCkpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sYWRkU3BsaXRFZGdlczpmdW5jdGlvbih0KXt0aGlzLmFkZEVuZHBvaW50cygpLHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpLG49ZS5uZXh0KCk7ZS5oYXNOZXh0KCk7KXt2YXIgaT1lLm5leHQoKSxyPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4saSk7dC5hZGQociksbj1pfX0sZmluZENvbGxhcHNlSW5kZXg6ZnVuY3Rpb24odCxlLG4pe2lmKCF0LmNvb3JkLmVxdWFsczJEKGUuY29vcmQpKXJldHVybiExO3ZhciBpPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4O3JldHVybiBlLmlzSW50ZXJpb3IoKXx8aS0tLDE9PT1pJiYoblswXT10LnNlZ21lbnRJbmRleCsxLCEwKX0sZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuaXRlcmF0b3IoKSxpPW4ubmV4dCgpO24uaGFzTmV4dCgpOyl7dmFyIHI9bi5uZXh0KCkscz10aGlzLmZpbmRDb2xsYXBzZUluZGV4KGkscixlKTtzJiZ0LmFkZChuZXcgYihlWzBdKSksaT1yfX0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2V9LGFkZEVuZHBvaW50czpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5zaXplKCktMTt0aGlzLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZSh0KSx0KX0sY3JlYXRlU3BsaXRFZGdlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMixpPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxyPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChpKTtyfHxuLS07dmFyIHM9bmV3IEFycmF5KG4pLmZpbGwobnVsbCksbz0wO3NbbysrXT1uZXcgZyh0LmNvb3JkKTtmb3IodmFyIGE9dC5zZWdtZW50SW5kZXgrMTthPD1lLnNlZ21lbnRJbmRleDthKyspc1tvKytdPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGEpO3JldHVybiByJiYoc1tvXT1uZXcgZyhlLmNvb3JkKSksbmV3IEtlKHMsdGhpcy5lZGdlLmdldERhdGEoKSl9LGFkZDpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBYZSh0aGlzLmVkZ2UsdCxlLHRoaXMuZWRnZS5nZXRTZWdtZW50T2N0YW50KGUpKSxpPXRoaXMubm9kZU1hcC5nZXQobik7cmV0dXJuIG51bGwhPT1pPyhmLmlzVHJ1ZShpLmNvb3JkLmVxdWFsczJEKHQpLFwiRm91bmQgZXF1YWwgbm9kZXMgd2l0aCBkaWZmZXJlbnQgY29vcmRpbmF0ZXNcIiksaSk6KHRoaXMubm9kZU1hcC5wdXQobixuKSxuKX0sY2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3M6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlLmdldENvb3JkaW5hdGVzKCksbj10LmdldCgwKSxpPW4uZ2V0Q29vcmRpbmF0ZSgwKTtpZighaS5lcXVhbHMyRChlWzBdKSl0aHJvdyBuZXcgbChcImJhZCBzcGxpdCBlZGdlIHN0YXJ0IHBvaW50IGF0IFwiK2kpO3ZhciByPXQuZ2V0KHQuc2l6ZSgpLTEpLHM9ci5nZXRDb29yZGluYXRlcygpLG89c1tzLmxlbmd0aC0xXTtpZighby5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSl0aHJvdyBuZXcgbChcImJhZCBzcGxpdCBlZGdlIGVuZCBwb2ludCBhdCBcIitvKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSGV9fSksZShXZS5wcm90b3R5cGUse25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuY3Vyck5vZGU/KHRoaXMuY3Vyck5vZGU9dGhpcy5uZXh0Tm9kZSx0aGlzLmN1cnJTZWdJbmRleD10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCx0aGlzLnJlYWROZXh0Tm9kZSgpLHRoaXMuY3Vyck5vZGUpOm51bGw9PT10aGlzLm5leHROb2RlP251bGw6dGhpcy5uZXh0Tm9kZS5zZWdtZW50SW5kZXg9PT10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleD8odGhpcy5jdXJyTm9kZT10aGlzLm5leHROb2RlLHRoaXMuY3VyclNlZ0luZGV4PXRoaXMuY3Vyck5vZGUuc2VnbWVudEluZGV4LHRoaXMucmVhZE5leHROb2RlKCksdGhpcy5jdXJyTm9kZSk6KHRoaXMubmV4dE5vZGUuc2VnbWVudEluZGV4PnRoaXMuY3Vyck5vZGUuc2VnbWVudEluZGV4LG51bGwpfSxyZW1vdmU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9LGhhc05leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMubmV4dE5vZGV9LHJlYWROZXh0Tm9kZTpmdW5jdGlvbigpe3RoaXMubm9kZUl0Lmhhc05leHQoKT90aGlzLm5leHROb2RlPXRoaXMubm9kZUl0Lm5leHQoKTp0aGlzLm5leHROb2RlPW51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3BdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXZX19KSxlKGplLnByb3RvdHlwZSx7YWRkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltiZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGplfX0pLGUoS2UucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzW3RdfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0U2VnbWVudE9jdGFudDpmdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXMucHRzLmxlbmd0aC0xPy0xOnRoaXMuc2FmZU9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxzYWZlT2N0YW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZXF1YWxzMkQoZSk/MDpQZS5vY3RhbnQodCxlKX0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGFkZEludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9KGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pLHM9bmV3IGcobi5nZXRJbnRlcnNlY3Rpb24ocikpO3RoaXMuYWRkSW50ZXJzZWN0aW9uKHMsaSl9fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IEd0KHRoaXMucHRzKSl9LGdldE5vZGVMaXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZUxpc3R9LGFkZEludGVyc2VjdGlvbk5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLGk9bisxO2lmKGk8dGhpcy5wdHMubGVuZ3RoKXt2YXIgcj10aGlzLnB0c1tpXTt0LmVxdWFsczJEKHIpJiYobj1pKX12YXIgcz10aGlzLm5vZGVMaXN0LmFkZCh0LG4pO3JldHVybiBzfSxhZGRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7aSsrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltqZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtlfX0pLEtlLmdldE5vZGVkU3Vic3RyaW5ncz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSTtyZXR1cm4gS2UuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bi5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7cy5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXMoaSl9fSxlKFplLnByb3RvdHlwZSx7b3ZlcmxhcDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5vdmVybGFwU2VnMSksXG5uLmdldExpbmVTZWdtZW50KGksdGhpcy5vdmVybGFwU2VnMiksdGhpcy5vdmVybGFwKHRoaXMub3ZlcmxhcFNlZzEsdGhpcy5vdmVybGFwU2VnMil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBaZX19KSxlKFFlLnByb3RvdHlwZSx7Z2V0TGluZVNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtlLnAwPXRoaXMucHRzW3RdLGUucDE9dGhpcy5wdHNbdCsxXX0sY29tcHV0ZVNlbGVjdDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLnB0c1tlXSxzPXRoaXMucHRzW25dO2lmKGkudGVtcEVudjEuaW5pdChyLHMpLG4tZT09PTEpcmV0dXJuIGkuc2VsZWN0KHRoaXMsZSksbnVsbDtpZighdC5pbnRlcnNlY3RzKGkudGVtcEVudjEpKXJldHVybiBudWxsO3ZhciBvPU1hdGgudHJ1bmMoKGUrbikvMik7ZTxvJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxlLG8saSksbzxuJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxvLG4saSl9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmVuZC10aGlzLnN0YXJ0KzEpLmZpbGwobnVsbCksZT0wLG49dGhpcy5zdGFydDtuPD10aGlzLmVuZDtuKyspdFtlKytdPXRoaXMucHRzW25dO3JldHVybiB0fSxjb21wdXRlT3ZlcmxhcHM6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHRoaXMuc3RhcnQsdGhpcy5lbmQsdCx0LnN0YXJ0LHQuZW5kLGUpfSxzZXRJZDpmdW5jdGlvbih0KXt0aGlzLmlkPXR9LHNlbGVjdDpmdW5jdGlvbih0LGUpe3RoaXMuY29tcHV0ZVNlbGVjdCh0LHRoaXMuc3RhcnQsdGhpcy5lbmQsZSl9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZW52KXt2YXIgdD10aGlzLnB0c1t0aGlzLnN0YXJ0XSxlPXRoaXMucHRzW3RoaXMuZW5kXTt0aGlzLmVudj1uZXcgQyh0LGUpfXJldHVybiB0aGlzLmVudn0sZ2V0RW5kSW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmR9LGdldFN0YXJ0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydH0sZ2V0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHR9LGdldElkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWR9LGNvbXB1dGVPdmVybGFwc0ludGVybmFsOmZ1bmN0aW9uKHQsZSxuLGkscixzKXt2YXIgbz10aGlzLnB0c1t0XSxhPXRoaXMucHRzW2VdLHU9bi5wdHNbaV0sbD1uLnB0c1tyXTtpZihlLXQ9PT0xJiZyLWk9PT0xKXJldHVybiBzLm92ZXJsYXAodGhpcyx0LG4saSksbnVsbDtpZihzLnRlbXBFbnYxLmluaXQobyxhKSxzLnRlbXBFbnYyLmluaXQodSxsKSwhcy50ZW1wRW52MS5pbnRlcnNlY3RzKHMudGVtcEVudjIpKXJldHVybiBudWxsO3ZhciBoPU1hdGgudHJ1bmMoKHQrZSkvMiksYz1NYXRoLnRydW5jKChpK3IpLzIpO3Q8aCYmKGk8YyYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0LGgsbixpLGMscyksYzxyJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHQsaCxuLGMscixzKSksaDxlJiYoaTxjJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKGgsZSxuLGksYyxzKSxjPHImJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoaCxlLG4sYyxyLHMpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUWV9fSksZShKZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEplfX0pLEplLmlzTm9ydGhlcm49ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1KZS5ORXx8dD09PUplLk5XfSxKZS5pc09wcG9zaXRlPWZ1bmN0aW9uKHQsZSl7aWYodD09PWUpcmV0dXJuITE7dmFyIG49KHQtZSs0KSU0O3JldHVybiAyPT09bn0sSmUuY29tbW9uSGFsZlBsYW5lPWZ1bmN0aW9uKHQsZSl7aWYodD09PWUpcmV0dXJuIHQ7dmFyIG49KHQtZSs0KSU0O2lmKDI9PT1uKXJldHVybi0xO3ZhciBpPXQ8ZT90OmUscj10PmU/dDplO3JldHVybiAwPT09aSYmMz09PXI/MzppfSxKZS5pc0luSGFsZlBsYW5lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU9PT1KZS5TRT90PT09SmUuU0V8fHQ9PT1KZS5TVzp0PT09ZXx8dD09PWUrMX0sSmUucXVhZHJhbnQ9ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBpKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtyZXR1cm4gdD49MD9lPj0wP0plLk5FOkplLlNFOmU+PTA/SmUuTlc6SmUuU1d9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtpZihyLng9PT1uLngmJnIueT09PW4ueSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrbik7cmV0dXJuIHIueD49bi54P3IueT49bi55P0plLk5FOkplLlNFOnIueT49bi55P0plLk5XOkplLlNXfX0sSmUuTkU9MCxKZS5OVz0xLEplLlNXPTIsSmUuU0U9MyxlKCRlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJGV9fSksJGUuZ2V0Q2hhaW5TdGFydEluZGljZXM9ZnVuY3Rpb24odCl7dmFyIGU9MCxuPW5ldyBJO24uYWRkKG5ldyBiKGUpKTtkb3t2YXIgaT0kZS5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChuZXcgYihpKSksZT1pfXdoaWxlKGU8dC5sZW5ndGgtMSk7dmFyIHI9JGUudG9JbnRBcnJheShuKTtyZXR1cm4gcn0sJGUuZmluZENoYWluRW5kPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWU7bjx0Lmxlbmd0aC0xJiZ0W25dLmVxdWFsczJEKHRbbisxXSk7KW4rKztpZihuPj10Lmxlbmd0aC0xKXJldHVybiB0Lmxlbmd0aC0xO2Zvcih2YXIgaT1KZS5xdWFkcmFudCh0W25dLHRbbisxXSkscj1lKzE7cjx0Lmxlbmd0aDspe2lmKCF0W3ItMV0uZXF1YWxzMkQodFtyXSkpe3ZhciBzPUplLnF1YWRyYW50KHRbci0xXSx0W3JdKTtpZihzIT09aSlicmVha31yKyt9cmV0dXJuIHItMX0sJGUuZ2V0Q2hhaW5zPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gJGUuZ2V0Q2hhaW5zKHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uZXcgSSxyPSRlLmdldENoYWluU3RhcnRJbmRpY2VzKGUpLHM9MDtzPHIubGVuZ3RoLTE7cysrKXt2YXIgbz1uZXcgUWUoZSxyW3NdLHJbcysxXSxuKTtpLmFkZChvKX1yZXR1cm4gaX19LCRlLnRvSW50QXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfSxlKHRuLnByb3RvdHlwZSx7Y29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe30sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB0bn19KSxlKGVuLnByb3RvdHlwZSx7c2V0U2VnbWVudEludGVyc2VjdG9yOmZ1bmN0aW9uKHQpe3RoaXMuc2VnSW50PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3RuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZW59fSksaChubixlbiksZShubi5wcm90b3R5cGUse2dldE1vbm90b25lQ2hhaW5zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9ub0NoYWluc30sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLm5vZGVkU2VnU3RyaW5ncyl9LGdldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5kZXh9LGFkZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9JGUuZ2V0Q2hhaW5zKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0SWQodGhpcy5pZENvdW50ZXIrKyksdGhpcy5pbmRleC5pbnNlcnQoaS5nZXRFbnZlbG9wZSgpLGkpLHRoaXMubW9ub0NoYWlucy5hZGQoaSl9fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dGhpcy5ub2RlZFNlZ1N0cmluZ3M9dDtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7dGhpcy5pbnRlcnNlY3RDaGFpbnMoKX0saW50ZXJzZWN0Q2hhaW5zOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBybih0aGlzLnNlZ0ludCksZT10aGlzLm1vbm9DaGFpbnMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9dGhpcy5pbmRleC5xdWVyeShuLmdldEVudmVsb3BlKCkpLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYocy5nZXRJZCgpPm4uZ2V0SWQoKSYmKG4uY29tcHV0ZU92ZXJsYXBzKHMsdCksdGhpcy5uT3ZlcmxhcHMrKyksdGhpcy5zZWdJbnQuaXNEb25lKCkpcmV0dXJuIG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBubn19KSxoKHJuLFplKSxlKHJuLnByb3RvdHlwZSx7b3ZlcmxhcDpmdW5jdGlvbigpe2lmKDQhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBaZS5wcm90b3R5cGUub3ZlcmxhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdLHI9dC5nZXRDb250ZXh0KCkscz1uLmdldENvbnRleHQoKTt0aGlzLnNpLnByb2Nlc3NJbnRlcnNlY3Rpb25zKHIsZSxzLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBybn19KSxubi5TZWdtZW50T3ZlcmxhcEFjdGlvbj1ybixoKHNuLGwpLGUoc24ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNufX0pLHNuLm1zZ1dpdGhDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH0sZShvbi5wcm90b3R5cGUse3Byb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe30saXNEb25lOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvbn19KSxlKGFuLnByb3RvdHlwZSx7Z2V0SW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0sc2V0Q2hlY2tFbmRTZWdtZW50c09ubHk6ZnVuY3Rpb24odCl7dGhpcy5pc0NoZWNrRW5kU2VnbWVudHNPbmx5PXR9LGdldEludGVyc2VjdGlvblNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50U2VnbWVudHN9LGNvdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uQ291bnR9LGdldEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25zfSxzZXRGaW5kQWxsSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9LHNldEtlZXBJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQpe3RoaXMua2VlcEludGVyc2VjdGlvbnM9dH0scHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYoIXRoaXMuZmluZEFsbEludGVyc2VjdGlvbnMmJnRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIG51bGw7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO2lmKHRoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seSl7dmFyIHI9dGhpcy5pc0VuZFNlZ21lbnQodCxlKXx8dGhpcy5pc0VuZFNlZ21lbnQobixpKTtpZighcilyZXR1cm4gbnVsbH12YXIgcz10LmdldENvb3JkaW5hdGVzKClbZV0sbz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSx1PW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihzLG8sYSx1KSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMuaW50U2VnbWVudHM9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5pbnRTZWdtZW50c1swXT1zLHRoaXMuaW50U2VnbWVudHNbMV09byx0aGlzLmludFNlZ21lbnRzWzJdPWEsdGhpcy5pbnRTZWdtZW50c1szXT11LHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb249dGhpcy5saS5nZXRJbnRlcnNlY3Rpb24oMCksdGhpcy5rZWVwSW50ZXJzZWN0aW9ucyYmdGhpcy5pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uKSx0aGlzLmludGVyc2VjdGlvbkNvdW50KyspfSxpc0VuZFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09PWV8fGU+PXQuc2l6ZSgpLTJ9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuZmluZEFsbEludGVyc2VjdGlvbnMmJm51bGwhPT10aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFufX0pLGFuLmNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXI9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFuKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlfSxhbi5jcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBhbih0KX0sYW4uY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuc2V0S2VlcEludGVyc2VjdGlvbnMoITEpLGV9LGUodW4ucHJvdG90eXBlLHtleGVjdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnNlZ0ludD9udWxsOnZvaWQgdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpfSxnZXRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnSW50LmdldEludGVyc2VjdGlvbnMoKX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dGUoKSx0aGlzLl9pc1ZhbGlkfSxzZXRGaW5kQWxsSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9LGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7dGhpcy5faXNWYWxpZD0hMCx0aGlzLnNlZ0ludD1uZXcgYW4odGhpcy5saSksdGhpcy5zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucyk7dmFyIHQ9bmV3IG5uO2lmKHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLnNlZ1N0cmluZ3MpLHRoaXMuc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpKXJldHVybiB0aGlzLl9pc1ZhbGlkPSExLG51bGx9LGNoZWNrVmFsaWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmV4ZWN1dGUoKSwhdGhpcy5faXNWYWxpZCl0aHJvdyBuZXcgc24odGhpcy5nZXRFcnJvck1lc3NhZ2UoKSx0aGlzLnNlZ0ludC5nZXRJbnRlcmlvckludGVyc2VjdGlvbigpKX0sZ2V0RXJyb3JNZXNzYWdlOmZ1bmN0aW9uKCl7aWYodGhpcy5faXNWYWxpZClyZXR1cm5cIm5vIGludGVyc2VjdGlvbnMgZm91bmRcIjt2YXIgdD10aGlzLnNlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO3JldHVyblwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBiZXR3ZWVuIFwiK3NlLnRvTGluZVN0cmluZyh0WzBdLHRbMV0pK1wiIGFuZCBcIitzZS50b0xpbmVTdHJpbmcodFsyXSx0WzNdKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdW59fSksdW4uY29tcHV0ZUludGVyc2VjdGlvbnM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHVuKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLmlzVmFsaWQoKSxlLmdldEludGVyc2VjdGlvbnMoKX0sZShsbi5wcm90b3R5cGUse2NoZWNrVmFsaWQ6ZnVuY3Rpb24oKXt0aGlzLm52LmNoZWNrVmFsaWQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbG59fSksbG4udG9TZWdtZW50U3RyaW5ncz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmFkZChuZXcgT2UoaS5nZXRDb29yZGluYXRlcygpLGkpKX1yZXR1cm4gZX0sbG4uY2hlY2tWYWxpZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgbG4odCk7ZS5jaGVja1ZhbGlkKCl9LGUoaG4ucHJvdG90eXBlLHttYXA6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dGhpcy5tYXBPcC5tYXAodC5nZXRHZW9tZXRyeU4obikpO2kuaXNFbXB0eSgpfHxlLmFkZChpKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheShlKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhufX0pLGhuLm1hcD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBobihlKTtyZXR1cm4gbi5tYXAodCl9LGUoY24ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjbn19KSxjbi5vcHBvc2l0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdD09PWNuLkxFRlQ/Y24uUklHSFQ6dD09PWNuLlJJR0hUP2NuLkxFRlQ6dH0sY24uT049MCxjbi5MRUZUPTEsY24uUklHSFQ9MixlKGZuLnByb3RvdHlwZSx7c2V0QWxsTG9jYXRpb25zOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09dH0saXNOdWxsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XSE9PUwuTk9ORSlyZXR1cm4hMTtyZXR1cm4hMH0sc2V0QWxsTG9jYXRpb25zSWZOdWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKXRoaXMubG9jYXRpb25bZV09PT1MLk5PTkUmJih0aGlzLmxvY2F0aW9uW2VdPXQpfSxpc0xpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubG9jYXRpb24ubGVuZ3RofSxtZXJnZTpmdW5jdGlvbih0KXtpZih0LmxvY2F0aW9uLmxlbmd0aD50aGlzLmxvY2F0aW9uLmxlbmd0aCl7dmFyIGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7ZVtjbi5PTl09dGhpcy5sb2NhdGlvbltjbi5PTl0sZVtjbi5MRUZUXT1MLk5PTkUsZVtjbi5SSUdIVF09TC5OT05FLHRoaXMubG9jYXRpb249ZX1mb3IodmFyIG49MDtuPHRoaXMubG9jYXRpb24ubGVuZ3RoO24rKyl0aGlzLmxvY2F0aW9uW25dPT09TC5OT05FJiZuPHQubG9jYXRpb24ubGVuZ3RoJiYodGhpcy5sb2NhdGlvbltuXT10LmxvY2F0aW9uW25dKX0sZ2V0TG9jYXRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG9jYXRpb259LGZsaXA6ZnVuY3Rpb24oKXtpZih0aGlzLmxvY2F0aW9uLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLmxvY2F0aW9uW2NuLkxFRlRdO3RoaXMubG9jYXRpb25bY24uTEVGVF09dGhpcy5sb2NhdGlvbltjbi5SSUdIVF0sdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09dH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQoTC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bY24uTEVGVF0pKSx0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5PTl0pKSx0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5SSUdIVF0pKSx0LnRvU3RyaW5nKCl9LHNldExvY2F0aW9uczpmdW5jdGlvbih0LGUsbil7dGhpcy5sb2NhdGlvbltjbi5PTl09dCx0aGlzLmxvY2F0aW9uW2NuLkxFRlRdPWUsdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09bn0sZ2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0PHRoaXMubG9jYXRpb24ubGVuZ3RoP3RoaXMubG9jYXRpb25bdF06TC5OT05FfSxpc0FyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MX0saXNBbnlOdWxsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XT09PUwuTk9ORSlyZXR1cm4hMDtyZXR1cm4hMX0sc2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TG9jYXRpb24oY24uT04sdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMubG9jYXRpb25bZV09bn19LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5sb2NhdGlvbj1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLnNldEFsbExvY2F0aW9ucyhMLk5PTkUpfSxpc0VxdWFsT25TaWRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRpb25bZV09PT10LmxvY2F0aW9uW2VdfSxhbGxQb3NpdGlvbnNFcXVhbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKylpZih0aGlzLmxvY2F0aW9uW2VdIT09dClyZXR1cm4hMTtyZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZm59fSksZShnbi5wcm90b3R5cGUse2dldEdlb21ldHJ5Q291bnQ6ZnVuY3Rpb24oKXt2YXIgdD0wO3JldHVybiB0aGlzLmVsdFswXS5pc051bGwoKXx8dCsrLHRoaXMuZWx0WzFdLmlzTnVsbCgpfHx0KyssdH0sc2V0QWxsTG9jYXRpb25zOmZ1bmN0aW9uKHQsZSl7dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zKGUpfSxpc051bGw6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTnVsbCgpfSxzZXRBbGxMb2NhdGlvbnNJZk51bGw6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdCksdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5lbHRbZV0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKG4pfX0saXNMaW5lOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0xpbmUoKX0sbWVyZ2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTwyO2UrKyludWxsPT09dGhpcy5lbHRbZV0mJm51bGwhPT10LmVsdFtlXT90aGlzLmVsdFtlXT1uZXcgZm4odC5lbHRbZV0pOnRoaXMuZWx0W2VdLm1lcmdlKHQuZWx0W2VdKX0sZmxpcDpmdW5jdGlvbigpe3RoaXMuZWx0WzBdLmZsaXAoKSx0aGlzLmVsdFsxXS5mbGlwKCl9LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KGNuLk9OKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmVsdFtlXS5nZXQobil9fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiBudWxsIT09dGhpcy5lbHRbMF0mJih0LmFwcGVuZChcIkE6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpKSxudWxsIT09dGhpcy5lbHRbMV0mJih0LmFwcGVuZChcIiBCOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFsxXS50b1N0cmluZygpKSksdC50b1N0cmluZygpfSxpc0FyZWE6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5lbHRbMF0uaXNBcmVhKCl8fHRoaXMuZWx0WzFdLmlzQXJlYSgpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmlzQXJlYSgpfX0saXNBbnlOdWxsOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0FueU51bGwoKX0sc2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0W3RdLnNldExvY2F0aW9uKGNuLk9OLGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmVsdFtuXS5zZXRMb2NhdGlvbihpLHIpfX0saXNFcXVhbE9uU2lkZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKHQuZWx0WzBdLGUpJiZ0aGlzLmVsdFsxXS5pc0VxdWFsT25TaWRlKHQuZWx0WzFdLGUpfSxhbGxQb3NpdGlvbnNFcXVhbDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVsdFt0XS5hbGxQb3NpdGlvbnNFcXVhbChlKX0sdG9MaW5lOmZ1bmN0aW9uKHQpe3RoaXMuZWx0W3RdLmlzQXJlYSgpJiYodGhpcy5lbHRbdF09bmV3IGZuKHRoaXMuZWx0W3RdLmxvY2F0aW9uWzBdKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdufX0pLGduLnRvTGluZUxhYmVsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgZ24oTC5OT05FKSxuPTA7bjwyO24rKyllLnNldExvY2F0aW9uKG4sdC5nZXRMb2NhdGlvbihuKSk7cmV0dXJuIGV9LGUoZG4ucHJvdG90eXBlLHtjb21wdXRlUmluZzpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnJpbmcpcmV0dXJuIG51bGw7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnB0cy5zaXplKCkpLmZpbGwobnVsbCksZT0wO2U8dGhpcy5wdHMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMucHRzLmdldChlKTt0aGlzLnJpbmc9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0KSx0aGlzLl9pc0hvbGU9aGUuaXNDQ1codGhpcy5yaW5nLmdldENvb3JkaW5hdGVzKCkpfSxpc0lzb2xhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLmxhYmVsLmdldEdlb21ldHJ5Q291bnQoKX0sY29tcHV0ZVBvaW50czpmdW5jdGlvbih0KXt0aGlzLnN0YXJ0RGU9dDt2YXIgZT10LG49ITA7ZG97aWYobnVsbD09PWUpdGhyb3cgbmV3IHNuKFwiRm91bmQgbnVsbCBEaXJlY3RlZEVkZ2VcIik7aWYoZS5nZXRFZGdlUmluZygpPT09dGhpcyl0aHJvdyBuZXcgc24oXCJEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgXCIrZS5nZXRDb29yZGluYXRlKCkpO3RoaXMuZWRnZXMuYWRkKGUpO3ZhciBpPWUuZ2V0TGFiZWwoKTtmLmlzVHJ1ZShpLmlzQXJlYSgpKSx0aGlzLm1lcmdlTGFiZWwoaSksdGhpcy5hZGRQb2ludHMoZS5nZXRFZGdlKCksZS5pc0ZvcndhcmQoKSxuKSxuPSExLHRoaXMuc2V0RWRnZVJpbmcoZSx0aGlzKSxlPXRoaXMuZ2V0TmV4dChlKX13aGlsZShlIT09dGhpcy5zdGFydERlKX0sZ2V0TGluZWFyUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJpbmd9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzLmdldCh0KX0sY29tcHV0ZU1heE5vZGVEZWdyZWU6ZnVuY3Rpb24oKXt0aGlzLm1heE5vZGVEZWdyZWU9MDt2YXIgdD10aGlzLnN0YXJ0RGU7ZG97dmFyIGU9dC5nZXROb2RlKCksbj1lLmdldEVkZ2VzKCkuZ2V0T3V0Z29pbmdEZWdyZWUodGhpcyk7bj50aGlzLm1heE5vZGVEZWdyZWUmJih0aGlzLm1heE5vZGVEZWdyZWU9biksdD10aGlzLmdldE5leHQodCl9d2hpbGUodCE9PXRoaXMuc3RhcnREZSk7dGhpcy5tYXhOb2RlRGVncmVlKj0yfSxhZGRQb2ludHM6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlKXt2YXIgcj0xO24mJihyPTApO2Zvcih2YXIgcz1yO3M8aS5sZW5ndGg7cysrKXRoaXMucHRzLmFkZChpW3NdKX1lbHNle3ZhciByPWkubGVuZ3RoLTI7biYmKHI9aS5sZW5ndGgtMSk7Zm9yKHZhciBzPXI7cz49MDtzLS0pdGhpcy5wdHMuYWRkKGlbc10pfX0saXNIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN0YXJ0RGU7ZG8gdC5nZXRFZGdlKCkuc2V0SW5SZXN1bHQoITApLHQ9dC5nZXROZXh0KCk7d2hpbGUodCE9PXRoaXMuc3RhcnREZSl9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRMaW5lYXJSaW5nKCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5jb250YWlucyh0KSlyZXR1cm4hMTtpZighaGUuaXNQb2ludEluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSkpcmV0dXJuITE7Zm9yKHZhciBpPXRoaXMuaG9sZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKHIuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMX1yZXR1cm4hMH0sYWRkSG9sZTpmdW5jdGlvbih0KXt0aGlzLmhvbGVzLmFkZCh0KX0saXNTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5zaGVsbH0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sZ2V0TWF4Tm9kZURlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heE5vZGVEZWdyZWU8MCYmdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpLHRoaXMubWF4Tm9kZURlZ3JlZX0sZ2V0U2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbH0sbWVyZ2VMYWJlbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQsMCksdGhpcy5tZXJnZUxhYmVsKHQsMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9ZS5nZXRMb2NhdGlvbihuLGNuLlJJR0hUKTtpZihpPT09TC5OT05FKXJldHVybiBudWxsO2lmKHRoaXMubGFiZWwuZ2V0TG9jYXRpb24obik9PT1MLk5PTkUpcmV0dXJuIHRoaXMubGFiZWwuc2V0TG9jYXRpb24obixpKSxudWxsfX0sc2V0U2hlbGw6ZnVuY3Rpb24odCl7dGhpcy5zaGVsbD10LG51bGwhPT10JiZ0LmFkZEhvbGUodGhpcyl9LHRvUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHRoaXMuaG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPHRoaXMuaG9sZXMuc2l6ZSgpO24rKyllW25dPXRoaXMuaG9sZXMuZ2V0KG4pLmdldExpbmVhclJpbmcoKTt2YXIgaT10LmNyZWF0ZVBvbHlnb24odGhpcy5nZXRMaW5lYXJSaW5nKCksZSk7cmV0dXJuIGl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRufX0pLGgocG4sZG4pLGUocG4ucHJvdG90eXBlLHtzZXRFZGdlUmluZzpmdW5jdGlvbih0LGUpe3Quc2V0TWluRWRnZVJpbmcoZSl9LGdldE5leHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0TmV4dE1pbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwbn19KSxoKHZuLGRuKSxlKHZuLnByb3RvdHlwZSx7YnVpbGRNaW5pbWFsUmluZ3M6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSSxlPXRoaXMuc3RhcnREZTtkb3tpZihudWxsPT09ZS5nZXRNaW5FZGdlUmluZygpKXt2YXIgbj1uZXcgcG4oZSx0aGlzLmdlb21ldHJ5RmFjdG9yeSk7dC5hZGQobil9ZT1lLmdldE5leHQoKX13aGlsZShlIT09dGhpcy5zdGFydERlKTtyZXR1cm4gdH0sc2V0RWRnZVJpbmc6ZnVuY3Rpb24odCxlKXt0LnNldEVkZ2VSaW5nKGUpfSxsaW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN0YXJ0RGU7ZG97dmFyIGU9dC5nZXROb2RlKCk7ZS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzKSx0PXQuZ2V0TmV4dCgpfXdoaWxlKHQhPT10aGlzLnN0YXJ0RGUpfSxnZXROZXh0OmZ1bmN0aW9uKHQpe3JldHVybiB0LmdldE5leHQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdm59fSksZShtbi5wcm90b3R5cGUse3NldFZpc2l0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNWaXNpdGVkPXR9LHNldEluUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH0saXNDb3ZlcmVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZH0saXNDb3ZlcmVkU2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldH0sc2V0TGFiZWw6ZnVuY3Rpb24odCl7dGhpcy5sYWJlbD10fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxzZXRDb3ZlcmVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzQ292ZXJlZD10LHRoaXMuX2lzQ292ZXJlZFNldD0hMH0sdXBkYXRlSU06ZnVuY3Rpb24odCl7Zi5pc1RydWUodGhpcy5sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCk+PTIsXCJmb3VuZCBwYXJ0aWFsIGxhYmVsXCIpLHRoaXMuY29tcHV0ZUlNKHQpfSxpc0luUmVzdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9LGlzVmlzaXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1ufX0pLGgoeW4sbW4pLGUoeW4ucHJvdG90eXBlLHtpc0luY2lkZW50RWRnZUluUmVzdWx0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtpZihlLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpcmV0dXJuITB9cmV0dXJuITF9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIm5vZGUgXCIrdGhpcy5jb29yZCtcIiBsYmw6IFwiK3RoaXMubGFiZWwpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7fSxjb21wdXRlTWVyZ2VkTG9jYXRpb246ZnVuY3Rpb24odCxlKXt2YXIgbj1MLk5PTkU7aWYobj10aGlzLmxhYmVsLmdldExvY2F0aW9uKGUpLCF0LmlzTnVsbChlKSl7dmFyIGk9dC5nZXRMb2NhdGlvbihlKTtuIT09TC5CT1VOREFSWSYmKG49aSl9cmV0dXJuIG59LHNldExhYmVsOmZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG1uLnByb3RvdHlwZS5zZXRMYWJlbC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLmxhYmVsP3RoaXMubGFiZWw9bmV3IGduKHQsZSk6dGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LGUpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxtZXJnZUxhYmVsOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5bil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0LmxhYmVsKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ24pZm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPTA7bjwyO24rKyl7dmFyIGk9dGhpcy5jb21wdXRlTWVyZ2VkTG9jYXRpb24oZSxuKSxyPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24obik7cj09PUwuTk9ORSYmdGhpcy5sYWJlbC5zZXRMb2NhdGlvbihuLGkpfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMuaW5zZXJ0KHQpLHQuc2V0Tm9kZSh0aGlzKX0sc2V0TGFiZWxCb3VuZGFyeTpmdW5jdGlvbih0KXtpZihudWxsPT09dGhpcy5sYWJlbClyZXR1cm4gbnVsbDt2YXIgZT1MLk5PTkU7bnVsbCE9PXRoaXMubGFiZWwmJihlPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24odCkpO3ZhciBuPW51bGw7c3dpdGNoKGUpe2Nhc2UgTC5CT1VOREFSWTpuPUwuSU5URVJJT1I7YnJlYWs7Y2FzZSBMLklOVEVSSU9SOm49TC5CT1VOREFSWTticmVhaztkZWZhdWx0Om49TC5CT1VOREFSWX10aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsbil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHlufX0pLGUoeG4ucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfSxhZGROb2RlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09ZSYmKGU9dGhpcy5ub2RlRmFjdC5jcmVhdGVOb2RlKHQpLHRoaXMubm9kZU1hcC5wdXQodCxlKSksZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgbj1hcmd1bWVudHNbMF0sZT10aGlzLm5vZGVNYXAuZ2V0KG4uZ2V0Q29vcmRpbmF0ZSgpKTtyZXR1cm4gbnVsbD09PWU/KHRoaXMubm9kZU1hcC5wdXQobi5nZXRDb29yZGluYXRlKCksbiksbik6KGUubWVyZ2VMYWJlbChuKSxlKX19LHByaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGdldEJvdW5kYXJ5Tm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpPT09TC5CT1VOREFSWSYmZS5hZGQoaSl9cmV0dXJuIGV9LGFkZDpmdW5jdGlvbih0KXt2YXIgZT10LmdldENvb3JkaW5hdGUoKSxuPXRoaXMuYWRkTm9kZShlKTtuLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geG59fSksZShFbi5wcm90b3R5cGUse2NvbXBhcmVEaXJlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZHg9PT10LmR4JiZ0aGlzLmR5PT09dC5keT8wOnRoaXMucXVhZHJhbnQ+dC5xdWFkcmFudD8xOnRoaXMucXVhZHJhbnQ8dC5xdWFkcmFudD8tMTpoZS5jb21wdXRlT3JpZW50YXRpb24odC5wMCx0LnAxLHRoaXMucDEpfSxnZXREeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmR5fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDB9LHNldE5vZGU6ZnVuY3Rpb24odCl7dGhpcy5ub2RlPXR9LHByaW50OmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguYXRhbjIodGhpcy5keSx0aGlzLmR4KSxuPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksaT1uLmxhc3RJbmRleE9mKFwiLlwiKSxyPW4uc3Vic3RyaW5nKGkrMSk7dC5wcmludChcIiAgXCIrcitcIjogXCIrdGhpcy5wMCtcIiAtIFwiK3RoaXMucDErXCIgXCIrdGhpcy5xdWFkcmFudCtcIjpcIitlK1wiICAgXCIrdGhpcy5sYWJlbCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9LGdldERpcmVjdGVkQ29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAxfSxnZXREeDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmR4fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0sZ2V0UXVhZHJhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFkcmFudH0sZ2V0Tm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5hdGFuMih0aGlzLmR5LHRoaXMuZHgpLGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpLGk9ZS5zdWJzdHJpbmcobisxKTtyZXR1cm5cIiAgXCIraStcIjogXCIrdGhpcy5wMCtcIiAtIFwiK3RoaXMucDErXCIgXCIrdGhpcy5xdWFkcmFudCtcIjpcIit0K1wiICAgXCIrdGhpcy5sYWJlbH0sY29tcHV0ZUxhYmVsOmZ1bmN0aW9uKHQpe30saW5pdDpmdW5jdGlvbih0LGUpe3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5keD1lLngtdC54LHRoaXMuZHk9ZS55LXQueSx0aGlzLnF1YWRyYW50PUplLnF1YWRyYW50KHRoaXMuZHgsdGhpcy5keSksZi5pc1RydWUoISgwPT09dGhpcy5keCYmMD09PXRoaXMuZHkpLFwiRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmRcIil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFbn19KSxoKEluLEVuKSxlKEluLnByb3RvdHlwZSx7Z2V0TmV4dE1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHRNaW59LGdldERlcHRoOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlcHRoW3RdfSxzZXRWaXNpdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzVmlzaXRlZD10fSxjb21wdXRlRGlyZWN0ZWRMYWJlbDpmdW5jdGlvbigpe3RoaXMubGFiZWw9bmV3IGduKHRoaXMuZWRnZS5nZXRMYWJlbCgpKSx0aGlzLl9pc0ZvcndhcmR8fHRoaXMubGFiZWwuZmxpcCgpfSxnZXROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0sc2V0RGVwdGg6ZnVuY3Rpb24odCxlKXtpZih0aGlzLmRlcHRoW3RdIT09LTk5OSYmdGhpcy5kZXB0aFt0XSE9PWUpdGhyb3cgbmV3IHNuKFwiYXNzaWduZWQgZGVwdGhzIGRvIG5vdCBtYXRjaFwiLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLmRlcHRoW3RdPWV9LGlzSW50ZXJpb3JBcmVhRWRnZTpmdW5jdGlvbiB0KCl7Zm9yKHZhciB0PSEwLGU9MDtlPDI7ZSsrKXRoaXMubGFiZWwuaXNBcmVhKGUpJiZ0aGlzLmxhYmVsLmdldExvY2F0aW9uKGUsY24uTEVGVCk9PT1MLklOVEVSSU9SJiZ0aGlzLmxhYmVsLmdldExvY2F0aW9uKGUsY24uUklHSFQpPT09TC5JTlRFUklPUnx8KHQ9ITEpO3JldHVybiB0fSxzZXROZXh0TWluOmZ1bmN0aW9uKHQpe3RoaXMubmV4dE1pbj10fSxwcmludDpmdW5jdGlvbih0KXtFbi5wcm90b3R5cGUucHJpbnQuY2FsbCh0aGlzLHQpLHQucHJpbnQoXCIgXCIrdGhpcy5kZXB0aFtjbi5MRUZUXStcIi9cIit0aGlzLmRlcHRoW2NuLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9LHNldE1pbkVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3RoaXMubWluRWRnZVJpbmc9dH0saXNMaW5lRWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGFiZWwuaXNMaW5lKDApfHx0aGlzLmxhYmVsLmlzTGluZSgxKSxlPSF0aGlzLmxhYmVsLmlzQXJlYSgwKXx8dGhpcy5sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgwLEwuRVhURVJJT1IpLG49IXRoaXMubGFiZWwuaXNBcmVhKDEpfHx0aGlzLmxhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsTC5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59LHNldEVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZVJpbmc9dH0sZ2V0TWluRWRnZVJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW5FZGdlUmluZ30sZ2V0RGVwdGhEZWx0YTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9LHNldEluUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5SZXN1bHQ9dH0sZ2V0U3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltfSxpc0ZvcndhcmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0scHJpbnRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuZWRnZS5wcmludCh0KTp0aGlzLmVkZ2UucHJpbnRSZXZlcnNlKHQpfSxzZXRTeW06ZnVuY3Rpb24odCl7dGhpcy5zeW09dH0sc2V0VmlzaXRlZEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5zZXRWaXNpdGVkKHQpLHRoaXMuc3ltLnNldFZpc2l0ZWQodCl9LHNldEVkZ2VEZXB0aHM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7dGhpcy5faXNGb3J3YXJkfHwobj0tbik7dmFyIGk9MTt0PT09Y24uTEVGVCYmKGk9LTEpO3ZhciByPWNuLm9wcG9zaXRlKHQpLHM9bippLG89ZStzO3RoaXMuc2V0RGVwdGgodCxlKSx0aGlzLnNldERlcHRoKHIsbyl9LGdldEVkZ2VSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZVJpbmd9LGlzSW5SZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSW59fSksSW4uZGVwdGhGYWN0b3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PUwuRVhURVJJT1ImJmU9PT1MLklOVEVSSU9SPzE6dD09PUwuSU5URVJJT1ImJmU9PT1MLkVYVEVSSU9SPy0xOjB9LGUoTm4ucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeW4odCxudWxsKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTm59fSksZShDbi5wcm90b3R5cGUse3ByaW50RWRnZXM6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiRWRnZXM6XCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKXt0LnByaW50bG4oXCJlZGdlIFwiK2UrXCI6XCIpO3ZhciBuPXRoaXMuZWRnZXMuZ2V0KGUpO24ucHJpbnQodCksbi5laUxpc3QucHJpbnQodCl9fSxmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVzLmZpbmQodCl9LGFkZE5vZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubm9kZXMuYWRkTm9kZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5ub2Rlcy5hZGROb2RlKGUpfX0sZ2V0Tm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMuaXRlcmF0b3IoKX0sbGlua1Jlc3VsdERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCl9fSxkZWJ1Z1ByaW50bG46ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbih0KX0saXNCb3VuZGFyeU5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLm5vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7dmFyIGk9bi5nZXRMYWJlbCgpO3JldHVybiBudWxsIT09aSYmaS5nZXRMb2NhdGlvbih0KT09PUwuQk9VTkRBUll9LGxpbmtBbGxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpfX0sbWF0Y2hJblNhbWVEaXJlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuISF0LmVxdWFscyhuKSYmKGhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsaSk9PT1oZS5DT0xMSU5FQVImJkplLnF1YWRyYW50KHQsZSk9PT1KZS5xdWFkcmFudChuLGkpKX0sZ2V0RWRnZUVuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRW5kTGlzdH0sZGVidWdQcmludDpmdW5jdGlvbih0KXtBLm91dC5wcmludCh0KX0sZ2V0RWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0sZmluZEVkZ2VJblNhbWVEaXJlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMuZWRnZXMuc2l6ZSgpO24rKyl7dmFyIGk9dGhpcy5lZGdlcy5nZXQobikscj1pLmdldENvb3JkaW5hdGVzKCk7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsclswXSxyWzFdKSlyZXR1cm4gaTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxyW3IubGVuZ3RoLTFdLHJbci5sZW5ndGgtMl0pKXJldHVybiBpfXJldHVybiBudWxsfSxpbnNlcnRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMuYWRkKHQpfSxmaW5kRWRnZUVuZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIG59cmV0dXJuIG51bGx9LGFkZEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmVkZ2VzLmFkZChuKTt2YXIgaT1uZXcgSW4obiwoITApKSxyPW5ldyBJbihuLCghMSkpO2kuc2V0U3ltKHIpLHIuc2V0U3ltKGkpLHRoaXMuYWRkKGkpLHRoaXMuYWRkKHIpfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMubm9kZXMuYWRkKHQpLHRoaXMuZWRnZUVuZExpc3QuYWRkKHQpfSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzLnZhbHVlcygpfSxmaW5kRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5lZGdlcy5zaXplKCk7bisrKXt2YXIgaT10aGlzLmVkZ2VzLmdldChuKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0LmVxdWFscyhyWzBdKSYmZS5lcXVhbHMoclsxXSkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENufX0pLENuLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19LGUoU24ucHJvdG90eXBlLHtzb3J0U2hlbGxzQW5kSG9sZXM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzSG9sZSgpP24uYWRkKHIpOmUuYWRkKHIpfX0sY29tcHV0ZVBvbHlnb25zOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS50b1BvbHlnb24odGhpcy5nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHIpfXJldHVybiBlfSxwbGFjZUZyZWVIb2xlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihudWxsPT09aS5nZXRTaGVsbCgpKXt2YXIgcj10aGlzLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoaSx0KTtpZihudWxsPT09cil0aHJvdyBuZXcgc24oXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGkuZ2V0Q29vcmRpbmF0ZSgwKSk7aS5zZXRTaGVsbChyKX19fSxidWlsZE1pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uZXcgSSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHMuZ2V0TWF4Tm9kZURlZ3JlZSgpPjIpe3MubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7dmFyIG89cy5idWlsZE1pbmltYWxSaW5ncygpLGE9dGhpcy5maW5kU2hlbGwobyk7bnVsbCE9PWE/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoYSxvKSxlLmFkZChhKSk6bi5hZGRBbGwobyl9ZWxzZSBpLmFkZChzKX1yZXR1cm4gaX0sY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5zaGVsbExpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMH1yZXR1cm4hMX0sYnVpbGRNYXhpbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNJblJlc3VsdCgpJiZpLmdldExhYmVsKCkuaXNBcmVhKCkmJm51bGw9PT1pLmdldEVkZ2VSaW5nKCkpe3ZhciByPW5ldyB2bihpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChyKSxyLnNldEluUmVzdWx0KCl9fXJldHVybiBlfSxwbGFjZVBvbHlnb25Ib2xlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSG9sZSgpJiZpLnNldFNoZWxsKHQpfX0sZ2V0UG9seWdvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLnNoZWxsTGlzdCk7cmV0dXJuIHR9LGZpbmRFZGdlUmluZ0NvbnRhaW5pbmc6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRMaW5lYXJSaW5nKCksaT1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscz1udWxsLG89bnVsbCxhPWUuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpLGw9dS5nZXRMaW5lYXJSaW5nKCksaD1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtudWxsIT09cyYmKG89cy5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTt2YXIgYz0hMTtoLmNvbnRhaW5zKGkpJiZoZS5pc1BvaW50SW5SaW5nKHIsbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09c3x8by5jb250YWlucyhoKSkmJihzPXUpfXJldHVybiBzfSxmaW5kU2hlbGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj1udWxsLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc0hvbGUoKXx8KG49cixlKyspfXJldHVybiBmLmlzVHJ1ZShlPD0xLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQuZ2V0RWRnZUVuZHMoKSx0LmdldE5vZGVzKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtDbi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhuKTt2YXIgaT10aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyhlKSxyPW5ldyBJLHM9dGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3MoaSx0aGlzLnNoZWxsTGlzdCxyKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhzLHRoaXMuc2hlbGxMaXN0LHIpLHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5zaGVsbExpc3Qscil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTbn19KSxlKHduLnByb3RvdHlwZSx7Y29sbGVjdExpbmVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm9wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5jb2xsZWN0TGluZUVkZ2Uobix0LHRoaXMubGluZUVkZ2VzTGlzdCksdGhpcy5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2Uobix0LHRoaXMubGluZUVkZ2VzTGlzdCl9fSxsYWJlbElzb2xhdGVkTGluZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLm9wLmdldEFyZ0dlb21ldHJ5KGUpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX0sYnVpbGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKSx0aGlzLmNvbGxlY3RMaW5lcyh0KSx0aGlzLmJ1aWxkTGluZXModCksdGhpcy5yZXN1bHRMaW5lTGlzdH0sY29sbGVjdExpbmVFZGdlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldExhYmVsKCkscj10LmdldEVkZ2UoKTt0LmlzTGluZUVkZ2UoKSYmKHQuaXNWaXNpdGVkKCl8fCFpaS5pc1Jlc3VsdE9mT3AoaSxlKXx8ci5pc0NvdmVyZWQoKXx8KG4uYWRkKHIpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSl9LGZpbmRDb3ZlcmVkTGluZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMub3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKX1mb3IodmFyIG49dGhpcy5vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRFZGdlKCk7aWYoaS5pc0xpbmVFZGdlKCkmJiFyLmlzQ292ZXJlZFNldCgpKXt2YXIgcz10aGlzLm9wLmlzQ292ZXJlZEJ5QShpLmdldENvb3JkaW5hdGUoKSk7ci5zZXRDb3ZlcmVkKHMpfX19LGxhYmVsSXNvbGF0ZWRMaW5lczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7bi5pc0lzb2xhdGVkKCkmJihpLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKG4sMCk6dGhpcy5sYWJlbElzb2xhdGVkTGluZShuLDEpKX19LGJ1aWxkTGluZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMubGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT0obi5nZXRMYWJlbCgpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobi5nZXRDb29yZGluYXRlcygpKSk7dGhpcy5yZXN1bHRMaW5lTGlzdC5hZGQoaSksbi5zZXRJblJlc3VsdCghMCl9fSxjb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2U6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0TGFiZWwoKTtyZXR1cm4gdC5pc0xpbmVFZGdlKCk/bnVsbDp0LmlzVmlzaXRlZCgpP251bGw6dC5pc0ludGVyaW9yQXJlYUVkZ2UoKT9udWxsOnQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKT9udWxsOihmLmlzVHJ1ZSghKHQuaXNJblJlc3VsdCgpfHx0LmdldFN5bSgpLmlzSW5SZXN1bHQoKSl8fCF0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpLHZvaWQoaWkuaXNSZXN1bHRPZk9wKGksZSkmJmU9PT1paS5JTlRFUlNFQ1RJT04mJihuLmFkZCh0LmdldEVkZ2UoKSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdufX0pLGUoTG4ucHJvdG90eXBlLHtmaWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRDb29yZGluYXRlKCk7aWYoIXRoaXMub3AuaXNDb3ZlcmVkQnlMQShlKSl7dmFyIG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSk7dGhpcy5yZXN1bHRQb2ludExpc3QuYWRkKG4pfX0sZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKCEobi5pc0luUmVzdWx0KCl8fG4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpfHwwIT09bi5nZXRFZGdlcygpLmdldERlZ3JlZSgpJiZ0IT09aWkuSU5URVJTRUNUSU9OKSl7dmFyIGk9bi5nZXRMYWJlbCgpO2lpLmlzUmVzdWx0T2ZPcChpLHQpJiZ0aGlzLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKX19fSxidWlsZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMucmVzdWx0UG9pbnRMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMbn19KSxlKFJuLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUm59fSksZShUbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXtyZXR1cm4gVG4ubG9jYXRlKHQsdGhpcy5nZW9tKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUm5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUbn19KSxUbi5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpJiZoZS5pc1BvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKX0sVG4uY29udGFpbnNQb2ludEluUG9seWdvbj1mdW5jdGlvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiExO3ZhciBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCk7aWYoIVRuLmlzUG9pbnRJblJpbmcodCxuKSlyZXR1cm4hMTtmb3IodmFyIGk9MDtpPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7aSsrKXt2YXIgcj1lLmdldEludGVyaW9yUmluZ04oaSk7aWYoVG4uaXNQb2ludEluUmluZyh0LHIpKXJldHVybiExfXJldHVybiEwfSxUbi5jb250YWluc1BvaW50PWZ1bmN0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIFR0KXJldHVybiBUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uKHQsZSk7aWYoZSBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgbj1uZXcgUmUoZSk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpIT09ZSYmVG4uY29udGFpbnNQb2ludCh0LGkpKXJldHVybiEwfXJldHVybiExfSxUbi5sb2NhdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/TC5FWFRFUklPUjpUbi5jb250YWluc1BvaW50KHQsZSk/TC5JTlRFUklPUjpMLkVYVEVSSU9SfSxlKFBuLnByb3RvdHlwZSx7Z2V0TmV4dENXOmZ1bmN0aW9uKHQpe3RoaXMuZ2V0RWRnZXMoKTt2YXIgZT10aGlzLmVkZ2VMaXN0LmluZGV4T2YodCksbj1lLTE7cmV0dXJuIDA9PT1lJiYobj10aGlzLmVkZ2VMaXN0LnNpemUoKS0xKSx0aGlzLmVkZ2VMaXN0LmdldChuKX0scHJvcGFnYXRlU2lkZUxhYmVsczpmdW5jdGlvbih0KXtmb3IodmFyIGU9TC5OT05FLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCk7ci5pc0FyZWEodCkmJnIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSE9PUwuTk9ORSYmKGU9ci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpKX1pZihlPT09TC5OT05FKXJldHVybiBudWxsO2Zvcih2YXIgcz1lLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCk7aWYoci5nZXRMb2NhdGlvbih0LGNuLk9OKT09PUwuTk9ORSYmci5zZXRMb2NhdGlvbih0LGNuLk9OLHMpLHIuaXNBcmVhKHQpKXt2YXIgbz1yLmdldExvY2F0aW9uKHQsY24uTEVGVCksYT1yLmdldExvY2F0aW9uKHQsY24uUklHSFQpO2lmKGEhPT1MLk5PTkUpe2lmKGEhPT1zKXRocm93IG5ldyBzbihcInNpZGUgbG9jYXRpb24gY29uZmxpY3RcIixpLmdldENvb3JkaW5hdGUoKSk7bz09PUwuTk9ORSYmZi5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHNpbmdsZSBudWxsIHNpZGUgKGF0IFwiK2kuZ2V0Q29vcmRpbmF0ZSgpK1wiKVwiKSxzPW99ZWxzZSBmLmlzVHJ1ZShyLmdldExvY2F0aW9uKHQsY24uTEVGVCk9PT1MLk5PTkUsXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlXCIpLHIuc2V0TG9jYXRpb24odCxjbi5SSUdIVCxzKSxyLnNldExvY2F0aW9uKHQsY24uTEVGVCxzKX19fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5pdGVyYXRvcigpO2lmKCF0Lmhhc05leHQoKSlyZXR1cm4gbnVsbDt2YXIgZT10Lm5leHQoKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlKCl9LHByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO1xubi5wcmludCh0KX19LGlzQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModC5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCgwKX0sY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7dmFyIG49ZS5zaXplKCktMSxpPWUuZ2V0KG4pLmdldExhYmVsKCkscj1pLmdldExvY2F0aW9uKHQsY24uTEVGVCk7Zi5pc1RydWUociE9PUwuTk9ORSxcIkZvdW5kIHVubGFiZWxsZWQgYXJlYSBlZGdlXCIpO2Zvcih2YXIgcz1yLG89dGhpcy5pdGVyYXRvcigpO28uaGFzTmV4dCgpOyl7dmFyIGE9by5uZXh0KCksdT1hLmdldExhYmVsKCk7Zi5pc1RydWUodS5pc0FyZWEodCksXCJGb3VuZCBub24tYXJlYSBlZGdlXCIpO3ZhciBsPXUuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSxoPXUuZ2V0TG9jYXRpb24odCxjbi5SSUdIVCk7aWYobD09PWgpcmV0dXJuITE7aWYoaCE9PXMpcmV0dXJuITE7cz1sfXJldHVybiEwfSxmaW5kSW5kZXg6ZnVuY3Rpb24odCl7dGhpcy5pdGVyYXRvcigpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlTGlzdC5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmVkZ2VMaXN0LmdldChlKTtpZihuPT09dClyZXR1cm4gZX1yZXR1cm4tMX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmVkZ2VMaXN0JiYodGhpcy5lZGdlTGlzdD1uZXcgSSh0aGlzLmVkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLmVkZ2VMaXN0fSxnZXRMb2NhdGlvbjpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XT09PUwuTk9ORSYmKHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XT1Ubi5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7dC5hcHBlbmQoXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSksdC5hcHBlbmQoXCJcXG5cIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QuYXBwZW5kKG4pLHQuYXBwZW5kKFwiXFxuXCIpfXJldHVybiB0LnRvU3RyaW5nKCl9LGNvbXB1dGVFZGdlRW5kTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmNvbXB1dGVMYWJlbCh0KX19LGNvbXB1dGVMYWJlbGxpbmc6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtmb3IodmFyIGU9WyExLCExXSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZm9yKHZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpLHM9MDtzPDI7cysrKXIuaXNMaW5lKHMpJiZyLmdldExvY2F0aW9uKHMpPT09TC5CT1VOREFSWSYmKGVbc109ITApO2Zvcih2YXIgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7czwyO3MrKylpZihyLmlzQW55TnVsbChzKSl7dmFyIG89TC5OT05FO2lmKGVbc10pbz1MLkVYVEVSSU9SO2Vsc2V7dmFyIGE9aS5nZXRDb29yZGluYXRlKCk7bz10aGlzLmdldExvY2F0aW9uKHMsYSx0KX1yLnNldEFsbExvY2F0aW9uc0lmTnVsbChzLG8pfX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZU1hcC5zaXplKCl9LGluc2VydEVkZ2VFbmQ6ZnVuY3Rpb24odCxlKXt0aGlzLmVkZ2VNYXAucHV0KHQsZSksdGhpcy5lZGdlTGlzdD1udWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQbn19KSxoKGJuLFBuKSxlKGJuLnByb3RvdHlwZSx7bGlua1Jlc3VsdERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO2Zvcih2YXIgdD1udWxsLGU9bnVsbCxuPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HLGk9MDtpPHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTtpKyspe3ZhciByPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKSxzPXIuZ2V0U3ltKCk7aWYoci5nZXRMYWJlbCgpLmlzQXJlYSgpKXN3aXRjaChudWxsPT09dCYmci5pc0luUmVzdWx0KCkmJih0PXIpLG4pe2Nhc2UgdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoIXMuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2U9cyxuPXRoaXMuTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuTElOS0lOR19UT19PVVRHT0lORzppZighci5pc0luUmVzdWx0KCkpY29udGludWU7ZS5zZXROZXh0KHIpLG49dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkd9fWlmKG49PT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkcpe2lmKG51bGw9PT10KXRocm93IG5ldyBzbihcIm5vIG91dGdvaW5nIGRpckVkZ2UgZm91bmRcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7Zi5pc1RydWUodC5pc0luUmVzdWx0KCksXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksZS5zZXROZXh0KHQpfX0saW5zZXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5pbnNlcnRFZGdlRW5kKGUsZSl9LGdldFJpZ2h0bW9zdEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldEVkZ2VzKCksZT10LnNpemUoKTtpZihlPDEpcmV0dXJuIG51bGw7dmFyIG49dC5nZXQoMCk7aWYoMT09PWUpcmV0dXJuIG47dmFyIGk9dC5nZXQoZS0xKSxyPW4uZ2V0UXVhZHJhbnQoKSxzPWkuZ2V0UXVhZHJhbnQoKTtpZihKZS5pc05vcnRoZXJuKHIpJiZKZS5pc05vcnRoZXJuKHMpKXJldHVybiBuO2lmKCFKZS5pc05vcnRoZXJuKHIpJiYhSmUuaXNOb3J0aGVybihzKSlyZXR1cm4gaTtyZXR1cm4gMCE9PW4uZ2V0RHkoKT9uOjAhPT1pLmdldER5KCk/aTooZi5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGVcIiksbnVsbCl9LHByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oXCJEaXJlY3RlZEVkZ2VTdGFyOiBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QucHJpbnQoXCJvdXQgXCIpLG4ucHJpbnQodCksdC5wcmludGxuKCksdC5wcmludChcImluIFwiKSxuLmdldFN5bSgpLnByaW50KHQpLHQucHJpbnRsbigpfX0sZ2V0UmVzdWx0QXJlYUVkZ2VzOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0KXJldHVybiB0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdDt0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdD1uZXcgSTtmb3IodmFyIHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7KGUuaXNJblJlc3VsdCgpfHxlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkmJnRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChlKX1yZXR1cm4gdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3R9LHVwZGF0ZUxhYmVsbGluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7aS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0LmdldExvY2F0aW9uKDApKSxpLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQuZ2V0TG9jYXRpb24oMSkpfX0sbGlua0FsbERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmdldEVkZ2VzKCk7Zm9yKHZhciB0PW51bGwsZT1udWxsLG49dGhpcy5lZGdlTGlzdC5zaXplKCktMTtuPj0wO24tLSl7dmFyIGk9dGhpcy5lZGdlTGlzdC5nZXQobikscj1pLmdldFN5bSgpO251bGw9PT1lJiYoZT1yKSxudWxsIT09dCYmci5zZXROZXh0KHQpLHQ9aX1lLnNldE5leHQodCl9LGNvbXB1dGVEZXB0aHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5maW5kSW5kZXgodCksbj0odC5nZXRMYWJlbCgpLHQuZ2V0RGVwdGgoY24uTEVGVCkpLGk9dC5nZXREZXB0aChjbi5SSUdIVCkscj10aGlzLmNvbXB1dGVEZXB0aHMoZSsxLHRoaXMuZWRnZUxpc3Quc2l6ZSgpLG4pLHM9dGhpcy5jb21wdXRlRGVwdGhzKDAsZSxyKTtpZihzIT09aSl0aHJvdyBuZXcgc24oXCJkZXB0aCBtaXNtYXRjaCBhdCBcIit0LmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXSxsPXUsaD1vO2g8YTtoKyspe3ZhciBjPXRoaXMuZWRnZUxpc3QuZ2V0KGgpO2MuZ2V0TGFiZWwoKTtjLnNldEVkZ2VEZXB0aHMoY24uUklHSFQsbCksbD1jLmdldERlcHRoKGNuLkxFRlQpfXJldHVybiBsfX0sbWVyZ2VTeW1MYWJlbHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7bi5tZXJnZShlLmdldFN5bSgpLmdldExhYmVsKCkpfX0sbGlua01pbmltYWxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49bnVsbCxpPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HLHI9dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpLTE7cj49MDtyLS0pe3ZhciBzPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmdldChyKSxvPXMuZ2V0U3ltKCk7c3dpdGNoKG51bGw9PT1lJiZzLmdldEVkZ2VSaW5nKCk9PT10JiYoZT1zKSxpKXtjYXNlIHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKG8uZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bj1vLGk9dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HOmlmKHMuZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bi5zZXROZXh0TWluKHMpLGk9dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkd9fWk9PT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkcmJihmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksZi5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfSxnZXRPdXRnb2luZ0RlZ3JlZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9MCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uaXNJblJlc3VsdCgpJiZ0Kyt9cmV0dXJuIHR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0sdD0wLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlUmluZygpPT09aSYmdCsrfXJldHVybiB0fX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sZmluZENvdmVyZWRMaW5lRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9TC5OT05FLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9TC5JTlRFUklPUjticmVha31pZihpLmlzSW5SZXN1bHQoKSl7dD1MLkVYVEVSSU9SO2JyZWFrfX19aWYodD09PUwuTk9ORSlyZXR1cm4gbnVsbDtmb3IodmFyIHI9dCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKHI9PT1MLklOVEVSSU9SKToobi5pc0luUmVzdWx0KCkmJihyPUwuRVhURVJJT1IpLGkuaXNJblJlc3VsdCgpJiYocj1MLklOVEVSSU9SKSl9fSxjb21wdXRlTGFiZWxsaW5nOmZ1bmN0aW9uKHQpe1BuLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcyx0KSx0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpLHI9aS5nZXRMYWJlbCgpLHM9MDtzPDI7cysrKXt2YXIgbz1yLmdldExvY2F0aW9uKHMpO28hPT1MLklOVEVSSU9SJiZvIT09TC5CT1VOREFSWXx8dGhpcy5sYWJlbC5zZXRMb2NhdGlvbihzLEwuSU5URVJJT1IpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYm59fSksaChPbixObiksZShPbi5wcm90b3R5cGUse2NyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB5bih0LG5ldyBibil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9ufX0pLGUoX24ucHJvdG90eXBlLHtjb21wdXRlSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUpe3RoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LHQubWNlLHQuY2hhaW5JbmRleCxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX259fSksZShNbi5wcm90b3R5cGUse2lzRGVsZXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZlbnRUeXBlPT09TW4uREVMRVRFfSxzZXREZWxldGVFdmVudEluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuZGVsZXRlRXZlbnRJbmRleD10fSxnZXRPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vYmp9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnhWYWx1ZTxlLnhWYWx1ZT8tMTp0aGlzLnhWYWx1ZT5lLnhWYWx1ZT8xOnRoaXMuZXZlbnRUeXBlPGUuZXZlbnRUeXBlPy0xOnRoaXMuZXZlbnRUeXBlPmUuZXZlbnRUeXBlPzE6MH0sZ2V0SW5zZXJ0RXZlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnNlcnRFdmVudH0saXNJbnNlcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudFR5cGU9PT1Nbi5JTlNFUlR9LGlzU2FtZUxhYmVsOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dGhpcy5sYWJlbCYmdGhpcy5sYWJlbD09PXQubGFiZWx9LGdldERlbGV0ZUV2ZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxldGVFdmVudEluZGV4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTW59fSksTW4uSU5TRVJUPTEsTW4uREVMRVRFPTIsZShEbi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERufX0pLGUoQW4ucHJvdG90eXBlLHtpc1RyaXZpYWxJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJjE9PT10aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihBbi5pc0FkamFjZW50U2VnbWVudHMoZSxpKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe3ZhciByPXQuZ2V0TnVtUG9pbnRzKCktMTtpZigwPT09ZSYmaT09PXJ8fDA9PT1pJiZlPT09cilyZXR1cm4hMH19cmV0dXJuITF9LGdldFByb3BlckludGVyc2VjdGlvblBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9LHNldElzRG9uZUlmUHJvcGVySW50OmZ1bmN0aW9uKHQpe3RoaXMuaXNEb25lV2hlblByb3BlckludD10fSxoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3BlckludGVyaW9yfSxpc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0Q29vcmRpbmF0ZSgpO2lmKHQuaXNJbnRlcnNlY3Rpb24ocikpcmV0dXJuITB9cmV0dXJuITF9LGhhc1Byb3BlckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3Blcn0saGFzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX0saXNCb3VuZGFyeVBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPT1lJiYoISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVswXSl8fCEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMV0pKX0sc2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbih0LGUpe3RoaXMuYmR5Tm9kZXM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5iZHlOb2Rlc1swXT10LHRoaXMuYmR5Tm9kZXNbMV09ZX0sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLnJlY29yZElzb2xhdGVkJiYodC5zZXRJc29sYXRlZCghMSksbi5zZXRJc29sYXRlZCghMSkpLHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLGkpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLmluY2x1ZGVQcm9wZXImJnRoaXMubGkuaXNQcm9wZXIoKXx8KHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKSksdGhpcy5saS5pc1Byb3BlcigpJiYodGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLmxpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCksdGhpcy5oYXNQcm9wZXI9ITAsdGhpcy5pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLmxpLHRoaXMuYmR5Tm9kZXMpfHwodGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFufX0pLEFuLmlzQWRqYWNlbnRTZWdtZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX0saChGbixEbiksZShGbi5wcm90b3R5cGUse3ByZXBhcmVFdmVudHM6ZnVuY3Rpb24oKXtoby5zb3J0KHRoaXMuZXZlbnRzKTtmb3IodmFyIHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZXZlbnRzLmdldCh0KTtlLmlzRGVsZXRlKCkmJmUuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KHQpfX0sY29tcHV0ZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmV2ZW50cy5nZXQoZSk7aWYobi5pc0luc2VydCgpJiZ0aGlzLnByb2Nlc3NPdmVybGFwcyhlLG4uZ2V0RGVsZXRlRXZlbnRJbmRleCgpLG4sdCksdC5pc0RvbmUoKSlicmVha319ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFuJiZSKGFyZ3VtZW50c1swXSx5KSYmUihhcmd1bWVudHNbMV0seSkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmFkZEVkZ2VzKGksaSksdGhpcy5hZGRFZGdlcyhyLHIpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMocyl9ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmUihhcmd1bWVudHNbMF0seSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQW4pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTt1P3RoaXMuYWRkRWRnZXMobyxudWxsKTp0aGlzLmFkZEVkZ2VzKG8pLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoYSl9fSxhZGRFZGdlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKSxpPW4uZ2V0U3RhcnRJbmRleGVzKCkscj0wO3I8aS5sZW5ndGgtMTtyKyspe3ZhciBzPW5ldyBfbihuLHIpLG89bmV3IE1uKGUsbi5nZXRNaW5YKHIpLHMpO3RoaXMuZXZlbnRzLmFkZChvKSx0aGlzLmV2ZW50cy5hZGQobmV3IE1uKG4uZ2V0TWF4WChyKSxvKSl9fSxwcm9jZXNzT3ZlcmxhcHM6ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPW4uZ2V0T2JqZWN0KCkscz10O3M8ZTtzKyspe3ZhciBvPXRoaXMuZXZlbnRzLmdldChzKTtpZihvLmlzSW5zZXJ0KCkpe3ZhciBhPW8uZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbChvKXx8KHIuY29tcHV0ZUludGVyc2VjdGlvbnMoYSxpKSx0aGlzLm5PdmVybGFwcysrKX19fSxhZGRFZGdlczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2UobixuKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sZT1pLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2UobixyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZufX0pLGUoR24ucHJvdG90eXBlLHtnZXRNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW59LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHRoaXMubWluPmV8fHRoaXMubWF4PHQpfSxnZXRNYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyhuZXcgZyh0aGlzLm1pbiwwKSxuZXcgZyh0aGlzLm1heCwwKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdufX0pLGUocW4ucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWUscj0obi5taW4rbi5tYXgpLzIscz0oaS5taW4raS5tYXgpLzI7cmV0dXJuIHI8cz8tMTpyPnM/MTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcW59fSksR24uTm9kZUNvbXBhcmF0b3I9cW4saChCbixHbiksZShCbi5wcm90b3R5cGUse3F1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQsZSk/dm9pZCBuLnZpc2l0SXRlbSh0aGlzLml0ZW0pOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJufX0pLGgoem4sR24pLGUoem4ucHJvdG90eXBlLHtidWlsZEV4dGVudDpmdW5jdGlvbih0LGUpe3RoaXMubWluPU1hdGgubWluKHQubWluLGUubWluKSx0aGlzLm1heD1NYXRoLm1heCh0Lm1heCxlLm1heCl9LHF1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQsZSk/KG51bGwhPT10aGlzLm5vZGUxJiZ0aGlzLm5vZGUxLnF1ZXJ5KHQsZSxuKSx2b2lkKG51bGwhPT10aGlzLm5vZGUyJiZ0aGlzLm5vZGUyLnF1ZXJ5KHQsZSxuKSkpOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpufX0pLGUoVm4ucHJvdG90eXBlLHtidWlsZFRyZWU6ZnVuY3Rpb24oKXtoby5zb3J0KHRoaXMubGVhdmVzLG5ldyBJbnRlcnZhbFJUcmVlTm9kZS5Ob2RlQ29tcGFyYXRvcik7Zm9yKHZhciB0PXRoaXMubGVhdmVzLGU9bnVsbCxuPW5ldyBJOzspe2lmKHRoaXMuYnVpbGRMZXZlbCh0LG4pLDE9PT1uLnNpemUoKSlyZXR1cm4gbi5nZXQoMCk7ZT10LHQ9bixuPWV9fSxpbnNlcnQ6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGwhPT10aGlzLnJvb3QpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkluZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWRcIik7dGhpcy5sZWF2ZXMuYWRkKG5ldyBCbih0LGUsbikpfSxxdWVyeTpmdW5jdGlvbih0LGUsbil7dGhpcy5pbml0KCksdGhpcy5yb290LnF1ZXJ5KHQsZSxuKX0sYnVpbGRSb290OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/bnVsbDp2b2lkKHRoaXMucm9vdD10aGlzLmJ1aWxkVHJlZSgpKX0scHJpbnROb2RlOmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oc2UudG9MaW5lU3RyaW5nKG5ldyBnKHQubWluLHRoaXMubGV2ZWwpLG5ldyBnKHQubWF4LHRoaXMubGV2ZWwpKSl9LGluaXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD9udWxsOnZvaWQgdGhpcy5idWlsZFJvb3QoKX0sYnVpbGRMZXZlbDpmdW5jdGlvbih0LGUpe3RoaXMubGV2ZWwrKyxlLmNsZWFyKCk7Zm9yKHZhciBuPTA7bjx0LnNpemUoKTtuKz0yKXt2YXIgaT10LmdldChuKSxyPW4rMTx0LnNpemUoKT90LmdldChuKTpudWxsO2lmKG51bGw9PT1yKWUuYWRkKGkpO2Vsc2V7dmFyIHM9bmV3IHpuKHQuZ2V0KG4pLHQuZ2V0KG4rMSkpO2UuYWRkKHMpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZufX0pLGUoa24ucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7aWYodGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZyYmdCBpbnN0YW5jZW9mIGJ0KXt2YXIgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLmxpbmVzLmFkZChlKSxudWxsfXQgaW5zdGFuY2VvZiBTdCYmdGhpcy5saW5lcy5hZGQodCl9LHNldEZvcmNlVG9MaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3RoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmc9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtufX0pLGtuLmdldEdlb21ldHJ5PWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShrbi5nZXRMaW5lcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShrbi5nZXRMaW5lcyhlLG4pKX19LGtuLmdldExpbmVzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4ga24uZ2V0TGluZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpJiZSKGFyZ3VtZW50c1sxXSx2KSl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2tuLmdldExpbmVzKHIsbil9cmV0dXJuIG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9bmV3IEk7cmV0dXJuIHMuYXBwbHkobmV3IGtuKGEsbykpLGF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZSKGFyZ3VtZW50c1sxXSx2KSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdO3JldHVybiB1IGluc3RhbmNlb2YgU3Q/bC5hZGQodSk6dS5hcHBseShuZXcga24obCkpLGx9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZSKGFyZ3VtZW50c1swXSx2KSYmUihhcmd1bWVudHNbMV0sdikpe2Zvcih2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1hcmd1bWVudHNbMl0saT1oLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtrbi5nZXRMaW5lcyhyLGMsZil9cmV0dXJuIGN9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmUihhcmd1bWVudHNbMV0sdikpe3ZhciBnPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXTtyZXR1cm4gZy5hcHBseShuZXcga24oZCxwKSksZH19fSxlKFluLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKHQpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlufX0pLGUoVW4ucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGxlKHQpLG49bmV3IFhuKGUpO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHQueSx0LnksbiksZS5nZXRMb2NhdGlvbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVufX0pLGUoWG4ucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmNvdW50ZXIuY291bnRTZWdtZW50KGUuZ2V0Q29vcmRpbmF0ZSgwKSxlLmdldENvb3JkaW5hdGUoMSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhufX0pLGUoSG4ucHJvdG90eXBlLHtpbml0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1rbi5nZXRMaW5lcyh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRDb29yZGluYXRlcygpO3RoaXMuYWRkTGluZShyKX19LGFkZExpbmU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPW5ldyBjZSh0W2UtMV0sdFtlXSksaT1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxyPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuaW5kZXguaW5zZXJ0KGkscixuKX19LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBZbjtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5pbmRleC5xdWVyeShpLHIscyl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIbn19KSxVbi5TZWdtZW50VmlzaXRvcj1YbixVbi5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeT1IbixlKFduLnByb3RvdHlwZSx7Z2V0U2VnbWVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KSx0LnByaW50bG4oXCIgZGlzdCA9IFwiK3RoaXMuZGlzdCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmUoZS5zZWdtZW50SW5kZXgsZS5kaXN0KX0saXNFbmRQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYwPT09dGhpcy5kaXN0fHx0aGlzLnNlZ21lbnRJbmRleD09PXR9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmQrXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCtcIiBkaXN0ID0gXCIrdGhpcy5kaXN0fSxnZXREaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3R9LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg8dD8tMTp0aGlzLnNlZ21lbnRJbmRleD50PzE6dGhpcy5kaXN0PGU/LTE6dGhpcy5kaXN0PmU/MTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV259fSksZShqbi5wcm90b3R5cGUse3ByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIkludGVyc2VjdGlvbnM6XCIpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9LGFkZFNwbGl0RWRnZXM6ZnVuY3Rpb24odCl7dGhpcy5hZGRFbmRwb2ludHMoKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpLG49ZS5uZXh0KCk7ZS5oYXNOZXh0KCk7KXt2YXIgaT1lLm5leHQoKSxyPXRoaXMuY3JlYXRlU3BsaXRFZGdlKG4saSk7dC5hZGQociksbj1pfX0sYWRkRW5kcG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lZGdlLnB0cy5sZW5ndGgtMTt0aGlzLmFkZCh0aGlzLmVkZ2UucHRzWzBdLDAsMCksdGhpcy5hZGQodGhpcy5lZGdlLnB0c1t0XSx0LDApfSxjcmVhdGVTcGxpdEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyLGk9dGhpcy5lZGdlLnB0c1tlLnNlZ21lbnRJbmRleF0scj1lLmRpc3Q+MHx8IWUuY29vcmQuZXF1YWxzMkQoaSk7cnx8bi0tO3ZhciBzPW5ldyBBcnJheShuKS5maWxsKG51bGwpLG89MDtzW28rK109bmV3IGcodC5jb29yZCk7Zm9yKHZhciBhPXQuc2VnbWVudEluZGV4KzE7YTw9ZS5zZWdtZW50SW5kZXg7YSsrKXNbbysrXT10aGlzLmVkZ2UucHRzW2FdO3JldHVybiByJiYoc1tvXT1lLmNvb3JkKSxuZXcgSm4ocyxuZXcgZ24odGhpcy5lZGdlLmxhYmVsKSl9LGFkZDpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IFduKHQsZSxuKSxyPXRoaXMubm9kZU1hcC5nZXQoaSk7cmV0dXJuIG51bGwhPT1yP3I6KHRoaXMubm9kZU1hcC5wdXQoaSxpKSxpKX0saXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uY29vcmQuZXF1YWxzKHQpKXJldHVybiEwfXJldHVybiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqbn19KSxlKEtuLnByb3RvdHlwZSx7Z2V0Q2hhaW5TdGFydEluZGljZXM6ZnVuY3Rpb24odCl7dmFyIGU9MCxuPW5ldyBJO24uYWRkKG5ldyBiKGUpKTtkb3t2YXIgaT10aGlzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKG5ldyBiKGkpKSxlPWl9d2hpbGUoZTx0Lmxlbmd0aC0xKTt2YXIgcj1Lbi50b0ludEFycmF5KG4pO3JldHVybiByfSxmaW5kQ2hhaW5FbmQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49SmUucXVhZHJhbnQodFtlXSx0W2UrMV0pLGk9ZSsxO2k8dC5sZW5ndGg7KXt2YXIgcj1KZS5xdWFkcmFudCh0W2ktMV0sdFtpXSk7aWYociE9PW4pYnJlYWs7aSsrfXJldHVybiBpLTF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtufX0pLEtuLnRvSW50QXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfSxlKFpuLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LGdldE1heFg6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU+bj9lOm59LGdldE1pblg6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3RdXS54LG49dGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W3QrMV1dLng7cmV0dXJuIGU8bj9lOm59LGNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW46ZnVuY3Rpb24oKXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbdF0sdGhpcy5zdGFydEluZGV4W3QrMV0sZSxlLnN0YXJ0SW5kZXhbbl0sZS5zdGFydEluZGV4W24rMV0saSl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdLHU9YXJndW1lbnRzWzRdLGw9YXJndW1lbnRzWzVdLGg9dGhpcy5wdHNbcl0sYz10aGlzLnB0c1tzXSxmPW8ucHRzW2FdLGc9by5wdHNbdV07aWYocy1yPT09MSYmdS1hPT09MSlyZXR1cm4gbC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuZSxyLG8uZSxhKSxudWxsO2lmKHRoaXMuZW52MS5pbml0KGgsYyksdGhpcy5lbnYyLmluaXQoZixnKSwhdGhpcy5lbnYxLmludGVyc2VjdHModGhpcy5lbnYyKSlyZXR1cm4gbnVsbDt2YXIgZD1NYXRoLnRydW5jKChyK3MpLzIpLHA9TWF0aC50cnVuYygoYSt1KS8yKTtyPGQmJihhPHAmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihyLGQsbyxhLHAsbCkscDx1JiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4ocixkLG8scCx1LGwpKSxkPHMmJihhPHAmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihkLHMsbyxhLHAsbCkscDx1JiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oZCxzLG8scCx1LGwpKX19LGdldFN0YXJ0SW5kZXhlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0SW5kZXh9LGNvbXB1dGVJbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLnN0YXJ0SW5kZXgubGVuZ3RoLTE7bisrKWZvcih2YXIgaT0wO2k8dC5zdGFydEluZGV4Lmxlbmd0aC0xO2krKyl0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obix0LGksZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFpufX0pLGUoUW4ucHJvdG90eXBlLHtnZXREZXB0aDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRlcHRoW3RdW2VdfSxzZXREZXB0aDpmdW5jdGlvbih0LGUsbil7dGhpcy5kZXB0aFt0XVtlXT1ufSxpc051bGw6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PTA7dDwyO3QrKylmb3IodmFyIGU9MDtlPDM7ZSsrKWlmKHRoaXMuZGVwdGhbdF1bZV0hPT1Rbi5OVUxMX1ZBTFVFKXJldHVybiExO3JldHVybiEwfWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGVwdGhbbl1bMV09PT1Rbi5OVUxMX1ZBTFVFfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZGVwdGhbaV1bcl09PT1Rbi5OVUxMX1ZBTFVFfX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDwyO3QrKylpZighdGhpcy5pc051bGwodCkpe3ZhciBlPXRoaXMuZGVwdGhbdF1bMV07dGhpcy5kZXB0aFt0XVsyXTxlJiYoZT10aGlzLmRlcHRoW3RdWzJdKSxlPDAmJihlPTApO2Zvcih2YXIgbj0xO248MztuKyspe3ZhciBpPTA7dGhpcy5kZXB0aFt0XVtuXT5lJiYoaT0xKSx0aGlzLmRlcHRoW3RdW25dPWl9fX0sZ2V0RGVsdGE6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVwdGhbdF1bY24uUklHSFRdLXRoaXMuZGVwdGhbdF1bY24uTEVGVF19LGdldExvY2F0aW9uOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGVwdGhbdF1bZV08PTA/TC5FWFRFUklPUjpMLklOVEVSSU9SfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiQTogXCIrdGhpcy5kZXB0aFswXVsxXStcIixcIit0aGlzLmRlcHRoWzBdWzJdK1wiIEI6IFwiK3RoaXMuZGVwdGhbMV1bMV0rXCIsXCIrdGhpcy5kZXB0aFsxXVsyXX0sYWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTwyO2UrKylmb3IodmFyIG49MTtuPDM7bisrKXt2YXIgaT10LmdldExvY2F0aW9uKGUsbik7aSE9PUwuRVhURVJJT1ImJmkhPT1MLklOVEVSSU9SfHwodGhpcy5pc051bGwoZSxuKT90aGlzLmRlcHRoW2VdW25dPVFuLmRlcHRoQXRMb2NhdGlvbihpKTp0aGlzLmRlcHRoW2VdW25dKz1Rbi5kZXB0aEF0TG9jYXRpb24oaSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtvPT09TC5JTlRFUklPUiYmdGhpcy5kZXB0aFtyXVtzXSsrfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUW59fSksUW4uZGVwdGhBdExvY2F0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09TC5FWFRFUklPUj8wOnQ9PT1MLklOVEVSSU9SPzE6UW4uTlVMTF9WQUxVRX0sUW4uTlVMTF9WQUxVRT0tMSxoKEpuLG1uKSxlKEpuLnByb3RvdHlwZSx7Z2V0RGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZXB0aH0sZ2V0Q29sbGFwc2VkRWRnZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3RbMF09dGhpcy5wdHNbMF0sdFsxXT10aGlzLnB0c1sxXTt2YXIgZT1uZXcgSm4odCxnbi50b0xpbmVMYWJlbCh0aGlzLmxhYmVsKSk7cmV0dXJuIGV9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJc29sYXRlZH0sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LHNldElzb2xhdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzSXNvbGF0ZWQ9dH0sc2V0TmFtZTpmdW5jdGlvbih0KXt0aGlzLm5hbWU9dH0sZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEpuKSlyZXR1cm4hMTt2YXIgZT10O2lmKHRoaXMucHRzLmxlbmd0aCE9PWUucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49ITAsaT0hMCxyPXRoaXMucHRzLmxlbmd0aCxzPTA7czx0aGlzLnB0cy5sZW5ndGg7cysrKWlmKHRoaXMucHRzW3NdLmVxdWFsczJEKGUucHRzW3NdKXx8KG49ITEpLHRoaXMucHRzW3NdLmVxdWFsczJEKGUucHRzWy0tcl0pfHwoaT0hMSksIW4mJiFpKXJldHVybiExO3JldHVybiEwfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucHRzLmxlbmd0aD4wP3RoaXMucHRzWzBdOm51bGw7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wdHNbdF19fSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKSx0LnByaW50KFwiTElORVNUUklORyAoXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTt0LnByaW50KFwiKSAgXCIrdGhpcy5sYWJlbCtcIiBcIit0aGlzLmRlcHRoRGVsdGEpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7Sm4udXBkYXRlSU0odGhpcy5sYWJlbCx0KX0saXNDb2xsYXBzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMubGFiZWwuaXNBcmVhKCkmJigzPT09dGhpcy5wdHMubGVuZ3RoJiYhIXRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSkpfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0TWF4aW11bVNlZ21lbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGgtMX0sZ2V0RGVwdGhEZWx0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlcHRoRGVsdGF9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LHByaW50UmV2ZXJzZTpmdW5jdGlvbih0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKTtmb3IodmFyIGU9dGhpcy5wdHMubGVuZ3RoLTE7ZT49MDtlLS0pdC5wcmludCh0aGlzLnB0c1tlXStcIiBcIik7dC5wcmludGxuKFwiXCIpfSxnZXRNb25vdG9uZUNoYWluRWRnZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5tY2UmJih0aGlzLm1jZT1uZXcgWm4odGhpcykpLHRoaXMubWNlfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7dGhpcy5lbnY9bmV3IEM7Zm9yKHZhciB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMuZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLnB0c1t0XSl9cmV0dXJuIHRoaXMuZW52fSxhZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IGcodC5nZXRJbnRlcnNlY3Rpb24oaSkpLHM9ZSxvPXQuZ2V0RWRnZURpc3RhbmNlKG4saSksYT1zKzE7aWYoYTx0aGlzLnB0cy5sZW5ndGgpe3ZhciB1PXRoaXMucHRzW2FdO3IuZXF1YWxzMkQodSkmJihzPWEsbz0wKX10aGlzLmVpTGlzdC5hZGQocixzLG8pfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3QuYXBwZW5kKFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKSx0LmFwcGVuZChcIkxJTkVTVFJJTkcgKFwiKTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LmFwcGVuZChcIixcIiksdC5hcHBlbmQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTtyZXR1cm4gdC5hcHBlbmQoXCIpICBcIit0aGlzLmxhYmVsK1wiIFwiK3RoaXMuZGVwdGhEZWx0YSksdC50b1N0cmluZygpfSxpc1BvaW50d2lzZUVxdWFsOmZ1bmN0aW9uKHQpe2lmKHRoaXMucHRzLmxlbmd0aCE9PXQucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspaWYoIXRoaXMucHRzW2VdLmVxdWFsczJEKHQucHRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH0sc2V0RGVwdGhEZWx0YTpmdW5jdGlvbih0KXt0aGlzLmRlcHRoRGVsdGE9dH0sZ2V0RWRnZUludGVyc2VjdGlvbkxpc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5laUxpc3R9LGFkZEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtpKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEpufX0pLEpuLnVwZGF0ZUlNPWZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG1uLnByb3RvdHlwZS51cGRhdGVJTS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Uuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGNuLk9OKSx0LmdldExvY2F0aW9uKDEsY24uT04pLDEpLHQuaXNBcmVhKCkmJihlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxjbi5MRUZUKSx0LmdldExvY2F0aW9uKDEsY24uTEVGVCksMiksZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsY24uUklHSFQpLHQuZ2V0TG9jYXRpb24oMSxjbi5SSUdIVCksMikpfSxoKCRuLENuKSxlKCRuLnByb3RvdHlwZSx7aW5zZXJ0Qm91bmRhcnlQb2ludDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubm9kZXMuYWRkTm9kZShlKSxpPW4uZ2V0TGFiZWwoKSxyPTEscz1MLk5PTkU7cz1pLmdldExvY2F0aW9uKHQsY24uT04pLHM9PT1MLkJPVU5EQVJZJiZyKys7dmFyIG89JG4uZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5ib3VuZGFyeU5vZGVSdWxlLHIpO2kuc2V0TG9jYXRpb24odCxvKX0sY29tcHV0ZVNlbGZOb2RlczpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2Rlcyh0LGUsITEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz1uZXcgQW4obiwoITApLCghMSkpO3Muc2V0SXNEb25lSWZQcm9wZXJJbnQocik7dmFyIG89dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKSxhPXRoaXMucGFyZW50R2VvbSBpbnN0YW5jZW9mIGJ0fHx0aGlzLnBhcmVudEdlb20gaW5zdGFuY2VvZiBUdHx8dGhpcy5wYXJlbnRHZW9tIGluc3RhbmNlb2YgT3QsdT1pfHwhYTtyZXR1cm4gby5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLmVkZ2VzLHMsdSksdGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModGhpcy5hcmdJbmRleCksc319LGNvbXB1dGVTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmVpTGlzdC5hZGRTcGxpdEVkZ2VzKHQpfX0sY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgQW4oZSxuLCghMCkpO2kuc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSx0LmdldEJvdW5kYXJ5Tm9kZXMoKSk7dmFyIHI9dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKTtyZXR1cm4gci5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLmVkZ2VzLHQuZWRnZXMsaSksaX0sZ2V0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRHZW9tfSxnZXRCb3VuZGFyeU5vZGVSdWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRhcnlOb2RlUnVsZX0saGFzVG9vRmV3UG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c30sYWRkUG9pbnQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldENvb3JkaW5hdGUoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZSxMLklOVEVSSU9SKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxuLEwuSU5URVJJT1IpfX0sYWRkUG9seWdvbjpmdW5jdGlvbih0KXt0aGlzLmFkZFBvbHlnb25SaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksTC5FWFRFUklPUixMLklOVEVSSU9SKTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXt2YXIgbj10LmdldEludGVyaW9yUmluZ04oZSk7dGhpcy5hZGRQb2x5Z29uUmluZyhuLEwuSU5URVJJT1IsTC5FWFRFUklPUil9fSxhZGRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGVbMF0sTC5CT1VOREFSWSksdGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGVbZS5sZW5ndGgtMV0sTC5CT1VOREFSWSl9LGFkZExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLmludmFsaWRQb2ludD1lWzBdLG51bGw7dmFyIG49bmV3IEpuKGUsbmV3IGduKHRoaXMuYXJnSW5kZXgsTC5JTlRFUklPUikpO3RoaXMubGluZUVkZ2VNYXAucHV0KHQsbiksdGhpcy5pbnNlcnRFZGdlKG4pLGYuaXNUcnVlKGUubGVuZ3RoPj0yLFwiZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludFwiKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5hcmdJbmRleCxlWzBdKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5hcmdJbmRleCxlW2UubGVuZ3RoLTFdKX0sZ2V0SW52YWxpZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52YWxpZFBvaW50fSxnZXRCb3VuZGFyeVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSxlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTAsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtlW24rK109ci5nZXRDb29yZGluYXRlKCkuY29weSgpfXJldHVybiBlfSxnZXRCb3VuZGFyeU5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmJvdW5kYXJ5Tm9kZXMmJih0aGlzLmJvdW5kYXJ5Tm9kZXM9dGhpcy5ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuYXJnSW5kZXgpKSx0aGlzLmJvdW5kYXJ5Tm9kZXN9LGFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pc0JvdW5kYXJ5Tm9kZSh0LGUpP251bGw6dm9pZChuPT09TC5CT1VOREFSWSYmdGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlP3RoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpOnRoaXMuaW5zZXJ0UG9pbnQodCxlLG4pKX0sYWRkUG9seWdvblJpbmc6ZnVuY3Rpb24odCxlLG4pe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBpPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihpLmxlbmd0aDw0KXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5pbnZhbGlkUG9pbnQ9aVswXSxudWxsO3ZhciByPWUscz1uO2hlLmlzQ0NXKGkpJiYocj1uLHM9ZSk7dmFyIG89bmV3IEpuKGksbmV3IGduKHRoaXMuYXJnSW5kZXgsTC5CT1VOREFSWSxyLHMpKTt0aGlzLmxpbmVFZGdlTWFwLnB1dCh0LG8pLHRoaXMuaW5zZXJ0RWRnZShvKSx0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsaVswXSxMLkJPVU5EQVJZKX0saW5zZXJ0UG9pbnQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMubm9kZXMuYWRkTm9kZShlKSxyPWkuZ2V0TGFiZWwoKTtudWxsPT09cj9pLmxhYmVsPW5ldyBnbih0LG4pOnIuc2V0TG9jYXRpb24odCxuKX0sY3JlYXRlRWRnZVNldEludGVyc2VjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBGbn0sYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTt0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQscy5jb29yZCxpKX19LGFkZDpmdW5jdGlvbigpe2lmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBDbi5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIE90JiYodGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSExKSx0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fSxhZGRDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19LGxvY2F0ZTpmdW5jdGlvbih0KXtyZXR1cm4gUih0aGlzLnBhcmVudEdlb20sUnQpJiZ0aGlzLnBhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpPjUwPyhudWxsPT09dGhpcy5hcmVhUHRMb2NhdG9yJiYodGhpcy5hcmVhUHRMb2NhdG9yPW5ldyBVbih0aGlzLnBhcmVudEdlb20pKSx0aGlzLmFyZWFQdExvY2F0b3IubG9jYXRlKHQpKTp0aGlzLnB0TG9jYXRvci5sb2NhdGUodCx0aGlzLnBhcmVudEdlb20pfSxmaW5kRWRnZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubGluZUVkZ2VNYXAuZ2V0KHQpfXJldHVybiBDbi5wcm90b3R5cGUuZmluZEVkZ2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkbn19KSwkbi5kZXRlcm1pbmVCb3VuZGFyeT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlzSW5Cb3VuZGFyeShlKT9MLkJPVU5EQVJZOkwuSU5URVJJT1J9LGUodGkucHJvdG90eXBlLHtnZXRBcmdHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcmdbdF0uZ2V0R2VvbWV0cnkoKX0sc2V0Q29tcHV0YXRpb25QcmVjaXNpb246ZnVuY3Rpb24odCl7dGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMubGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRpfX0pLGUoZWkucHJvdG90eXBlLHtjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPWVpLmNvbXBhcmVPcmllbnRlZCh0aGlzLnB0cyx0aGlzLl9vcmllbnRhdGlvbixlLnB0cyxlLl9vcmllbnRhdGlvbik7cmV0dXJuIG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlaX19KSxlaS5vcmllbnRhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gMT09PUguaW5jcmVhc2luZ0RpcmVjdGlvbih0KX0sZWkuY29tcGFyZU9yaWVudGVkPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1lPzE6LTEscz1pPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGE9aT9uLmxlbmd0aDotMSx1PWU/MDp0Lmxlbmd0aC0xLGw9aT8wOm4ubGVuZ3RoLTE7Oyl7dmFyIGg9dFt1XS5jb21wYXJlVG8obltsXSk7aWYoMCE9PWgpcmV0dXJuIGg7dSs9cixsKz1zO3ZhciBjPXU9PT1vLGY9bD09PWE7aWYoYyYmIWYpcmV0dXJuLTE7aWYoIWMmJmYpcmV0dXJuIDE7aWYoYyYmZilyZXR1cm4gMH19LGUobmkucHJvdG90eXBlLHtwcmludDpmdW5jdGlvbih0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmVkZ2VzLmdldChlKTtlPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoXCIoXCIpO2Zvcih2YXIgaT1uLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGg7cisrKXI+MCYmdC5wcmludChcIixcIiksdC5wcmludChpW3JdLngrXCIgXCIraVtyXS55KTt0LnByaW50bG4oXCIpXCIpfXQucHJpbnQoXCIpICBcIil9LGFkZEFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9LGZpbmRFZGdlSW5kZXg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5lZGdlcy5nZXQoZSkuZXF1YWxzKHQpKXJldHVybiBlO3JldHVybi0xfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LGdldDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lZGdlcy5nZXQodCl9LGZpbmRFcXVhbEVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGVpKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLm9jYU1hcC5nZXQoZSk7cmV0dXJuIG59LGFkZDpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLmFkZCh0KTt2YXIgZT1uZXcgZWkodC5nZXRDb29yZGluYXRlcygpKTt0aGlzLm9jYU1hcC5wdXQoZSx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbml9fSksaChpaSx0aSksZShpaS5wcm90b3R5cGUse2luc2VydFVuaXF1ZUVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXt2YXIgbj1lLmdldExhYmVsKCksaT10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwoaT1uZXcgZ24odC5nZXRMYWJlbCgpKSxpLmZsaXAoKSk7dmFyIHI9ZS5nZXREZXB0aCgpO3IuaXNOdWxsKCkmJnIuYWRkKG4pLHIuYWRkKGkpLG4ubWVyZ2UoaSl9ZWxzZSB0aGlzLmVkZ2VMaXN0LmFkZCh0KX0sZ2V0R3JhcGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaH0sY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0U3ltKCk7ZS5pc0luUmVzdWx0KCkmJm4uaXNJblJlc3VsdCgpJiYoZS5zZXRJblJlc3VsdCghMSksbi5zZXRJblJlc3VsdCghMSkpfX0saXNDb3ZlcmVkQnlMQTpmdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5yZXN1bHRMaW5lTGlzdCl8fCEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdFBvbHlMaXN0KX0sY29tcHV0ZUdlb21ldHJ5OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBJO3JldHVybiByLmFkZEFsbCh0KSxyLmFkZEFsbChlKSxyLmFkZEFsbChuKSxyLmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpLHRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCksdGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKSx0aGlzLmdlb21GYWN0KTp0aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkocil9LG1lcmdlU3ltTGFiZWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCl9fSxpc0NvdmVyZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj10aGlzLnB0TG9jYXRvci5sb2NhdGUodCxpKTtpZihyIT09TC5FWFRFUklPUilyZXR1cm4hMH1yZXR1cm4hMX0scmVwbGFjZUNvbGxhcHNlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5lZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5pc0NvbGxhcHNlZCgpJiYoZS5yZW1vdmUoKSx0LmFkZChuLmdldENvbGxhcHNlZEVkZ2UoKSkpfXRoaXMuZWRnZUxpc3QuYWRkQWxsKHQpfSx1cGRhdGVOb2RlTGFiZWxsaW5nOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtlLmdldExhYmVsKCkubWVyZ2Uobil9fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wdXRlT3ZlcmxheSh0KSx0aGlzLnJlc3VsdEdlb219LGluc2VydFVuaXF1ZUVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2Uobil9fSxjb21wdXRlT3ZlcmxheTpmdW5jdGlvbih0KXt0aGlzLmNvcHlQb2ludHMoMCksdGhpcy5jb3B5UG9pbnRzKDEpLHRoaXMuYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKSx0aGlzLmFyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5hcmdbMV0sdGhpcy5saSwhMCk7dmFyIGU9bmV3IEk7dGhpcy5hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoZSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhlKSx0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCksdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKSxcbmxuLmNoZWNrVmFsaWQodGhpcy5lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmdyYXBoLmFkZEVkZ2VzKHRoaXMuZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5jb21wdXRlTGFiZWxsaW5nKCksdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpLHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyh0KSx0aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7dmFyIG49bmV3IFNuKHRoaXMuZ2VvbUZhY3QpO24uYWRkKHRoaXMuZ3JhcGgpLHRoaXMucmVzdWx0UG9seUxpc3Q9bi5nZXRQb2x5Z29ucygpO3ZhciBpPW5ldyB3bih0aGlzLHRoaXMuZ2VvbUZhY3QsdGhpcy5wdExvY2F0b3IpO3RoaXMucmVzdWx0TGluZUxpc3Q9aS5idWlsZCh0KTt2YXIgcj1uZXcgTG4odGhpcyx0aGlzLmdlb21GYWN0LHRoaXMucHRMb2NhdG9yKTt0aGlzLnJlc3VsdFBvaW50TGlzdD1yLmJ1aWxkKHQpLHRoaXMucmVzdWx0R2VvbT10aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLnJlc3VsdFBvaW50TGlzdCx0aGlzLnJlc3VsdExpbmVMaXN0LHRoaXMucmVzdWx0UG9seUxpc3QsdCl9LGxhYmVsSW5jb21wbGV0ZU5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9LGNvcHlQb2ludHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT10aGlzLmdyYXBoLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpO2kuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX0sZmluZFJlc3VsdEFyZWFFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtpLmlzQXJlYSgpJiYhbi5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmaWkuaXNSZXN1bHRPZk9wKGkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCksaS5nZXRMb2NhdGlvbigxLGNuLlJJR0hUKSx0KSYmbi5zZXRJblJlc3VsdCghMCl9fSxjb21wdXRlTGFiZWxzRnJvbURlcHRoczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKSxpPWUuZ2V0RGVwdGgoKTtpZighaS5pc051bGwoKSl7aS5ub3JtYWxpemUoKTtmb3IodmFyIHI9MDtyPDI7cisrKW4uaXNOdWxsKHIpfHwhbi5pc0FyZWEoKXx8aS5pc051bGwocil8fCgwPT09aS5nZXREZWx0YShyKT9uLnRvTGluZShyKTooZi5pc1RydWUoIWkuaXNOdWxsKHIsY24uTEVGVCksXCJkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24ocixjbi5MRUZULGkuZ2V0TG9jYXRpb24ocixjbi5MRUZUKSksZi5pc1RydWUoIWkuaXNOdWxsKHIsY24uUklHSFQpLFwiZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbihyLGNuLlJJR0hULGkuZ2V0TG9jYXRpb24ocixjbi5SSUdIVCkpKSl9fX0sY29tcHV0ZUxhYmVsbGluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuYXJnKX10aGlzLm1lcmdlU3ltTGFiZWxzKCksdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCl9LGxhYmVsSW5jb21wbGV0ZU5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO24uaXNJc29sYXRlZCgpJiYodCsrLGkuaXNOdWxsKDApP3RoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShuLDApOnRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShuLDEpKSxuLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKGkpfX0saXNDb3ZlcmVkQnlBOmZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdFBvbHlMaXN0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaWl9fSksaWkub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgaWkodCxlKSxyPWkuZ2V0UmVzdWx0R2VvbWV0cnkobik7cmV0dXJuIHJ9LGlpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuSU5URVJTRUNUSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXt2YXIgbj1lO3JldHVybiBobi5tYXAodCx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTWFwT3BdfSxtYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKG4pfX0pfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5JTlRFUlNFQ1RJT04pfSxpaS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0saWkucmVzdWx0RGltZW5zaW9uPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmdldERpbWVuc2lvbigpLHI9bi5nZXREaW1lbnNpb24oKSxzPS0xO3N3aXRjaCh0KXtjYXNlIGlpLklOVEVSU0VDVElPTjpzPU1hdGgubWluKGkscik7YnJlYWs7Y2FzZSBpaS5VTklPTjpzPU1hdGgubWF4KGkscik7YnJlYWs7Y2FzZSBpaS5ESUZGRVJFTkNFOnM9aTticmVhaztjYXNlIGlpLlNZTURJRkZFUkVOQ0U6cz1NYXRoLm1heChpLHIpfXJldHVybiBzfSxpaS5jcmVhdGVFbXB0eVJlc3VsdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3N3aXRjaChpaS5yZXN1bHREaW1lbnNpb24odCxlLG4pKXtjYXNlLTE6cj1pLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7YnJlYWs7Y2FzZSAwOnI9aS5jcmVhdGVQb2ludCgpO2JyZWFrO2Nhc2UgMTpyPWkuY3JlYXRlTGluZVN0cmluZygpO2JyZWFrO2Nhc2UgMjpyPWkuY3JlYXRlUG9seWdvbigpfXJldHVybiByfSxpaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaXNFbXB0eSgpP2lpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLkRJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTplLmlzRW1wdHkoKT90LmNvcHkoKToodC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSkpfSxpaS5pc1Jlc3VsdE9mT3A9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbigwKSxpPXQuZ2V0TG9jYXRpb24oMSk7cmV0dXJuIGlpLmlzUmVzdWx0T2ZPcChuLGksZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtzd2l0Y2gocj09PUwuQk9VTkRBUlkmJihyPUwuSU5URVJJT1IpLHM9PT1MLkJPVU5EQVJZJiYocz1MLklOVEVSSU9SKSxvKXtjYXNlIGlpLklOVEVSU0VDVElPTjpyZXR1cm4gcj09PUwuSU5URVJJT1ImJnM9PT1MLklOVEVSSU9SO2Nhc2UgaWkuVU5JT046cmV0dXJuIHI9PT1MLklOVEVSSU9SfHxzPT09TC5JTlRFUklPUjtjYXNlIGlpLkRJRkZFUkVOQ0U6cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzIT09TC5JTlRFUklPUjtjYXNlIGlpLlNZTURJRkZFUkVOQ0U6cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzIT09TC5JTlRFUklPUnx8ciE9PUwuSU5URVJJT1ImJnM9PT1MLklOVEVSSU9SfXJldHVybiExfX0saWkuSU5URVJTRUNUSU9OPTEsaWkuVU5JT049MixpaS5ESUZGRVJFTkNFPTMsaWkuU1lNRElGRkVSRU5DRT00LGUocmkucHJvdG90eXBlLHtzZWxmU25hcDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSWUodCksbj1lLnNuYXBUbyh0LHRoaXMuc25hcFRvbGVyYW5jZSk7cmV0dXJuIG59LHJlbW92ZUNvbW1vbkJpdHM6ZnVuY3Rpb24odCl7dGhpcy5jYnI9bmV3IFNlLHRoaXMuY2JyLmFkZCh0WzBdKSx0aGlzLmNici5hZGQodFsxXSk7dmFyIGU9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIGVbMF09dGhpcy5jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzBdLmNvcHkoKSksZVsxXT10aGlzLmNici5yZW1vdmVDb21tb25CaXRzKHRbMV0uY29weSgpKSxlfSxwcmVwYXJlUmVzdWx0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNici5hZGRDb21tb25CaXRzKHQpLHR9LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc25hcCh0aGlzLmdlb20pLG49aWkub3ZlcmxheU9wKGVbMF0sZVsxXSx0KTtyZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KG4pfSxjaGVja1ZhbGlkOmZ1bmN0aW9uKHQpe3QuaXNWYWxpZCgpfHxBLm91dC5wcmludGxuKFwiU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkXCIpfSxjb21wdXRlU25hcFRvbGVyYW5jZTpmdW5jdGlvbigpe3RoaXMuc25hcFRvbGVyYW5jZT1JZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSl9LHNuYXA6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpLG49SWUuc25hcChlWzBdLGVbMV0sdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcml9fSkscmkub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgcmkodCxlKTtyZXR1cm4gaS5nZXRSZXN1bHRHZW9tZXRyeShuKX0scmkudW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHJpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLklOVEVSU0VDVElPTil9LHJpLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0scmkuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpfSxlKHNpLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbCxuPSExLGk9bnVsbDt0cnl7ZT1paS5vdmVybGF5T3AodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSx0KTt2YXIgcj0hMDtyJiYobj0hMCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbCkpdGhyb3cgdDtpPXR9ZmluYWxseXt9aWYoIW4pdHJ5e2U9cmkub3ZlcmxheU9wKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0sdCl9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGw/aTp0fWZpbmFsbHl7fXJldHVybiBlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzaX19KSxzaS5vdmVybGF5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBzaSh0LGUpO3JldHVybiBpLmdldFJlc3VsdEdlb21ldHJ5KG4pfSxzaS51bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sc2kuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuSU5URVJTRUNUSU9OKX0sc2kuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlNZTURJRkZFUkVOQ0UpfSxzaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSl9LGUob2kucHJvdG90eXBlLHthZGRQb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPW51bGwsbj0wLGk9dGhpcy5ob3Jpem9udGFsQmlzZWN0b3IodCk7aWYoMD09PWkuZ2V0TGVuZ3RoKCkpbj0wLGU9aS5nZXRDb29yZGluYXRlKCk7ZWxzZXt2YXIgcj1zaS5vdmVybGF5T3AoaSx0LGlpLklOVEVSU0VDVElPTikscz10aGlzLndpZGVzdEdlb21ldHJ5KHIpO249cy5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSxlPW9pLmNlbnRyZShzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9KG51bGw9PT10aGlzLmludGVyaW9yUG9pbnR8fG4+dGhpcy5tYXhXaWR0aCkmJih0aGlzLmludGVyaW9yUG9pbnQ9ZSx0aGlzLm1heFdpZHRoPW4pfSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sd2lkZXN0R2VvbWV0cnk6ZnVuY3Rpb24gdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZnQpe3ZhciBlPWFyZ3VtZW50c1swXTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gZTtmb3IodmFyIHQ9ZS5nZXRHZW9tZXRyeU4oMCksbj0xO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWUuZ2V0R2VvbWV0cnlOKG4pLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpPnQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCkmJih0PWUuZ2V0R2VvbWV0cnlOKG4pKTtyZXR1cm4gdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBpPWFyZ3VtZW50c1swXTtyZXR1cm4gaSBpbnN0YW5jZW9mIGZ0P3RoaXMud2lkZXN0R2VvbWV0cnkoaSk6aX19LGhvcml6b250YWxCaXNlY3RvcjpmdW5jdGlvbih0KXt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPWFpLmdldEJpc2VjdG9yWSh0KTtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBnKGUuZ2V0TWluWCgpLG4pLG5ldyBnKGUuZ2V0TWF4WCgpLG4pXSl9LGFkZDpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5TihuKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9pfX0pLG9pLmNlbnRyZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcob2kuYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKSxvaS5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpKX0sb2kuYXZnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQrZSkvMn0sZShhaS5wcm90b3R5cGUse3VwZGF0ZUludGVydmFsOmZ1bmN0aW9uKHQpe3Q8PXRoaXMuY2VudHJlWT90PnRoaXMubG9ZJiYodGhpcy5sb1k9dCk6dD50aGlzLmNlbnRyZVkmJnQ8dGhpcy5oaVkmJih0aGlzLmhpWT10KX0sZ2V0QmlzZWN0b3JZOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzKHRoaXMucG9seS5nZXRFeHRlcmlvclJpbmcoKSk7Zm9yKHZhciB0PTA7dDx0aGlzLnBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXRoaXMucHJvY2Vzcyh0aGlzLnBvbHkuZ2V0SW50ZXJpb3JSaW5nTih0KSk7dmFyIGU9b2kuYXZnKHRoaXMuaGlZLHRoaXMubG9ZKTtyZXR1cm4gZX0scHJvY2VzczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPTA7bjxlLnNpemUoKTtuKyspe3ZhciBpPWUuZ2V0WShuKTt0aGlzLnVwZGF0ZUludGVydmFsKGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYWl9fSksYWkuZ2V0QmlzZWN0b3JZPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhaSh0KTtyZXR1cm4gZS5nZXRCaXNlY3RvclkoKX0sb2kuU2FmZUJpc2VjdG9yRmluZGVyPWFpLGUodWkucHJvdG90eXBlLHthZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRFbmRwb2ludHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGRFbmRwb2ludHMoZS5nZXRHZW9tZXRyeU4obikpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuYWRkKGlbMF0pLHRoaXMuYWRkKGlbaS5sZW5ndGgtMV0pfX0sZ2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9yUG9pbnR9LGFkZEludGVyaW9yOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkSW50ZXJpb3IodC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGRJbnRlcmlvcihlLmdldEdlb21ldHJ5TihuKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KWZvcih2YXIgaT1hcmd1bWVudHNbMF0sbj0xO248aS5sZW5ndGgtMTtuKyspdGhpcy5hZGQoaVtuXSl9LGFkZDpmdW5jdGlvbih0KXt2YXIgZT10LmRpc3RhbmNlKHRoaXMuY2VudHJvaWQpO2U8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMuaW50ZXJpb3JQb2ludD1uZXcgZyh0KSx0aGlzLm1pbkRpc3RhbmNlPWUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1aX19KSxlKGxpLnByb3RvdHlwZSx7Z2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9yUG9pbnR9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKG4pKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGk9YXJndW1lbnRzWzBdLHI9aS5kaXN0YW5jZSh0aGlzLmNlbnRyb2lkKTtyPHRoaXMubWluRGlzdGFuY2UmJih0aGlzLmludGVyaW9yUG9pbnQ9bmV3IGcoaSksdGhpcy5taW5EaXN0YW5jZT1yKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxpfX0pLGUoaGkucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5zZWxlY3RlZFNlZ21lbnQpLHRoaXMuc2VsZWN0KHRoaXMuc2VsZWN0ZWRTZWdtZW50KX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhpfX0pLGUoY2kucHJvdG90eXBlLHtoYXNDaGlsZHJlbjpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8Mjt0KyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVt0XSlyZXR1cm4hMDtyZXR1cm4hMX0saXNQcnVuYWJsZTpmdW5jdGlvbigpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfSxhZGRBbGxJdGVtczpmdW5jdGlvbih0KXt0LmFkZEFsbCh0aGlzLml0ZW1zKTtmb3IodmFyIGU9MDtlPDI7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJnRoaXMuc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH0sc2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPDI7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLml0ZW1zLnNpemUoKX0sYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmc6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXR8fHRoaXMuaXNTZWFyY2hNYXRjaCh0KT8oZS5hZGRBbGwodGhpcy5pdGVtcyksbnVsbCE9PXRoaXMuc3Vibm9kZVswXSYmdGhpcy5zdWJub2RlWzBdLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSksdm9pZChudWxsIT09dGhpcy5zdWJub2RlWzFdJiZ0aGlzLnN1Ym5vZGVbMV0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKSkpOm51bGx9LGhhc0l0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXRlbXMuaXNFbXB0eSgpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2Zvcih2YXIgbj0hMSxpPTA7aTwyO2krKylpZihudWxsIT09dGhpcy5zdWJub2RlW2ldJiYobj10aGlzLnN1Ym5vZGVbaV0ucmVtb3ZlKHQsZSkpKXt0aGlzLnN1Ym5vZGVbaV0uaXNQcnVuYWJsZSgpJiYodGhpcy5zdWJub2RlW2ldPW51bGwpO2JyZWFrfXJldHVybiBuP246bj10aGlzLml0ZW1zLnJlbW92ZShlKX0sZ2V0SXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtc30sZGVwdGg6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTwyO2UrKylpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV0uZGVwdGgoKTtuPnQmJih0PW4pfXJldHVybiB0KzF9LG5vZGVTaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wO2U8MjtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5ub2RlU2l6ZSgpKTtyZXR1cm4gdCsxfSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5pdGVtcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNpfX0pLGNpLmdldFN1Ym5vZGVJbmRleD1mdW5jdGlvbih0LGUpe3ZhciBuPS0xO3JldHVybiB0Lm1pbj49ZSYmKG49MSksdC5tYXg8PWUmJihuPTApLG59LGUoZmkucHJvdG90eXBlLHtleHBhbmRUb0luY2x1ZGU6ZnVuY3Rpb24odCl7dC5tYXg+dGhpcy5tYXgmJih0aGlzLm1heD10Lm1heCksdC5taW48dGhpcy5taW4mJih0aGlzLm1pbj10Lm1pbil9LGdldFdpZHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4LXRoaXMubWlufSxvdmVybGFwczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMub3ZlcmxhcHModC5taW4sdC5tYXgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuISh0aGlzLm1pbj5ufHx0aGlzLm1heDxlKX19LGdldE1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbn0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIltcIit0aGlzLm1pbitcIiwgXCIrdGhpcy5tYXgrXCJdXCJ9LGNvbnRhaW5zOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZmkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb250YWlucyh0Lm1pbix0Lm1heCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBlPj10aGlzLm1pbiYmZTw9dGhpcy5tYXh9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gbj49dGhpcy5taW4mJmk8PXRoaXMubWF4fX0saW5pdDpmdW5jdGlvbih0LGUpe3RoaXMubWluPXQsdGhpcy5tYXg9ZSx0PmUmJih0aGlzLm1pbj1lLHRoaXMubWF4PXQpfSxnZXRNYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZpfX0pLGdpLmV4cG9uZW50PWZ1bmN0aW9uKHQpe3JldHVybiBkaSg2NCx0KS0xMDIzfSxnaS5wb3dlck9mMj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0KX0sZShwaS5wcm90b3R5cGUse2dldEludGVydmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJ2YWx9LGdldExldmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGV2ZWx9LGNvbXB1dGVLZXk6ZnVuY3Rpb24odCl7Zm9yKHRoaXMubGV2ZWw9cGkuY29tcHV0ZUxldmVsKHQpLHRoaXMuaW50ZXJ2YWw9bmV3IGZpLHRoaXMuY29tcHV0ZUludGVydmFsKHRoaXMubGV2ZWwsdCk7IXRoaXMuaW50ZXJ2YWwuY29udGFpbnModCk7KXRoaXMubGV2ZWwrPTEsdGhpcy5jb21wdXRlSW50ZXJ2YWwodGhpcy5sZXZlbCx0KX0sY29tcHV0ZUludGVydmFsOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z2kucG93ZXJPZjIodCk7dGhpcy5wdD1NYXRoLmZsb29yKGUuZ2V0TWluKCkvbikqbix0aGlzLmludGVydmFsLmluaXQodGhpcy5wdCx0aGlzLnB0K24pfSxnZXRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwaX19KSxwaS5jb21wdXRlTGV2ZWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpLG49Z2kuZXhwb25lbnQoZSkrMTtyZXR1cm4gbn0saCh2aSxjaSksZSh2aS5wcm90b3R5cGUse2dldEludGVydmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJ2YWx9LGZpbmQ6ZnVuY3Rpb24odCl7dmFyIGU9Y2kuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmUpO2lmKGU9PT0tMSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV07cmV0dXJuIG4uZmluZCh0KX1yZXR1cm4gdGhpc30saW5zZXJ0OmZ1bmN0aW9uKHQpe2YuaXNUcnVlKG51bGw9PT10aGlzLmludGVydmFsfHx0aGlzLmludGVydmFsLmNvbnRhaW5zKHQuaW50ZXJ2YWwpKTt2YXIgZT1jaS5nZXRTdWJub2RlSW5kZXgodC5pbnRlcnZhbCx0aGlzLmNlbnRyZSk7aWYodC5sZXZlbD09PXRoaXMubGV2ZWwtMSl0aGlzLnN1Ym5vZGVbZV09dDtlbHNle3ZhciBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydCh0KSx0aGlzLnN1Ym5vZGVbZV09bn19LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIHQub3ZlcmxhcHModGhpcy5pbnRlcnZhbCl9LGdldFN1Ym5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10aGlzLnN1Ym5vZGVbdF0mJih0aGlzLnN1Ym5vZGVbdF09dGhpcy5jcmVhdGVTdWJub2RlKHQpKSx0aGlzLnN1Ym5vZGVbdF19LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9Y2kuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmUpO2lmKGUhPT0tMSl7dmFyIG49dGhpcy5nZXRTdWJub2RlKGUpO3JldHVybiBuLmdldE5vZGUodCl9cmV0dXJuIHRoaXN9LGNyZWF0ZVN1Ym5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9MCxuPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuaW50ZXJ2YWwuZ2V0TWluKCksbj10aGlzLmNlbnRyZTticmVhaztjYXNlIDE6ZT10aGlzLmNlbnRyZSxuPXRoaXMuaW50ZXJ2YWwuZ2V0TWF4KCl9dmFyIGk9bmV3IGZpKGUsbikscj1uZXcgdmkoaSx0aGlzLmxldmVsLTEpO3JldHVybiByfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2aX19KSx2aS5jcmVhdGVOb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBwaSh0KSxuPW5ldyB2aShlLmdldEludGVydmFsKCksZS5nZXRMZXZlbCgpKTtyZXR1cm4gbn0sdmkuY3JlYXRlRXhwYW5kZWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZmkoZSk7bnVsbCE9PXQmJm4uZXhwYW5kVG9JbmNsdWRlKHQuaW50ZXJ2YWwpO3ZhciBpPXZpLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZpLmluc2VydCh0KSxpfSxlKG1pLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbWl9fSk7bWkuaXNaZXJvV2lkdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7dmFyIGk9TWF0aC5tYXgoTWF0aC5hYnModCksTWF0aC5hYnMoZSkpLHI9bi9pLHM9Z2kuZXhwb25lbnQocik7cmV0dXJuIHM8PW1pLk1JTl9CSU5BUllfRVhQT05FTlR9O21pLk1JTl9CSU5BUllfRVhQT05FTlQ9LTUwLGgoeWksY2kpLGUoeWkucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1jaS5nZXRTdWJub2RlSW5kZXgodCx5aS5vcmlnaW4pO2lmKG49PT0tMSlyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDt2YXIgaT10aGlzLnN1Ym5vZGVbbl07aWYobnVsbD09PWl8fCFpLmdldEludGVydmFsKCkuY29udGFpbnModCkpe3ZhciByPXZpLmNyZWF0ZUV4cGFuZGVkKGksdCk7dGhpcy5zdWJub2RlW25dPXJ9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5zdWJub2RlW25dLHQsZSl9LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuITB9LGluc2VydENvbnRhaW5lZDpmdW5jdGlvbih0LGUsbil7Zi5pc1RydWUodC5nZXRJbnRlcnZhbCgpLmNvbnRhaW5zKGUpKTt2YXIgaT1taS5pc1plcm9XaWR0aChlLmdldE1pbigpLGUuZ2V0TWF4KCkpLHI9bnVsbDtyPWk/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxyLmFkZChuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geWl9fSkseWkub3JpZ2luPTAsZSh4aS5wcm90b3R5cGUse3NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Quc2l6ZSgpOjB9LGluc2VydDpmdW5jdGlvbih0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO3ZhciBuPXhpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTt0aGlzLnJvb3QuaW5zZXJ0KG4sZSl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5xdWVyeShuZXcgZmkodCx0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmaSl7dmFyIGU9YXJndW1lbnRzWzBdLG49bmV3IEk7cmV0dXJuIHRoaXMucXVlcnkoZSxuKSxufX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy5yb290LmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKGkscil9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3JldHVybiB0aGlzLnJvb3QuYWRkQWxsSXRlbXModCksdC5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXt2YXIgbj14aS5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7cmV0dXJuIHRoaXMucm9vdC5yZW1vdmUobixlKX0sY29sbGVjdFN0YXRzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMubWluRXh0ZW50JiZlPjAmJih0aGlzLm1pbkV4dGVudD1lKX0sZGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3QuZGVwdGgoKTowfSxub2RlU2l6ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5ub2RlU2l6ZSgpOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhpfX0pLHhpLmVuc3VyZUV4dGVudD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TWluKCksaT10LmdldE1heCgpO3JldHVybiBuIT09aT90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxuZXcgZmkobixpKSl9LGUoRWkucHJvdG90eXBlLHtpc0luc2lkZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVpfX0pLGUoSWkucHJvdG90eXBlLHt0ZXN0TGluZVNlZ21lbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPWUucDAsdT1lLnAxO2k9YS54LXQueCxyPWEueS10Lnkscz11LngtdC54LG89dS55LXQueSwocj4wJiZvPD0wfHxvPjAmJnI8PTApJiYobj11ZS5zaWduT2ZEZXQyeDIoaSxyLHMsbykvKG8tciksMDxuJiZ0aGlzLmNyb3NzaW5ncysrKX0sYnVpbGRJbmRleDpmdW5jdGlvbigpe3RoaXMudHJlZT1uZXcgeGk7Zm9yKHZhciB0PUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModGhpcy5yaW5nLmdldENvb3JkaW5hdGVzKCkpLGU9JGUuZ2V0Q2hhaW5zKHQpLG49MDtuPGUuc2l6ZSgpO24rKyl7dmFyIGk9ZS5nZXQobikscj1pLmdldEVudmVsb3BlKCk7dGhpcy5pbnRlcnZhbC5taW49ci5nZXRNaW5ZKCksdGhpcy5pbnRlcnZhbC5tYXg9ci5nZXRNYXhZKCksdGhpcy50cmVlLmluc2VydCh0aGlzLmludGVydmFsLGkpfX0sdGVzdE1vbm90b25lQ2hhaW46ZnVuY3Rpb24odCxlLG4pe24uc2VsZWN0KHQsZSl9LGlzSW5zaWRlOmZ1bmN0aW9uKHQpe3RoaXMuY3Jvc3NpbmdzPTA7dmFyIGU9bmV3IEMoci5ORUdBVElWRV9JTkZJTklUWSxyLlBPU0lUSVZFX0lORklOSVRZLHQueSx0LnkpO3RoaXMuaW50ZXJ2YWwubWluPXQueSx0aGlzLmludGVydmFsLm1heD10Lnk7Zm9yKHZhciBuPXRoaXMudHJlZS5xdWVyeSh0aGlzLmludGVydmFsKSxpPW5ldyBOaSh0aGlzLHQpLHM9bi5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7dGhpcy50ZXN0TW9ub3RvbmVDaGFpbihlLGksbyl9cmV0dXJuIHRoaXMuY3Jvc3NpbmdzJTI9PT0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltFaV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElpfX0pLGgoTmksaGkpLGUoTmkucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oKXtpZigxIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaGkucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWNwLnRlc3RMaW5lU2VnbWVudCh0aGlzLnAsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5pfX0pLElpLk1DU2VsZWN0ZXI9TmksZShDaS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENpfX0pLENpLnRvRGVncmVlcz1mdW5jdGlvbih0KXtyZXR1cm4gMTgwKnQvTWF0aC5QSX0sQ2kubm9ybWFsaXplPWZ1bmN0aW9uKHQpe2Zvcig7dD5NYXRoLlBJOyl0LT1DaS5QSV9USU1FU18yO2Zvcig7dDw9LU1hdGguUEk7KXQrPUNpLlBJX1RJTUVTXzI7cmV0dXJuIHR9LENpLmFuZ2xlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hdGFuMih0LnksdC54KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9bi54LWUueCxyPW4ueS1lLnk7cmV0dXJuIE1hdGguYXRhbjIocixpKX19LENpLmlzQWN1dGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9bi54LWUueCxvPW4ueS1lLnksYT1pKnMrcipvO3JldHVybiBhPjB9LENpLmlzT2J0dXNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LngtZS54LHI9dC55LWUueSxzPW4ueC1lLngsbz1uLnktZS55LGE9aSpzK3IqbztyZXR1cm4gYTwwfSxDaS5pbnRlcmlvckFuZ2xlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1DaS5hbmdsZShlLHQpLHI9Q2kuYW5nbGUoZSxuKTtyZXR1cm4gTWF0aC5hYnMoci1pKX0sQ2kubm9ybWFsaXplUG9zaXRpdmU9ZnVuY3Rpb24odCl7aWYodDwwKXtmb3IoO3Q8MDspdCs9Q2kuUElfVElNRVNfMjt0Pj1DaS5QSV9USU1FU18yJiYodD0wKX1lbHNle2Zvcig7dD49Q2kuUElfVElNRVNfMjspdC09Q2kuUElfVElNRVNfMjt0PDAmJih0PTApfXJldHVybiB0fSxDaS5hbmdsZUJldHdlZW49ZnVuY3Rpb24odCxlLG4pe3ZhciBpPUNpLmFuZ2xlKGUsdCkscj1DaS5hbmdsZShlLG4pO3JldHVybiBDaS5kaWZmKGkscil9LENpLmRpZmY9ZnVuY3Rpb24odCxlKXt2YXIgbj1udWxsO3JldHVybiBuPXQ8ZT9lLXQ6dC1lLG4+TWF0aC5QSSYmKG49MipNYXRoLlBJLW4pLG59LENpLnRvUmFkaWFucz1mdW5jdGlvbih0KXtyZXR1cm4gdCpNYXRoLlBJLzE4MH0sQ2kuZ2V0VHVybj1mdW5jdGlvbih0LGUpe3ZhciBuPU1hdGguc2luKGUtdCk7cmV0dXJuIG4+MD9DaS5DT1VOVEVSQ0xPQ0tXSVNFOm48MD9DaS5DTE9DS1dJU0U6Q2kuTk9ORX0sQ2kuYW5nbGVCZXR3ZWVuT3JpZW50ZWQ9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPUNpLmFuZ2xlKGUsdCkscj1DaS5hbmdsZShlLG4pLHM9ci1pO3JldHVybiBzPD0tTWF0aC5QST9zK0NpLlBJX1RJTUVTXzI6cz5NYXRoLlBJP3MtQ2kuUElfVElNRVNfMjpzfSxDaS5QSV9USU1FU18yPTIqTWF0aC5QSSxDaS5QSV9PVkVSXzI9TWF0aC5QSS8yLENpLlBJX09WRVJfND1NYXRoLlBJLzQsQ2kuQ09VTlRFUkNMT0NLV0lTRT1oZS5DT1VOVEVSQ0xPQ0tXSVNFLENpLkNMT0NLV0lTRT1oZS5DTE9DS1dJU0UsQ2kuTk9ORT1oZS5DT0xMSU5FQVIsZShTaS5wcm90b3R5cGUse2FyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gU2kuYXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LHNpZ25lZEFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gU2kuc2lnbmVkQXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGludGVycG9sYXRlWjpmdW5jdGlvbih0KXtpZihudWxsPT09dCl0aHJvdyBuZXcgaShcIlN1cHBsaWVkIHBvaW50IGlzIG51bGwuXCIpO3JldHVybiBTaS5pbnRlcnBvbGF0ZVoodCx0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGxvbmdlc3RTaWRlTGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIFNpLmxvbmdlc3RTaWRlTGVuZ3RoKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saXNBY3V0ZTpmdW5jdGlvbigpe3JldHVybiBTaS5pc0FjdXRlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sY2lyY3VtY2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIFNpLmNpcmN1bWNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGFyZWEzRDpmdW5jdGlvbigpe3JldHVybiBTaS5hcmVhM0QodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxjZW50cm9pZDpmdW5jdGlvbigpe3JldHVybiBTaS5jZW50cm9pZCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGluQ2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIFNpLmluQ2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU2l9fSksU2kuYXJlYT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE1hdGguYWJzKCgobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzIpfSxTaS5zaWduZWRBcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4oKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yfSxTaS5kZXQ9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIHQqaS1lKm59LFNpLmludGVycG9sYXRlWj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1lLngscz1lLnksbz1uLngtcixhPWkueC1yLHU9bi55LXMsbD1pLnktcyxoPW8qbC1hKnUsYz10LngtcixmPXQueS1zLGc9KGwqYy1hKmYpL2gsZD0oLXUqYytvKmYpL2gscD1lLnorZyoobi56LWUueikrZCooaS56LWUueik7cmV0dXJuIHB9LFNpLmxvbmdlc3RTaWRlTGVuZ3RoPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmRpc3RhbmNlKGUpLHI9ZS5kaXN0YW5jZShuKSxzPW4uZGlzdGFuY2UodCksbz1pO3JldHVybiByPm8mJihvPXIpLHM+byYmKG89cyksb30sU2kuaXNBY3V0ZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuISFDaS5pc0FjdXRlKHQsZSxuKSYmKCEhQ2kuaXNBY3V0ZShlLG4sdCkmJiEhQ2kuaXNBY3V0ZShuLHQsZSkpfSxTaS5jaXJjdW1jZW50cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4ueCxyPW4ueSxzPXQueC1pLG89dC55LXIsYT1lLngtaSx1PWUueS1yLGw9MipTaS5kZXQocyxvLGEsdSksaD1TaS5kZXQobyxzKnMrbypvLHUsYSphK3UqdSksYz1TaS5kZXQocyxzKnMrbypvLGEsYSphK3UqdSksZj1pLWgvbCxkPXIrYy9sO3JldHVybiBuZXcgZyhmLGQpfSxTaS5wZXJwZW5kaWN1bGFyQmlzZWN0b3I9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLngtdC54LGk9ZS55LXQueSxyPW5ldyBGKHQueCtuLzIsdC55K2kvMiwxKSxzPW5ldyBGKHQueC1pK24vMix0LnkrbitpLzIsMSk7cmV0dXJuIG5ldyBGKHIscyl9LFNpLmFuZ2xlQmlzZWN0b3I9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUuZGlzdGFuY2UodCkscj1lLmRpc3RhbmNlKG4pLHM9aS8oaStyKSxvPW4ueC10LngsYT1uLnktdC55LHU9bmV3IGcodC54K3Mqbyx0LnkrcyphKTtyZXR1cm4gdX0sU2kuYXJlYTNEPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLngtdC54LHI9ZS55LXQueSxzPWUuei10Lnosbz1uLngtdC54LGE9bi55LXQueSx1PW4uei10LnosbD1yKnUtcyphLGg9cypvLWkqdSxjPWkqYS1yKm8sZj1sKmwraCpoK2MqYyxnPU1hdGguc3FydChmKS8yO3JldHVybiBnfSxTaS5jZW50cm9pZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9KHQueCtlLngrbi54KS8zLHI9KHQueStlLnkrbi55KS8zO3JldHVybiBuZXcgZyhpLHIpfSxTaS5pbkNlbnRyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5kaXN0YW5jZShuKSxyPXQuZGlzdGFuY2Uobikscz10LmRpc3RhbmNlKGUpLG89aStyK3MsYT0oaSp0LngrciplLngrcypuLngpL28sdT0oaSp0LnkrciplLnkrcypuLnkpL287cmV0dXJuIG5ldyBnKGEsdSl9LGUod2kucHJvdG90eXBlLHtnZXRSYWRpdXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5yYWRpdXN9LGdldERpYW1ldGVyOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKX12YXIgdD10aGlzLmV4dHJlbWFsUHRzWzBdLGU9dGhpcy5leHRyZW1hbFB0c1sxXTtyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9LGdldEV4dHJlbWFsUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHN9LGNvbXB1dGVDaXJjbGVQb2ludHM6ZnVuY3Rpb24oKXtpZih0aGlzLmlucHV0LmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO2lmKDE9PT10aGlzLmlucHV0LmdldE51bVBvaW50cygpKXt2YXIgdD10aGlzLmlucHV0LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9W25ldyBnKHRbMF0pXSxudWxsfXZhciBlPXRoaXMuaW5wdXQuY29udmV4SHVsbCgpLG49ZS5nZXRDb29yZGluYXRlcygpLHQ9bjtpZihuWzBdLmVxdWFsczJEKG5bbi5sZW5ndGgtMV0pJiYodD1uZXcgQXJyYXkobi5sZW5ndGgtMSkuZmlsbChudWxsKSxILmNvcHlEZWVwKG4sMCx0LDAsbi5sZW5ndGgtMSkpLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPUguY29weURlZXAodCksbnVsbDtmb3IodmFyIGk9d2kubG93ZXN0UG9pbnQodCkscj13aS5wb2ludFdpdE1pbkFuZ2xlV2l0aFgodCxpKSxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBvPXdpLnBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQodCxpLHIpO2lmKENpLmlzT2J0dXNlKGksbyxyKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcoaSksbmV3IGcocildLG51bGw7aWYoQ2kuaXNPYnR1c2UobyxpLHIpKWk9bztlbHNle2lmKCFDaS5pc09idHVzZShvLHIsaSkpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9W25ldyBnKGkpLG5ldyBnKHIpLG5ldyBnKG8pXSxudWxsO3I9b319Zi5zaG91bGROZXZlclJlYWNoSGVyZShcIkxvZ2ljIGZhaWx1cmUgaW4gTWluaW11bSBCb3VuZGluZyBDaXJjbGUgYWxnb3JpdGhtIVwiKX0sY29tcHV0ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5leHRyZW1hbFB0cz9udWxsOih0aGlzLmNvbXB1dGVDaXJjbGVQb2ludHMoKSx0aGlzLmNvbXB1dGVDZW50cmUoKSx2b2lkKG51bGwhPT10aGlzLmNlbnRyZSYmKHRoaXMucmFkaXVzPXRoaXMuY2VudHJlLmRpc3RhbmNlKHRoaXMuZXh0cmVtYWxQdHNbMF0pKSkpfSxnZXRGYXJ0aGVzdFBvaW50czpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLmNlbnRyZSl9dmFyIHQ9dGhpcy5leHRyZW1hbFB0c1swXSxlPXRoaXMuZXh0cmVtYWxQdHNbdGhpcy5leHRyZW1hbFB0cy5sZW5ndGgtMV07cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfSxnZXRDaXJjbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGUoKSxudWxsPT09dGhpcy5jZW50cmUpcmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oKTt2YXIgdD10aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLmNlbnRyZSk7cmV0dXJuIDA9PT10aGlzLnJhZGl1cz90OnQuYnVmZmVyKHRoaXMucmFkaXVzKX0sZ2V0Q2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMuY2VudHJlfSxjb21wdXRlQ2VudHJlOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6dGhpcy5jZW50cmU9bnVsbDticmVhaztjYXNlIDE6dGhpcy5jZW50cmU9dGhpcy5leHRyZW1hbFB0c1swXTticmVhaztjYXNlIDI6dGhpcy5jZW50cmU9bmV3IGcoKHRoaXMuZXh0cmVtYWxQdHNbMF0ueCt0aGlzLmV4dHJlbWFsUHRzWzFdLngpLzIsKHRoaXMuZXh0cmVtYWxQdHNbMF0ueSt0aGlzLmV4dHJlbWFsUHRzWzFdLnkpLzIpO2JyZWFrO2Nhc2UgMzp0aGlzLmNlbnRyZT1TaS5jaXJjdW1jZW50cmUodGhpcy5leHRyZW1hbFB0c1swXSx0aGlzLmV4dHJlbWFsUHRzWzFdLHRoaXMuZXh0cmVtYWxQdHNbMl0pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd2l9fSksd2kucG9pbnRXaXRNaW5BbmdsZVdpdGhYPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXIuTUFYX1ZBTFVFLGk9bnVsbCxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBvPXRbc107aWYobyE9PWUpe3ZhciBhPW8ueC1lLngsdT1vLnktZS55O3U8MCYmKHU9LXUpO3ZhciBsPU1hdGguc3FydChhKmErdSp1KSxoPXUvbDtoPG4mJihuPWgsaT1vKX19cmV0dXJuIGl9LHdpLmxvd2VzdFBvaW50PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10WzBdLG49MTtuPHQubGVuZ3RoO24rKyl0W25dLnk8ZS55JiYoZT10W25dKTtyZXR1cm4gZX0sd2kucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXIuTUFYX1ZBTFVFLHM9bnVsbCxvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBhPXRbb107aWYoYSE9PWUmJmEhPT1uKXt2YXIgdT1DaS5hbmdsZUJldHdlZW4oZSxhLG4pO3U8aSYmKGk9dSxzPWEpfX1yZXR1cm4gc30sZShMaS5wcm90b3R5cGUse2dldFdpZHRoQ29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLm1pbldpZHRoUHR9LGdldFN1cHBvcnRpbmdTZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLm1pbkJhc2VTZWcucDAsdGhpcy5taW5CYXNlU2VnLnAxXSl9LGdldERpYW1ldGVyOmZ1bmN0aW9uKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksbnVsbD09PXRoaXMubWluV2lkdGhQdClyZXR1cm4gdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCk7dmFyIHQ9dGhpcy5taW5CYXNlU2VnLnByb2plY3QodGhpcy5taW5XaWR0aFB0KTtyZXR1cm4gdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsdGhpcy5taW5XaWR0aFB0XSl9LGNvbXB1dGVXaWR0aENvbnZleDpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgVHQ/dGhpcy5jb252ZXhIdWxsUHRzPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKTp0aGlzLmNvbnZleEh1bGxQdHM9dC5nZXRDb29yZGluYXRlcygpLDA9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PW51bGwsdGhpcy5taW5CYXNlU2VnPW51bGwpOjE9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDA9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMT10aGlzLmNvbnZleEh1bGxQdHNbMF0pOjI9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RofHwzPT09dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5taW5XaWR0aD0wLHRoaXMubWluV2lkdGhQdD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAwPXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDE9dGhpcy5jb252ZXhIdWxsUHRzWzFdKTp0aGlzLmNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodGhpcy5jb252ZXhIdWxsUHRzKX0sY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcjpmdW5jdGlvbih0KXt0aGlzLm1pbldpZHRoPXIuTUFYX1ZBTFVFO2Zvcih2YXIgZT0xLG49bmV3IGNlLGk9MDtpPHQubGVuZ3RoLTE7aSsrKW4ucDA9dFtpXSxuLnAxPXRbaSsxXSxlPXRoaXMuZmluZE1heFBlcnBEaXN0YW5jZSh0LG4sZSl9LGNvbXB1dGVNaW5pbXVtRGlhbWV0ZXI6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5taW5XaWR0aFB0KXJldHVybiBudWxsO2lmKHRoaXMuaXNDb252ZXgpdGhpcy5jb21wdXRlV2lkdGhDb252ZXgodGhpcy5pbnB1dEdlb20pO2Vsc2V7dmFyIHQ9bmV3IG1lKHRoaXMuaW5wdXRHZW9tKS5nZXRDb252ZXhIdWxsKCk7dGhpcy5jb21wdXRlV2lkdGhDb252ZXgodCl9fSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5taW5XaWR0aH0sZmluZE1heFBlcnBEaXN0YW5jZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbbl0pLHI9aSxzPW4sbz1zO3I+PWk7KWk9cixzPW8sbz1MaS5uZXh0SW5kZXgodCxzKSxyPWUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHRbb10pO3JldHVybiBpPHRoaXMubWluV2lkdGgmJih0aGlzLm1pblB0SW5kZXg9cyx0aGlzLm1pbldpZHRoPWksdGhpcy5taW5XaWR0aFB0PXRbdGhpcy5taW5QdEluZGV4XSx0aGlzLm1pbkJhc2VTZWc9bmV3IGNlKGUpKSxzfSxnZXRNaW5pbXVtUmVjdGFuZ2xlOmZ1bmN0aW9uKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksMD09PXRoaXMubWluV2lkdGgpcmV0dXJuIHRoaXMubWluQmFzZVNlZy5wMC5lcXVhbHMyRCh0aGlzLm1pbkJhc2VTZWcucDEpP3RoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLm1pbkJhc2VTZWcucDApOnRoaXMubWluQmFzZVNlZy50b0dlb21ldHJ5KHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKSk7Zm9yKHZhciB0PXRoaXMubWluQmFzZVNlZy5wMS54LXRoaXMubWluQmFzZVNlZy5wMC54LGU9dGhpcy5taW5CYXNlU2VnLnAxLnktdGhpcy5taW5CYXNlU2VnLnAwLnksbj1yLk1BWF9WQUxVRSxpPS1yLk1BWF9WQUxVRSxzPXIuTUFYX1ZBTFVFLG89LXIuTUFYX1ZBTFVFLGE9MDthPHRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg7YSsrKXt2YXIgdT1MaS5jb21wdXRlQyh0LGUsdGhpcy5jb252ZXhIdWxsUHRzW2FdKTt1PmkmJihpPXUpLHU8biYmKG49dSk7dmFyIGw9TGkuY29tcHV0ZUMoLWUsdCx0aGlzLmNvbnZleEh1bGxQdHNbYV0pO2w+byYmKG89bCksbDxzJiYocz1sKX12YXIgaD1MaS5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsbyksYz1MaS5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUscyksZj1MaS5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxpKSxnPUxpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LG4pLGQ9Zi5saW5lSW50ZXJzZWN0aW9uKGgpLHA9Zy5saW5lSW50ZXJzZWN0aW9uKGgpLHY9Zy5saW5lSW50ZXJzZWN0aW9uKGMpLG09Zi5saW5lSW50ZXJzZWN0aW9uKGMpLHk9dGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoW2QscCx2LG0sZF0pO3JldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbih5LG51bGwpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMaX19KSxMaS5uZXh0SW5kZXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSsrLGU+PXQubGVuZ3RoJiYoZT0wKSxlfSxMaS5jb21wdXRlQz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHQqbi55LWUqbi54fSxMaS5nZXRNaW5pbXVtRGlhbWV0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBMaSh0KS5nZXREaWFtZXRlcigpfSxMaS5nZXRNaW5pbXVtUmVjdGFuZ2xlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTGkodCkuZ2V0TWluaW11bVJlY3RhbmdsZSgpfSxMaS5jb21wdXRlU2VnbWVudEZvckxpbmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW51bGwscj1udWxsO3JldHVybiBNYXRoLmFicyhlKT5NYXRoLmFicyh0KT8oaT1uZXcgZygwLG4vZSkscj1uZXcgZygxLG4vZS10L2UpKTooaT1uZXcgZyhuL3QsMCkscj1uZXcgZyhuL3QtZS90LDEpKSxuZXcgY2UoaSxyKX07dmFyIGNvPU9iamVjdC5mcmVlemUoe0NlbnRyb2lkOmdlLENHQWxnb3JpdGhtczpoZSxDb252ZXhIdWxsOm1lLEludGVyaW9yUG9pbnRBcmVhOm9pLEludGVyaW9yUG9pbnRMaW5lOnVpLEludGVyaW9yUG9pbnRQb2ludDpsaSxSb2J1c3RMaW5lSW50ZXJzZWN0b3I6YWUsTUNQb2ludEluUmluZzpJaSxNaW5pbXVtQm91bmRpbmdDaXJjbGU6d2ksTWluaW11bURpYW1ldGVyOkxpfSk7ZShSaS5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUaSh0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5pbnB1dEdlb20pfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXtpZih0PD0wKXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSaX19KSxSaS5kZW5zaWZ5UG9pbnRzPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IGNlLHI9bmV3IE4scz0wO3M8dC5sZW5ndGgtMTtzKyspe2kucDA9dFtzXSxpLnAxPXRbcysxXSxyLmFkZChpLnAwLCExKTt2YXIgbz1pLmdldExlbmd0aCgpLGE9TWF0aC50cnVuYyhvL2UpKzE7aWYoYT4xKWZvcih2YXIgdT1vL2EsbD0xO2w8YTtsKyspe3ZhciBoPWwqdS9vLGM9aS5wb2ludEFsb25nKGgpO24ubWFrZVByZWNpc2UoYyksci5hZGQoYywhMSl9fXJldHVybiByLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxyLnRvQ29vcmRpbmF0ZUFycmF5KCl9LFJpLmRlbnNpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgUmkodCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKFRpLHhlKSxlKFRpLnByb3RvdHlwZSx7dHJhbnNmb3JtTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49eGUucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIE90P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLGk9UmkuZGVuc2lmeVBvaW50cyhuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UsZS5nZXRQcmVjaXNpb25Nb2RlbCgpKTtyZXR1cm4gZSBpbnN0YW5jZW9mIFN0JiYxPT09aS5sZW5ndGgmJihpPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKSx0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0sY3JlYXRlVmFsaWRBcmVhOmZ1bmN0aW9uKHQpe3JldHVybiB0LmJ1ZmZlcigwKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVGl9fSksUmkuRGVuc2lmeVRyYW5zZm9ybWVyPVRpO3ZhciBmbz1PYmplY3QuZnJlZXplKHtEZW5zaWZpZXI6Uml9KTtlKFBpLnByb3RvdHlwZSx7ZmluZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2Rve2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKGUuZGVzdCgpLmVxdWFsczJEKHQpKXJldHVybiBlO2U9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gbnVsbH0sZGVzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWd9LG9OZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH0saW5zZXJ0OmZ1bmN0aW9uKHQpe2lmKHRoaXMub05leHQoKT09PXRoaXMpcmV0dXJuIHRoaXMuaW5zZXJ0QWZ0ZXIodCksbnVsbDt2YXIgZT10aGlzLmNvbXBhcmVUbyh0KSxuPXRoaXM7ZG97dmFyIGk9bi5vTmV4dCgpLHI9aS5jb21wYXJlVG8odCk7aWYociE9PWV8fGk9PT10aGlzKXJldHVybiBuLmluc2VydEFmdGVyKHQpLG51bGw7bj1pfXdoaWxlKG4hPT10aGlzKTtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9LGluc2VydEFmdGVyOmZ1bmN0aW9uKHQpe2YuZXF1YWxzKHRoaXMuX29yaWcsdC5vcmlnKCkpO3ZhciBlPXRoaXMub05leHQoKTt0aGlzLl9zeW0uc2V0TmV4dCh0KSx0LnN5bSgpLnNldE5leHQoZSl9LGRlZ3JlZTpmdW5jdGlvbiB0KCl7dmFyIHQ9MCxlPXRoaXM7ZG8gdCsrLGU9ZS5vTmV4dCgpO3doaWxlKGUhPT10aGlzKTtyZXR1cm4gdH0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19LGRlbHRhWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueS10aGlzLl9vcmlnLnl9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW19LHByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfSxjb21wYXJlQW5ndWxhckRpcmVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmRlbHRhWCgpLG49dGhpcy5kZWx0YVkoKSxpPXQuZGVsdGFYKCkscj10LmRlbHRhWSgpO2lmKGU9PT1pJiZuPT09cilyZXR1cm4gMDt2YXIgcz1KZS5xdWFkcmFudChlLG4pLG89SmUucXVhZHJhbnQoaSxyKTtyZXR1cm4gcz5vPzE6czxvPy0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0Ll9vcmlnLHQuZGVzdCgpLHRoaXMuZGVzdCgpKX0scHJldk5vZGU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpczsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLmNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKGUpO3JldHVybiBufSxuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25leHR9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLl9zeW09dH0sb3JpZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcmlnfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5fbmV4dD10fSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9LGRlbHRhWDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueC10aGlzLl9vcmlnLnh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBpfX0pLFBpLmluaXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsIT09dC5fc3ltfHxudWxsIT09ZS5fc3ltfHxudWxsIT09dC5fbmV4dHx8bnVsbCE9PWUuX25leHQpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkVkZ2VzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXCIpO3JldHVybiB0LmluaXQoZSksdH0sUGkuY3JlYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFBpKHQpLGk9bmV3IFBpKGUpO3JldHVybiBuLmluaXQoaSksbn0saChiaSxQaSksZShiaS5wcm90b3R5cGUse21hcms6ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMH0sc2V0TWFyazpmdW5jdGlvbih0KXt0aGlzLl9pc01hcmtlZD10fSxpc01hcmtlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc01hcmtlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYml9fSksYmkuc2V0TWFya0JvdGg9ZnVuY3Rpb24odCxlKXt0LnNldE1hcmsoZSksdC5zeW0oKS5zZXRNYXJrKGUpfSxiaS5pc01hcmtlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc01hcmtlZCgpfSxiaS5zZXRNYXJrPWZ1bmN0aW9uKHQsZSl7dC5zZXRNYXJrKGUpfSxiaS5tYXJrQm90aD1mdW5jdGlvbih0KXt0Lm1hcmsoKSx0LnN5bSgpLm1hcmsoKX0sYmkubWFyaz1mdW5jdGlvbih0KXt0Lm1hcmsoKX0sZShPaS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5jcmVhdGUodCxlKTtudWxsIT09bj9uLmluc2VydChpKTp0aGlzLnZlcnRleE1hcC5wdXQodCxpKTt2YXIgcj10aGlzLnZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1yP3IuaW5zZXJ0KGkuc3ltKCkpOnRoaXMudmVydGV4TWFwLnB1dChlLGkuc3ltKCkpLGl9LGNyZWF0ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRnZSh0KSxpPXRoaXMuY3JlYXRlRWRnZShlKTtyZXR1cm4gUGkuaW5pdChuLGkpLG59LGNyZWF0ZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQaSh0KX0sYWRkRWRnZTpmdW5jdGlvbih0LGUpe2lmKCFPaS5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO3ZhciBuPXRoaXMudmVydGV4TWFwLmdldCh0KSxpPW51bGw7aWYobnVsbCE9PW4mJihpPW4uZmluZChlKSksbnVsbCE9PWkpcmV0dXJuIGk7dmFyIHI9dGhpcy5pbnNlcnQodCxlLG4pO3JldHVybiByfSxnZXRWZXJ0ZXhFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleE1hcC52YWx1ZXMoKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe1xucmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9pfX0pLE9pLmlzVmFsaWRFZGdlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5jb21wYXJlVG8odCk7cmV0dXJuIDAhPT1ufSxoKF9pLGJpKSxlKF9pLnByb3RvdHlwZSx7c2V0U3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9pc1N0YXJ0PSEwfSxpc1N0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzU3RhcnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9pfX0pLGgoTWksT2kpLGUoTWkucHJvdG90eXBlLHtjcmVhdGVFZGdlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgX2kodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1pfX0pLGUoRGkucHJvdG90eXBlLHthZGRMaW5lOmZ1bmN0aW9uKHQpe3RoaXMubGluZXMuYWRkKHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQudG9Db29yZGluYXRlQXJyYXkoKSkpfSx1cGRhdGVSaW5nU3RhcnRFZGdlOmZ1bmN0aW9uKHQpe3JldHVybiB0LmlzU3RhcnQoKXx8KHQ9dC5zeW0oKSx0LmlzU3RhcnQoKSk/bnVsbD09PXRoaXMucmluZ1N0YXJ0RWRnZT8odGhpcy5yaW5nU3RhcnRFZGdlPXQsbnVsbCk6dm9pZCh0Lm9yaWcoKS5jb21wYXJlVG8odGhpcy5yaW5nU3RhcnRFZGdlLm9yaWcoKSk8MCYmKHRoaXMucmluZ1N0YXJ0RWRnZT10KSk6bnVsbH0sZ2V0UmVzdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnJlc3VsdCYmdGhpcy5jb21wdXRlUmVzdWx0KCksdGhpcy5yZXN1bHR9LHByb2Nlc3M6ZnVuY3Rpb24odCl7dmFyIGU9dC5wcmV2Tm9kZSgpO251bGw9PT1lJiYoZT10KSx0aGlzLnN0YWNrRWRnZXMoZSksdGhpcy5idWlsZExpbmVzKCl9LGJ1aWxkUmluZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTixuPXQ7Zm9yKGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt2YXIgaT1uLm5leHQoKTtpZihpPT09dClicmVhaztlLmFkZChpLm9yaWcoKS5jb3B5KCksITEpLG49aX1lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuYWRkTGluZShlKX0sYnVpbGRMaW5lOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBOLG49dDtmb3IodGhpcy5yaW5nU3RhcnRFZGdlPW51bGwsYmkubWFya0JvdGgobiksZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe3RoaXMudXBkYXRlUmluZ1N0YXJ0RWRnZShuKTt2YXIgaT1uLm5leHQoKTtpZihpPT09dClyZXR1cm4gdGhpcy5idWlsZFJpbmcodGhpcy5yaW5nU3RhcnRFZGdlKSxudWxsO2UuYWRkKGkub3JpZygpLmNvcHkoKSwhMSksbj1pLGJpLm1hcmtCb3RoKG4pfWUuYWRkKG4uZGVzdCgpLmNvcHkoKSwhMSksdGhpcy5zdGFja0VkZ2VzKG4uc3ltKCkpLHRoaXMuYWRkTGluZShlKX0sc3RhY2tFZGdlczpmdW5jdGlvbih0KXt2YXIgZT10O2RvIGJpLmlzTWFya2VkKGUpfHx0aGlzLm5vZGVFZGdlU3RhY2suYWRkKGUpLGU9ZS5vTmV4dCgpO3doaWxlKGUhPT10KX0sY29tcHV0ZVJlc3VsdDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldFZlcnRleEVkZ2VzKCksZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtiaS5pc01hcmtlZChuKXx8dGhpcy5wcm9jZXNzKG4pfXRoaXMucmVzdWx0PXRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMubGluZXMpfSxidWlsZExpbmVzOmZ1bmN0aW9uKCl7Zm9yKDshdGhpcy5ub2RlRWRnZVN0YWNrLmVtcHR5KCk7KXt2YXIgdD10aGlzLm5vZGVFZGdlU3RhY2sucG9wKCk7YmkuaXNNYXJrZWQodCl8fHRoaXMuYnVpbGRMaW5lKHQpfX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dC5hcHBseSh7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuYWRkKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIHI9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmZhY3RvcnkmJih0aGlzLmZhY3Rvcnk9ci5nZXRGYWN0b3J5KCkpO2Zvcih2YXIgcz1yLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG89ITEsbj0xO248cy5zaXplKCk7bisrKXt2YXIgYT10aGlzLmdyYXBoLmFkZEVkZ2Uocy5nZXRDb29yZGluYXRlKG4tMSkscy5nZXRDb29yZGluYXRlKG4pKTtudWxsIT09YSYmKG98fChhLnNldFN0YXJ0KCksbz0hMCkpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERpfX0pLERpLmRpc3NvbHZlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEaTtyZXR1cm4gZS5hZGQodCksZS5nZXRSZXN1bHQoKX07dmFyIGdvPU9iamVjdC5mcmVlemUoe0xpbmVEaXNzb2x2ZXI6RGl9KSxwbz1PYmplY3QuZnJlZXplKHtHZW9tZXRyeUdyYXBoOiRufSk7ZShBaS5wcm90b3R5cGUse2hhc0NoaWxkcmVuOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDw0O3QrKylpZihudWxsIT09dGhpcy5zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfSxpc1BydW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9LGFkZEFsbEl0ZW1zOmZ1bmN0aW9uKHQpe3QuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmdGhpcy5zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fSxnZXROb2RlQ291bnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrMX0sc2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLml0ZW1zLnNpemUoKX0sYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmc6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO2UuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtuXSYmdGhpcy5zdWJub2RlW25dLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl9LHZpc2l0SXRlbXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5pdGVtcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLnZpc2l0SXRlbShuLm5leHQoKSl9LGhhc0l0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXRlbXMuaXNFbXB0eSgpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2Zvcih2YXIgbj0hMSxpPTA7aTw0O2krKylpZihudWxsIT09dGhpcy5zdWJub2RlW2ldJiYobj10aGlzLnN1Ym5vZGVbaV0ucmVtb3ZlKHQsZSkpKXt0aGlzLnN1Ym5vZGVbaV0uaXNQcnVuYWJsZSgpJiYodGhpcy5zdWJub2RlW2ldPW51bGwpO2JyZWFrfXJldHVybiBuP246bj10aGlzLml0ZW1zLnJlbW92ZShlKX0sdmlzaXQ6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO3RoaXMudmlzaXRJdGVtcyh0LGUpO2Zvcih2YXIgbj0wO248NDtuKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtuXSYmdGhpcy5zdWJub2RlW25dLnZpc2l0KHQsZSl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGRlcHRoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfSxpc0VtcHR5OmZ1bmN0aW9uIHQoKXt2YXIgdD0hMDt0aGlzLml0ZW1zLmlzRW1wdHkoKXx8KHQ9ITEpO2Zvcih2YXIgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHRoaXMuc3Vibm9kZVtlXS5pc0VtcHR5KCl8fCh0PSExKSk7cmV0dXJuIHR9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFpfX0pLEFpLmdldFN1Ym5vZGVJbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9LTE7cmV0dXJuIHQuZ2V0TWluWCgpPj1lJiYodC5nZXRNaW5ZKCk+PW4mJihpPTMpLHQuZ2V0TWF4WSgpPD1uJiYoaT0xKSksdC5nZXRNYXhYKCk8PWUmJih0LmdldE1pblkoKT49biYmKGk9MiksdC5nZXRNYXhZKCk8PW4mJihpPTApKSxpfSxlKEZpLnByb3RvdHlwZSx7Z2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sY29tcHV0ZUtleTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zm9yKHRoaXMubGV2ZWw9RmkuY29tcHV0ZVF1YWRMZXZlbCh0KSx0aGlzLmVudj1uZXcgQyx0aGlzLmNvbXB1dGVLZXkodGhpcy5sZXZlbCx0KTshdGhpcy5lbnYuY29udGFpbnModCk7KXRoaXMubGV2ZWwrPTEsdGhpcy5jb21wdXRlS2V5KHRoaXMubGV2ZWwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9Z2kucG93ZXJPZjIoZSk7dGhpcy5wdC54PU1hdGguZmxvb3Iobi5nZXRNaW5YKCkvaSkqaSx0aGlzLnB0Lnk9TWF0aC5mbG9vcihuLmdldE1pblkoKS9pKSppLHRoaXMuZW52LmluaXQodGhpcy5wdC54LHRoaXMucHQueCtpLHRoaXMucHQueSx0aGlzLnB0LnkraSl9fSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVudn0sZ2V0Q2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKCh0aGlzLmVudi5nZXRNaW5YKCkrdGhpcy5lbnYuZ2V0TWF4WCgpKS8yLCh0aGlzLmVudi5nZXRNaW5ZKCkrdGhpcy5lbnYuZ2V0TWF4WSgpKS8yKX0sZ2V0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRml9fSksRmkuY29tcHV0ZVF1YWRMZXZlbD1mdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLGk9ZT5uP2U6bixyPWdpLmV4cG9uZW50KGkpKzE7cmV0dXJuIHJ9LGgoR2ksQWkpLGUoR2kucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPUFpLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuY2VudHJleCx0aGlzLmNlbnRyZXkpO2lmKGU9PT0tMSlyZXR1cm4gdGhpcztpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV07cmV0dXJuIG4uZmluZCh0KX1yZXR1cm4gdGhpc30saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbnYuaW50ZXJzZWN0cyh0KX0sZ2V0U3Vibm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMuc3Vibm9kZVt0XSYmKHRoaXMuc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuc3Vibm9kZVt0XX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnZ9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9QWkuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYoZSE9PS0xKXt2YXIgbj10aGlzLmdldFN1Ym5vZGUoZSk7cmV0dXJuIG4uZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc30sY3JlYXRlU3Vibm9kZTpmdW5jdGlvbih0KXt2YXIgZT0wLG49MCxpPTAscj0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLmVudi5nZXRNaW5YKCksbj10aGlzLmNlbnRyZXgsaT10aGlzLmVudi5nZXRNaW5ZKCkscj10aGlzLmNlbnRyZXk7YnJlYWs7Y2FzZSAxOmU9dGhpcy5jZW50cmV4LG49dGhpcy5lbnYuZ2V0TWF4WCgpLGk9dGhpcy5lbnYuZ2V0TWluWSgpLHI9dGhpcy5jZW50cmV5O2JyZWFrO2Nhc2UgMjplPXRoaXMuZW52LmdldE1pblgoKSxuPXRoaXMuY2VudHJleCxpPXRoaXMuY2VudHJleSxyPXRoaXMuZW52LmdldE1heFkoKTticmVhaztjYXNlIDM6ZT10aGlzLmNlbnRyZXgsbj10aGlzLmVudi5nZXRNYXhYKCksaT10aGlzLmNlbnRyZXkscj10aGlzLmVudi5nZXRNYXhZKCl9dmFyIHM9bmV3IEMoZSxuLGksciksbz1uZXcgR2kocyx0aGlzLmxldmVsLTEpO3JldHVybiBvfSxpbnNlcnROb2RlOmZ1bmN0aW9uKHQpe2YuaXNUcnVlKG51bGw9PT10aGlzLmVudnx8dGhpcy5lbnYuY29udGFpbnModC5lbnYpKTt2YXIgZT1BaS5nZXRTdWJub2RlSW5kZXgodC5lbnYsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYodC5sZXZlbD09PXRoaXMubGV2ZWwtMSl0aGlzLnN1Ym5vZGVbZV09dDtlbHNle3ZhciBuPXRoaXMuY3JlYXRlU3Vibm9kZShlKTtuLmluc2VydE5vZGUodCksdGhpcy5zdWJub2RlW2VdPW59fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHaX19KSxHaS5jcmVhdGVOb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBGaSh0KSxuPW5ldyBHaShlLmdldEVudmVsb3BlKCksZS5nZXRMZXZlbCgpKTtyZXR1cm4gbn0sR2kuY3JlYXRlRXhwYW5kZWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQyhlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5lbnYpO3ZhciBpPUdpLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZpLmluc2VydE5vZGUodCksaX0saChxaSxBaSksZShxaS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe3ZhciBuPUFpLmdldFN1Ym5vZGVJbmRleCh0LHFpLm9yaWdpbi54LHFpLm9yaWdpbi55KTtpZihuPT09LTEpcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7dmFyIGk9dGhpcy5zdWJub2RlW25dO2lmKG51bGw9PT1pfHwhaS5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKHQpKXt2YXIgcj1HaS5jcmVhdGVFeHBhbmRlZChpLHQpO3RoaXMuc3Vibm9kZVtuXT1yfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuc3Vibm9kZVtuXSx0LGUpfSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiEwfSxpbnNlcnRDb250YWluZWQ6ZnVuY3Rpb24odCxlLG4pe2YuaXNUcnVlKHQuZ2V0RW52ZWxvcGUoKS5jb250YWlucyhlKSk7dmFyIGk9bWkuaXNaZXJvV2lkdGgoZS5nZXRNaW5YKCksZS5nZXRNYXhYKCkpLHI9bWkuaXNaZXJvV2lkdGgoZS5nZXRNaW5ZKCksZS5nZXRNYXhZKCkpLHM9bnVsbDtzPWl8fHI/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxzLmFkZChuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcWl9fSkscWkub3JpZ2luPW5ldyBnKDAsMCksZShCaS5wcm90b3R5cGUse3NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Quc2l6ZSgpOjB9LGluc2VydDpmdW5jdGlvbih0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO3ZhciBuPUJpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTt0aGlzLnJvb3QuaW5zZXJ0KG4sZSl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBZbjtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGUuZ2V0SXRlbXMoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMucm9vdC52aXNpdChuLGkpfX0scXVlcnlBbGw6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTtyZXR1cm4gdGhpcy5yb290LmFkZEFsbEl0ZW1zKHQpLHR9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3ZhciBuPUJpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTtyZXR1cm4gdGhpcy5yb290LnJlbW92ZShuLGUpfSxjb2xsZWN0U3RhdHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5taW5FeHRlbnQmJmU+MCYmKHRoaXMubWluRXh0ZW50PWUpO3ZhciBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLm1pbkV4dGVudCYmbj4wJiYodGhpcy5taW5FeHRlbnQ9bil9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LmRlcHRoKCk6MH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltGZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQml9fSksQmkuZW5zdXJlRXh0ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRNaW5YKCksaT10LmdldE1heFgoKSxyPXQuZ2V0TWluWSgpLHM9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1pJiZyIT09cz90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxyPT09cyYmKHItPWUvMixzPXIrZS8yKSxuZXcgQyhuLGkscixzKSl9LEJpLnNlcmlhbFZlcnNpb25VSUQ9LTB4Njc4YjYwYzk2N2EyNTQwMDt2YXIgdm89T2JqZWN0LmZyZWV6ZSh7UXVhZHRyZWU6Qml9KSxtbz1PYmplY3QuZnJlZXplKHtTVFJ0cmVlOmtlfSkseW89T2JqZWN0LmZyZWV6ZSh7cXVhZHRyZWU6dm8sc3RydHJlZTptb30pLHhvPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtlKHppLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7dmFyIG49ZS50eXBlO2lmKCFFb1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrZS50eXBlKTtyZXR1cm4geG8uaW5kZXhPZihuKSE9PS0xP0VvW25dLmFwcGx5KHRoaXMsW2UuY29vcmRpbmF0ZXNdKTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bj9Fb1tuXS5hcHBseSh0aGlzLFtlLmdlb21ldHJpZXNdKTpFb1tuXS5hcHBseSh0aGlzLFtlXSl9LHdyaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cnlUeXBlKCk7aWYoIUlvW2VdKXRocm93IG5ldyBFcnJvcihcIkdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIElvW2VdLmFwcGx5KHRoaXMsW3RdKX19KTt2YXIgRW89e0ZlYXR1cmU6ZnVuY3Rpb24odCl7dmFyIGU9e307Zm9yKHZhciBuIGluIHQpZVtuXT10W25dO2lmKHQuZ2VvbWV0cnkpe3ZhciBpPXQuZ2VvbWV0cnkudHlwZTtpZighRW9baV0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK3QudHlwZSk7ZS5nZW9tZXRyeT10aGlzLnJlYWQodC5nZW9tZXRyeSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD1Fby5iYm94LmFwcGx5KHRoaXMsW3QuYmJveF0pKSxlfSxGZWF0dXJlQ29sbGVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT17fTtpZih0LmZlYXR1cmVzKXtlLmZlYXR1cmVzPVtdO2Zvcih2YXIgbj0wO248dC5mZWF0dXJlcy5sZW5ndGg7KytuKWUuZmVhdHVyZXMucHVzaCh0aGlzLnJlYWQodC5mZWF0dXJlc1tuXSkpfXJldHVybiB0LmJib3gmJihlLmJib3g9dGhpcy5wYXJzZS5iYm94LmFwcGx5KHRoaXMsW3QuYmJveF0pKSxlfSxjb29yZGluYXRlczpmdW5jdGlvbiB0KGUpe2Zvcih2YXIgdD1bXSxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciBpPWVbbl07dC5wdXNoKG5ldyBnKGlbMF0saVsxXSkpfXJldHVybiB0fSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0WzBdLHRbMV0pLG5ldyBnKHRbMl0sdFsxXSksbmV3IGcodFsyXSx0WzNdKSxuZXcgZyh0WzBdLHRbM10pLG5ldyBnKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodFswXSx0WzFdKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSl9LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goRW8uUG9pbnQuYXBwbHkodGhpcyxbdFtuXV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT1Fby5jb29yZGluYXRlcy5hcHBseSh0aGlzLFt0XSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZSl9LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChFby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW3Rbbl1dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9RW8uY29vcmRpbmF0ZXMuYXBwbHkodGhpcyxbdFswXV0pLG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhlKSxpPVtdLHI9MTtyPHQubGVuZ3RoOysrcil7dmFyIHM9dFtyXSxvPUVvLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsW3NdKSxhPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobyk7aS5wdXNoKGEpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4saSl9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKXt2YXIgaT10W25dO2UucHVzaChFby5Qb2x5Z29uLmFwcGx5KHRoaXMsW2ldKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBpPXRbbl07ZS5wdXNoKHRoaXMucmVhZChpKSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX19LElvPXtjb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVyblt0LngsdC55XX0sUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9SW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFt0LmdldENvb3JkaW5hdGUoKV0pO3JldHVybnt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczplfX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPUlvLlBvaW50LmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49dC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoOysraSl7dmFyIHI9bltpXTtlLnB1c2goSW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFtyXSkpfXJldHVybnt0eXBlOlwiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1Jby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT1bXSxuPUlvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbdC5zaGVsbF0pO2UucHVzaChuLmNvb3JkaW5hdGVzKTtmb3IodmFyIGk9MDtpPHQuaG9sZXMubGVuZ3RoOysraSl7dmFyIHI9dC5ob2xlc1tpXSxzPUlvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbcl0pO2UucHVzaChzLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIlBvbHlnb25cIixjb29yZGluYXRlczplfX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9SW8uUG9seWdvbi5hcHBseSh0aGlzLFtpXSk7ZS5wdXNoKHIuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPWkuZ2V0R2VvbWV0cnlUeXBlKCk7ZS5wdXNoKElvW3JdLmFwcGx5KHRoaXMsW2ldKSl9cmV0dXJue3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOmV9fX07ZShWaS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wYXJzZXIucmVhZCh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5nZXRUeXBlKCk9PT1lZS5GSVhFRCYmdGhpcy5yZWR1Y2VQcmVjaXNpb24oZSksZX0scmVkdWNlUHJlY2lzaW9uOmZ1bmN0aW9uKHQpe3ZhciBlLG47aWYodC5jb29yZGluYXRlKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5jb29yZGluYXRlKTtlbHNlIGlmKHQucG9pbnRzKWZvcihlPTAsbj10LnBvaW50cy5sZW5ndGg7ZTxuO2UrKyl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQucG9pbnRzW2VdKTtlbHNlIGlmKHQuZ2VvbWV0cmllcylmb3IoZT0wLG49dC5nZW9tZXRyaWVzLmxlbmd0aDtlPG47ZSsrKXRoaXMucmVkdWNlUHJlY2lzaW9uKHQuZ2VvbWV0cmllc1tlXSl9fSksZShraS5wcm90b3R5cGUse3dyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX19KSxlKFlpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnBhcnNlci5yZWFkKHQpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLmdldFR5cGUoKT09PWVlLkZJWEVEJiZ0aGlzLnJlZHVjZVByZWNpc2lvbihlKSxlfSxyZWR1Y2VQcmVjaXNpb246ZnVuY3Rpb24odCl7aWYodC5jb29yZGluYXRlKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5jb29yZGluYXRlKTtlbHNlIGlmKHQucG9pbnRzKWZvcih2YXIgZT0wLG49dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO2U8bjtlKyspdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LnBvaW50cy5jb29yZGluYXRlc1tlXSk7ZWxzZSBpZih0Lmdlb21ldHJpZXMpZm9yKHZhciBpPTAscj10Lmdlb21ldHJpZXMubGVuZ3RoO2k8cjtpKyspdGhpcy5yZWR1Y2VQcmVjaXNpb24odC5nZW9tZXRyaWVzW2ldKX19KSxlKFhpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLm9sO3JldHVybiB0IGluc3RhbmNlb2YgZS5nZW9tLlBvaW50P3RoaXMuY29udmVydEZyb21Qb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5MaW5lYXJSaW5nP3RoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9pbnQodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5NdWx0aUxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uP3RoaXMuY29udmVydEZyb21Db2xsZWN0aW9uKHQpOnZvaWQgMH0sY29udmVydEZyb21Qb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBnKGVbMF0sZVsxXSkpfSxjb252ZXJ0RnJvbUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKX0sY29udmVydEZyb21MaW5lYXJSaW5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRbMF0sdFsxXSl9KSl9LGNvbnZlcnRGcm9tUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRMaW5lYXJSaW5ncygpLG49bnVsbCxpPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIHM9dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcoZVtyXSk7MD09PXI/bj1zOmkucHVzaChzKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLGkpfSxjb252ZXJ0RnJvbU11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2ludCh0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LGNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0TGluZVN0cmluZ3MoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxjb252ZXJ0RnJvbU11bHRpUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT10LmdldFBvbHlnb25zKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihlKX0sY29udmVydEZyb21Db2xsZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cmllcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfSx3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm5cIlBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9pbnQodC5nZXRDb29yZGluYXRlKCkpOlwiTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodCk6XCJMaW5lYXJSaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZWFyUmluZyh0KTpcIlBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQpOlwiTXVsdGlQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9pbnQodCk6XCJNdWx0aUxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCk6XCJNdWx0aVBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvbHlnb24odCk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Db2xsZWN0aW9uKHQpOnZvaWQgMH0sY29udmVydFRvUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uUG9pbnQoW3QueCx0LnldKX0sY29udmVydFRvTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50cy5jb29yZGluYXRlcy5tYXAoVWkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVTdHJpbmcoZSl9LGNvbnZlcnRUb0xpbmVhclJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKFVpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5MaW5lYXJSaW5nKGUpfSxjb252ZXJ0VG9Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bdC5zaGVsbC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKFVpKV0sbj0wO248dC5ob2xlcy5sZW5ndGg7bisrKWUucHVzaCh0LmhvbGVzW25dLnBvaW50cy5jb29yZGluYXRlcy5tYXAoVWkpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2x5Z29uKGUpfSxjb252ZXJ0VG9NdWx0aVBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9pbnQodC5nZXRDb29yZGluYXRlcygpLm1hcChVaSkpfSxjb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodC5nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmcoZSl9LGNvbnZlcnRUb011bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZS5wdXNoKHRoaXMuY29udmVydFRvUG9seWdvbih0Lmdlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9seWdvbihlKX0sY29udmVydFRvQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspe3ZhciBpPXQuZ2VvbWV0cmllc1tuXTtlLnB1c2godGhpcy53cml0ZShpKSl9cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0pO3ZhciBObz1PYmplY3QuZnJlZXplKHtHZW9KU09OUmVhZGVyOlZpLEdlb0pTT05Xcml0ZXI6a2ksT0wzUGFyc2VyOlhpLFdLVFJlYWRlcjpZaSxXS1RXcml0ZXI6c2V9KTtlKEhpLnByb3RvdHlwZSx7cmVzY2FsZTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLnJlc2NhbGUobi5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPW51bGwscz1udWxsOzI9PT1pLmxlbmd0aCYmKHI9bmV3IGcoaVswXSkscz1uZXcgZyhpWzFdKSk7Zm9yKHZhciBlPTA7ZTxpLmxlbmd0aDtlKyspaVtlXS54PWlbZV0ueC90aGlzLnNjYWxlRmFjdG9yK3RoaXMub2Zmc2V0WCxpW2VdLnk9aVtlXS55L3RoaXMuc2NhbGVGYWN0b3IrdGhpcy5vZmZzZXRZOzI9PT1pLmxlbmd0aCYmaVswXS5lcXVhbHMyRChpWzFdKSYmQS5vdXQucHJpbnRsbihpKX19LHNjYWxlOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBLZSh0aGlzLnNjYWxlKGkuZ2V0Q29vcmRpbmF0ZXMoKSksaS5nZXREYXRhKCkpKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIHI9YXJndW1lbnRzWzBdLHM9bmV3IEFycmF5KHIubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPHIubGVuZ3RoO24rKylzW25dPW5ldyBnKE1hdGgucm91bmQoKHJbbl0ueC10aGlzLm9mZnNldFgpKnRoaXMuc2NhbGVGYWN0b3IpLE1hdGgucm91bmQoKHJbbl0ueS10aGlzLm9mZnNldFkpKnRoaXMuc2NhbGVGYWN0b3IpLHJbbl0ueik7dmFyIG89SC5yZW1vdmVSZXBlYXRlZFBvaW50cyhzKTtyZXR1cm4gb319LGlzSW50ZWdlclByZWNpc2lvbjpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5zY2FsZUZhY3Rvcn0sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtyZXR1cm4gdGhpcy5pc1NjYWxlZCYmdGhpcy5yZXNjYWxlKHQpLHR9LGNvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuaXNTY2FsZWQmJihlPXRoaXMuc2NhbGUodCkpLHRoaXMubm9kZXIuY29tcHV0ZU5vZGVzKGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhpfX0pO3ZhciBDbz1PYmplY3QuZnJlZXplKHtNQ0luZGV4Tm9kZXI6bm4sU2NhbGVkTm9kZXI6SGksU2VnbWVudFN0cmluZzpiZX0pO2UoV2kucHJvdG90eXBlLHtpc1NpbXBsZU11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Zm9yKHZhciBlPW5ldyBhdCxuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pLHI9aS5nZXRDb29yZGluYXRlKCk7aWYoZS5jb250YWlucyhyKSlyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1yLCExO2UuYWRkKHIpfXJldHVybiEwfSxpc1NpbXBsZVBvbHlnb25hbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9a24uZ2V0TGluZXModCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighdGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KGkpKXJldHVybiExfXJldHVybiEwfSxoYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IHJ0LG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9KGkuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpLGkuaXNDbG9zZWQoKSkscz1pLmdldENvb3JkaW5hdGUoMCk7dGhpcy5hZGRFbmRwb2ludChlLHMscik7dmFyIG89aS5nZXRDb29yZGluYXRlKGkuZ2V0TnVtUG9pbnRzKCktMSk7dGhpcy5hZGRFbmRwb2ludChlLG8scil9Zm9yKHZhciBuPWUudmFsdWVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBhPW4ubmV4dCgpO2lmKGEuaXNDbG9zZWQmJjIhPT1hLmRlZ3JlZSlyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1hLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX0sZ2V0Tm9uU2ltcGxlTG9jYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbn0saXNTaW1wbGVMaW5lYXJHZW9tZXRyeTpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDt2YXIgZT1uZXcgJG4oMCx0KSxuPW5ldyBhZSxpPWUuY29tcHV0ZVNlbGZOb2RlcyhuLCEwKTtyZXR1cm4haS5oYXNJbnRlcnNlY3Rpb24oKXx8KGkuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMubm9uU2ltcGxlTG9jYXRpb249aS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKTohdGhpcy5oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbihlKSYmKCF0aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcnx8IXRoaXMuaGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSkpKX0saGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZighcy5pc0VuZFBvaW50KGkpKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPXMuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfSxhZGRFbmRwb2ludDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXQoZSk7bnVsbD09PWkmJihpPW5ldyBqaShlKSx0LnB1dChlLGkpKSxpLmFkZEVuZHBvaW50KG4pfSxjb21wdXRlU2ltcGxlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPW51bGwsISF0LmlzRW1wdHkoKXx8KHQgaW5zdGFuY2VvZiBTdD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIGd0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgUHQ/dGhpcy5pc1NpbXBsZU11bHRpUG9pbnQodCk6Uih0LFJ0KT90aGlzLmlzU2ltcGxlUG9seWdvbmFsKHQpOiEodCBpbnN0YW5jZW9mIGZ0KXx8dGhpcy5pc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbih0KSl9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249bnVsbCx0aGlzLmNvbXB1dGVTaW1wbGUodGhpcy5pbnB1dEdlb20pfSxpc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2l9fSksZShqaS5wcm90b3R5cGUse2FkZEVuZHBvaW50OmZ1bmN0aW9uKHQpe3RoaXMuZGVncmVlKyssdGhpcy5pc0Nsb3NlZHw9dH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqaX19KSxXaS5FbmRwb2ludEluZm89amksZShLaS5wcm90b3R5cGUse2dldEVuZENhcFN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kQ2FwU3R5bGV9LGlzU2luZ2xlU2lkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH0sc2V0UXVhZHJhbnRTZWdtZW50czpmdW5jdGlvbih0KXt0aGlzLnF1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5xdWFkcmFudFNlZ21lbnRzJiYodGhpcy5qb2luU3R5bGU9S2kuSk9JTl9CRVZFTCksdGhpcy5xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLmpvaW5TdHlsZT1LaS5KT0lOX01JVFJFLHRoaXMubWl0cmVMaW1pdD1NYXRoLmFicyh0aGlzLnF1YWRyYW50U2VnbWVudHMpKSx0PD0wJiYodGhpcy5xdWFkcmFudFNlZ21lbnRzPTEpLHRoaXMuam9pblN0eWxlIT09S2kuSk9JTl9ST1VORCYmKHRoaXMucXVhZHJhbnRTZWdtZW50cz1LaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX0sZ2V0Sm9pblN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblN0eWxlfSxzZXRKb2luU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5qb2luU3R5bGU9dH0sc2V0U2ltcGxpZnlGYWN0b3I6ZnVuY3Rpb24odCl7dGhpcy5zaW1wbGlmeUZhY3Rvcj10PDA/MDp0fSxnZXRTaW1wbGlmeUZhY3RvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpbXBsaWZ5RmFjdG9yfSxnZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVhZHJhbnRTZWdtZW50c30sc2V0RW5kQ2FwU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5lbmRDYXBTdHlsZT10fSxnZXRNaXRyZUxpbWl0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWl0cmVMaW1pdH0sc2V0TWl0cmVMaW1pdDpmdW5jdGlvbih0KXt0aGlzLm1pdHJlTGltaXQ9dH0sc2V0U2luZ2xlU2lkZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNTaW5nbGVTaWRlZD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLaX19KSxLaS5idWZmZXJEaXN0YW5jZUVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguUEkvMi90O3JldHVybiAxLU1hdGguY29zKGUvMil9LEtpLkNBUF9ST1VORD0xLEtpLkNBUF9GTEFUPTIsS2kuQ0FQX1NRVUFSRT0zLEtpLkpPSU5fUk9VTkQ9MSxLaS5KT0lOX01JVFJFPTIsS2kuSk9JTl9CRVZFTD0zLEtpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM9OCxLaS5ERUZBVUxUX01JVFJFX0xJTUlUPTUsS2kuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I9LjAxLGUoWmkucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluQ29vcmR9LGdldFJpZ2h0bW9zdFNpZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKTtyZXR1cm4gbjwwJiYobj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlLTEpKSxuPDAmJih0aGlzLm1pbkNvb3JkPW51bGwsdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCkpLG59LGZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2YuaXNUcnVlKHRoaXMubWluSW5kZXg+MCYmdGhpcy5taW5JbmRleDx0Lmxlbmd0aCxcInJpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZVwiKTt2YXIgZT10W3RoaXMubWluSW5kZXgtMV0sbj10W3RoaXMubWluSW5kZXgrMV0saT1oZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5taW5Db29yZCxuLGUpLHI9ITE7ZS55PHRoaXMubWluQ29vcmQueSYmbi55PHRoaXMubWluQ29vcmQueSYmaT09PWhlLkNPVU5URVJDTE9DS1dJU0U/cj0hMDplLnk+dGhpcy5taW5Db29yZC55JiZuLnk+dGhpcy5taW5Db29yZC55JiZpPT09aGUuQ0xPQ0tXSVNFJiYocj0hMCksciYmKHRoaXMubWluSW5kZXg9dGhpcy5taW5JbmRleC0xKX0sZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0RWRnZSgpLGk9bi5nZXRDb29yZGluYXRlcygpO2lmKGU8MHx8ZSsxPj1pLmxlbmd0aClyZXR1cm4tMTtpZihpW2VdLnk9PT1pW2UrMV0ueSlyZXR1cm4tMTt2YXIgcj1jbi5MRUZUO3JldHVybiBpW2VdLnk8aVtlKzFdLnkmJihyPWNuLlJJR0hUKSxyfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZW50ZWREZX0sY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLG49MDtuPGUubGVuZ3RoLTE7bisrKShudWxsPT09dGhpcy5taW5Db29yZHx8ZVtuXS54PnRoaXMubWluQ29vcmQueCkmJih0aGlzLm1pbkRlPXQsdGhpcy5taW5JbmRleD1uLHRoaXMubWluQ29vcmQ9ZVtuXSl9LGZpbmRSaWdodG1vc3RFZGdlQXROb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5taW5EZS5nZXROb2RlKCksZT10LmdldEVkZ2VzKCk7dGhpcy5taW5EZT1lLmdldFJpZ2h0bW9zdEVkZ2UoKSx0aGlzLm1pbkRlLmlzRm9yd2FyZCgpfHwodGhpcy5taW5EZT10aGlzLm1pbkRlLmdldFN5bSgpLHRoaXMubWluSW5kZXg9dGhpcy5taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSl9LGZpbmRFZGdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmlzRm9yd2FyZCgpJiZ0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZShuKX1mLmlzVHJ1ZSgwIT09dGhpcy5taW5JbmRleHx8dGhpcy5taW5Db29yZC5lcXVhbHModGhpcy5taW5EZS5nZXRDb29yZGluYXRlKCkpLFwiaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZ1wiKSwwPT09dGhpcy5taW5JbmRleD90aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk6dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCksdGhpcy5vcmllbnRlZERlPXRoaXMubWluRGU7dmFyIGk9dGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMubWluRGUsdGhpcy5taW5JbmRleCk7aT09PWNuLkxFRlQmJih0aGlzLm9yaWVudGVkRGU9dGhpcy5taW5EZS5nZXRTeW0oKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFppfX0pLFFpLnByb3RvdHlwZS5hZGRMYXN0PWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlfLnB1c2godCl9LFFpLnByb3RvdHlwZS5yZW1vdmVGaXJzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5zaGlmdCgpfSxRaS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxlKEppLnByb3RvdHlwZSx7Y2xlYXJWaXNpdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5zZXRWaXNpdGVkKCExKX19LGdldFJpZ2h0bW9zdENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodE1vc3RDb29yZH0sY29tcHV0ZU5vZGVEZXB0aDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5pc1Zpc2l0ZWQoKXx8aS5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSl7ZT1pO2JyZWFrfX1pZihudWxsPT09ZSl0aHJvdyBuZXcgc24oXCJ1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKTt0LmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhlKTtmb3IodmFyIG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldFZpc2l0ZWQoITApLHRoaXMuY29weVN5bURlcHRocyhpKX19LGNvbXB1dGVEZXB0aDpmdW5jdGlvbih0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7dmFyIGU9dGhpcy5maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKTtlLnNldEVkZ2VEZXB0aHMoY24uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX0sY3JlYXRlOmZ1bmN0aW9uKHQpe3RoaXMuYWRkUmVhY2hhYmxlKHQpLHRoaXMuZmluZGVyLmZpbmRFZGdlKHRoaXMuZGlyRWRnZUxpc3QpLHRoaXMucmlnaHRNb3N0Q29vcmQ9dGhpcy5maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfSxmaW5kUmVzdWx0RWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXREZXB0aChjbi5SSUdIVCk+PTEmJmUuZ2V0RGVwdGgoY24uTEVGVCk8PTAmJiFlLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZlLnNldEluUmVzdWx0KCEwKX19LGNvbXB1dGVEZXB0aHM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEosbj1uZXcgUWksaT10LmdldE5vZGUoKTtmb3Iobi5hZGRMYXN0KGkpLGUuYWRkKGkpLHQuc2V0VmlzaXRlZCghMCk7IW4uaXNFbXB0eSgpOyl7dmFyIHI9bi5yZW1vdmVGaXJzdCgpO2UuYWRkKHIpLHRoaXMuY29tcHV0ZU5vZGVEZXB0aChyKTtmb3IodmFyIHM9ci5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxhPW8uZ2V0U3ltKCk7aWYoIWEuaXNWaXNpdGVkKCkpe3ZhciB1PWEuZ2V0Tm9kZSgpO2UuY29udGFpbnModSl8fChuLmFkZExhc3QodSksZS5hZGQodSkpfX19fSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5yaWdodE1vc3RDb29yZC54PGUucmlnaHRNb3N0Q29vcmQueD8tMTp0aGlzLnJpZ2h0TW9zdENvb3JkLng+ZS5yaWdodE1vc3RDb29yZC54PzE6MH0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5lbnYpe2Zvcih2YXIgdD1uZXcgQyxlPXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aC0xO3IrKyl0LmV4cGFuZFRvSW5jbHVkZShpW3JdKTt0aGlzLmVudj10fXJldHVybiB0aGlzLmVudn0sYWRkUmVhY2hhYmxlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBwZTtmb3IoZS5hZGQodCk7IWUuZW1wdHkoKTspe3ZhciBuPWUucG9wKCk7dGhpcy5hZGQobixlKX19LGNvcHlTeW1EZXB0aHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRTeW0oKTtlLnNldERlcHRoKGNuLkxFRlQsdC5nZXREZXB0aChjbi5SSUdIVCkpLGUuc2V0RGVwdGgoY24uUklHSFQsdC5nZXREZXB0aChjbi5MRUZUKSl9LGFkZDpmdW5jdGlvbih0LGUpe3Quc2V0VmlzaXRlZCghMCksdGhpcy5ub2Rlcy5hZGQodCk7Zm9yKHZhciBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5kaXJFZGdlTGlzdC5hZGQoaSk7dmFyIHI9aS5nZXRTeW0oKSxzPXIuZ2V0Tm9kZSgpO3MuaXNWaXNpdGVkKCl8fGUucHVzaChzKX19LGdldE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXN9LGdldERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXJFZGdlTGlzdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEppfX0pLGUoJGkucHJvdG90eXBlLHtpc0RlbGV0YWJsZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmlucHV0TGluZVt0XSxzPXRoaXMuaW5wdXRMaW5lW2VdLG89dGhpcy5pbnB1dExpbmVbbl07cmV0dXJuISF0aGlzLmlzQ29uY2F2ZShyLHMsbykmJighIXRoaXMuaXNTaGFsbG93KHIscyxvLGkpJiZ0aGlzLmlzU2hhbGxvd1NhbXBsZWQocixzLHQsbixpKSl9LGRlbGV0ZVNoYWxsb3dDb25jYXZpdGllczpmdW5jdGlvbigpe2Zvcih2YXIgdD0xLGU9KHRoaXMuaW5wdXRMaW5lLmxlbmd0aC0xLHRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCkpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKSxpPSExO248dGhpcy5pbnB1dExpbmUubGVuZ3RoOyl7dmFyIHI9ITE7dGhpcy5pc0RlbGV0YWJsZSh0LGUsbix0aGlzLmRpc3RhbmNlVG9sKSYmKHRoaXMuaXNEZWxldGVkW2VdPSRpLkRFTEVURSxyPSEwLGk9ITApLHQ9cj9uOmUsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKX1yZXR1cm4gaX0saXNTaGFsbG93Q29uY2F2aXR5OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbikscz1yPT09dGhpcy5hbmdsZU9yaWVudGF0aW9uO2lmKCFzKXJldHVybiExO3ZhciBvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsdCxuKTtyZXR1cm4gbzxpfSxpc1NoYWxsb3dTYW1wbGVkOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9TWF0aC50cnVuYygoaS1uKS8kaS5OVU1fUFRTX1RPX0NIRUNLKTtzPD0wJiYocz0xKTtmb3IodmFyIG89bjtvPGk7bys9cylpZighdGhpcy5pc1NoYWxsb3codCxlLHRoaXMuaW5wdXRMaW5lW29dLHIpKXJldHVybiExO3JldHVybiEwfSxpc0NvbmNhdmU6ZnVuY3Rpb24gdChlLG4saSl7dmFyIHI9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGUsbixpKSx0PXI9PT10aGlzLmFuZ2xlT3JpZW50YXRpb247cmV0dXJuIHR9LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2w9TWF0aC5hYnModCksdDwwJiYodGhpcy5hbmdsZU9yaWVudGF0aW9uPWhlLkNMT0NLV0lTRSksdGhpcy5pc0RlbGV0ZWQ9bmV3IEFycmF5KHRoaXMuaW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTt2YXIgZT0hMTtkbyBlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCk7d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9LGZpbmROZXh0Tm9uRGVsZXRlZEluZGV4OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10KzE7ZTx0aGlzLmlucHV0TGluZS5sZW5ndGgmJnRoaXMuaXNEZWxldGVkW2VdPT09JGkuREVMRVRFOyllKys7cmV0dXJuIGV9LGlzU2hhbGxvdzpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1oZS5kaXN0YW5jZVBvaW50TGluZShlLHQsbik7cmV0dXJuIHI8aX0sY29sbGFwc2VMaW5lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBOLGU9MDtlPHRoaXMuaW5wdXRMaW5lLmxlbmd0aDtlKyspdGhpcy5pc0RlbGV0ZWRbZV0hPT0kaS5ERUxFVEUmJnQuYWRkKHRoaXMuaW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkaX19KSwkaS5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyAkaSh0KTtyZXR1cm4gbi5zaW1wbGlmeShlKX0sJGkuSU5JVD0wLCRpLkRFTEVURT0xLCRpLktFRVA9MSwkaS5OVU1fUFRTX1RPX0NIRUNLPTEwLGUodHIucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHRMaXN0LnRvQXJyYXkodHIuQ09PUkRJTkFURV9BUlJBWV9UWVBFKTtyZXR1cm4gdH0sc2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy5wcmVjaXNpb25Nb2RlbD10fSxhZGRQdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZyh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShlKSx0aGlzLmlzUmVkdW5kYW50KGUpP251bGw6dm9pZCB0aGlzLnB0TGlzdC5hZGQoZSl9LHJldmVyc2U6ZnVuY3Rpb24oKXt9LGFkZFB0czpmdW5jdGlvbih0LGUpe2lmKGUpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5hZGRQdCh0W25dKTtlbHNlIGZvcih2YXIgbj10Lmxlbmd0aC0xO24+PTA7bi0tKXRoaXMuYWRkUHQodFtuXSl9LGlzUmVkdW5kYW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMucHRMaXN0LnNpemUoKTwxKXJldHVybiExO3ZhciBlPXRoaXMucHRMaXN0LmdldCh0aGlzLnB0TGlzdC5zaXplKCktMSksbj10LmRpc3RhbmNlKGUpO3JldHVybiBuPHRoaXMubWluaW1pbVZlcnRleERpc3RhbmNlfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBpZSxlPXQuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBlLnRvU3RyaW5nKCl9LGNsb3NlUmluZzpmdW5jdGlvbigpe2lmKHRoaXMucHRMaXN0LnNpemUoKTwxKXJldHVybiBudWxsO3ZhciB0PW5ldyBnKHRoaXMucHRMaXN0LmdldCgwKSksZT10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTEpLG49bnVsbDtyZXR1cm4gdGhpcy5wdExpc3Quc2l6ZSgpPj0yJiYobj10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTIpKSx0LmVxdWFscyhlKT9udWxsOnZvaWQgdGhpcy5wdExpc3QuYWRkKHQpfSxzZXRNaW5pbXVtVmVydGV4RGlzdGFuY2U6ZnVuY3Rpb24odCl7dGhpcy5taW5pbWltVmVydGV4RGlzdGFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdHJ9fSksdHIuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLGUoZXIucHJvdG90eXBlLHthZGROZXh0U2VnbWVudDpmdW5jdGlvbih0LGUpe2lmKHRoaXMuczA9dGhpcy5zMSx0aGlzLnMxPXRoaXMuczIsdGhpcy5zMj10LHRoaXMuc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLnMwLHRoaXMuczEpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcwLHRoaXMuc2lkZSx0aGlzLmRpc3RhbmNlLHRoaXMub2Zmc2V0MCksdGhpcy5zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuczEsdGhpcy5zMiksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLnNlZzEsdGhpcy5zaWRlLHRoaXMuZGlzdGFuY2UsdGhpcy5vZmZzZXQxKSx0aGlzLnMxLmVxdWFscyh0aGlzLnMyKSlyZXR1cm4gbnVsbDt2YXIgbj1oZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczIpLGk9bj09PWhlLkNMT0NLV0lTRSYmdGhpcy5zaWRlPT09Y24uTEVGVHx8bj09PWhlLkNPVU5URVJDTE9DS1dJU0UmJnRoaXMuc2lkZT09PWNuLlJJR0hUOzA9PT1uP3RoaXMuYWRkQ29sbGluZWFyKGUpOmk/dGhpcy5hZGRPdXRzaWRlVHVybihuLGUpOnRoaXMuYWRkSW5zaWRlVHVybihuLGUpfSxhZGRMaW5lRW5kQ2FwOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNlKHQsZSksaT1uZXcgY2U7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGNuLkxFRlQsdGhpcy5kaXN0YW5jZSxpKTt2YXIgcj1uZXcgY2U7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGNuLlJJR0hULHRoaXMuZGlzdGFuY2Uscik7dmFyIHM9ZS54LXQueCxvPWUueS10LnksYT1NYXRoLmF0YW4yKG8scyk7c3dpdGNoKHRoaXMuYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgS2kuQ0FQX1JPVU5EOnRoaXMuc2VnTGlzdC5hZGRQdChpLnAxKSx0aGlzLmFkZEZpbGxldEFyYyhlLGErTWF0aC5QSS8yLGEtTWF0aC5QSS8yLGhlLkNMT0NLV0lTRSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuYWRkUHQoci5wMSk7YnJlYWs7Y2FzZSBLaS5DQVBfRkxBVDp0aGlzLnNlZ0xpc3QuYWRkUHQoaS5wMSksdGhpcy5zZWdMaXN0LmFkZFB0KHIucDEpO2JyZWFrO2Nhc2UgS2kuQ0FQX1NRVUFSRTp2YXIgdT1uZXcgZzt1Lng9TWF0aC5hYnModGhpcy5kaXN0YW5jZSkqTWF0aC5jb3MoYSksdS55PU1hdGguYWJzKHRoaXMuZGlzdGFuY2UpKk1hdGguc2luKGEpO3ZhciBsPW5ldyBnKGkucDEueCt1LngsaS5wMS55K3UueSksaD1uZXcgZyhyLnAxLngrdS54LHIucDEueSt1LnkpO3RoaXMuc2VnTGlzdC5hZGRQdChsKSx0aGlzLnNlZ0xpc3QuYWRkUHQoaCl9fSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2VnTGlzdC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0fSxhZGRNaXRyZUpvaW46ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9ITAscz1udWxsO3RyeXtzPUYuaW50ZXJzZWN0aW9uKGUucDAsZS5wMSxuLnAwLG4ucDEpO3ZhciBvPWk8PTA/MTpzLmRpc3RhbmNlKHQpL01hdGguYWJzKGkpO28+dGhpcy5idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpJiYocj0hMSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgdykpdGhyb3cgdDtzPW5ldyBnKDAsMCkscj0hMX1maW5hbGx5e31yP3RoaXMuc2VnTGlzdC5hZGRQdChzKTp0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4oZSxuLGksdGhpcy5idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKX0sYWRkRmlsbGV0Q29ybmVyOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9ZS54LXQueCxvPWUueS10LnksYT1NYXRoLmF0YW4yKG8scyksdT1uLngtdC54LGw9bi55LXQueSxoPU1hdGguYXRhbjIobCx1KTtpPT09aGUuQ0xPQ0tXSVNFP2E8PWgmJihhKz0yKk1hdGguUEkpOmE+PWgmJihhLT0yKk1hdGguUEkpLHRoaXMuc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZEZpbGxldEFyYyh0LGEsaCxpLHIpLHRoaXMuc2VnTGlzdC5hZGRQdChuKX0sYWRkT3V0c2lkZVR1cm46ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMub2Zmc2V0MS5wMCk8dGhpcy5kaXN0YW5jZSplci5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj8odGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksbnVsbCk6dm9pZCh0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUtpLkpPSU5fTUlUUkU/dGhpcy5hZGRNaXRyZUpvaW4odGhpcy5zMSx0aGlzLm9mZnNldDAsdGhpcy5vZmZzZXQxLHRoaXMuZGlzdGFuY2UpOnRoaXMuYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09S2kuSk9JTl9CRVZFTD90aGlzLmFkZEJldmVsSm9pbih0aGlzLm9mZnNldDAsdGhpcy5vZmZzZXQxKTooZSYmdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksdGhpcy5hZGRGaWxsZXRDb3JuZXIodGhpcy5zMSx0aGlzLm9mZnNldDAucDEsdGhpcy5vZmZzZXQxLnAwLHQsdGhpcy5kaXN0YW5jZSksdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCkpKX0sY3JlYXRlU3F1YXJlOmZ1bmN0aW9uKHQpe3RoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnkrdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnktdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5kaXN0YW5jZSx0LnktdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5kaXN0YW5jZSx0LnkrdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5jbG9zZVJpbmcoKX0sYWRkU2VnbWVudHM6ZnVuY3Rpb24odCxlKXt0aGlzLnNlZ0xpc3QuYWRkUHRzKHQsZSl9LGFkZEZpcnN0U2VnbWVudDpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApfSxhZGRMYXN0U2VnbWVudDpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDEpfSxpbml0U2lkZVNlZ21lbnRzOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLnMxPXQsdGhpcy5zMj1lLHRoaXMuc2lkZT1uLHRoaXMuc2VnMS5zZXRDb29yZGluYXRlcyh0LGUpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcxLG4sdGhpcy5kaXN0YW5jZSx0aGlzLm9mZnNldDEpO1xufSxhZGRMaW1pdGVkTWl0cmVKb2luOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMuc2VnMC5wMSxzPUNpLmFuZ2xlKHIsdGhpcy5zZWcwLnAwKSxvPShDaS5hbmdsZShyLHRoaXMuc2VnMS5wMSksQ2kuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5zZWcwLnAwLHIsdGhpcy5zZWcxLnAxKSksYT1vLzIsdT1DaS5ub3JtYWxpemUocythKSxsPUNpLm5vcm1hbGl6ZSh1K01hdGguUEkpLGg9aSpuLGM9aCpNYXRoLmFicyhNYXRoLnNpbihhKSksZj1uLWMsZD1yLngraCpNYXRoLmNvcyhsKSxwPXIueStoKk1hdGguc2luKGwpLHY9bmV3IGcoZCxwKSxtPW5ldyBjZShyLHYpLHk9bS5wb2ludEFsb25nT2Zmc2V0KDEsZikseD1tLnBvaW50QWxvbmdPZmZzZXQoMSwtZik7dGhpcy5zaWRlPT09Y24uTEVGVD8odGhpcy5zZWdMaXN0LmFkZFB0KHkpLHRoaXMuc2VnTGlzdC5hZGRQdCh4KSk6KHRoaXMuc2VnTGlzdC5hZGRQdCh4KSx0aGlzLnNlZ0xpc3QuYWRkUHQoeSkpfSxjb21wdXRlT2Zmc2V0U2VnbWVudDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1lPT09Y24uTEVGVD8xOi0xLHM9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksYT1NYXRoLnNxcnQocypzK28qbyksdT1yKm4qcy9hLGw9cipuKm8vYTtpLnAwLng9dC5wMC54LWwsaS5wMC55PXQucDAueSt1LGkucDEueD10LnAxLngtbCxpLnAxLnk9dC5wMS55K3V9LGFkZEZpbGxldEFyYzpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPWk9PT1oZS5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksYT1NYXRoLnRydW5jKG8vdGhpcy5maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKGE8MSlyZXR1cm4gbnVsbDt2YXIgdT1udWxsLGw9bnVsbDt1PTAsbD1vL2E7Zm9yKHZhciBoPXUsYz1uZXcgZztoPG87KXt2YXIgZj1lK3MqaDtjLng9dC54K3IqTWF0aC5jb3MoZiksYy55PXQueStyKk1hdGguc2luKGYpLHRoaXMuc2VnTGlzdC5hZGRQdChjKSxoKz1sfX0sYWRkSW5zaWRlVHVybjpmdW5jdGlvbih0LGUpe2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLm9mZnNldDAucDAsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCx0aGlzLm9mZnNldDEucDEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLm9mZnNldDAucDEuZGlzdGFuY2UodGhpcy5vZmZzZXQxLnAwKTx0aGlzLmRpc3RhbmNlKmVyLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXt2YXIgbj1uZXcgZygodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS54K3RoaXMuczEueCkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS55K3RoaXMuczEueSkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5zZWdMaXN0LmFkZFB0KG4pO3ZhciBpPW5ldyBnKCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLngrdGhpcy5zMS54KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLnkrdGhpcy5zMS55KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLnNlZ0xpc3QuYWRkUHQoaSl9ZWxzZSB0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5zMSk7dGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCl9fSxjcmVhdGVDaXJjbGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55KTt0aGlzLnNlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGRGaWxsZXRBcmModCwwLDIqTWF0aC5QSSwtMSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGFkZEJldmVsSm9pbjpmdW5jdGlvbih0LGUpe3RoaXMuc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLnNlZ0xpc3QuYWRkUHQoZS5wMCl9LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZT10LHRoaXMubWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5zZWdMaXN0PW5ldyB0cix0aGlzLnNlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5wcmVjaXNpb25Nb2RlbCksdGhpcy5zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KmVyLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9LGFkZENvbGxpbmVhcjpmdW5jdGlvbih0KXt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczEsdGhpcy5zMik7dmFyIGU9dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTtlPj0yJiYodGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1LaS5KT0lOX0JFVkVMfHx0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUtpLkpPSU5fTUlUUkU/KHQmJnRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApKTp0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLnMxLHRoaXMub2Zmc2V0MC5wMSx0aGlzLm9mZnNldDEucDAsaGUuQ0xPQ0tXSVNFLHRoaXMuZGlzdGFuY2UpKX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7dGhpcy5zZWdMaXN0LmNsb3NlUmluZygpfSxoYXNOYXJyb3dDb25jYXZlQW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlcn19KSxlci5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLGVyLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLGVyLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LGVyLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwLGUobnIucHJvdG90eXBlLHtnZXRPZmZzZXRDdXJ2ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj1lPDAsaT1NYXRoLmFicyhlKSxyPXRoaXMuZ2V0U2VnR2VuKGkpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxyKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4scik7dmFyIHM9ci5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZILnJldmVyc2Uocyksc30sY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTt2YXIgcj0kaS5zaW1wbGlmeSh0LC1pKSxzPXIubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKHJbc10scltzLTFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPXMtMjtvPj0wO28tLSluLmFkZE5leHRTZWdtZW50KHJbb10sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTt2YXIgYT0kaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7bzw9dTtvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCksbi5jbG9zZVJpbmcoKX0sY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKTtlPT09Y24uUklHSFQmJihpPS1pKTt2YXIgcj0kaS5zaW1wbGlmeSh0LGkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzLTFdLHJbMF0sZSk7Zm9yKHZhciBvPTE7bzw9cztvKyspe3ZhciBhPTEhPT1vO24uYWRkTmV4dFNlZ21lbnQocltvXSxhKX1uLmNsb3NlUmluZygpfSxjb21wdXRlTGluZUJ1ZmZlckN1cnZlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKSxpPSRpLnNpbXBsaWZ5KHQsbikscj1pLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhpWzBdLGlbMV0sY24uTEVGVCk7Zm9yKHZhciBzPTI7czw9cjtzKyspZS5hZGROZXh0U2VnbWVudChpW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKGlbci0xXSxpW3JdKTt2YXIgbz0kaS5zaW1wbGlmeSh0LC1uKSxhPW8ubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKG9bYV0sb1thLTFdLGNuLkxFRlQpO2Zvcih2YXIgcz1hLTI7cz49MDtzLS0pZS5hZGROZXh0U2VnbWVudChvW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKG9bMV0sb1swXSksZS5jbG9zZVJpbmcoKX0sY29tcHV0ZVBvaW50Q3VydmU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godGhpcy5idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBLaS5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBLaS5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX0sZ2V0TGluZUN1cnZlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5kaXN0YW5jZT1lLGU8MCYmIXRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtpZigwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTtlbHNlIGlmKHRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSl7dmFyIHI9ZTwwO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxyLGkpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQsaSk7dmFyIHM9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBzfSxnZXRCdWZmZXJQYXJhbWV0ZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmUGFyYW1zfSxzaW1wbGlmeVRvbGVyYW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmJ1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpfSxnZXRSaW5nQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZGlzdGFuY2U9bix0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUodCxuKTtpZigwPT09bilyZXR1cm4gbnIuY29weUNvb3JkaW5hdGVzKHQpO3ZhciBpPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLGkpLGkuZ2V0Q29vcmRpbmF0ZXMoKX0sY29tcHV0ZU9mZnNldEN1cnZlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpO2lmKGUpe3ZhciByPSRpLnNpbXBsaWZ5KHQsLWkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzXSxyW3MtMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89cy0yO28+PTA7by0tKW4uYWRkTmV4dFNlZ21lbnQocltvXSwhMCl9ZWxzZXt2YXIgYT0kaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7bzw9dTtvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9LGdldFNlZ0dlbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGVyKHRoaXMucHJlY2lzaW9uTW9kZWwsdGhpcy5idWZQYXJhbXMsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5yfX0pLG5yLmNvcHlDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfSxlKGlyLnByb3RvdHlwZSx7ZmluZFN0YWJiZWRTZWdtZW50czpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10aGlzLnN1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldEVudmVsb3BlKCk7dC55PHIuZ2V0TWluWSgpfHx0Lnk+ci5nZXRNYXhZKCl8fHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LGkuZ2V0RGlyZWN0ZWRFZGdlcygpLGUpfXJldHVybiBlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSW4pZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPWFyZ3VtZW50c1syXSx1PW8uZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCksbj0wO248dS5sZW5ndGgtMTtuKyspe3RoaXMuc2VnLnAwPXVbbl0sdGhpcy5zZWcucDE9dVtuKzFdLHRoaXMuc2VnLnAwLnk+dGhpcy5zZWcucDEueSYmdGhpcy5zZWcucmV2ZXJzZSgpO3ZhciBsPU1hdGgubWF4KHRoaXMuc2VnLnAwLngsdGhpcy5zZWcucDEueCk7aWYoIShsPHMueHx8dGhpcy5zZWcuaXNIb3Jpem9udGFsKCl8fHMueTx0aGlzLnNlZy5wMC55fHxzLnk+dGhpcy5zZWcucDEueXx8aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuc2VnLnAwLHRoaXMuc2VnLnAxLHMpPT09aGUuUklHSFQpKXt2YXIgaD1vLmdldERlcHRoKGNuLkxFRlQpO3RoaXMuc2VnLnAwLmVxdWFscyh1W25dKXx8KGg9by5nZXREZXB0aChjbi5SSUdIVCkpO3ZhciBjPW5ldyBycih0aGlzLnNlZyxoKTthLmFkZChjKX19ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZSKGFyZ3VtZW50c1sxXSx5KSlmb3IodmFyIGY9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdLG49ZC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIHY9bi5uZXh0KCk7di5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKGYsdixwKX19LGdldERlcHRoOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtpZigwPT09ZS5zaXplKCkpcmV0dXJuIDA7dmFyIG49aG8ubWluKGUpO3JldHVybiBuLmxlZnREZXB0aH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaXJ9fSksZShyci5wcm90b3R5cGUse2NvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O2lmKHRoaXMudXB3YXJkU2VnLm1pblgoKT49ZS51cHdhcmRTZWcubWF4WCgpKXJldHVybiAxO2lmKHRoaXMudXB3YXJkU2VnLm1heFgoKTw9ZS51cHdhcmRTZWcubWluWCgpKXJldHVybi0xO3ZhciBuPXRoaXMudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgoZS51cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy51cHdhcmRTZWcpLDAhPT1uP246dGhpcy51cHdhcmRTZWcuY29tcGFyZVRvKGUudXB3YXJkU2VnKSl9LGNvbXBhcmVYOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dC5wMS5jb21wYXJlVG8oZS5wMSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXB3YXJkU2VnLnRvU3RyaW5nKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBycn19KSxpci5EZXB0aFNlZ21lbnQ9cnIsZShzci5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMuZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7dmFyIGU9dC5nZXRDb29yZGluYXRlcygpLG49dGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLEwuRVhURVJJT1IsTC5JTlRFUklPUil9LGFkZFBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaXN0YW5jZSxuPWNuLkxFRlQ7dGhpcy5kaXN0YW5jZTwwJiYoZT0tdGhpcy5kaXN0YW5jZSxuPWNuLlJJR0hUKTt2YXIgaT10LmdldEV4dGVyaW9yUmluZygpLHI9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyhpLmdldENvb3JkaW5hdGVzKCkpO2lmKHRoaXMuZGlzdGFuY2U8MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoaSx0aGlzLmRpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLmRpc3RhbmNlPD0wJiZyLmxlbmd0aDwzKXJldHVybiBudWxsO3RoaXMuYWRkUG9seWdvblJpbmcocixlLG4sTC5FWFRFUklPUixMLklOVEVSSU9SKTtmb3IodmFyIHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10LmdldEludGVyaW9yUmluZ04ocyksYT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKG8uZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShvLC10aGlzLmRpc3RhbmNlKXx8dGhpcy5hZGRQb2x5Z29uUmluZyhhLGUsY24ub3Bwb3NpdGUobiksTC5JTlRFUklPUixMLkVYVEVSSU9SKX19LGlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5OmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFNpKHRbMF0sdFsxXSx0WzJdKSxpPW4uaW5DZW50cmUoKSxyPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGksbi5wMCxuLnAxKTtyZXR1cm4gcjxNYXRoLmFicyhlKX0sYWRkTGluZVN0cmluZzpmdW5jdGlvbih0KXtpZih0aGlzLmRpc3RhbmNlPD0wJiYhdGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLmN1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLmRpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sTC5FWFRFUklPUixMLklOVEVSSU9SKX0sYWRkQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGw9PT10fHx0Lmxlbmd0aDwyKXJldHVybiBudWxsO3ZhciBpPW5ldyBLZSh0LG5ldyBnbigwLEwuQk9VTkRBUlksZSxuKSk7dGhpcy5jdXJ2ZUxpc3QuYWRkKGkpfSxnZXRDdXJ2ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGQodGhpcy5pbnB1dEdlb20pLHRoaXMuY3VydmVMaXN0fSxhZGRQb2x5Z29uUmluZzpmdW5jdGlvbih0LGUsbixpLHIpe2lmKDA9PT1lJiZ0Lmxlbmd0aDxidC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7dmFyIHM9aSxvPXI7dC5sZW5ndGg+PWJ0Lk1JTklNVU1fVkFMSURfU0laRSYmaGUuaXNDQ1codCkmJihzPXIsbz1pLG49Y24ub3Bwb3NpdGUobikpO3ZhciBhPXRoaXMuY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZSh0LG4sZSk7dGhpcy5hZGRDdXJ2ZShhLHMsbyl9LGFkZDpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fSxpc0Vyb2RlZENvbXBsZXRlbHk6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGVzKCk7aWYobi5sZW5ndGg8NClyZXR1cm4gZTwwO2lmKDQ9PT1uLmxlbmd0aClyZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShuLGUpO3ZhciBpPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9TWF0aC5taW4oaS5nZXRIZWlnaHQoKSxpLmdldFdpZHRoKCkpO3JldHVybiBlPDAmJjIqTWF0aC5hYnMoZSk+cn0sYWRkQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7dGhpcy5hZGQobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzcn19KSxlKG9yLnByb3RvdHlwZSx7aXNUcml2aWFsSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiYxPT09dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYob3IuaXNBZGphY2VudFNlZ21lbnRzKGUsaSkpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXt2YXIgcj10LnNpemUoKS0xO2lmKDA9PT1lJiZpPT09cnx8MD09PWkmJmU9PT1yKXJldHVybiEwfX1yZXR1cm4hMX0sZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH0saGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNQcm9wZXJJbnRlcmlvcn0sZ2V0TGluZUludGVyc2VjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl9LGhhc1Byb3BlckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3Blcn0scHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3RoaXMubnVtVGVzdHMrKzt2YXIgcj10LmdldENvb3JkaW5hdGVzKClbZV0scz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihyLHMsbyxhKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuaGFzSW50ZXJpb3I9ITApLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLGkpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKSx0aGlzLmxpLmlzUHJvcGVyKCkmJih0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKyx0aGlzLmhhc1Byb3Blcj0hMCx0aGlzLmhhc1Byb3BlckludGVyaW9yPSEwKSkpfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0saGFzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcmlvcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvcn19KSxvci5pc0FkamFjZW50U2VnbWVudHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PU1hdGguYWJzKHQtZSl9LGUoYXIucHJvdG90eXBlLHtzZXRXb3JraW5nUHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw9dH0saW5zZXJ0VW5pcXVlRWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe3ZhciBuPWUuZ2V0TGFiZWwoKSxpPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChpPW5ldyBnbih0LmdldExhYmVsKCkpLGkuZmxpcCgpKSxuLm1lcmdlKGkpO3ZhciByPWFyLmRlcHRoRGVsdGEoaSkscz1lLmdldERlcHRoRGVsdGEoKSxvPXMrcjtlLnNldERlcHRoRGVsdGEobyl9ZWxzZSB0aGlzLmVkZ2VMaXN0LmFkZCh0KSx0LnNldERlcHRoRGVsdGEoYXIuZGVwdGhEZWx0YSh0LmdldExhYmVsKCkpKX0sYnVpbGRTdWJncmFwaHM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKSxzPXIuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLG89bmV3IGlyKG4pLGE9by5nZXREZXB0aChzKTtyLmNvbXB1dGVEZXB0aChhKSxyLmZpbmRSZXN1bHRFZGdlcygpLG4uYWRkKHIpLGUuYWRkKHIuZ2V0RGlyZWN0ZWRFZGdlcygpLHIuZ2V0Tm9kZXMoKSl9fSxjcmVhdGVTdWJncmFwaHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5nZXROb2RlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighaS5pc1Zpc2l0ZWQoKSl7dmFyIHI9bmV3IEppO3IuY3JlYXRlKGkpLGUuYWRkKHIpfX1yZXR1cm4gaG8uc29ydChlLGhvLnJldmVyc2VPcmRlcigpKSxlfSxjcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCk7cmV0dXJuIHR9LGdldE5vZGVyOmZ1bmN0aW9uKHQpe2lmKG51bGwhPT10aGlzLndvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy53b3JraW5nTm9kZXI7dmFyIGU9bmV3IG5uLG49bmV3IGFlO3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBvcihuKSksZX0sYnVmZmVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5nZW9tRmFjdD10LmdldEZhY3RvcnkoKTt2YXIgaT1uZXcgbnIobix0aGlzLmJ1ZlBhcmFtcykscj1uZXcgc3IodCxlLGkpLHM9ci5nZXRDdXJ2ZXMoKTtpZihzLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhzLG4pLHRoaXMuZ3JhcGg9bmV3IENuKG5ldyBPbiksdGhpcy5ncmFwaC5hZGRFZGdlcyh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpO3ZhciBvPXRoaXMuY3JlYXRlU3ViZ3JhcGhzKHRoaXMuZ3JhcGgpLGE9bmV3IFNuKHRoaXMuZ2VvbUZhY3QpO3RoaXMuYnVpbGRTdWJncmFwaHMobyxhKTt2YXIgdT1hLmdldFBvbHlnb25zKCk7aWYodS5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3ZhciBsPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh1KTtyZXR1cm4gbH0sY29tcHV0ZU5vZGVkRWRnZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldE5vZGVyKGUpO24uY29tcHV0ZU5vZGVzKHQpO2Zvcih2YXIgaT1uLmdldE5vZGVkU3Vic3RyaW5ncygpLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldENvb3JkaW5hdGVzKCk7aWYoMiE9PW8ubGVuZ3RofHwhb1swXS5lcXVhbHMyRChvWzFdKSl7dmFyIGE9cy5nZXREYXRhKCksdT1uZXcgSm4ocy5nZXRDb29yZGluYXRlcygpLG5ldyBnbihhKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKHUpfX19LHNldE5vZGVyOmZ1bmN0aW9uKHQpe3RoaXMud29ya2luZ05vZGVyPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFyfX0pLGFyLmRlcHRoRGVsdGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRMb2NhdGlvbigwLGNuLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKTtyZXR1cm4gZT09PUwuSU5URVJJT1ImJm49PT1MLkVYVEVSSU9SPzE6ZT09PUwuRVhURVJJT1ImJm49PT1MLklOVEVSSU9SPy0xOjB9LGFyLmNvbnZlcnRTZWdTdHJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgaWUsbj1uZXcgSTt0Lmhhc05leHQoKTspe3ZhciBpPXQubmV4dCgpLHI9ZS5jcmVhdGVMaW5lU3RyaW5nKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQocil9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX0sZSh1ci5wcm90b3R5cGUse2NoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhuWzBdLHRoaXMuc2VnU3RyaW5ncyksdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhuW24ubGVuZ3RoLTFdLHRoaXMuc2VnU3RyaW5ncyl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHQ9ci5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCkscz0xO3M8bi5sZW5ndGgtMTtzKyspaWYobltzXS5lcXVhbHMoaSkpdGhyb3cgbmV3IGwoXCJmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggXCIrcytcIiA6cHQgXCIraSl9LGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoZSxpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1yLmdldENvb3JkaW5hdGVzKCksYT1zLmdldENvb3JkaW5hdGVzKCksdT0wO3U8by5sZW5ndGgtMTt1KyspZm9yKHZhciBoPTA7aDxhLmxlbmd0aC0xO2grKyl0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHIsdSxzLGgpO2Vsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBjPWFyZ3VtZW50c1swXSxmPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxkPWFyZ3VtZW50c1szXTtpZihjPT09ZyYmZj09PWQpcmV0dXJuIG51bGw7dmFyIHA9Yy5nZXRDb29yZGluYXRlcygpW2ZdLHY9Yy5nZXRDb29yZGluYXRlcygpW2YrMV0sbT1nLmdldENvb3JkaW5hdGVzKClbZF0seT1nLmdldENvb3JkaW5hdGVzKClbZCsxXTtpZih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocCx2LG0seSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubGkuaXNQcm9wZXIoKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLmxpLHAsdil8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5saSxtLHkpKSl0aHJvdyBuZXcgbChcImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgXCIrcCtcIi1cIit2K1wiIGFuZCBcIittK1wiLVwiK3kpfX0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0NvbGxhcHNlcygpfSxjaGVja0NvbGxhcHNlczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO3RoaXMuY2hlY2tDb2xsYXBzZXMoZSl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG49YXJndW1lbnRzWzBdLGk9bi5nZXRDb29yZGluYXRlcygpLHQ9MDt0PGkubGVuZ3RoLTI7dCsrKXRoaXMuY2hlY2tDb2xsYXBzZShpW3RdLGlbdCsxXSxpW3QrMl0pfSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl7dmFyIHI9dC5nZXRJbnRlcnNlY3Rpb24oaSk7aWYoIXIuZXF1YWxzKGUpJiYhci5lcXVhbHMobikpcmV0dXJuITB9cmV0dXJuITF9LGNoZWNrQ29sbGFwc2U6ZnVuY3Rpb24odCxlLG4pe2lmKHQuZXF1YWxzKG4pKXRocm93IG5ldyBsKFwiZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0IFwiK3VyLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbdCxlLG5dKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVyfX0pLHVyLmZhY3Q9bmV3IGllLGUobHIucHJvdG90eXBlLHtpbnRlcnNlY3RzU2NhbGVkOmZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5taW4odC54LGUueCksaT1NYXRoLm1heCh0LngsZS54KSxyPU1hdGgubWluKHQueSxlLnkpLHM9TWF0aC5tYXgodC55LGUueSksbz10aGlzLm1heHg8bnx8dGhpcy5taW54Pml8fHRoaXMubWF4eTxyfHx0aGlzLm1pbnk+cztpZihvKXJldHVybiExO3ZhciBhPXRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSh0LGUpO3JldHVybiBmLmlzVHJ1ZSghKG8mJmEpLFwiRm91bmQgYmFkIGVudmVsb3BlIHRlc3RcIiksYX0saW5pdENvcm5lcnM6ZnVuY3Rpb24odCl7dmFyIGU9LjU7dGhpcy5taW54PXQueC1lLHRoaXMubWF4eD10LngrZSx0aGlzLm1pbnk9dC55LWUsdGhpcy5tYXh5PXQueStlLHRoaXMuY29ybmVyWzBdPW5ldyBnKHRoaXMubWF4eCx0aGlzLm1heHkpLHRoaXMuY29ybmVyWzFdPW5ldyBnKHRoaXMubWlueCx0aGlzLm1heHkpLHRoaXMuY29ybmVyWzJdPW5ldyBnKHRoaXMubWlueCx0aGlzLm1pbnkpLHRoaXMuY29ybmVyWzNdPW5ldyBnKHRoaXMubWF4eCx0aGlzLm1pbnkpfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT10aGlzLnNjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLnAwU2NhbGVkKSx0aGlzLmNvcHlTY2FsZWQoZSx0aGlzLnAxU2NhbGVkKSx0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5wMFNjYWxlZCx0aGlzLnAxU2NhbGVkKSl9LHNjYWxlOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5zY2FsZUZhY3Rvcil9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnaW5hbFB0fSxjb3B5U2NhbGVkOmZ1bmN0aW9uKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfSxnZXRTYWZlRW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5zYWZlRW52KXt2YXIgdD1sci5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SL3RoaXMuc2NhbGVGYWN0b3I7dGhpcy5zYWZlRW52PW5ldyBDKHRoaXMub3JpZ2luYWxQdC54LXQsdGhpcy5vcmlnaW5hbFB0LngrdCx0aGlzLm9yaWdpbmFsUHQueS10LHRoaXMub3JpZ2luYWxQdC55K3QpfXJldHVybiB0aGlzLnNhZmVFbnZ9LGludGVyc2VjdHNQaXhlbENsb3N1cmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclswXSx0aGlzLmNvcm5lclsxXSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsxXSx0aGlzLmNvcm5lclsyXSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsyXSx0aGlzLmNvcm5lclszXSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclszXSx0aGlzLmNvcm5lclswXSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpKSkpfSxpbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ITEsaT0hMTtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclswXSx0aGlzLmNvcm5lclsxXSksISF0aGlzLmxpLmlzUHJvcGVyKCl8fCh0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzFdLHRoaXMuY29ybmVyWzJdKSwhIXRoaXMubGkuaXNQcm9wZXIoKXx8KHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJihuPSEwKSx0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzJdLHRoaXMuY29ybmVyWzNdKSwhIXRoaXMubGkuaXNQcm9wZXIoKXx8KHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJihpPSEwKSx0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzNdLHRoaXMuY29ybmVyWzBdKSwhIXRoaXMubGkuaXNQcm9wZXIoKXx8KCEoIW58fCFpKXx8KCEhdC5lcXVhbHModGhpcy5wdCl8fCEhZS5lcXVhbHModGhpcy5wdCkpKSkpKX0sYWRkU25hcHBlZE5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGUoZSksaT10LmdldENvb3JkaW5hdGUoZSsxKTtyZXR1cm4hIXRoaXMuaW50ZXJzZWN0cyhuLGkpJiYodC5hZGRJbnRlcnNlY3Rpb24odGhpcy5nZXRDb29yZGluYXRlKCksZSksITApfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBscn19KSxsci5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SPS43NSxlKGhyLnByb3RvdHlwZSx7c25hcDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc25hcCh0LG51bGwsLTEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl0scj1lLmdldFNhZmVFbnZlbG9wZSgpLHM9bmV3IGNyKGUsbixpKTtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeShyLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LHZpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O2Uuc2VsZWN0KHIscyl9fSkscy5pc05vZGVBZGRlZCgpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHJ9fSksaChjcixoaSksZShjci5wcm90b3R5cGUse2lzTm9kZUFkZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkfSxzZWxlY3Q6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaGkucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb250ZXh0KCk7cmV0dXJuIG51bGwhPT10aGlzLnBhcmVudEVkZ2UmJm49PT10aGlzLnBhcmVudEVkZ2UmJmU9PT10aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg/bnVsbDp2b2lkKHRoaXMuX2lzTm9kZUFkZGVkPXRoaXMuaG90UGl4ZWwuYWRkU25hcHBlZE5vZGUobixlKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNyfX0pLGhyLkhvdFBpeGVsU25hcEFjdGlvbj1jcixlKGZyLnByb3RvdHlwZSx7cHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07aWYodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKXtmb3IodmFyIHU9MDt1PHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7dSsrKXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzLmxpLmdldEludGVyc2VjdGlvbih1KSk7dC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpfX0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGdldEludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmcn19KSxlKGdyLnByb3RvdHlwZSx7Y2hlY2tDb3JyZWN0bmVzczpmdW5jdGlvbih0KXt2YXIgZT1LZS5nZXROb2RlZFN1YnN0cmluZ3ModCksbj1uZXcgdXIoZSk7dHJ5e24uY2hlY2tWYWxpZCgpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHQ7dC5wcmludFN0YWNrVHJhY2UoKX1maW5hbGx5e319LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5ub2RlZFNlZ1N0cmluZ3MpfSxzbmFwUm91bmQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKTt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhuKSx0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyh0KX0sZmluZEludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBmcihlKTtyZXR1cm4gdGhpcy5ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobiksdGhpcy5ub2Rlci5jb21wdXRlTm9kZXModCksbi5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKX0sY29tcHV0ZVZlcnRleFNuYXBzOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBLZSlmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9aS5nZXRDb29yZGluYXRlcygpLHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIG89bmV3IGxyKHJbc10sdGhpcy5zY2FsZUZhY3Rvcix0aGlzLmxpKSxhPXRoaXMucG9pbnRTbmFwcGVyLnNuYXAobyxpLHMpO2EmJmkuYWRkSW50ZXJzZWN0aW9uKHJbc10scyl9fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dGhpcy5ub2RlZFNlZ1N0cmluZ3M9dCx0aGlzLm5vZGVyPW5ldyBubix0aGlzLnBvaW50U25hcHBlcj1uZXcgaHIodGhpcy5ub2Rlci5nZXRJbmRleCgpKSx0aGlzLnNuYXBSb3VuZCh0LHRoaXMubGkpfSxjb21wdXRlSW50ZXJzZWN0aW9uU25hcHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bmV3IGxyKG4sdGhpcy5zY2FsZUZhY3Rvcix0aGlzLmxpKTt0aGlzLnBvaW50U25hcHBlci5zbmFwKGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdG5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBncn19KSxlKGRyLnByb3RvdHlwZSx7YnVmZmVyRml4ZWRQcmVjaXNpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEhpKG5ldyBncihuZXcgZWUoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgYXIodGhpcy5idWZQYXJhbXMpO24uc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKHQpLG4uc2V0Tm9kZXIoZSksdGhpcy5yZXN1bHRHZW9tZXRyeT1uLmJ1ZmZlcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSl9LGJ1ZmZlclJlZHVjZWRQcmVjaXNpb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWRyLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIHNuKSl0aHJvdyB0O3RoaXMuc2F2ZUV4Y2VwdGlvbj10fWZpbmFsbHl7fWlmKG51bGwhPT10aGlzLnJlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsfXRocm93IHRoaXMuc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49ZHIucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5hcmdHZW9tLHRoaXMuZGlzdGFuY2UsZSksaT1uZXcgZWUobik7dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihpKX19LGNvbXB1dGVHZW9tZXRyeTpmdW5jdGlvbigpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLmFyZ0dlb20uZ2V0RmFjdG9yeSgpLmdldFByZWNpc2lvbk1vZGVsKCk7dC5nZXRUeXBlKCk9PT1lZS5GSVhFRD90aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpOnRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpfSxzZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKHQpe3RoaXMuYnVmUGFyYW1zLnNldFF1YWRyYW50U2VnbWVudHModCl9LGJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uOmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW5ldyBhcih0aGlzLmJ1ZlBhcmFtcyk7dGhpcy5yZXN1bHRHZW9tZXRyeT10LmJ1ZmZlcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbCkpdGhyb3cgdDt0aGlzLnNhdmVFeGNlcHRpb249dH1maW5hbGx5e319LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRpc3RhbmNlPXQsdGhpcy5jb21wdXRlR2VvbWV0cnkoKSx0aGlzLnJlc3VsdEdlb21ldHJ5fSxzZXRFbmRDYXBTdHlsZTpmdW5jdGlvbih0KXt0aGlzLmJ1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHJ9fSksZHIuYnVmZmVyT3A9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGRyKHQpLGk9bi5nZXRSZXN1bHRHZW9tZXRyeShlKTtyZXR1cm4gaX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPW5ldyBkcihyKTthLnNldFF1YWRyYW50U2VnbWVudHMobyk7dmFyIGk9YS5nZXRSZXN1bHRHZW9tZXRyeShzKTtyZXR1cm4gaX1pZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEtpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXSxoPWFyZ3VtZW50c1syXSxhPW5ldyBkcih1LGgpLGk9YS5nZXRSZXN1bHRHZW9tZXRyeShsKTtyZXR1cm4gaX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdLGE9bmV3IGRyKGMpO2Euc2V0UXVhZHJhbnRTZWdtZW50cyhnKSxhLnNldEVuZENhcFN0eWxlKGQpO3ZhciBpPWEuZ2V0UmVzdWx0R2VvbWV0cnkoZik7cmV0dXJuIGl9fSxkci5wcmVjaXNpb25TY2FsZUZhY3Rvcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkscj1ULm1heChNYXRoLmFicyhpLmdldE1heFgoKSksTWF0aC5hYnMoaS5nZXRNYXhZKCkpLE1hdGguYWJzKGkuZ2V0TWluWCgpKSxNYXRoLmFicyhpLmdldE1pblkoKSkpLHM9ZT4wP2U6MCxvPXIrMipzLGE9TWF0aC50cnVuYyhNYXRoLmxvZyhvKS9NYXRoLmxvZygxMCkrMSksdT1uLWEsbD1NYXRoLnBvdygxMCx1KTtyZXR1cm4gbH0sZHIuQ0FQX1JPVU5EPUtpLkNBUF9ST1VORCxkci5DQVBfQlVUVD1LaS5DQVBfRkxBVCxkci5DQVBfRkxBVD1LaS5DQVBfRkxBVCxkci5DQVBfU1FVQVJFPUtpLkNBUF9TUVVBUkUsZHIuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIFNvPU9iamVjdC5mcmVlemUoe0J1ZmZlck9wOmRyLEJ1ZmZlclBhcmFtZXRlcnM6S2l9KTtlKHByLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBUdCYmdGhpcy5jb21wcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHJ9fSkscHIuZ2V0UG9seWdvbnM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBwci5nZXRQb2x5Z29ucyh0LG5ldyBJKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlIGluc3RhbmNlb2YgVHQ/bi5hZGQoZSk6ZSBpbnN0YW5jZW9mIGZ0JiZlLmFwcGx5KG5ldyBwcihuKSksbn19LGUodnIucHJvdG90eXBlLHtpc0luc2lkZUFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbmRleD09PXZyLklOU0lERV9BUkVBfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGdldEdlb21ldHJ5Q29tcG9uZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcG9uZW50fSxnZXRTZWdtZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbmRleH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdnJ9fSksdnIuSU5TSURFX0FSRUE9LTEsZShtci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgTHQmJnRoaXMucHRzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtcn19KSxtci5nZXRQb2ludHM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0IGluc3RhbmNlb2YgTHQ/aG8uc2luZ2xldG9uTGlzdCh0KTptci5nZXRQb2ludHModCxuZXcgSSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZSBpbnN0YW5jZW9mIEx0P24uYWRkKGUpOmUgaW5zdGFuY2VvZiBmdCYmZS5hcHBseShuZXcgbXIobikpLG59fSxlKHlyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpeyh0IGluc3RhbmNlb2YgTHR8fHQgaW5zdGFuY2VvZiBTdHx8dCBpbnN0YW5jZW9mIFR0KSYmdGhpcy5sb2NhdGlvbnMuYWRkKG5ldyB2cih0LDAsdC5nZXRDb29yZGluYXRlKCkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5cn19KSx5ci5nZXRMb2NhdGlvbnM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7cmV0dXJuIHQuYXBwbHkobmV3IHlyKGUpKSxlfSxlKHhyLnByb3RvdHlwZSx7Y29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2U6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLHQpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPTEtZSxyPXByLmdldFBvbHlnb25zKHRoaXMuZ2VvbVtlXSk7aWYoci5zaXplKCk+MCl7dmFyIHM9eXIuZ2V0TG9jYXRpb25zKHRoaXMuZ2VvbVtpXSk7aWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShzLHIsbiksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uW2ldPW5bMF0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uW2VdPW5bMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZSKGFyZ3VtZW50c1swXSx5KSYmUihhcmd1bWVudHNbMV0seSkpe2Zvcih2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl0sbD0wO2w8by5zaXplKCk7bCsrKWZvcih2YXIgaD1vLmdldChsKSxjPTA7YzxhLnNpemUoKTtjKyspaWYodGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShoLGEuZ2V0KGMpLHUpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHZyJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFR0KXt2YXIgZj1hcmd1bWVudHNbMF0sZz1hcmd1bWVudHNbMV0sZD1hcmd1bWVudHNbMl0scD1mLmdldENvb3JkaW5hdGUoKTtpZihMLkVYVEVSSU9SIT09dGhpcy5wdExvY2F0b3IubG9jYXRlKHAsZykpcmV0dXJuIHRoaXMubWluRGlzdGFuY2U9MCxkWzBdPWYsZFsxXT1uZXcgdnIoZyxwKSxudWxsfX0sY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKHIsbyxuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0sY29tcHV0ZUZhY2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPWtuLmdldExpbmVzKHRoaXMuZ2VvbVswXSksbj1rbi5nZXRMaW5lcyh0aGlzLmdlb21bMV0pLGk9bXIuZ2V0UG9pbnRzKHRoaXMuZ2VvbVswXSkscj1tci5nZXRQb2ludHModGhpcy5nZW9tWzFdKTtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhlLG4sdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLHIsdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhuLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCEwKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMoaSxyLHQpLHZvaWQgdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSkpKX0sbmVhcmVzdExvY2F0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbn0sdXBkYXRlTWluRGlzdGFuY2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXRbMF0/bnVsbDp2b2lkKGU/KHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXT10WzFdLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMF0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMV0pKX0sbmVhcmVzdFBvaW50czpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7dmFyIHQ9W3RoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV07cmV0dXJuIHR9LGNvbXB1dGVNaW5EaXN0YW5jZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihudWxsIT09dGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uKXJldHVybiBudWxsO2lmKHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMubWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Zm9yKHZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0Q29vcmRpbmF0ZSgpLHM9MDtzPGkubGVuZ3RoLTE7cysrKXt2YXIgbz1oZS5kaXN0YW5jZVBvaW50TGluZShyLGlbc10saVtzKzFdKTtpZihvPHRoaXMubWluRGlzdGFuY2Upe3RoaXMubWluRGlzdGFuY2U9bzt2YXIgYT1uZXcgY2UoaVtzXSxpW3MrMV0pLHU9YS5jbG9zZXN0UG9pbnQocik7blswXT1uZXcgdnIodCxzLHUpLG5bMV09bmV3IHZyKGUsMCxyKX1pZih0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgU3Qpe3ZhciBsPWFyZ3VtZW50c1swXSxoPWFyZ3VtZW50c1sxXSxjPWFyZ3VtZW50c1syXTtpZihsLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShoLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtmb3IodmFyIGk9bC5nZXRDb29yZGluYXRlcygpLGY9aC5nZXRDb29yZGluYXRlcygpLHM9MDtzPGkubGVuZ3RoLTE7cysrKWZvcih2YXIgZz0wO2c8Zi5sZW5ndGgtMTtnKyspe3ZhciBvPWhlLmRpc3RhbmNlTGluZUxpbmUoaVtzXSxpW3MrMV0sZltnXSxmW2crMV0pO2lmKG88dGhpcy5taW5EaXN0YW5jZSl7dGhpcy5taW5EaXN0YW5jZT1vO3ZhciBkPW5ldyBjZShpW3NdLGlbcysxXSkscD1uZXcgY2UoZltnXSxmW2crMV0pLHY9ZC5jbG9zZXN0UG9pbnRzKHApO2NbMF09bmV3IHZyKGwscyx2WzBdKSxjWzFdPW5ldyB2cihoLGcsdlsxXSl9aWYodGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fSxjb21wdXRlTWluRGlzdGFuY2VQb2ludHM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpLGE9ci5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uoby5nZXRDb29yZGluYXRlKCkpO2lmKGE8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMubWluRGlzdGFuY2U9YSxuWzBdPW5ldyB2cihyLDAsci5nZXRDb29yZGluYXRlKCkpLG5bMV09bmV3IHZyKG8sMCxvLmdldENvb3JkaW5hdGUoKSkpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmdlb21bMF18fG51bGw9PT10aGlzLmdlb21bMV0pdGhyb3cgbmV3IGkoXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuZ2VvbVswXS5pc0VtcHR5KCl8fHRoaXMuZ2VvbVsxXS5pc0VtcHR5KCk/MDoodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLm1pbkRpc3RhbmNlKX0sY29tcHV0ZU1pbkRpc3RhbmNlTGluZXM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5zaXplKCk7aSsrKWZvcih2YXIgcj10LmdldChpKSxzPTA7czxlLnNpemUoKTtzKyspe3ZhciBvPWUuZ2V0KHMpO2lmKHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKHIsbyxuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geHJ9fSkseHIuZGlzdGFuY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgeHIodCxlKTtyZXR1cm4gbi5kaXN0YW5jZSgpfSx4ci5pc1dpdGhpbkRpc3RhbmNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgeHIodCxlLG4pO3JldHVybiBpLmRpc3RhbmNlKCk8PW59LHhyLm5lYXJlc3RQb2ludHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgeHIodCxlKTtyZXR1cm4gbi5uZWFyZXN0UG9pbnRzKCl9O3ZhciB3bz1PYmplY3QuZnJlZXplKHtEaXN0YW5jZU9wOnhyfSk7ZShFci5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuY29vcmRpbmF0ZXMpe2Zvcih2YXIgdD0wLGU9MCxuPW5ldyBOLGk9dGhpcy5kaXJlY3RlZEVkZ2VzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKHIuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLHIuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLmNvb3JkaW5hdGVzPW4udG9Db29yZGluYXRlQXJyYXkoKSxlPnQmJkgucmV2ZXJzZSh0aGlzLmNvb3JkaW5hdGVzKX1yZXR1cm4gdGhpcy5jb29yZGluYXRlc30sdG9MaW5lU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSl9LGFkZDpmdW5jdGlvbih0KXt0aGlzLmRpcmVjdGVkRWRnZXMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFcn19KSxlKElyLnByb3RvdHlwZSx7c2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0saXNNYXJrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxzZXRNYXJrZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNNYXJrZWQ9dH0sZ2V0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGlzVmlzaXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9LHNldENvbnRleHQ6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElyfX0pLElyLmdldENvbXBvbmVudFdpdGhWaXNpdGVkU3RhdGU9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9LElyLnNldFZpc2l0ZWQ9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7bi5zZXRWaXNpdGVkKGUpfX0sSXIuc2V0TWFya2VkPWZ1bmN0aW9uKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3ZhciBuPXQubmV4dCgpO24uc2V0TWFya2VkKGUpfX0saChOcixJciksZShOci5wcm90b3R5cGUse2lzUmVtb3ZlZDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5wYXJlbnRFZGdlfSxjb21wYXJlRGlyZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnF1YWRyYW50PnQucXVhZHJhbnQ/MTp0aGlzLnF1YWRyYW50PHQucXVhZHJhbnQ/LTE6aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQucDAsdC5wMSx0aGlzLnAxKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyb20uZ2V0Q29vcmRpbmF0ZSgpfSxwcmludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIiksaT1lLnN1YnN0cmluZyhuKzEpO3QucHJpbnQoXCIgIFwiK2krXCI6IFwiK3RoaXMucDArXCIgLSBcIit0aGlzLnAxK1wiIFwiK3RoaXMucXVhZHJhbnQrXCI6XCIrdGhpcy5hbmdsZSl9LGdldERpcmVjdGlvblB0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDF9LGdldEFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYW5nbGV9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSl9LGdldEZyb21Ob2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJvbX0sZ2V0U3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltO1xufSxzZXRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMucGFyZW50RWRnZT10fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLnN5bT1udWxsLHRoaXMucGFyZW50RWRnZT1udWxsfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50RWRnZX0sZ2V0UXVhZHJhbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFkcmFudH0sc2V0U3ltOmZ1bmN0aW9uKHQpe3RoaXMuc3ltPXR9LGdldFRvTm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvfSxnZXRFZGdlRGlyZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZURpcmVjdGlvbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5yfX0pLE5yLnRvRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmFkZChuLm5leHQoKS5wYXJlbnRFZGdlKTtyZXR1cm4gZX0saChDcixOciksZShDci5wcm90b3R5cGUse2dldE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gMiE9PXRoaXMuZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCk/bnVsbDp0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCk9PT10aGlzLmdldFN5bSgpP3RoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKTooZi5pc1RydWUodGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpPT09dGhpcy5nZXRTeW0oKSksdGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3J9fSksaChTcixJciksZShTci5wcm90b3R5cGUse2lzUmVtb3ZlZDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5kaXJFZGdlfSxzZXREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQsZSl7dGhpcy5kaXJFZGdlPVt0LGVdLHQuc2V0RWRnZSh0aGlzKSxlLnNldEVkZ2UodGhpcyksdC5zZXRTeW0oZSksZS5zZXRTeW0odCksdC5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UodCksZS5nZXRGcm9tTm9kZSgpLmFkZE91dEVkZ2UoZSl9LGdldERpckVkZ2U6ZnVuY3Rpb24oKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kaXJFZGdlW3RdfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHIpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT1lP3RoaXMuZGlyRWRnZVswXTp0aGlzLmRpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PWU/dGhpcy5kaXJFZGdlWzFdOm51bGx9fSxyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLmRpckVkZ2U9bnVsbH0sZ2V0T3Bwb3NpdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5kaXJFZGdlWzBdLmdldFRvTm9kZSgpOnRoaXMuZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLmRpckVkZ2VbMV0uZ2V0VG9Ob2RlKCk6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU3J9fSksZSh3ci5wcm90b3R5cGUse2dldE5leHRFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMub3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZSsxKSl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLml0ZXJhdG9yKCk7aWYoIXQuaGFzTmV4dCgpKXJldHVybiBudWxsO3ZhciBlPXQubmV4dCgpO3JldHVybiBlLmdldENvb3JkaW5hdGUoKX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLm91dEVkZ2VzLml0ZXJhdG9yKCl9LHNvcnRFZGdlczpmdW5jdGlvbigpe3RoaXMuc29ydGVkfHwoaG8uc29ydCh0aGlzLm91dEVkZ2VzKSx0aGlzLnNvcnRlZD0hMCl9LHJlbW92ZTpmdW5jdGlvbih0KXt0aGlzLm91dEVkZ2VzLnJlbW92ZSh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLm91dEVkZ2VzfSxnZXROZXh0Q1dFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5kZXgodCk7cmV0dXJuIHRoaXMub3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZS0xKSl9LGdldEluZGV4OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLm91dEVkZ2VzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMub3V0RWRnZXMuZ2V0KGUpO2lmKG4uZ2V0RWRnZSgpPT09dClyZXR1cm4gZX1yZXR1cm4tMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE5yKXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IodmFyIGU9MDtlPHRoaXMub3V0RWRnZXMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5vdXRFZGdlcy5nZXQoZSk7aWYobj09PWkpcmV0dXJuIGV9cmV0dXJuLTF9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgcj1hcmd1bWVudHNbMF0scz1yJXRoaXMub3V0RWRnZXMuc2l6ZSgpO3JldHVybiBzPDAmJihzKz10aGlzLm91dEVkZ2VzLnNpemUoKSksc319LGFkZDpmdW5jdGlvbih0KXt0aGlzLm91dEVkZ2VzLmFkZCh0KSx0aGlzLnNvcnRlZD0hMX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0RWRnZXMuc2l6ZSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3cn19KSxoKExyLElyKSxlKExyLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnB0fSxhZGRPdXRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuZGVTdGFyLmFkZCh0KX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxnZXRPdXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlU3Rhcn0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5wdD1udWxsO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmRlU3Rhci5yZW1vdmUodCl9fSxnZXRJbmRleDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kZVN0YXIuZ2V0SW5kZXgodCl9LGdldERlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlU3Rhci5nZXREZWdyZWUoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHJ9fSksTHIuZ2V0RWRnZXNCZXR3ZWVuPWZ1bmN0aW9uKHQsZSl7dmFyIG49TnIudG9FZGdlcyh0LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSksaT1uZXcgSihuKSxyPU5yLnRvRWRnZXMoZS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpO3JldHVybiBpLnJldGFpbkFsbChyKSxpfSxoKFJyLFNyKSxlKFJyLnByb3RvdHlwZSx7Z2V0TGluZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJyfX0pLGUoVHIucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0scmVtb3ZlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAucmVtb3ZlKHQpfSx2YWx1ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfSxhZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5wdXQodC5nZXRDb29yZGluYXRlKCksdCksdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVHJ9fSksZShQci5wcm90b3R5cGUse2ZpbmROb2Rlc09mRGVncmVlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldERlZ3JlZSgpPT09dCYmZS5hZGQoaSl9cmV0dXJuIGV9LGRpckVkZ2VJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpckVkZ2VzLml0ZXJhdG9yKCl9LGVkZ2VJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LHJlbW92ZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Ipe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMCkpLHRoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5lZGdlcy5yZW1vdmUodCksdC5yZW1vdmUoKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTnIpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWUuZ2V0U3ltKCk7bnVsbCE9PW4mJm4uc2V0U3ltKG51bGwpLGUuZ2V0RnJvbU5vZGUoKS5yZW1vdmUoZSksZS5yZW1vdmUoKSx0aGlzLmRpckVkZ2VzLnJlbW92ZShlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHIpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0scj1pLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxzPXIuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpLG49by5nZXRTeW0oKTtudWxsIT09biYmdGhpcy5yZW1vdmUobiksdGhpcy5kaXJFZGdlcy5yZW1vdmUobyk7dmFyIGE9by5nZXRFZGdlKCk7bnVsbCE9PWEmJnRoaXMuZWRnZXMucmVtb3ZlKGEpfXRoaXMubm9kZU1hcC5yZW1vdmUoaS5nZXRDb29yZGluYXRlKCkpLGkucmVtb3ZlKCl9fSxmaW5kTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLmZpbmQodCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LG5vZGVJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAuaXRlcmF0b3IoKX0sY29udGFpbnM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFNyKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWRnZXMuY29udGFpbnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOcil7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VzLmNvbnRhaW5zKGUpfX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZU1hcC5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFNyKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5lZGdlcy5hZGQoZSksdGhpcy5hZGQoZS5nZXREaXJFZGdlKDApKSx0aGlzLmFkZChlLmdldERpckVkZ2UoMSkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOcil7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMuZGlyRWRnZXMuYWRkKG4pfX0sZ2V0Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQcn19KSxoKGJyLFByKSxlKGJyLnByb3RvdHlwZSx7YWRkRWRnZTpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8PTEpcmV0dXJuIG51bGw7dmFyIG49ZVswXSxpPWVbZS5sZW5ndGgtMV0scj10aGlzLmdldE5vZGUobikscz10aGlzLmdldE5vZGUoaSksbz1uZXcgQ3IocixzLGVbMV0sKCEwKSksYT1uZXcgQ3IocyxyLGVbZS5sZW5ndGgtMl0sKCExKSksdT1uZXcgUnIodCk7dS5zZXREaXJlY3RlZEVkZ2VzKG8sYSksdGhpcy5hZGQodSl9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBMcih0KSx0aGlzLmFkZChlKSksZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnJ9fSksZShPci5wcm90b3R5cGUse2J1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5pc01hcmtlZCgpfHwoZi5pc1RydWUoMj09PWUuZ2V0RGVncmVlKCkpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTsyIT09ZS5nZXREZWdyZWUoKSYmKHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2RlczpmdW5jdGlvbigpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2RlcygpfSxnZXRNZXJnZWRMaW5lU3RyaW5nczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1lcmdlKCksdGhpcy5tZXJnZWRMaW5lU3RyaW5nc30sYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlKCkuaXNNYXJrZWQoKXx8dGhpcy5lZGdlU3RyaW5ncy5hZGQodGhpcy5idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgobikpfX0sbWVyZ2U6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5tZXJnZWRMaW5lU3RyaW5ncylyZXR1cm4gbnVsbDtJci5zZXRNYXJrZWQodGhpcy5ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSksSXIuc2V0TWFya2VkKHRoaXMuZ3JhcGguZWRnZUl0ZXJhdG9yKCksITEpLHRoaXMuZWRnZVN0cmluZ3M9bmV3IEksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCksdGhpcy5tZXJnZWRMaW5lU3RyaW5ncz1uZXcgSTtmb3IodmFyIHQ9dGhpcy5lZGdlU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7dGhpcy5tZXJnZWRMaW5lU3RyaW5ncy5hZGQoZS50b0xpbmVTdHJpbmcoKSl9fSxidWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGg6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVyKHRoaXMuZmFjdG9yeSksbj10O2RvIGUuYWRkKG4pLG4uZ2V0RWRnZSgpLnNldE1hcmtlZCghMCksbj1uLmdldE5leHQoKTt3aGlsZShudWxsIT09biYmbiE9PXQpO3JldHVybiBlfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0LmFwcGx5KHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBTdCYmdGhpcy5hZGQodCl9fSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VkTGluZVN0cmluZ3M9bnVsbDtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5hZGQoaSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIHI9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmZhY3RvcnkmJih0aGlzLmZhY3Rvcnk9ci5nZXRGYWN0b3J5KCkpLHRoaXMuZ3JhcGguYWRkRWRnZShyKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzOmZ1bmN0aW9uKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlcygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPcn19KTt2YXIgTG89T2JqZWN0LmZyZWV6ZSh7TGluZU1lcmdlcjpPcn0pLFJvPU9iamVjdC5mcmVlemUoe092ZXJsYXlPcDppaX0pO2goX3IsTnIpLGUoX3IucHJvdG90eXBlLHtnZXROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0saXNJblJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZWRnZVJpbmd9LHNldFJpbmc6ZnVuY3Rpb24odCl7dGhpcy5lZGdlUmluZz10fSxzZXRMYWJlbDpmdW5jdGlvbih0KXt0aGlzLmxhYmVsPXR9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5uZXh0PXR9LGdldFJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlUmluZ30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3J9fSksaChNcixTciksZShNci5wcm90b3R5cGUse2dldExpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNcn19KSxlKERyLnByb3RvdHlwZSx7dmlzaXRJbnRlcmlvclJpbmc6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGVzKCksaT1uWzBdLHI9RHIuZmluZERpZmZlcmVudFBvaW50KG4saSkscz1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKGksciksbz1lLmZpbmRFZGdlRW5kKHMpLGE9bnVsbDtvLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SP2E9bzpvLmdldFN5bSgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SJiYoYT1vLmdldFN5bSgpKSxmLmlzVHJ1ZShudWxsIT09YSxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMoYSl9LHZpc2l0U2hlbGxJbnRlcmlvcnM6ZnVuY3Rpb24odCxlKXtpZih0IGluc3RhbmNlb2YgVHQpe3ZhciBuPXQ7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfWlmKHQgaW5zdGFuY2VvZiBPdClmb3IodmFyIGk9dCxyPTA7cjxpLmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBuPWkuZ2V0R2VvbWV0cnlOKHIpO3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNjb25uZWN0ZWRSaW5nY29vcmR9LHNldEludGVyaW9yRWRnZXNJblJlc3VsdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SJiZuLnNldEluUmVzdWx0KCEwKX19LHZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlczpmdW5jdGlvbih0KXt2YXIgZT10LG49dDtkbyBmLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCk7d2hpbGUobiE9PWUpfSxidWlsZEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmlzSW5SZXN1bHQoKSYmbnVsbD09PWkuZ2V0RWRnZVJpbmcoKSl7dmFyIHI9bmV3IHZuKGksdGhpcy5nZW9tZXRyeUZhY3RvcnkpO3IubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7dmFyIHM9ci5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX0saGFzVW52aXNpdGVkU2hlbGxFZGdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5zaXplKCk7ZSsrKXt2YXIgbj10LmdldChlKTtpZighbi5pc0hvbGUoKSl7dmFyIGk9bi5nZXRFZGdlcygpLHI9aS5nZXQoMCk7aWYoci5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsY24uUklHSFQpPT09TC5JTlRFUklPUilmb3IodmFyIHM9MDtzPGkuc2l6ZSgpO3MrKylpZihyPWkuZ2V0KHMpLCFyLmlzVmlzaXRlZCgpKXJldHVybiB0aGlzLmRpc2Nvbm5lY3RlZFJpbmdjb29yZD1yLmdldENvb3JkaW5hdGUoKSwhMH19cmV0dXJuITF9LGlzSW50ZXJpb3JzQ29ubmVjdGVkOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7dGhpcy5nZW9tR3JhcGguY29tcHV0ZVNwbGl0RWRnZXModCk7dmFyIGU9bmV3IENuKG5ldyBPbik7ZS5hZGRFZGdlcyh0KSx0aGlzLnNldEludGVyaW9yRWRnZXNJblJlc3VsdChlKSxlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7dmFyIG49dGhpcy5idWlsZEVkZ2VSaW5ncyhlLmdldEVkZ2VFbmRzKCkpO3JldHVybiB0aGlzLnZpc2l0U2hlbGxJbnRlcmlvcnModGhpcy5nZW9tR3JhcGguZ2V0R2VvbWV0cnkoKSxlKSwhdGhpcy5oYXNVbnZpc2l0ZWRTaGVsbEVkZ2Uobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERyfX0pLERyLmZpbmREaWZmZXJlbnRQb2ludD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlKSlyZXR1cm4gdFtuXTtyZXR1cm4gbnVsbH0sZShBci5wcm90b3R5cGUse2NyZWF0ZUVkZ2VFbmRGb3JOZXh0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW4uc2VnbWVudEluZGV4KzE7aWYocj49dC5nZXROdW1Qb2ludHMoKSYmbnVsbD09PWkpcmV0dXJuIG51bGw7dmFyIHM9dC5nZXRDb29yZGluYXRlKHIpO251bGwhPT1pJiZpLnNlZ21lbnRJbmRleD09PW4uc2VnbWVudEluZGV4JiYocz1pLmNvb3JkKTt2YXIgbz1uZXcgRW4odCxuLmNvb3JkLHMsbmV3IGduKHQuZ2V0TGFiZWwoKSkpO2UuYWRkKG8pfSxjcmVhdGVFZGdlRW5kRm9yUHJldjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uLnNlZ21lbnRJbmRleDtpZigwPT09bi5kaXN0KXtpZigwPT09cilyZXR1cm4gbnVsbDtyLS19dmFyIHM9dC5nZXRDb29yZGluYXRlKHIpO251bGwhPT1pJiZpLnNlZ21lbnRJbmRleD49ciYmKHM9aS5jb29yZCk7dmFyIG89bmV3IGduKHQuZ2V0TGFiZWwoKSk7by5mbGlwKCk7dmFyIGE9bmV3IEVuKHQsbi5jb29yZCxzLG8pO2UuYWRkKGEpfSxjb21wdXRlRWRnZUVuZHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJLG49dDtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY29tcHV0ZUVkZ2VFbmRzKGksZSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPXIuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtvLmFkZEVuZHBvaW50cygpO3ZhciBhPW8uaXRlcmF0b3IoKSx1PW51bGwsbD1udWxsO2lmKCFhLmhhc05leHQoKSlyZXR1cm4gbnVsbDt2YXIgaD1hLm5leHQoKTtkbyB1PWwsbD1oLGg9bnVsbCxhLmhhc05leHQoKSYmKGg9YS5uZXh0KCkpLG51bGwhPT1sJiYodGhpcy5jcmVhdGVFZGdlRW5kRm9yUHJldihyLHMsbCx1KSx0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHIscyxsLGgpKTt3aGlsZShudWxsIT09bCl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBcn19KSxoKEZyLEVuKSxlKEZyLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQpe3RoaXMuZWRnZUVuZHMuYWRkKHQpfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS0+IExhYmVsOiBcIit0aGlzLmxhYmVsKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KSx0LnByaW50bG4oKX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZHMuaXRlcmF0b3IoKX0sZ2V0RWRnZUVuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRW5kc30sY29tcHV0ZUxhYmVsT246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPSExLHI9dGhpcy5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7bz09PUwuQk9VTkRBUlkmJm4rKyxvPT09TC5JTlRFUklPUiYmKGk9ITApfXZhciBvPUwuTk9ORTtpJiYobz1MLklOVEVSSU9SKSxuPjAmJihvPSRuLmRldGVybWluZUJvdW5kYXJ5KGUsbikpLHRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxvKX0sY29tcHV0ZUxhYmVsU2lkZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmdldExhYmVsKCkuaXNBcmVhKCkpe3ZhciByPWkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKHI9PT1MLklOVEVSSU9SKXJldHVybiB0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSxMLklOVEVSSU9SKSxudWxsO3I9PT1MLkVYVEVSSU9SJiZ0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSxMLkVYVEVSSU9SKX19fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxjb21wdXRlTGFiZWxTaWRlczpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxjbi5MRUZUKSx0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxjbi5SSUdIVCl9LHVwZGF0ZUlNOmZ1bmN0aW9uKHQpe0puLnVwZGF0ZUlNKHRoaXMubGFiZWwsdCl9LGNvbXB1dGVMYWJlbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9ITEsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX1lP3RoaXMubGFiZWw9bmV3IGduKEwuTk9ORSxMLk5PTkUsTC5OT05FKTp0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpO2Zvcih2YXIgcj0wO3I8MjtyKyspdGhpcy5jb21wdXRlTGFiZWxPbihyLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMocil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZyfX0pLGgoR3IsUG4pLGUoR3IucHJvdG90eXBlLHt1cGRhdGVJTTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KX19LGluc2VydDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VNYXAuZ2V0KHQpO251bGw9PT1lPyhlPW5ldyBGcih0KSx0aGlzLmluc2VydEVkZ2VFbmQodCxlKSk6ZS5pbnNlcnQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdyfX0pLGgocXIseW4pLGUocXIucHJvdG90eXBlLHt1cGRhdGVJTUZyb21FZGdlczpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLnVwZGF0ZUlNKHQpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7dC5zZXRBdExlYXN0SWZWYWxpZCh0aGlzLmxhYmVsLmdldExvY2F0aW9uKDApLHRoaXMubGFiZWwuZ2V0TG9jYXRpb24oMSksMCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFyfX0pLGgoQnIsTm4pLGUoQnIucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcXIodCxuZXcgR3IpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCcn19KSxlKHpyLnByb3RvdHlwZSx7aW5zZXJ0RWRnZUVuZHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMubm9kZXMuYWRkKG4pfX0sZ2V0Tm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMuaXRlcmF0b3IoKX0sY29weU5vZGVzQW5kTGFiZWxzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0Tm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPXRoaXMubm9kZXMuYWRkTm9kZShpLmdldENvb3JkaW5hdGUoKSk7ci5zZXRMYWJlbChlLGkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSl9fSxidWlsZDpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKHQsMCk7dmFyIGU9bmV3IEFyLG49ZS5jb21wdXRlRWRnZUVuZHModC5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhuKX0sY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSxzPWkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT10aGlzLm5vZGVzLmFkZE5vZGUoby5jb29yZCk7cj09PUwuQk9VTkRBUlk/YS5zZXRMYWJlbEJvdW5kYXJ5KGUpOmEuZ2V0TGFiZWwoKS5pc051bGwoZSkmJmEuc2V0TGFiZWwoZSxMLklOVEVSSU9SKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpyfX0pLGUoVnIucHJvdG90eXBlLHtpc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtpZighZS5nZXRFZGdlcygpLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodGhpcy5nZW9tR3JhcGgpKXJldHVybiB0aGlzLmludmFsaWRQb2ludD1lLmdldENvb3JkaW5hdGUoKS5jb3B5KCksITF9cmV0dXJuITB9LGdldEludmFsaWRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludmFsaWRQb2ludH0saGFzRHVwbGljYXRlUmluZ3M6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5nZXRFZGdlRW5kcygpLnNpemUoKT4xKXJldHVybiB0aGlzLmludmFsaWRQb2ludD1pLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlKDApLCEwfXJldHVybiExfSxpc05vZGVDb25zaXN0ZW50QXJlYTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2VvbUdyYXBoLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMCwhMCk7cmV0dXJuIHQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuaW52YWxpZFBvaW50PXQuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6KHRoaXMubm9kZUdyYXBoLmJ1aWxkKHRoaXMuZ2VvbUdyYXBoKSx0aGlzLmlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVnJ9fSksZShrci5wcm90b3R5cGUse2J1aWxkSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLmluZGV4PW5ldyBrZTtmb3IodmFyIHQ9MDt0PHRoaXMucmluZ3Muc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5yaW5ncy5nZXQodCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTt0aGlzLmluZGV4Lmluc2VydChuLGUpfX0sZ2V0TmVzdGVkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXN0ZWRQdH0saXNOb25OZXN0ZWQ6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkSW5kZXgoKTtmb3IodmFyIHQ9MDt0PHRoaXMucmluZ3Muc2l6ZSgpO3QrKylmb3IodmFyIGU9dGhpcy5yaW5ncy5nZXQodCksbj1lLmdldENvb3JkaW5hdGVzKCksaT10aGlzLmluZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSxyPTA7cjxpLnNpemUoKTtyKyspe3ZhciBzPWkuZ2V0KHIpLG89cy5nZXRDb29yZGluYXRlcygpO2lmKGUhPT1zJiZlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSl7dmFyIGE9VXIuZmluZFB0Tm90Tm9kZShuLHMsdGhpcy5ncmFwaCk7aWYobnVsbCE9PWEpe3ZhciB1PWhlLmlzUG9pbnRJblJpbmcoYSxvKTtpZih1KXJldHVybiB0aGlzLm5lc3RlZFB0PWEsITF9fX1yZXR1cm4hMH0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMucmluZ3MuYWRkKHQpLHRoaXMudG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga3J9fSksZShZci5wcm90b3R5cGUse2dldEVycm9yVHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVycm9yVHlwZX0sZ2V0TWVzc2FnZTpmdW5jdGlvbigpe3JldHVybiBZci5lcnJNc2dbdGhpcy5lcnJvclR5cGVdfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMucHQmJih0PVwiIGF0IG9yIG5lYXIgcG9pbnQgXCIrdGhpcy5wdCksdGhpcy5nZXRNZXNzYWdlKCkrdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWXJ9fSksWXIuRVJST1I9MCxZci5SRVBFQVRFRF9QT0lOVD0xLFlyLkhPTEVfT1VUU0lERV9TSEVMTD0yLFlyLk5FU1RFRF9IT0xFUz0zLFlyLkRJU0NPTk5FQ1RFRF9JTlRFUklPUj00LFlyLlNFTEZfSU5URVJTRUNUSU9OPTUsWXIuUklOR19TRUxGX0lOVEVSU0VDVElPTj02LFlyLk5FU1RFRF9TSEVMTFM9NyxZci5EVVBMSUNBVEVfUklOR1M9OCxZci5UT09fRkVXX1BPSU5UUz05LFlyLklOVkFMSURfQ09PUkRJTkFURT0xMCxZci5SSU5HX05PVF9DTE9TRUQ9MTEsWXIuZXJyTXNnPVtcIlRvcG9sb2d5IFZhbGlkYXRpb24gRXJyb3JcIixcIlJlcGVhdGVkIFBvaW50XCIsXCJIb2xlIGxpZXMgb3V0c2lkZSBzaGVsbFwiLFwiSG9sZXMgYXJlIG5lc3RlZFwiLFwiSW50ZXJpb3IgaXMgZGlzY29ubmVjdGVkXCIsXCJTZWxmLWludGVyc2VjdGlvblwiLFwiUmluZyBTZWxmLWludGVyc2VjdGlvblwiLFwiTmVzdGVkIHNoZWxsc1wiLFwiRHVwbGljYXRlIFJpbmdzXCIsXCJUb28gZmV3IGRpc3RpbmN0IHBvaW50cyBpbiBnZW9tZXRyeSBjb21wb25lbnRcIixcIkludmFsaWQgQ29vcmRpbmF0ZVwiLFwiUmluZyBpcyBub3QgY2xvc2VkXCJdLGUoVXIucHJvdG90eXBlLHtjaGVja0ludmFsaWRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCFVci5pc1ZhbGlkKHRbZV0pKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyBZcihZci5JTlZBTElEX0NPT1JESU5BVEUsdFtlXSksbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTxuLmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGNoZWNrSG9sZXNOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGtyKGUpLGk9MDtpPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7aSsrKXt2YXIgcj10LmdldEludGVyaW9yUmluZ04oaSk7bi5hZGQocil9dmFyIHM9bi5pc05vbk5lc3RlZCgpO3N8fCh0aGlzLnZhbGlkRXJyPW5ldyBZcihZci5ORVNURURfSE9MRVMsbi5nZXROZXN0ZWRQb2ludCgpKSl9LGNoZWNrQ29uc2lzdGVudEFyZWE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFZyKHQpLG49ZS5pc05vZGVDb25zaXN0ZW50QXJlYSgpO3JldHVybiBuP3ZvaWQoZS5oYXNEdXBsaWNhdGVSaW5ncygpJiYodGhpcy52YWxpZEVycj1uZXcgWXIoWXIuRFVQTElDQVRFX1JJTkdTLGUuZ2V0SW52YWxpZFBvaW50KCkpKSk6KHRoaXMudmFsaWRFcnI9bmV3IFlyKFlyLlNFTEZfSU5URVJTRUNUSU9OLGUuZ2V0SW52YWxpZFBvaW50KCkpLG51bGwpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLnBhcmVudEdlb21ldHJ5KSxudWxsPT09dGhpcy52YWxpZEVycn0sY2hlY2tTaGVsbEluc2lkZUhvbGU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPVVyLmZpbmRQdE5vdE5vZGUoaSxlLG4pO2lmKG51bGwhPT1zKXt2YXIgbz1oZS5pc1BvaW50SW5SaW5nKHMscik7aWYoIW8pcmV0dXJuIHN9dmFyIGE9VXIuZmluZFB0Tm90Tm9kZShyLHQsbik7aWYobnVsbCE9PWEpe3ZhciB1PWhlLmlzUG9pbnRJblJpbmcoYSxpKTtyZXR1cm4gdT9hOm51bGx9cmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJwb2ludHMgaW4gc2hlbGwgYW5kIGhvbGUgYXBwZWFyIHRvIGJlIGVxdWFsXCIpLG51bGx9LGNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyhuLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0sY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERyKHQpO2UuaXNJbnRlcmlvcnNDb25uZWN0ZWQoKXx8KHRoaXMudmFsaWRFcnI9bmV3IFlyKFlyLkRJU0NPTk5FQ1RFRF9JTlRFUklPUixlLmdldENvb3JkaW5hdGUoKSkpfSxjaGVja05vU2VsZkludGVyc2VjdGluZ1Jpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBhdCxuPSEwLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYobiluPSExO2Vsc2V7aWYoZS5jb250YWlucyhyLmNvb3JkKSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgWXIoWXIuUklOR19TRUxGX0lOVEVSU0VDVElPTixyLmNvb3JkKSxudWxsO2UuYWRkKHIuY29vcmQpfX19LGNoZWNrSG9sZXNJblNoZWxsOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RXh0ZXJpb3JSaW5nKCksaT1uZXcgSWkobikscj0wO3I8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe3ZhciBzPXQuZ2V0SW50ZXJpb3JSaW5nTihyKSxvPVVyLmZpbmRQdE5vdE5vZGUocy5nZXRDb29yZGluYXRlcygpLG4sZSk7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7dmFyIGE9IWkuaXNJbnNpZGUobyk7aWYoYSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgWXIoWXIuSE9MRV9PVVRTSURFX1NIRUxMLG8pLG51bGx9fSxjaGVja1Rvb0Zld1BvaW50czpmdW5jdGlvbih0KXtpZih0Lmhhc1Rvb0Zld1BvaW50cygpKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyBZcihZci5UT09fRkVXX1BPSU5UUyx0LmdldEludmFsaWRQb2ludCgpKSxudWxsfSxnZXRWYWxpZGF0aW9uRXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMucGFyZW50R2VvbWV0cnkpLHRoaXMudmFsaWRFcnJ9LGNoZWNrVmFsaWQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMoZS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcobiksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAsbik7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgcj1uZXcgYWU7aS5jb21wdXRlU2VsZk5vZGVzKHIsITAsITApLHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciBzPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHMuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAscyk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciBvPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG8pLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhvKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgJG4oMCxvKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKSlyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKG8saSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKG8saSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT3Qpe2Zvcih2YXIgYT1hcmd1bWVudHNbMF0sdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKGwpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhsKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH12YXIgaT1uZXcgJG4oMCxhKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKSlyZXR1cm4gbnVsbDtmb3IodmFyIHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChsLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfWZvcih2YXIgdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQobCxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1pZih0aGlzLmNoZWNrU2hlbGxzTm90TmVzdGVkKGEsaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZnQpZm9yKHZhciBoPWFyZ3VtZW50c1swXSx1PTA7dTxoLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBjPWguZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tWYWxpZChjKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIGY9YXJndW1lbnRzWzBdO2lmKHRoaXMudmFsaWRFcnI9bnVsbCxmLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZihmIGluc3RhbmNlb2YgTHQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFB0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBidCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgU3QpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFR0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBPdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZXtpZighKGYgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGYuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuY2hlY2tWYWxpZChmKX19fSxzZXRTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZDpmdW5jdGlvbih0KXt0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH0sY2hlY2tTaGVsbE5vdE5lc3RlZDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpLHI9ZS5nZXRFeHRlcmlvclJpbmcoKSxzPXIuZ2V0Q29vcmRpbmF0ZXMoKSxvPVVyLmZpbmRQdE5vdE5vZGUoaSxyLG4pO2lmKG51bGw9PT1vKXJldHVybiBudWxsO3ZhciBhPWhlLmlzUG9pbnRJblJpbmcobyxzKTtpZighYSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyBZcihZci5ORVNURURfU0hFTExTLG8pLG51bGw7Zm9yKHZhciB1PW51bGwsbD0wO2w8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtsKyspe3ZhciBoPWUuZ2V0SW50ZXJpb3JSaW5nTihsKTtpZih1PXRoaXMuY2hlY2tTaGVsbEluc2lkZUhvbGUodCxoLG4pLG51bGw9PT11KXJldHVybiBudWxsfXRoaXMudmFsaWRFcnI9bmV3IFlyKFlyLk5FU1RFRF9TSEVMTFMsdSl9LGNoZWNrQ2xvc2VkUmluZ3M6ZnVuY3Rpb24odCl7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEludGVyaW9yUmluZ04oZSkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfSxjaGVja0Nsb3NlZFJpbmc6ZnVuY3Rpb24odCl7aWYoIXQuaXNDbG9zZWQoKSl7dmFyIGU9bnVsbDt0LmdldE51bVBvaW50cygpPj0xJiYoZT10LmdldENvb3JkaW5hdGVOKDApKSx0aGlzLnZhbGlkRXJyPW5ldyBZcihZci5SSU5HX05PVF9DTE9TRUQsZSl9fSxjaGVja1NoZWxsc05vdE5lc3RlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWZvcih2YXIgaT10LmdldEdlb21ldHJ5TihuKSxyPWkuZ2V0RXh0ZXJpb3JSaW5nKCkscz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKWlmKG4hPT1zKXt2YXIgbz10LmdldEdlb21ldHJ5TihzKTtpZih0aGlzLmNoZWNrU2hlbGxOb3ROZXN0ZWQocixvLGUpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVXJ9fSksVXIuZmluZFB0Tm90Tm9kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW4uZmluZEVkZ2UoZSkscj1pLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgbz10W3NdO2lmKCFyLmlzSW50ZXJzZWN0aW9uKG8pKXJldHVybiBvfXJldHVybiBudWxsfSxVci5pc1ZhbGlkPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgVXIodCk7cmV0dXJuIGUuaXNWYWxpZCgpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiFyLmlzTmFOKG4ueCkmJighci5pc0luZmluaXRlKG4ueCkmJighci5pc05hTihuLnkpJiYhci5pc0luZmluaXRlKG4ueSkpKX19LGUoWHIucHJvdG90eXBlLHtpc0luY2x1ZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWR9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMucmluZ1B0cyl7Zm9yKHZhciB0PW5ldyBOLGU9dGhpcy5kZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRFZGdlKCk7WHIuYWRkRWRnZShpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLG4uZ2V0RWRnZURpcmVjdGlvbigpLHQpfXRoaXMucmluZ1B0cz10LnRvQ29vcmRpbmF0ZUFycmF5KCl9cmV0dXJuIHRoaXMucmluZ1B0c30saXNJbmNsdWRlZFNldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkU2V0fSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSwhKHRoaXMucmluZ1B0cy5sZW5ndGg8PTMpJiYodGhpcy5nZXRSaW5nKCksVXIuaXNWYWxpZCh0aGlzLnJpbmcpKX0sYnVpbGQ6ZnVuY3Rpb24odCl7dmFyIGU9dDtkbyB0aGlzLmFkZChlKSxlLnNldFJpbmcodGhpcyksZT1lLmdldE5leHQoKSxmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxmLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKTt3aGlsZShlIT09dCl9LGlzT3V0ZXJIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl9pc0hvbGUmJiF0aGlzLmhhc1NoZWxsKCl9LGdldFBvbHlnb246ZnVuY3Rpb24oKXt2YXIgdD1udWxsO2lmKG51bGwhPT10aGlzLmhvbGVzKXt0PW5ldyBBcnJheSh0aGlzLmhvbGVzLnNpemUoKSkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuaG9sZXMuZ2V0KGUpfXZhciBuPXRoaXMuZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMucmluZyx0KTtyZXR1cm4gbn0saXNIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX0saXNQcm9jZXNzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNQcm9jZXNzZWR9LGFkZEhvbGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuaG9sZXMmJih0aGlzLmhvbGVzPW5ldyBJKSx0aGlzLmhvbGVzLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWHIpe3ZhciBlPWFyZ3VtZW50c1swXTtlLnNldFNoZWxsKHRoaXMpO3ZhciBuPWUuZ2V0UmluZygpO251bGw9PT10aGlzLmhvbGVzJiYodGhpcy5ob2xlcz1uZXcgSSksdGhpcy5ob2xlcy5hZGQobil9fSxzZXRJbmNsdWRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc0luY2x1ZGVkPXQsdGhpcy5faXNJbmNsdWRlZFNldD0hMH0sZ2V0T3V0ZXJIb2xlOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIHQ9MDt0PHRoaXMuZGVMaXN0LnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZGVMaXN0LmdldCh0KSxuPWUuZ2V0U3ltKCkuZ2V0UmluZygpO2lmKG4uaXNPdXRlckhvbGUoKSlyZXR1cm4gbn1yZXR1cm4gbnVsbH0sY29tcHV0ZUhvbGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFJpbmcoKTt0aGlzLl9pc0hvbGU9aGUuaXNDQ1codC5nZXRDb29yZGluYXRlcygpKX0saGFzU2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2hlbGx9LGlzT3V0ZXJTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5nZXRPdXRlckhvbGUoKX0sZ2V0TGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5yaW5nUHRzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLmdldENvb3JkaW5hdGVzKCkpKX0sZ2V0U2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLnNoZWxsOnRoaXN9LGFkZDpmdW5jdGlvbih0KXt0aGlzLmRlTGlzdC5hZGQodCl9LGdldFJpbmc6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5yaW5nKXJldHVybiB0aGlzLnJpbmc7dGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMucmluZ1B0cy5sZW5ndGg8MyYmQS5vdXQucHJpbnRsbih0aGlzLnJpbmdQdHMpO3RyeXt0aGlzLnJpbmc9dGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5yaW5nUHRzKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O0Eub3V0LnByaW50bG4odGhpcy5yaW5nUHRzKX1maW5hbGx5e31yZXR1cm4gdGhpcy5yaW5nfSx1cGRhdGVJbmNsdWRlZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKHZhciB0PTA7dDx0aGlzLmRlTGlzdC5zaXplKCk7dCsrKXt2YXIgZT10aGlzLmRlTGlzdC5nZXQodCksbj1lLmdldFN5bSgpLmdldFJpbmcoKS5nZXRTaGVsbCgpO2lmKG51bGwhPT1uJiZuLmlzSW5jbHVkZWRTZXQoKSlyZXR1cm4gdGhpcy5zZXRJbmNsdWRlZCghbi5pc0luY2x1ZGVkKCkpLG51bGx9fSxzZXRTaGVsbDpmdW5jdGlvbih0KXt0aGlzLnNoZWxsPXR9LHNldFByb2Nlc3NlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Byb2Nlc3NlZD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYcn19KSxYci5maW5kRGlyRWRnZXNJblJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9dCxuPW5ldyBJO2RvIG4uYWRkKGUpLGU9ZS5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIik7d2hpbGUoZSE9PXQpO3JldHVybiBufSxYci5hZGRFZGdlPWZ1bmN0aW9uKHQsZSxuKXtpZihlKWZvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKW4uYWRkKHRbaV0sITEpO2Vsc2UgZm9yKHZhciBpPXQubGVuZ3RoLTE7aT49MDtpLS0pbi5hZGQodFtpXSwhMSl9LFhyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmc9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRSaW5nKCksaT1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscz1udWxsLG89bnVsbCxhPWUuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpLGw9dS5nZXRSaW5nKCksaD1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighaC5lcXVhbHMoaSkmJmguY29udGFpbnMoaSkpe3I9SC5wdE5vdEluTGlzdChuLmdldENvb3JkaW5hdGVzKCksbC5nZXRDb29yZGluYXRlcygpKTt2YXIgYz0hMTtoZS5pc1BvaW50SW5SaW5nKHIsbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09c3x8by5jb250YWlucyhoKSkmJihzPXUsbz1zLmdldFJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpfX1yZXR1cm4gc30sZShIci5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4gbi5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKS5jb21wYXJlVG8oaS5nZXRSaW5nKCkuZ2V0RW52ZWxvcGUoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIcn19KSxYci5FbnZlbG9wZUNvbXBhcmF0b3I9SHIsaChXcixQciksZShXci5wcm90b3R5cGUse2ZpbmRFZGdlUmluZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgWHIodGhpcy5mYWN0b3J5KTtyZXR1cm4gZS5idWlsZCh0KSxlfSxjb21wdXRlRGVwdGhQYXJpdHk6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IoOzspe3ZhciB0PW51bGw7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRGVwdGhQYXJpdHkodCl9ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfX0sY29tcHV0ZU5leHRDV0VkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtXci5jb21wdXRlTmV4dENXRWRnZXMoZSl9fSxhZGRFZGdlOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO3ZhciBuPWVbMF0saT1lW2UubGVuZ3RoLTFdLHI9dGhpcy5nZXROb2RlKG4pLHM9dGhpcy5nZXROb2RlKGkpLG89bmV3IF9yKHIscyxlWzFdLCghMCkpLGE9bmV3IF9yKHMscixlW2UubGVuZ3RoLTJdLCghMSkpLHU9bmV3IE1yKHQpO3Uuc2V0RGlyZWN0ZWRFZGdlcyhvLGEpLHRoaXMuYWRkKHUpfSxkZWxldGVDdXRFZGdlczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksV3IuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5kaXJFZGdlcyk7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5kaXJFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYoIW4uaXNNYXJrZWQoKSl7dmFyIGk9bi5nZXRTeW0oKTtpZihuLmdldExhYmVsKCk9PT1pLmdldExhYmVsKCkpe24uc2V0TWFya2VkKCEwKSxpLnNldE1hcmtlZCghMCk7dmFyIHI9bi5nZXRFZGdlKCk7dC5hZGQoci5nZXRMaW5lKCkpfX19cmV0dXJuIHR9LGdldEVkZ2VSaW5nczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksV3IubGFiZWwodGhpcy5kaXJFZGdlcywtMSk7dmFyIHQ9V3IuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5kaXJFZGdlcyk7dGhpcy5jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KTtmb3IodmFyIGU9bmV3IEksbj10aGlzLmRpckVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighaS5pc01hcmtlZCgpJiYhaS5pc0luUmluZygpKXt2YXIgcj10aGlzLmZpbmRFZGdlUmluZyhpKTtlLmFkZChyKX19cmV0dXJuIGV9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBMcih0KSx0aGlzLmFkZChlKSksZX0sY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLHI9V3IuZmluZEludGVyc2VjdGlvbk5vZGVzKG4saSk7aWYobnVsbCE9PXIpZm9yKHZhciBzPXIuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpO1dyLmNvbXB1dGVOZXh0Q0NXRWRnZXMobyxpKX19fSxkZWxldGVEYW5nbGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZmluZE5vZGVzT2ZEZWdyZWUoMSksZT1uZXcgSixuPW5ldyBwZSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspbi5wdXNoKGkubmV4dCgpKTtmb3IoOyFuLmlzRW1wdHkoKTspe3ZhciByPW4ucG9wKCk7V3IuZGVsZXRlQWxsRWRnZXMocik7Zm9yKHZhciBzPXIuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLGk9cy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIG89aS5uZXh0KCk7by5zZXRNYXJrZWQoITApO3ZhciBhPW8uZ2V0U3ltKCk7bnVsbCE9PWEmJmEuc2V0TWFya2VkKCEwKTt2YXIgdT1vLmdldEVkZ2UoKTtlLmFkZCh1LmdldExpbmUoKSk7dmFyIGw9by5nZXRUb05vZGUoKTsxPT09V3IuZ2V0RGVncmVlTm9uRGVsZXRlZChsKSYmbi5wdXNoKGwpfX1yZXR1cm4gZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV3J9fSksV3IuZmluZExhYmVsZWRFZGdlUmluZ3M9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKCEoci5pc01hcmtlZCgpfHxyLmdldExhYmVsKCk+PTApKXtlLmFkZChyKTt2YXIgcz1Yci5maW5kRGlyRWRnZXNJblJpbmcocik7V3IubGFiZWwocyxuKSxuKyt9fXJldHVybiBlfSxXci5nZXREZWdyZWVOb25EZWxldGVkPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxuPTAsaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzTWFya2VkKCl8fG4rK31yZXR1cm4gbn0sV3IuZGVsZXRlQWxsRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRNYXJrZWQoITApO3ZhciByPWkuZ2V0U3ltKCk7bnVsbCE9PXImJnIuc2V0TWFya2VkKCEwKX19LFdyLmxhYmVsPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0TGFiZWwoZSl9fSxXci5jb21wdXRlTmV4dENXRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKSxuPW51bGwsaT1udWxsLHI9ZS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZighcy5pc01hcmtlZCgpKXtpZihudWxsPT09biYmKG49cyksbnVsbCE9PWkpe3ZhciBvPWkuZ2V0U3ltKCk7by5zZXROZXh0KHMpfWk9c319aWYobnVsbCE9PWkpe3ZhciBvPWkuZ2V0U3ltKCk7by5zZXROZXh0KG4pfX0sV3IuY29tcHV0ZU5leHRDQ1dFZGdlcz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE91dEVkZ2VzKCksaT1udWxsLHI9bnVsbCxzPW4uZ2V0RWRnZXMoKSxvPXMuc2l6ZSgpLTE7bz49MDtvLS0pe3ZhciBhPXMuZ2V0KG8pLHU9YS5nZXRTeW0oKSxsPW51bGw7YS5nZXRMYWJlbCgpPT09ZSYmKGw9YSk7dmFyIGg9bnVsbDt1LmdldExhYmVsKCk9PT1lJiYoaD11KSxudWxsPT09bCYmbnVsbD09PWh8fChudWxsIT09aCYmKHI9aCksbnVsbCE9PWwmJihudWxsIT09ciYmKHIuc2V0TmV4dChsKSxyPW51bGwpLG51bGw9PT1pJiYoaT1sKSkpfW51bGwhPT1yJiYoZi5pc1RydWUobnVsbCE9PWkpLHIuc2V0TmV4dChpKSl9LFdyLmdldERlZ3JlZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxpPTAscj1uLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtzLmdldExhYmVsKCk9PT1lJiZpKyt9cmV0dXJuIGl9LFdyLmZpbmRJbnRlcnNlY3Rpb25Ob2Rlcz1mdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1udWxsO2Rve3ZhciByPW4uZ2V0RnJvbU5vZGUoKTtXci5nZXREZWdyZWUocixlKT4xJiYobnVsbD09PWkmJihpPW5ldyBJKSxpLmFkZChyKSksbj1uLmdldE5leHQoKSxmLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxmLmlzVHJ1ZShuPT09dHx8IW4uaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShuIT09dCk7cmV0dXJuIGl9LGUoanIucHJvdG90eXBlLHtnZXRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5nZW9tRmFjdG9yeSYmKHRoaXMuZ2VvbUZhY3Rvcnk9bmV3IGllKSx0aGlzLnBvbHlnb25pemUoKSx0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsP3RoaXMuZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLnBvbHlMaXN0KTp0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkodGhpcy5wb2x5TGlzdCkpfSxnZXRJbnZhbGlkUmluZ0xpbmVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuaW52YWxpZFJpbmdMaW5lc30sZmluZFZhbGlkUmluZ3M6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzVmFsaWQoKT9lLmFkZChyKTpuLmFkZChyLmdldExpbmVTdHJpbmcoKSl9fSxwb2x5Z29uaXplOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucG9seUxpc3QpcmV0dXJuIG51bGw7XG5pZih0aGlzLnBvbHlMaXN0PW5ldyBJLG51bGw9PT10aGlzLmdyYXBoKXJldHVybiBudWxsO3RoaXMuZGFuZ2xlcz10aGlzLmdyYXBoLmRlbGV0ZURhbmdsZXMoKSx0aGlzLmN1dEVkZ2VzPXRoaXMuZ3JhcGguZGVsZXRlQ3V0RWRnZXMoKTt2YXIgdD10aGlzLmdyYXBoLmdldEVkZ2VSaW5ncygpLGU9bmV3IEk7dGhpcy5pbnZhbGlkUmluZ0xpbmVzPW5ldyBJLHRoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ/dGhpcy5maW5kVmFsaWRSaW5ncyh0LGUsdGhpcy5pbnZhbGlkUmluZ0xpbmVzKTplPXQsdGhpcy5maW5kU2hlbGxzQW5kSG9sZXMoZSksanIuYXNzaWduSG9sZXNUb1NoZWxscyh0aGlzLmhvbGVMaXN0LHRoaXMuc2hlbGxMaXN0KSxoby5zb3J0KHRoaXMuc2hlbGxMaXN0LG5ldyBYci5FbnZlbG9wZUNvbXBhcmF0b3IpO3ZhciBuPSEwO3RoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihqci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5zaGVsbExpc3QpLG49ITEpLHRoaXMucG9seUxpc3Q9anIuZXh0cmFjdFBvbHlnb25zKHRoaXMuc2hlbGxMaXN0LG4pfSxnZXREYW5nbGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuZGFuZ2xlc30sZ2V0Q3V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5jdXRFZGdlc30sZ2V0UG9seWdvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5wb2x5TGlzdH0sYWRkOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkKG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUZhY3Rvcnk9aS5nZXRGYWN0b3J5KCksbnVsbD09PXRoaXMuZ3JhcGgmJih0aGlzLmdyYXBoPW5ldyBXcih0aGlzLmdlb21GYWN0b3J5KSksdGhpcy5ncmFwaC5hZGRFZGdlKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgcj1hcmd1bWVudHNbMF07ci5hcHBseSh0aGlzLmxpbmVTdHJpbmdBZGRlcil9fSxzZXRDaGVja1JpbmdzVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD10fSxmaW5kU2hlbGxzQW5kSG9sZXM6ZnVuY3Rpb24odCl7dGhpcy5ob2xlTGlzdD1uZXcgSSx0aGlzLnNoZWxsTGlzdD1uZXcgSTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5jb21wdXRlSG9sZSgpLG4uaXNIb2xlKCk/dGhpcy5ob2xlTGlzdC5hZGQobik6dGhpcy5zaGVsbExpc3QuYWRkKG4pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ganJ9fSksanIuZmluZE91dGVyU2hlbGxzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0T3V0ZXJIb2xlKCk7bnVsbD09PWl8fGkuaXNQcm9jZXNzZWQoKXx8KG4uc2V0SW5jbHVkZWQoITApLGkuc2V0UHJvY2Vzc2VkKCEwKSl9fSxqci5leHRyYWN0UG9seWdvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTsoZXx8ci5pc0luY2x1ZGVkKCkpJiZuLmFkZChyLmdldFBvbHlnb24oKSl9cmV0dXJuIG59LGpyLmFzc2lnbkhvbGVzVG9TaGVsbHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7anIuYXNzaWduSG9sZVRvU2hlbGwoaSxlKX19LGpyLmFzc2lnbkhvbGVUb1NoZWxsPWZ1bmN0aW9uKHQsZSl7dmFyIG49WHIuZmluZEVkZ2VSaW5nQ29udGFpbmluZyh0LGUpO251bGwhPT1uJiZuLmFkZEhvbGUodCl9LGpyLmZpbmREaXNqb2ludFNoZWxscz1mdW5jdGlvbih0KXtqci5maW5kT3V0ZXJTaGVsbHModCk7dmFyIGU9bnVsbDtkb3tlPSExO2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSW5jbHVkZWRTZXQoKXx8KGkudXBkYXRlSW5jbHVkZWQoKSxpLmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9LGUoS3IucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLnAuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS3J9fSksanIuTGluZVN0cmluZ0FkZGVyPUtyO3ZhciBUbz1PYmplY3QuZnJlZXplKHtQb2x5Z29uaXplcjpqcn0pO2UoWnIucHJvdG90eXBlLHtpbnNlcnRFZGdlRW5kczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5ub2Rlcy5hZGQobil9fSxjb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU06ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLGk9dGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxyPXQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCkscz10Lmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCk7Mj09PW4mJjI9PT1pP3ImJmUuc2V0QXRMZWFzdChcIjIxMjEwMTIxMlwiKToyPT09biYmMT09PWk/KHImJmUuc2V0QXRMZWFzdChcIkZGRjBGRkZGMlwiKSxzJiZlLnNldEF0TGVhc3QoXCIxRkZGRkYxRkZcIikpOjE9PT1uJiYyPT09aT8ociYmZS5zZXRBdExlYXN0KFwiRjBGRkZGRkYyXCIpLHMmJmUuc2V0QXRMZWFzdChcIjFGMUZGRkZGRlwiKSk6MT09PW4mJjE9PT1pJiZzJiZlLnNldEF0TGVhc3QoXCIwRkZGRkZGRkZcIil9LGxhYmVsSXNvbGF0ZWRFZGdlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLmFyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuaXNJc29sYXRlZCgpJiYodGhpcy5sYWJlbElzb2xhdGVkRWRnZShpLGUsdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSksdGhpcy5pc29sYXRlZEVkZ2VzLmFkZChpKSl9fSxsYWJlbElzb2xhdGVkRWRnZTpmdW5jdGlvbih0LGUsbil7aWYobi5nZXREaW1lbnNpb24oKT4wKXt2YXIgaT10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksbik7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLGkpfWVsc2UgdC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLEwuRVhURVJJT1IpfSxjb21wdXRlSU06ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZmU7aWYodC5zZXQoTC5FWFRFUklPUixMLkVYVEVSSU9SLDIpLCF0aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4gdGhpcy5jb21wdXRlRGlzam9pbnRJTSh0KSx0O3RoaXMuYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKTt2YXIgZT10aGlzLmFyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5hcmdbMV0sdGhpcy5saSwhMSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMSksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMSksdGhpcy5sYWJlbElzb2xhdGVkTm9kZXMoKSx0aGlzLmNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTShlLHQpO3ZhciBuPW5ldyBBcixpPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuYXJnWzBdLmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKGkpO3ZhciByPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuYXJnWzFdLmdldEVkZ2VJdGVyYXRvcigpKTtyZXR1cm4gdGhpcy5pbnNlcnRFZGdlRW5kcyhyKSx0aGlzLmxhYmVsTm9kZUVkZ2VzKCksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMCwxKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygxLDApLHRoaXMudXBkYXRlSU0odCksdH0sbGFiZWxOb2RlRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5hcmcpfX0sY29weU5vZGVzQW5kTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9dGhpcy5ub2Rlcy5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKTtpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19LGxhYmVsSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkscj1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89dGhpcy5ub2Rlcy5maW5kKHMuY29vcmQpO28uZ2V0TGFiZWwoKS5pc051bGwodCkmJihpPT09TC5CT1VOREFSWT9vLnNldExhYmVsQm91bmRhcnkodCk6by5zZXRMYWJlbCh0LEwuSU5URVJJT1IpKX19LGxhYmVsSXNvbGF0ZWROb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxuKX0sY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMubm9kZXMuYWRkTm9kZShzLmNvb3JkKTtpPT09TC5CT1VOREFSWT9vLnNldExhYmVsQm91bmRhcnkodCk6by5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmby5zZXRMYWJlbCh0LEwuSU5URVJJT1IpfX0sbGFiZWxJc29sYXRlZE5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2YuaXNUcnVlKG4uZ2V0R2VvbWV0cnlDb3VudCgpPjAsXCJub2RlIHdpdGggZW1wdHkgbGFiZWwgZm91bmRcIiksZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMCk6dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDEpKX19LHVwZGF0ZUlNOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmlzb2xhdGVkRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24udXBkYXRlSU0odCl9Zm9yKHZhciBpPXRoaXMubm9kZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IudXBkYXRlSU0odCksci51cGRhdGVJTUZyb21FZGdlcyh0KX19LGNvbXB1dGVEaXNqb2ludElNOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCk7ZS5pc0VtcHR5KCl8fCh0LnNldChMLklOVEVSSU9SLEwuRVhURVJJT1IsZS5nZXREaW1lbnNpb24oKSksdC5zZXQoTC5CT1VOREFSWSxMLkVYVEVSSU9SLGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpO3ZhciBuPXRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCk7bi5pc0VtcHR5KCl8fCh0LnNldChMLkVYVEVSSU9SLEwuSU5URVJJT1Isbi5nZXREaW1lbnNpb24oKSksdC5zZXQoTC5FWFRFUklPUixMLkJPVU5EQVJZLG4uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBacn19KSxlKFFyLnByb3RvdHlwZSx7aXNDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBUdClyZXR1cm4hMTtpZih0IGluc3RhbmNlb2YgTHQpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLmlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCk7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeShuKSlyZXR1cm4hMX1yZXR1cm4hMH0saXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24odCxlKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0Lng9PT1lLngpe2lmKHQueD09PXRoaXMucmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMucmVjdEVudi5nZXRNYXhYKCkpcmV0dXJuITB9ZWxzZSBpZih0Lnk9PT1lLnkmJih0Lnk9PT10aGlzLnJlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WSgpKSlyZXR1cm4hMDtyZXR1cm4hMX0saXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPW5ldyBnLGk9bmV3IGcscj0wO3I8ZS5zaXplKCktMTtyKyspaWYoZS5nZXRDb29yZGluYXRlKHIsbiksZS5nZXRDb29yZGluYXRlKHIrMSxpKSwhdGhpcy5pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeShuLGkpKXJldHVybiExO3JldHVybiEwfSxpc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LmdldENvb3JkaW5hdGUoKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIGUueD09PXRoaXMucmVjdEVudi5nZXRNaW5YKCl8fGUueD09PXRoaXMucmVjdEVudi5nZXRNYXhYKCl8fGUueT09PXRoaXMucmVjdEVudi5nZXRNaW5ZKCl8fGUueT09PXRoaXMucmVjdEVudi5nZXRNYXhZKCl9fSxjb250YWluczpmdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMucmVjdEVudi5jb250YWlucyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJiF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUXJ9fSksUXIuY29udGFpbnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgUXIodCk7cmV0dXJuIG4uY29udGFpbnMoZSl9LGUoSnIucHJvdG90eXBlLHtpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEModCxlKTtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHMobikpcmV0dXJuITE7aWYodGhpcy5yZWN0RW52LmludGVyc2VjdHModCkpcmV0dXJuITA7aWYodGhpcy5yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuITA7aWYodC5jb21wYXJlVG8oZSk+MCl7dmFyIGk9dDt0PWUsZT1pfXZhciByPSExO3JldHVybiBlLnk+dC55JiYocj0hMCkscj90aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuZGlhZ0Rvd24wLHRoaXMuZGlhZ0Rvd24xKTp0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuZGlhZ1VwMCx0aGlzLmRpYWdVcDEpLCEhdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSnJ9fSksZSgkci5wcm90b3R5cGUse2FwcGx5VG86ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKSYmIXRoaXMuX2lzRG9uZTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKG4gaW5zdGFuY2VvZiBmdCl0aGlzLmFwcGx5VG8obik7ZWxzZSBpZih0aGlzLnZpc2l0KG4pLHRoaXMuaXNEb25lKCkpcmV0dXJuIHRoaXMuX2lzRG9uZT0hMCxudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJHJ9fSksZSh0cy5wcm90b3R5cGUse2ludGVyc2VjdHM6ZnVuY3Rpb24odCl7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTt2YXIgZT1uZXcgZXModGhpcy5yZWN0RW52KTtpZihlLmFwcGx5VG8odCksZS5pbnRlcnNlY3RzKCkpcmV0dXJuITA7dmFyIG49bmV3IG5zKHRoaXMucmVjdGFuZ2xlKTtpZihuLmFwcGx5VG8odCksbi5jb250YWluc1BvaW50KCkpcmV0dXJuITA7dmFyIGk9bmV3IGlzKHRoaXMucmVjdGFuZ2xlKTtyZXR1cm4gaS5hcHBseVRvKHQpLCEhaS5pbnRlcnNlY3RzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRzfX0pLHRzLmludGVyc2VjdHM9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgdHModCk7cmV0dXJuIG4uaW50ZXJzZWN0cyhlKX0saChlcywkciksZShlcy5wcm90b3R5cGUse2lzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzPT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiB0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLnJlY3RFbnYuY29udGFpbnMoZSk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6ZS5nZXRNaW5YKCk+PXRoaXMucmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOmUuZ2V0TWluWSgpPj10aGlzLnJlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5yZWN0RW52LmdldE1heFkoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTp2b2lkIDA6bnVsbH0saW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlc319KSxoKG5zLCRyKSxlKG5zLnByb3RvdHlwZSx7aXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgVHQpKXJldHVybiBudWxsO3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtmb3IodmFyIG49bmV3IGcsaT0wO2k8NDtpKyspaWYodGhpcy5yZWN0U2VxLmdldENvb3JkaW5hdGUoaSxuKSxlLmNvbnRhaW5zKG4pJiZUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uKG4sdCkpcmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnQ9ITAsbnVsbH0sY29udGFpbnNQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBuc319KSxoKGlzLCRyKSxlKGlzLnByb3RvdHlwZSx7aW50ZXJzZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uPT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDt2YXIgbj1rbi5nZXRMaW5lcyh0KTt0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzKG4pfSxjaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYodGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyhuKSx0aGlzLmhhc0ludGVyc2VjdGlvbilyZXR1cm4gbnVsbH19LGNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG49MTtuPGUuc2l6ZSgpO24rKylpZihlLmdldENvb3JkaW5hdGUobi0xLHRoaXMucDApLGUuZ2V0Q29vcmRpbmF0ZShuLHRoaXMucDEpLHRoaXMucmVjdEludGVyc2VjdG9yLmludGVyc2VjdHModGhpcy5wMCx0aGlzLnAxKSlyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb249ITAsbnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaXN9fSksaChycyx0aSksZShycy5wcm90b3R5cGUse2dldEludGVyc2VjdGlvbk1hdHJpeDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWxhdGUuY29tcHV0ZUlNKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJzfX0pLHJzLmNvdmVycz1mdW5jdGlvbih0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY292ZXJzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKCEhdC5pc1JlY3RhbmdsZSgpfHxycy5yZWxhdGUodCxlKS5pc0NvdmVycygpKX0scnMuaW50ZXJzZWN0cz1mdW5jdGlvbih0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJih0LmlzUmVjdGFuZ2xlKCk/dHMuaW50ZXJzZWN0cyh0LGUpOmUuaXNSZWN0YW5nbGUoKT90cy5pbnRlcnNlY3RzKGUsdCk6cnMucmVsYXRlKHQsZSkuaXNJbnRlcnNlY3RzKCkpfSxycy50b3VjaGVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmcnMucmVsYXRlKHQsZSkuaXNUb3VjaGVzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9LHJzLndpdGhpbj1mdW5jdGlvbih0LGUpe3JldHVybiBlLmNvbnRhaW5zKHQpfSxycy5jb3ZlcmVkQnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcnMuY292ZXJzKGUsdCl9LHJzLnJlbGF0ZT1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgcnModCxlKSxpPW4uZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCk7cmV0dXJuIGl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBCKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07cmV0dXJuIHJzLnJlbGF0ZVdpdGhDaGVjayhyLHMpLm1hdGNoZXMobyl9aWYoUihhcmd1bWVudHNbMl0sVikmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBCKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl0sbj1uZXcgcnMoYSx1LGwpLGk9bi5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKTtyZXR1cm4gaX19fSxycy5vdmVybGFwcz1mdW5jdGlvbih0LGUpe3JldHVybiEhdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJnJzLnJlbGF0ZSh0LGUpLmlzT3ZlcmxhcHModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX0scnMuZGlzam9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4hdC5pbnRlcnNlY3RzKGUpfSxycy5yZWxhdGVXaXRoQ2hlY2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHJzLnJlbGF0ZSh0LGUpfSxycy5jcm9zc2VzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmcnMucmVsYXRlKHQsZSkuaXNDcm9zc2VzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9LHJzLmNvbnRhaW5zPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJih0LmlzUmVjdGFuZ2xlKCk/UXIuY29udGFpbnModCxlKTpycy5yZWxhdGUodCxlKS5pc0NvbnRhaW5zKCkpfTt2YXIgUG89T2JqZWN0LmZyZWV6ZSh7UmVsYXRlT3A6cnN9KTtlKHNzLnByb3RvdHlwZSx7ZXh0cmFjdEVsZW1lbnRzOmZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pO3RoaXMuc2tpcEVtcHR5JiZpLmlzRW1wdHkoKXx8ZS5hZGQoaSl9fSxjb21iaW5lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5pbnB1dEdlb21zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3RFbGVtZW50cyhuLHQpfXJldHVybiAwPT09dC5zaXplKCk/bnVsbCE9PXRoaXMuZ2VvbUZhY3Rvcnk/dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCk6bnVsbDp0aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNzfX0pLHNzLmNvbWJpbmU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IHNzKHQpO3JldHVybiBlLmNvbWJpbmUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bmV3IHNzKHNzLmNyZWF0ZUxpc3QobixpKSk7cmV0dXJuIGUuY29tYmluZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sZT1uZXcgc3Moc3MuY3JlYXRlTGlzdChyLHMsbykpO3JldHVybiBlLmNvbWJpbmUoKX19LHNzLmV4dHJhY3RGYWN0b3J5PWZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRW1wdHkoKT9udWxsOnQuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpfSxzcy5jcmVhdGVMaXN0PWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBJO3JldHVybiBuLmFkZCh0KSxuLmFkZChlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbj1uZXcgSTtyZXR1cm4gbi5hZGQoaSksbi5hZGQociksbi5hZGQocyksbn19LGUob3MucHJvdG90eXBlLHt1bmlvbjpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgVGUsZT1uZXcgYXQsbj0wO248dGhpcy5wb2ludEdlb20uZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dGhpcy5wb2ludEdlb20uZ2V0R2VvbWV0cnlOKG4pLHI9aS5nZXRDb29yZGluYXRlKCkscz10LmxvY2F0ZShyLHRoaXMub3RoZXJHZW9tKTtzPT09TC5FWFRFUklPUiYmZS5hZGQocil9aWYoMD09PWUuc2l6ZSgpKXJldHVybiB0aGlzLm90aGVyR2VvbTt2YXIgbz1udWxsLGE9SC50b0Nvb3JkaW5hdGVBcnJheShlKTtyZXR1cm4gbz0xPT09YS5sZW5ndGg/dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludChhWzBdKTp0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGEpLHNzLmNvbWJpbmUobyx0aGlzLm90aGVyR2VvbSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9zfX0pLG9zLnVuaW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IG9zKHQsZSk7cmV0dXJuIG4udW5pb24oKX0sZShhcy5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0aGlzLnNvcnRJbmRleCE9PS0xJiZ0LmdldFNvcnRJbmRleCgpIT09dGhpcy5zb3J0SW5kZXh8fHRoaXMuY29tcHMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFzfX0pLGFzLmV4dHJhY3Q9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBhcy5leHRyYWN0KHQsZSxuZXcgSSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTtyZXR1cm4gbi5nZXRTb3J0SW5kZXgoKT09PWk/ci5hZGQobik6biBpbnN0YW5jZW9mIGZ0JiZuLmFwcGx5KG5ldyBhcyhpLHIpKSxyfX0sZSh1cy5wcm90b3R5cGUse3JlZHVjZVRvR2VvbWV0cmllczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPW51bGw7UihpLHkpP3I9dGhpcy51bmlvblRyZWUoaSk6aSBpbnN0YW5jZW9mIEImJihyPWkpLGUuYWRkKHIpfXJldHVybiBlfSxleHRyYWN0QnlFbnZlbG9wZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW5ldyBJLHI9MDtyPGUuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9ZS5nZXRHZW9tZXRyeU4ocik7cy5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9pLmFkZChzKTpuLmFkZChzKX1yZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KGkpfSx1bmlvbk9wdGltaXplZDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIW4uaW50ZXJzZWN0cyhpKSl7dmFyIHI9c3MuY29tYmluZSh0LGUpO3JldHVybiByfWlmKHQuZ2V0TnVtR2VvbWV0cmllcygpPD0xJiZlLmdldE51bUdlb21ldHJpZXMoKTw9MSlyZXR1cm4gdGhpcy51bmlvbkFjdHVhbCh0LGUpO3ZhciBzPW4uaW50ZXJzZWN0aW9uKGkpO3JldHVybiB0aGlzLnVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbih0LGUscyl9LHVuaW9uOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuaW5wdXRQb2x5cyl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwidW5pb24oKSBtZXRob2QgY2Fubm90IGJlIGNhbGxlZCB0d2ljZVwiKTtpZih0aGlzLmlucHV0UG9seXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuZ2VvbUZhY3Rvcnk9dGhpcy5pbnB1dFBvbHlzLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKTtmb3IodmFyIHQ9bmV3IGtlKHVzLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSksZT10aGlzLmlucHV0UG9seXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QuaW5zZXJ0KG4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG4pfXRoaXMuaW5wdXRQb2x5cz1udWxsO3ZhciBpPXQuaXRlbXNUcmVlKCkscj10aGlzLnVuaW9uVHJlZShpKTtyZXR1cm4gcn0sYmluYXJ5VW5pb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKHQsMCx0LnNpemUoKSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXTtpZihpLW48PTEpe3ZhciByPXVzLmdldEdlb21ldHJ5KGUsbik7cmV0dXJuIHRoaXMudW5pb25TYWZlKHIsbnVsbCl9aWYoaS1uPT09MilyZXR1cm4gdGhpcy51bmlvblNhZmUodXMuZ2V0R2VvbWV0cnkoZSxuKSx1cy5nZXRHZW9tZXRyeShlLG4rMSkpO3ZhciBzPU1hdGgudHJ1bmMoKGkrbikvMikscj10aGlzLmJpbmFyeVVuaW9uKGUsbixzKSxvPXRoaXMuYmluYXJ5VW5pb24oZSxzLGkpO3JldHVybiB0aGlzLnVuaW9uU2FmZShyLG8pfX0scmVwZWF0ZWRVbmlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2U9bnVsbD09PWU/aS5jb3B5KCk6ZS51bmlvbihpKX1yZXR1cm4gZX0sdW5pb25TYWZlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT10P2UuY29weSgpOm51bGw9PT1lP3QuY29weSgpOnRoaXMudW5pb25PcHRpbWl6ZWQodCxlKX0sdW5pb25BY3R1YWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdXMucmVzdHJpY3RUb1BvbHlnb25zKHQudW5pb24oZSkpfSx1bmlvblRyZWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZWR1Y2VUb0dlb21ldHJpZXModCksbj10aGlzLmJpbmFyeVVuaW9uKGUpO3JldHVybiBufSx1bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBJLHI9dGhpcy5leHRyYWN0QnlFbnZlbG9wZShuLHQsaSkscz10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sZSxpKSxvPXRoaXMudW5pb25BY3R1YWwocixzKTtpLmFkZChvKTt2YXIgYT1zcy5jb21iaW5lKGkpO3JldHVybiBhfSxidWZmZXJVbmlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldCgwKS5nZXRGYWN0b3J5KCksbj1lLmJ1aWxkR2VvbWV0cnkodCksaT1uLmJ1ZmZlcigwKTtyZXR1cm4gaX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLGU9ci5nZXRGYWN0b3J5KCksbj1lLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbcixzXSksaT1uLmJ1ZmZlcigwKTtyZXR1cm4gaX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVzfX0pLHVzLnJlc3RyaWN0VG9Qb2x5Z29ucz1mdW5jdGlvbih0KXtpZihSKHQsUnQpKXJldHVybiB0O3ZhciBlPXByLmdldFBvbHlnb25zKHQpO3JldHVybiAxPT09ZS5zaXplKCk/ZS5nZXQoMCk6dC5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKGllLnRvUG9seWdvbkFycmF5KGUpKX0sdXMuZ2V0R2VvbWV0cnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT49dC5zaXplKCk/bnVsbDp0LmdldChlKX0sdXMudW5pb249ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHVzKHQpO3JldHVybiBlLnVuaW9uKCl9LHVzLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWT00LGUobHMucHJvdG90eXBlLHt1bmlvbk5vT3B0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2VvbUZhY3QuY3JlYXRlUG9pbnQoKTtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHVuaW9uV2l0aE51bGw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PWU/dDpudWxsPT09dD9lOnQudW5pb24oZSl9LGV4dHJhY3Q6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5leHRyYWN0KG4pfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgaT1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuZ2VvbUZhY3QmJih0aGlzLmdlb21GYWN0PWkuZ2V0RmFjdG9yeSgpKSxhcy5leHRyYWN0KGksQi5TT1JUSU5ERVhfUE9MWUdPTix0aGlzLnBvbHlnb25zKSxhcy5leHRyYWN0KGksQi5TT1JUSU5ERVhfTElORVNUUklORyx0aGlzLmxpbmVzKSxhcy5leHRyYWN0KGksQi5TT1JUSU5ERVhfUE9JTlQsdGhpcy5wb2ludHMpfX0sdW5pb246ZnVuY3Rpb24gdCgpe2lmKG51bGw9PT10aGlzLmdlb21GYWN0KXJldHVybiBudWxsO3ZhciBlPW51bGw7aWYodGhpcy5wb2ludHMuc2l6ZSgpPjApe3ZhciBuPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLnBvaW50cyk7ZT10aGlzLnVuaW9uTm9PcHQobil9dmFyIGk9bnVsbDtpZih0aGlzLmxpbmVzLnNpemUoKT4wKXt2YXIgcj10aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5saW5lcyk7aT10aGlzLnVuaW9uTm9PcHQocil9dmFyIHM9bnVsbDt0aGlzLnBvbHlnb25zLnNpemUoKT4wJiYocz11cy51bmlvbih0aGlzLnBvbHlnb25zKSk7dmFyIG89dGhpcy51bmlvbldpdGhOdWxsKGkscyksdD1udWxsO3JldHVybiB0PW51bGw9PT1lP286bnVsbD09PW8/ZTpvcy51bmlvbihlLG8pLG51bGw9PT10P3RoaXMuZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbHN9fSksbHMudW5pb249ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBscyh0KTtyZXR1cm4gZS51bmlvbigpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIG49YXJndW1lbnRzWzBdLGU9bmV3IGxzKG4pO3JldHVybiBlLnVuaW9uKCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxlPW5ldyBscyhpLHIpO3JldHVybiBlLnVuaW9uKCl9fTt2YXIgYm89T2JqZWN0LmZyZWV6ZSh7VW5hcnlVbmlvbk9wOmxzfSksT289T2JqZWN0LmZyZWV6ZSh7SXNWYWxpZE9wOlVyLENvbnNpc3RlbnRBcmVhVGVzdGVyOlZyfSksX289T2JqZWN0LmZyZWV6ZSh7Qm91bmRhcnlPcDpkdCxJc1NpbXBsZU9wOldpLGJ1ZmZlcjpTbyxkaXN0YW5jZTp3byxsaW5lbWVyZ2U6TG8sb3ZlcmxheTpSbyxwb2x5Z29uaXplOlRvLHJlbGF0ZTpQbyx1bmlvbjpibyx2YWxpZDpPb30pO2goaHMsX3QuQ29vcmRpbmF0ZU9wZXJhdGlvbiksZShocy5wcm90b3R5cGUse2VkaXRDb29yZGluYXRlczpmdW5jdGlvbih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIHI9bmV3IGcodFtpXSk7dGhpcy50YXJnZXRQTS5tYWtlUHJlY2lzZShyKSxuW2ldPXJ9dmFyIHM9bmV3IE4obiwoITEpKSxvPXMudG9Db29yZGluYXRlQXJyYXkoKSxhPTA7ZSBpbnN0YW5jZW9mIFN0JiYoYT0yKSxlIGluc3RhbmNlb2YgYnQmJihhPTQpO3ZhciB1PW47cmV0dXJuIHRoaXMucmVtb3ZlQ29sbGFwc2VkJiYodT1udWxsKSxvLmxlbmd0aDxhP3U6b30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHN9fSksZShjcy5wcm90b3R5cGUse2ZpeFBvbHlnb25hbFRvcG9sb2d5OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMudGFyZ2V0UE0pKTt2YXIgbj1lLmJ1ZmZlcigwKSxpPW47cmV0dXJuIHRoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChpPXRoaXMuY2hhbmdlUE0obix0LmdldFByZWNpc2lvbk1vZGVsKCkpKSxpfSxyZWR1Y2VQb2ludHdpc2U6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbDtpZih0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsKXt2YXIgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy50YXJnZXRQTSk7ZT1uZXcgX3Qobil9ZWxzZSBlPW5ldyBfdDt2YXIgaT10aGlzLnJlbW92ZUNvbGxhcHNlZDt0LmdldERpbWVuc2lvbigpPj0yJiYoaT0hMCk7dmFyIHI9ZS5lZGl0KHQsbmV3IGhzKHRoaXMudGFyZ2V0UE0saSkpO3JldHVybiByfSxjaGFuZ2VQTTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRpdG9yKHQuZ2V0RmFjdG9yeSgpLGUpO3JldHVybiBuLmVkaXQodCxuZXcgX3QuTm9PcEdlb21ldHJ5T3BlcmF0aW9uKX0sc2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50czpmdW5jdGlvbih0KXt0aGlzLnJlbW92ZUNvbGxhcHNlZD10fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGllKGUsdC5nZXRTUklEKCksdC5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpO3JldHVybiBufSxzZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsPXR9LHJlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlZHVjZVBvaW50d2lzZSh0KTtyZXR1cm4gdGhpcy5pc1BvaW50d2lzZT9lOlIoZSxSdCk/ZS5pc1ZhbGlkKCk/ZTp0aGlzLmZpeFBvbHlnb25hbFRvcG9sb2d5KGUpOmV9LHNldFBvaW50d2lzZTpmdW5jdGlvbih0KXt0aGlzLmlzUG9pbnR3aXNlPXR9LGNyZWF0ZUVkaXRvcjpmdW5jdGlvbih0LGUpe2lmKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKT09PWUpcmV0dXJuIG5ldyBfdDt2YXIgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKSxpPW5ldyBfdChuKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3N9fSksY3MucmVkdWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNzKGUpO3JldHVybiBuLnJlZHVjZSh0KX0sY3MucmVkdWNlUG9pbnR3aXNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNzKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9O3ZhciBNbz1PYmplY3QuZnJlZXplKHtHZW9tZXRyeVByZWNpc2lvblJlZHVjZXI6Y3N9KTtlKGZzLnByb3RvdHlwZSx7c2ltcGxpZnlTZWN0aW9uOmZ1bmN0aW9uKHQsZSl7aWYodCsxPT09ZSlyZXR1cm4gbnVsbDt0aGlzLnNlZy5wMD10aGlzLnB0c1t0XSx0aGlzLnNlZy5wMT10aGlzLnB0c1tlXTtmb3IodmFyIG49LTEsaT10LHI9dCsxO3I8ZTtyKyspe3ZhciBzPXRoaXMuc2VnLmRpc3RhbmNlKHRoaXMucHRzW3JdKTtzPm4mJihuPXMsaT1yKX1pZihuPD10aGlzLmRpc3RhbmNlVG9sZXJhbmNlKWZvcih2YXIgcj10KzE7cjxlO3IrKyl0aGlzLnVzZVB0W3JdPSExO2Vsc2UgdGhpcy5zaW1wbGlmeVNlY3Rpb24odCxpKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihpLGUpfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5OmZ1bmN0aW9uKCl7dGhpcy51c2VQdD1uZXcgQXJyYXkodGhpcy5wdHMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLnVzZVB0W3RdPSEwO3RoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5wdHMubGVuZ3RoLTEpO2Zvcih2YXIgZT1uZXcgTix0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMudXNlUHRbdF0mJmUuYWRkKG5ldyBnKHRoaXMucHRzW3RdKSk7cmV0dXJuIGUudG9Db29yZGluYXRlQXJyYXkoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZnN9fSksZnMuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZnModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5zaW1wbGlmeSgpfSxlKGdzLnByb3RvdHlwZSx7c2V0RW5zdXJlVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuaW5wdXRHZW9tLmNvcHkoKTpuZXcgZHModGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuaW5wdXRHZW9tKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7aWYodDwwKXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3N9fSksZ3Muc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZ3ModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKGRzLHhlKSxlKGRzLnByb3RvdHlwZSx7dHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgT3Q/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sY3JlYXRlVmFsaWRBcmVhOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPW51bGw7cmV0dXJuIGk9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOmZzLnNpbXBsaWZ5KG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoaSl9LHRyYW5zZm9ybU11bHRpUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfSx0cmFuc2Zvcm1MaW5lYXJSaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSBpbnN0YW5jZW9mIFR0LGk9eGUucHJvdG90eXBlLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fGkgaW5zdGFuY2VvZiBidD9pOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRzfX0pLGdzLkRQVHJhbnNmb3JtZXI9ZHMsaChwcyxjZSksZShwcy5wcm90b3R5cGUse2dldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5kZXh9LGdldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHN9fSksZSh2cy5wcm90b3R5cGUse2FkZFRvUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMucmVzdWx0U2Vncy5hZGQodCl9LGFzTGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2VncykpfSxnZXRSZXN1bHRTaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yZXN1bHRTZWdzLnNpemUoKTtyZXR1cm4gMD09PXQ/MDp0KzF9LGdldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmV9LGdldFNlZ21lbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2Vnc1t0XX0sZ2V0UGFyZW50Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCl9LGdldE1pbmltdW1TaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluaW11bVNpemV9LGFzTGluZWFyUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2VncykpfSxnZXRTZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ3N9LGluaXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLnNlZ3M9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7dmFyIG49bmV3IHBzKHRbZV0sdFtlKzFdLHRoaXMucGFyZW50TGluZSxlKTt0aGlzLnNlZ3NbZV09bn19LGdldFJlc3VsdENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2c319KSx2cy5leHRyYWN0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSsxKS5maWxsKG51bGwpLG49bnVsbCxpPTA7aTx0LnNpemUoKTtpKyspbj10LmdldChpKSxlW2ldPW4ucDA7cmV0dXJuIGVbZS5sZW5ndGgtMV09bi5wMSxlfSxlKG1zLnByb3RvdHlwZSx7cmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuaW5kZXgucmVtb3ZlKG5ldyBDKHQucDAsdC5wMSksdCl9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdnMpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0U2VnbWVudHMoKSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07dGhpcy5hZGQoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgcj1hcmd1bWVudHNbMF07dGhpcy5pbmRleC5pbnNlcnQobmV3IEMoci5wMCxyLnAxKSxyKX19LHF1ZXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDKHQucDAsdC5wMSksbj1uZXcgeXModCk7dGhpcy5pbmRleC5xdWVyeShlLG4pO3ZhciBpPW4uZ2V0SXRlbXMoKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbXN9fSksZSh5cy5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O0MuaW50ZXJzZWN0cyhlLnAwLGUucDEsdGhpcy5xdWVyeVNlZy5wMCx0aGlzLnF1ZXJ5U2VnLnAxKSYmdGhpcy5pdGVtcy5hZGQodCl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geXN9fSksZSh4cy5wcm90b3R5cGUse2ZsYXR0ZW46ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmxpbmVQdHNbdF0saT10aGlzLmxpbmVQdHNbZV0scj1uZXcgY2UobixpKTtyZXR1cm4gdGhpcy5yZW1vdmUodGhpcy5saW5lLHQsZSksdGhpcy5vdXRwdXRJbmRleC5hZGQocikscn0saGFzQmFkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hIXRoaXMuaGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKG4pfHwhIXRoaXMuaGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5U2VjdGlvbjpmdW5jdGlvbih0LGUsbil7bis9MTt2YXIgaT1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0KzE9PT1lKXt2YXIgcj10aGlzLmxpbmUuZ2V0U2VnbWVudCh0KTtyZXR1cm4gdGhpcy5saW5lLmFkZFRvUmVzdWx0KHIpLG51bGx9dmFyIHM9ITA7aWYodGhpcy5saW5lLmdldFJlc3VsdFNpemUoKTx0aGlzLmxpbmUuZ2V0TWluaW11bVNpemUoKSl7dmFyIG89bisxO288dGhpcy5saW5lLmdldE1pbmltdW1TaXplKCkmJihzPSExKX12YXIgYT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSx1PXRoaXMuZmluZEZ1cnRoZXN0UG9pbnQodGhpcy5saW5lUHRzLHQsZSxhKTthWzBdPnRoaXMuZGlzdGFuY2VUb2xlcmFuY2UmJihzPSExKTt2YXIgbD1uZXcgY2U7aWYobC5wMD10aGlzLmxpbmVQdHNbdF0sbC5wMT10aGlzLmxpbmVQdHNbZV0saVswXT10LGlbMV09ZSx0aGlzLmhhc0JhZEludGVyc2VjdGlvbih0aGlzLmxpbmUsaSxsKSYmKHM9ITEpLHMpe3ZhciByPXRoaXMuZmxhdHRlbih0LGUpO3JldHVybiB0aGlzLmxpbmUuYWRkVG9SZXN1bHQociksbnVsbH10aGlzLnNpbXBsaWZ5U2VjdGlvbih0LHUsbiksdGhpcy5zaW1wbGlmeVNlY3Rpb24odSxlLG4pfSxoYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMub3V0cHV0SW5kZXgucXVlcnkodCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKGksdCkpcmV0dXJuITB9cmV0dXJuITF9LGZpbmRGdXJ0aGVzdFBvaW50OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBjZTtyLnAwPXRbZV0sci5wMT10W25dO2Zvcih2YXIgcz0tMSxvPWUsYT1lKzE7YTxuO2ErKyl7dmFyIHU9dFthXSxsPXIuZGlzdGFuY2UodSk7bD5zJiYocz1sLG89YSl9cmV0dXJuIGlbMF09cyxvfSxzaW1wbGlmeTpmdW5jdGlvbih0KXt0aGlzLmxpbmU9dCx0aGlzLmxpbmVQdHM9dC5nZXRQYXJlbnRDb29yZGluYXRlcygpLHRoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5saW5lUHRzLmxlbmd0aC0xLDApfSxyZW1vdmU6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1lO2k8bjtpKyspe3ZhciByPXQuZ2V0U2VnbWVudChpKTt0aGlzLmlucHV0SW5kZXgucmVtb3ZlKHIpfX0saGFzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQucDAsdC5wMSxlLnAwLGUucDEpLHRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpfSxoYXNCYWRJbnB1dEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXRoaXMuaW5wdXRJbmRleC5xdWVyeShuKSxyPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24ocyxuKSl7aWYoeHMuaXNJbkxpbmVTZWN0aW9uKHQsZSxzKSljb250aW51ZTtyZXR1cm4hMH19cmV0dXJuITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhzfX0pLHhzLmlzSW5MaW5lU2VjdGlvbj1mdW5jdGlvbih0LGUsbil7aWYobi5nZXRQYXJlbnQoKSE9PXQuZ2V0UGFyZW50KCkpcmV0dXJuITE7dmFyIGk9bi5nZXRJbmRleCgpO3JldHVybiBpPj1lWzBdJiZpPGVbMV19LGUoRXMucHJvdG90eXBlLHtzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuaW5wdXRJbmRleC5hZGQoZS5uZXh0KCkpO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1uZXcgeHModGhpcy5pbnB1dEluZGV4LHRoaXMub3V0cHV0SW5kZXgpO24uc2V0RGlzdGFuY2VUb2xlcmFuY2UodGhpcy5kaXN0YW5jZVRvbGVyYW5jZSksbi5zaW1wbGlmeShlLm5leHQoKSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFc319KSxlKElzLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlucHV0R2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuaW5wdXRHZW9tLmNvcHkoKTt0aGlzLmxpbmVzdHJpbmdNYXA9bmV3IHRlLHRoaXMuaW5wdXRHZW9tLmFwcGx5KG5ldyBDcyh0aGlzKSksdGhpcy5saW5lU2ltcGxpZmllci5zaW1wbGlmeSh0aGlzLmxpbmVzdHJpbmdNYXAudmFsdWVzKCkpO3ZhciB0PW5ldyBOcyh0aGlzLmxpbmVzdHJpbmdNYXApLnRyYW5zZm9ybSh0aGlzLmlucHV0R2VvbSk7cmV0dXJuIHR9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe2lmKHQ8MCl0aHJvdyBuZXcgaShcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLmxpbmVTaW1wbGlmaWVyLnNldERpc3RhbmNlVG9sZXJhbmNlKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJc319KSxJcy5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBJcyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9LGgoTnMseGUpLGUoTnMucHJvdG90eXBlLHt0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe2lmKDA9PT10LnNpemUoKSlyZXR1cm4gbnVsbDtpZihlIGluc3RhbmNlb2YgU3Qpe3ZhciBuPXRoaXMubGluZXN0cmluZ01hcC5nZXQoZSk7cmV0dXJuIHRoaXMuY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlKG4uZ2V0UmVzdWx0Q29vcmRpbmF0ZXMoKSl9cmV0dXJuIHhlLnByb3RvdHlwZS50cmFuc2Zvcm1Db29yZGluYXRlcy5jYWxsKHRoaXMsdCxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTnN9fSksZShDcy5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgU3Qpe3ZhciBlPXQ7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIG49ZS5pc0Nsb3NlZCgpPzQ6MixpPW5ldyB2cyhlLG4pO3RoaXMudHBzLmxpbmVzdHJpbmdNYXAucHV0KGUsaSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3N9fSksSXMuTGluZVN0cmluZ1RyYW5zZm9ybWVyPU5zLElzLkxpbmVTdHJpbmdNYXBCdWlsZGVyRmlsdGVyPUNzO3ZhciBEbz1PYmplY3QuZnJlZXplKHtEb3VnbGFzUGV1Y2tlclNpbXBsaWZpZXI6Z3MsVG9wb2xvZ3lQcmVzZXJ2aW5nU2ltcGxpZmllcjpJc30pO2UoU3MucHJvdG90eXBlLHtzcGxpdEF0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMubWluaW11bUxlbi90aGlzLnNlZ0xlbjtpZih0LmRpc3RhbmNlKHRoaXMuc2VnLnAwKTx0aGlzLm1pbmltdW1MZW4pcmV0dXJuIHRoaXMuc3BsaXRQdD10aGlzLnNlZy5wb2ludEFsb25nKGUpLG51bGw7aWYodC5kaXN0YW5jZSh0aGlzLnNlZy5wMSk8dGhpcy5taW5pbXVtTGVuKXJldHVybiB0aGlzLnNwbGl0UHQ9U3MucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5zZWcsZSksbnVsbDt0aGlzLnNwbGl0UHQ9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj10aGlzLmdldENvbnN0cmFpbmVkTGVuZ3RoKG4pLHM9ci90aGlzLnNlZ0xlbjtpLmVxdWFsczJEKHRoaXMuc2VnLnAwKT90aGlzLnNwbGl0UHQ9dGhpcy5zZWcucG9pbnRBbG9uZyhzKTp0aGlzLnNwbGl0UHQ9U3MucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5zZWcscyl9fSxzZXRNaW5pbXVtTGVuZ3RoOmZ1bmN0aW9uKHQpe3RoaXMubWluaW11bUxlbj10fSxnZXRDb25zdHJhaW5lZExlbmd0aDpmdW5jdGlvbih0KXtyZXR1cm4gdDx0aGlzLm1pbmltdW1MZW4/dGhpcy5taW5pbXVtTGVuOnR9LGdldFNwbGl0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpdFB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTc319KSxTcy5wb2ludEFsb25nUmV2ZXJzZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBnO3JldHVybiBuLng9dC5wMS54LWUqKHQucDEueC10LnAwLngpLG4ueT10LnAxLnktZSoodC5wMS55LXQucDAueSksbn0sZSh3cy5wcm90b3R5cGUse2ZpbmRTcGxpdFBvaW50OmZ1bmN0aW9uKHQsZSl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3c319KSxlKExzLnByb3RvdHlwZSx7ZmluZFNwbGl0UG9pbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldExpbmVTZWdtZW50KCksaT1uLmdldExlbmd0aCgpLHI9aS8yLHM9bmV3IFNzKG4pLG89THMucHJvamVjdGVkU3BsaXRQb2ludCh0LGUpLGE9MipvLmRpc3RhbmNlKGUpKi44LHU9YTtyZXR1cm4gdT5yJiYodT1yKSxzLnNldE1pbmltdW1MZW5ndGgodSkscy5zcGxpdEF0KG8pLHMuZ2V0U3BsaXRQb2ludCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt3c119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExzfX0pLExzLnByb2plY3RlZFNwbGl0UG9pbnQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldExpbmVTZWdtZW50KCksaT1uLnByb2plY3QoZSk7cmV0dXJuIGl9LGUoUnMucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSc319KSxScy50cmlBcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShlLnktdC55KSoobi54LXQueCl9LFJzLmlzSW5DaXJjbGVERE5vcm1hbGl6ZWQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KGkueCkscz1fLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3QoaS55KSxvPV8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdChpLngpLGE9Xy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KGkueSksdT1fLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QoaS54KSxsPV8udmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdChpLnkpLGg9ci5tdWx0aXBseShhKS5zZWxmU3VidHJhY3Qoby5tdWx0aXBseShzKSksYz1vLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdCh1Lm11bHRpcGx5KGEpKSxmPXUubXVsdGlwbHkocykuc2VsZlN1YnRyYWN0KHIubXVsdGlwbHkobCkpLGc9ci5tdWx0aXBseShyKS5zZWxmQWRkKHMubXVsdGlwbHkocykpLGQ9by5tdWx0aXBseShvKS5zZWxmQWRkKGEubXVsdGlwbHkoYSkpLHA9dS5tdWx0aXBseSh1KS5zZWxmQWRkKGwubXVsdGlwbHkobCkpLHY9Zy5zZWxmTXVsdGlwbHkoYykuc2VsZkFkZChkLnNlbGZNdWx0aXBseShmKSkuc2VsZkFkZChwLnNlbGZNdWx0aXBseShoKSksbT12LmRvdWJsZVZhbHVlKCk+MDtyZXR1cm4gbX0sUnMuY2hlY2tSb2J1c3RJbkNpcmNsZT1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1Scy5pc0luQ2lyY2xlTm9uUm9idXN0KHQsZSxuLGkpLHM9UnMuaXNJbkNpcmNsZUREU2xvdyh0LGUsbixpKSxvPVJzLmlzSW5DaXJjbGVDQyh0LGUsbixpKSxhPVNpLmNpcmN1bWNlbnRyZSh0LGUsbik7QS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSktdC5kaXN0YW5jZShhKSkvdC5kaXN0YW5jZShhKSkscj09PXMmJnI9PT1vfHwoQS5vdXQucHJpbnRsbihcImluQ2lyY2xlIHJvYnVzdG5lc3MgZmFpbHVyZSAoZG91YmxlIHJlc3VsdCA9IFwiK3IrXCIsIEREIHJlc3VsdCA9IFwiK3MrXCIsIENDIHJlc3VsdCA9IFwiK28rXCIpXCIpLEEub3V0LnByaW50bG4oc2UudG9MaW5lU3RyaW5nKG5ldyBHdChbdCxlLG4saV0pKSksQS5vdXQucHJpbnRsbihcIkNpcmN1bWNlbnRyZSA9IFwiK3NlLnRvUG9pbnQoYSkrXCIgcmFkaXVzID0gXCIrdC5kaXN0YW5jZShhKSksQS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYSA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSkvdC5kaXN0YW5jZShhKS0xKSksQS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYiA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSkvZS5kaXN0YW5jZShhKS0xKSksQS5vdXQucHJpbnRsbihcInAgcmFkaXVzIGRpZmYgYyA9IFwiK01hdGguYWJzKGkuZGlzdGFuY2UoYSkvbi5kaXN0YW5jZShhKS0xKSksQS5vdXQucHJpbnRsbigpKX0sUnMuaXNJbkNpcmNsZURERmFzdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnNxcih0LngpLnNlbGZBZGQoXy5zcXIodC55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QoZSxuLGkpKSxzPV8uc3FyKGUueCkuc2VsZkFkZChfLnNxcihlLnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdCh0LG4saSkpLG89Xy5zcXIobi54KS5zZWxmQWRkKF8uc3FyKG4ueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KHQsZSxpKSksYT1fLnNxcihpLngpLnNlbGZBZGQoXy5zcXIoaS55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QodCxlLG4pKSx1PXIuc2VsZlN1YnRyYWN0KHMpLnNlbGZBZGQobykuc2VsZlN1YnRyYWN0KGEpLGw9dS5kb3VibGVWYWx1ZSgpPjA7cmV0dXJuIGx9LFJzLmlzSW5DaXJjbGVDQz1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1TaS5jaXJjdW1jZW50cmUodCxlLG4pLHM9dC5kaXN0YW5jZShyKSxvPWkuZGlzdGFuY2UociktcztyZXR1cm4gbzw9MH0sUnMuaXNJbkNpcmNsZU5vcm1hbGl6ZWQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dC54LWkueCxzPXQueS1pLnksbz1lLngtaS54LGE9ZS55LWkueSx1PW4ueC1pLngsbD1uLnktaS55LGg9ciphLW8qcyxjPW8qbC11KmEsZj11KnMtcipsLGc9cipyK3MqcyxkPW8qbythKmEscD11KnUrbCpsLHY9ZypjK2QqZitwKmg7XG5yZXR1cm4gdj4wfSxScy5pc0luQ2lyY2xlRERTbG93PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZihpLngpLHM9Xy52YWx1ZU9mKGkueSksbz1fLnZhbHVlT2YodC54KSxhPV8udmFsdWVPZih0LnkpLHU9Xy52YWx1ZU9mKGUueCksbD1fLnZhbHVlT2YoZS55KSxoPV8udmFsdWVPZihuLngpLGM9Xy52YWx1ZU9mKG4ueSksZj1vLm11bHRpcGx5KG8pLmFkZChhLm11bHRpcGx5KGEpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KHUsbCxoLGMscixzKSksZz11Lm11bHRpcGx5KHUpLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSxoLGMscixzKSksZD1oLm11bHRpcGx5KGgpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSx1LGwscixzKSkscD1yLm11bHRpcGx5KHIpLmFkZChzLm11bHRpcGx5KHMpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSx1LGwsaCxjKSksdj1mLnN1YnRyYWN0KGcpLmFkZChkKS5zdWJ0cmFjdChwKSxtPXYuZG91YmxlVmFsdWUoKT4wO3JldHVybiBtfSxScy5pc0luQ2lyY2xlTm9uUm9idXN0PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPSh0LngqdC54K3QueSp0LnkpKlJzLnRyaUFyZWEoZSxuLGkpLShlLngqZS54K2UueSplLnkpKlJzLnRyaUFyZWEodCxuLGkpKyhuLngqbi54K24ueSpuLnkpKlJzLnRyaUFyZWEodCxlLGkpLShpLngqaS54K2kueSppLnkpKlJzLnRyaUFyZWEodCxlLG4pPjA7cmV0dXJuIHJ9LFJzLmlzSW5DaXJjbGVSb2J1c3Q9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIFJzLmlzSW5DaXJjbGVOb3JtYWxpemVkKHQsZSxuLGkpfSxScy50cmlBcmVhRERTbG93PWZ1bmN0aW9uKHQsZSxuLGkscixzKXtyZXR1cm4gbi5zdWJ0cmFjdCh0KS5tdWx0aXBseShzLnN1YnRyYWN0KGUpKS5zdWJ0cmFjdChpLnN1YnRyYWN0KGUpLm11bHRpcGx5KHIuc3VidHJhY3QodCkpKX0sUnMudHJpQXJlYURERmFzdD1mdW5jdGlvbih0LGUsbil7dmFyIGk9Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxyPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QodC54KSk7cmV0dXJuIGkuc2VsZlN1YnRyYWN0KHIpfSxlKFRzLnByb3RvdHlwZSx7Y2lyY2xlQ2VudGVyOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFRzKHRoaXMuZ2V0WCgpLHRoaXMuZ2V0WSgpKSxpPXRoaXMuYmlzZWN0b3Iobix0KSxyPXRoaXMuYmlzZWN0b3IodCxlKSxzPW5ldyBGKGksciksbz1udWxsO3RyeXtvPW5ldyBUcyhzLmdldFgoKSxzLmdldFkoKSl9Y2F0Y2goaSl7aWYoIShpIGluc3RhbmNlb2YgdykpdGhyb3cgaTtBLmVyci5wcmludGxuKFwiYTogXCIrbitcIiAgYjogXCIrdCtcIiAgYzogXCIrZSksQS5lcnIucHJpbnRsbihpKX1maW5hbGx5e31yZXR1cm4gb30sZG90OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAueCp0LmdldFgoKSt0aGlzLnAueSp0LmdldFkoKX0sbWFnbjpmdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5wLngqdGhpcy5wLngrdGhpcy5wLnkqdGhpcy5wLnkpfSxnZXRaOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC56fSxiaXNlY3RvcjpmdW5jdGlvbih0LGUpe3ZhciBuPWUuZ2V0WCgpLXQuZ2V0WCgpLGk9ZS5nZXRZKCktdC5nZXRZKCkscj1uZXcgRih0LmdldFgoKStuLzIsdC5nZXRZKCkraS8yLDEpLHM9bmV3IEYodC5nZXRYKCktaStuLzIsdC5nZXRZKCkrbitpLzIsMSk7cmV0dXJuIG5ldyBGKHIscyl9LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucC54PT09dC5nZXRYKCkmJnRoaXMucC55PT09dC5nZXRZKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5wLmRpc3RhbmNlKGUuZ2V0Q29vcmRpbmF0ZSgpKTxufX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB9LGlzSW5DaXJjbGU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBScy5pc0luQ2lyY2xlUm9idXN0KHQucCxlLnAsbi5wLHRoaXMucCl9LGludGVycG9sYXRlWlZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldFgoKSxyPXQuZ2V0WSgpLHM9ZS5nZXRYKCktaSxvPW4uZ2V0WCgpLWksYT1lLmdldFkoKS1yLHU9bi5nZXRZKCktcixsPXMqdS1vKmEsaD10aGlzLmdldFgoKS1pLGM9dGhpcy5nZXRZKCktcixmPSh1KmgtbypjKS9sLGc9KC1hKmgrcypjKS9sLGQ9dC5nZXRaKCkrZiooZS5nZXRaKCktdC5nZXRaKCkpK2cqKG4uZ2V0WigpLXQuZ2V0WigpKTtyZXR1cm4gZH0sbWlkUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9KHRoaXMucC54K3QuZ2V0WCgpKS8yLG49KHRoaXMucC55K3QuZ2V0WSgpKS8yLGk9KHRoaXMucC56K3QuZ2V0WigpKS8yO3JldHVybiBuZXcgVHMoZSxuLGkpfSxyaWdodE9mOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzQ0NXKHQuZGVzdCgpLHQub3JpZygpKX0saXNDQ1c6ZnVuY3Rpb24odCxlKXtyZXR1cm4odC5wLngtdGhpcy5wLngpKihlLnAueS10aGlzLnAueSktKHQucC55LXRoaXMucC55KSooZS5wLngtdGhpcy5wLngpPjB9LGdldFg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnh9LGNyb3NzUHJvZHVjdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wLngqdC5nZXRZKCktdGhpcy5wLnkqdC5nZXRYKCl9LHNldFo6ZnVuY3Rpb24odCl7dGhpcy5wLno9dH0sdGltZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0KnRoaXMucC54LHQqdGhpcy5wLnkpfSxjcm9zczpmdW5jdGlvbigpe3JldHVybiBuZXcgVHModGhpcy5wLnksKC10aGlzLnAueCkpfSxsZWZ0T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNDQ1codC5vcmlnKCksdC5kZXN0KCkpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiUE9JTlQgKFwiK3RoaXMucC54K1wiIFwiK3RoaXMucC55K1wiKVwifSxzdWI6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueC10LmdldFgoKSx0aGlzLnAueS10LmdldFkoKSl9LGdldFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnl9LGNsYXNzaWZ5OmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxpPWUuc3ViKHQpLHI9bi5zdWIodCkscz1pLmNyb3NzUHJvZHVjdChyKTtyZXR1cm4gcz4wP1RzLkxFRlQ6czwwP1RzLlJJR0hUOmkuZ2V0WCgpKnIuZ2V0WCgpPDB8fGkuZ2V0WSgpKnIuZ2V0WSgpPDA/VHMuQkVISU5EOmkubWFnbigpPHIubWFnbigpP1RzLkJFWU9ORDp0LmVxdWFscyhuKT9Ucy5PUklHSU46ZS5lcXVhbHMobik/VHMuREVTVElOQVRJT046VHMuQkVUV0VFTn0sc3VtOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVHModGhpcy5wLngrdC5nZXRYKCksdGhpcy5wLnkrdC5nZXRZKCkpfSxkaXN0YW5jZTpmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZS5nZXRYKCktdC5nZXRYKCksMikrTWF0aC5wb3coZS5nZXRZKCktdC5nZXRZKCksMikpfSxjaXJjdW1SYWRpdXNSYXRpbzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSksaT10aGlzLmRpc3RhbmNlKG4sdCkscj10aGlzLmRpc3RhbmNlKHRoaXMsdCkscz10aGlzLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHM8ciYmKHI9cykscz10aGlzLmRpc3RhbmNlKGUsdGhpcyksczxyJiYocj1zKSxpL3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRzfX0pLFRzLmludGVycG9sYXRlWj1mdW5jdGlvbigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1lLmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShlKSxzPW4uei1lLnosbz1lLnorcyooci9pKTtyZXR1cm4gb31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdLGg9YXJndW1lbnRzWzNdLGM9dS54LGY9dS55LGc9bC54LWMsZD1oLngtYyxwPWwueS1mLHY9aC55LWYsbT1nKnYtZCpwLHk9YS54LWMseD1hLnktZixFPSh2KnktZCp4KS9tLEk9KC1wKnkrZyp4KS9tLE49dS56K0UqKGwuei11LnopK0kqKGguei11LnopO3JldHVybiBOfX0sVHMuTEVGVD0wLFRzLlJJR0hUPTEsVHMuQkVZT05EPTIsVHMuQkVISU5EPTMsVHMuQkVUV0VFTj00LFRzLk9SSUdJTj01LFRzLkRFU1RJTkFUSU9OPTYsaChQcyxUcyksZShQcy5wcm90b3R5cGUse2dldENvbnN0cmFpbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJhaW50fSxzZXRPbkNvbnN0cmFpbnQ6ZnVuY3Rpb24odCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9dH0sbWVyZ2U6ZnVuY3Rpb24odCl7dC5faXNPbkNvbnN0cmFpbnQmJih0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLmNvbnN0cmFpbnQ9dC5jb25zdHJhaW50KX0saXNPbkNvbnN0cmFpbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNPbkNvbnN0cmFpbnR9LHNldENvbnN0cmFpbnQ6ZnVuY3Rpb24odCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5jb25zdHJhaW50PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBzfX0pLGUoYnMucHJvdG90eXBlLHtlcXVhbHNOb25PcmllbnRlZDpmdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuZXF1YWxzT3JpZW50ZWQodCl8fCEhdGhpcy5lcXVhbHNPcmllbnRlZCh0LnN5bSgpKX0sdG9MaW5lU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiBuZXcgY2UodGhpcy52ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9LGRlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW0oKS5vcmlnKCl9LG9OZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0sZXF1YWxzT3JpZW50ZWQ6ZnVuY3Rpb24odCl7cmV0dXJuISghdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSl8fCF0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSl9LGROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKS5zeW0oKX0sbFByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0LnN5bSgpfSxyUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCl9LHJvdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3R9LG9QcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5uZXh0Ll9yb3R9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3QuX3JvdH0sc2V0T3JpZzpmdW5jdGlvbih0KXt0aGlzLnZlcnRleD10fSxsTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkucm90KCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UodGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX0saW52Um90OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5zeW0oKX0sc2V0RGVzdDpmdW5jdGlvbih0KXt0aGlzLnN5bSgpLnNldE9yaWcodCl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxkZWxldGU6ZnVuY3Rpb24oKXt0aGlzLl9yb3Q9bnVsbH0sb3JpZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleH0sck5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90Lm5leHQuaW52Um90KCl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy52ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLGU9dGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiBzZS50b0xpbmVTdHJpbmcodCxlKX0saXNMaXZlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb3R9LGdldFByaW1hcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpPD0wP3RoaXM6dGhpcy5zeW0oKX0sZFByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLmludlJvdCgpfSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMubmV4dD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBic319KSxicy5tYWtlRWRnZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBicyxpPW5ldyBicyxyPW5ldyBicyxzPW5ldyBicztuLl9yb3Q9aSxpLl9yb3Q9cixyLl9yb3Q9cyxzLl9yb3Q9bixuLnNldE5leHQobiksaS5zZXROZXh0KHMpLHIuc2V0TmV4dChyKSxzLnNldE5leHQoaSk7dmFyIG89bjtyZXR1cm4gby5zZXRPcmlnKHQpLG8uc2V0RGVzdChlKSxvfSxicy5zd2FwPWZ1bmN0aW9uKHQpe3ZhciBlPXQub1ByZXYoKSxuPXQuc3ltKCkub1ByZXYoKTticy5zcGxpY2UodCxlKSxicy5zcGxpY2UodC5zeW0oKSxuKSxicy5zcGxpY2UodCxlLmxOZXh0KCkpLGJzLnNwbGljZSh0LnN5bSgpLG4ubE5leHQoKSksdC5zZXRPcmlnKGUuZGVzdCgpKSx0LnNldERlc3Qobi5kZXN0KCkpfSxicy5zcGxpY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm9OZXh0KCkucm90KCksaT1lLm9OZXh0KCkucm90KCkscj1lLm9OZXh0KCkscz10Lm9OZXh0KCksbz1pLm9OZXh0KCksYT1uLm9OZXh0KCk7dC5zZXROZXh0KHIpLGUuc2V0TmV4dChzKSxuLnNldE5leHQobyksaS5zZXROZXh0KGEpfSxicy5jb25uZWN0PWZ1bmN0aW9uKHQsZSl7dmFyIG49YnMubWFrZUVkZ2UodC5kZXN0KCksZS5vcmlnKCkpO3JldHVybiBicy5zcGxpY2Uobix0LmxOZXh0KCkpLGJzLnNwbGljZShuLnN5bSgpLGUpLG59LGUoT3MucHJvdG90eXBlLHtpbnNlcnRTaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc3ViZGl2LmxvY2F0ZSh0KTtpZih0aGlzLnN1YmRpdi5pc1ZlcnRleE9mRWRnZShlLHQpKXJldHVybiBlO3RoaXMuc3ViZGl2LmlzT25FZGdlKGUsdC5nZXRDb29yZGluYXRlKCkpJiYoZT1lLm9QcmV2KCksdGhpcy5zdWJkaXYuZGVsZXRlKGUub05leHQoKSkpO3ZhciBuPXRoaXMuc3ViZGl2Lm1ha2VFZGdlKGUub3JpZygpLHQpO2JzLnNwbGljZShuLGUpO3ZhciBpPW47ZG8gbj10aGlzLnN1YmRpdi5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCk7d2hpbGUoZS5sTmV4dCgpIT09aSk7Zm9yKDs7KXt2YXIgcj1lLm9QcmV2KCk7aWYoci5kZXN0KCkucmlnaHRPZihlKSYmdC5pc0luQ2lyY2xlKGUub3JpZygpLHIuZGVzdCgpLGUuZGVzdCgpKSlicy5zd2FwKGUpLGU9ZS5vUHJldigpO2Vsc2V7aWYoZS5vTmV4dCgpPT09aSlyZXR1cm4gbjtlPWUub05leHQoKS5sUHJldigpfX19LGluc2VydFNpdGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPc319KSxlKF9zLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3N9fSksZShNcy5wcm90b3R5cGUse2luaXQ6ZnVuY3Rpb24oKXt0aGlzLmxhc3RFZGdlPXRoaXMuZmluZEVkZ2UoKX0sbG9jYXRlOmZ1bmN0aW9uKHQpe3RoaXMubGFzdEVkZ2UuaXNMaXZlKCl8fHRoaXMuaW5pdCgpO3ZhciBlPXRoaXMuc3ViZGl2LmxvY2F0ZUZyb21FZGdlKHQsdGhpcy5sYXN0RWRnZSk7cmV0dXJuIHRoaXMubGFzdEVkZ2U9ZSxlfSxmaW5kRWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3ViZGl2LmdldEVkZ2VzKCk7cmV0dXJuIHQuaXRlcmF0b3IoKS5uZXh0KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19zXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTXN9fSksaChEcyxsKSxlKERzLnByb3RvdHlwZSx7Z2V0U2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHN9fSksRHMubXNnV2l0aFNwYXRpYWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9LGUoQXMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFzfX0pLGUoRnMucHJvdG90eXBlLHtnZXRUcmlhbmdsZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBCcztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcygpfSxpc0ZyYW1lVmVydGV4OmZ1bmN0aW9uKHQpe3JldHVybiEhdC5lcXVhbHModGhpcy5mcmFtZVZlcnRleFswXSl8fCghIXQuZXF1YWxzKHRoaXMuZnJhbWVWZXJ0ZXhbMV0pfHwhIXQuZXF1YWxzKHRoaXMuZnJhbWVWZXJ0ZXhbMl0pKX0saXNWZXJ0ZXhPZkVkZ2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4hKCFlLmVxdWFscyh0Lm9yaWcoKSx0aGlzLnRvbGVyYW5jZSkmJiFlLmVxdWFscyh0LmRlc3QoKSx0aGlzLnRvbGVyYW5jZSkpfSxjb25uZWN0OmZ1bmN0aW9uKHQsZSl7dmFyIG49YnMuY29ubmVjdCh0LGUpO3JldHVybiB0aGlzLnF1YWRFZGdlcy5hZGQobiksbn0sZ2V0Vm9yb25vaUNlbGxQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEksaT10O2Rve3ZhciByPXQucm90KCkub3JpZygpLmdldENvb3JkaW5hdGUoKTtuLmFkZChyKSx0PXQub1ByZXYoKX13aGlsZSh0IT09aSk7dmFyIHM9bmV3IE47cy5hZGRBbGwobiwhMSkscy5jbG9zZVJpbmcoKSxzLnNpemUoKTw0JiYoQS5vdXQucHJpbnRsbihzKSxzLmFkZChzLmdldChzLnNpemUoKS0xKSwhMCkpO3ZhciBvPXMudG9Db29yZGluYXRlQXJyYXkoKSxhPWUuY3JlYXRlUG9seWdvbihlLmNyZWF0ZUxpbmVhclJpbmcobyksbnVsbCksdT1pLm9yaWcoKTtyZXR1cm4gYS5zZXRVc2VyRGF0YSh1LmdldENvb3JkaW5hdGUoKSksYX0sc2V0TG9jYXRvcjpmdW5jdGlvbih0KXt0aGlzLmxvY2F0b3I9dH0saW5pdFN1YmRpdjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFswXSx0aGlzLmZyYW1lVmVydGV4WzFdKSxlPXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFsxXSx0aGlzLmZyYW1lVmVydGV4WzJdKTticy5zcGxpY2UodC5zeW0oKSxlKTt2YXIgbj10aGlzLm1ha2VFZGdlKHRoaXMuZnJhbWVWZXJ0ZXhbMl0sdGhpcy5mcmFtZVZlcnRleFswXSk7cmV0dXJuIGJzLnNwbGljZShlLnN5bSgpLG4pLGJzLnNwbGljZShuLnN5bSgpLHQpLHR9LGlzRnJhbWVCb3JkZXJFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO0ZzLmdldFRyaWFuZ2xlRWRnZXModCxlKTt2YXIgbj1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtGcy5nZXRUcmlhbmdsZUVkZ2VzKHQuc3ltKCksbik7dmFyIGk9dC5sTmV4dCgpLmRlc3QoKTtpZih0aGlzLmlzRnJhbWVWZXJ0ZXgoaSkpcmV0dXJuITA7dmFyIHI9dC5zeW0oKS5sTmV4dCgpLmRlc3QoKTtyZXR1cm4hIXRoaXMuaXNGcmFtZVZlcnRleChyKX0sbWFrZUVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1icy5tYWtlRWRnZSh0LGUpO3JldHVybiB0aGlzLnF1YWRFZGdlcy5hZGQobiksbn0sdmlzaXRUcmlhbmdsZXM6ZnVuY3Rpb24odCxlKXt0aGlzLnZpc2l0ZWRLZXkrKzt2YXIgbj1uZXcgcGU7bi5wdXNoKHRoaXMuc3RhcnRpbmdFZGdlKTtmb3IodmFyIGk9bmV3IEo7IW4uZW1wdHkoKTspe3ZhciByPW4ucG9wKCk7aWYoIWkuY29udGFpbnMocikpe3ZhciBzPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQocixuLGUsaSk7bnVsbCE9PXMmJnQudmlzaXQocyl9fX0saXNGcmFtZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuISghdGhpcy5pc0ZyYW1lVmVydGV4KHQub3JpZygpKSYmIXRoaXMuaXNGcmFtZVZlcnRleCh0LmRlc3QoKSkpfSxpc09uRWRnZTpmdW5jdGlvbih0LGUpe3RoaXMuc2VnLnNldENvb3JkaW5hdGVzKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSx0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpO3ZhciBuPXRoaXMuc2VnLmRpc3RhbmNlKGUpO3JldHVybiBuPHRoaXMuZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiBuZXcgQyh0aGlzLmZyYW1lRW52KX0sY3JlYXRlRnJhbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxpPTA7aT1lPm4/MTAqZToxMCpuLHRoaXMuZnJhbWVWZXJ0ZXhbMF09bmV3IFRzKCh0LmdldE1heFgoKSt0LmdldE1pblgoKSkvMix0LmdldE1heFkoKStpKSx0aGlzLmZyYW1lVmVydGV4WzFdPW5ldyBUcyh0LmdldE1pblgoKS1pLHQuZ2V0TWluWSgpLWkpLHRoaXMuZnJhbWVWZXJ0ZXhbMl09bmV3IFRzKHQuZ2V0TWF4WCgpK2ksdC5nZXRNaW5ZKCktaSksdGhpcy5mcmFtZUVudj1uZXcgQyh0aGlzLmZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLmZyYW1lVmVydGV4WzFdLmdldENvb3JkaW5hdGUoKSksdGhpcy5mcmFtZUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfSxnZXRUcmlhbmdsZUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB6cztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVzKCl9LGdldFZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSixuPXRoaXMucXVhZEVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKHIpO3ZhciBzPWkuZGVzdCgpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocyl8fGUuYWRkKHMpfXJldHVybiBlfSxmZXRjaFRyaWFuZ2xlVG9WaXNpdDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LHM9MCxvPSExO2Rve3RoaXMudHJpRWRnZXNbc109cix0aGlzLmlzRnJhbWVFZGdlKHIpJiYobz0hMCk7dmFyIGE9ci5zeW0oKTtpLmNvbnRhaW5zKGEpfHxlLnB1c2goYSksaS5hZGQocikscysrLHI9ci5sTmV4dCgpfXdoaWxlKHIhPT10KTtyZXR1cm4gbyYmIW4/bnVsbDp0aGlzLnRyaUVkZ2VzfSxnZXRFZGdlczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnF1YWRFZGdlcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKSxpPTAscj1lLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtuW2krK109dC5jcmVhdGVMaW5lU3RyaW5nKFtzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpXSl9cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfX0sZ2V0VmVydGV4VW5pcXVlRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49bmV3IEosaT10aGlzLnF1YWRFZGdlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCkscz1yLm9yaWcoKTtuLmNvbnRhaW5zKHMpfHwobi5hZGQocyksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChzKXx8ZS5hZGQocikpO3ZhciBvPXIuc3ltKCksYT1vLm9yaWcoKTtuLmNvbnRhaW5zKGEpfHwobi5hZGQoYSksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChhKXx8ZS5hZGQobykpfXJldHVybiBlfSxnZXRUcmlhbmdsZUVkZ2VzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBxcztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVFZGdlcygpfSxnZXRQcmltYXJ5RWRnZXM6ZnVuY3Rpb24odCl7dGhpcy52aXNpdGVkS2V5Kys7dmFyIGU9bmV3IEksbj1uZXcgcGU7bi5wdXNoKHRoaXMuc3RhcnRpbmdFZGdlKTtmb3IodmFyIGk9bmV3IEo7IW4uZW1wdHkoKTspe3ZhciByPW4ucG9wKCk7aWYoIWkuY29udGFpbnMocikpe3ZhciBzPXIuZ2V0UHJpbWFyeSgpOyF0JiZ0aGlzLmlzRnJhbWVFZGdlKHMpfHxlLmFkZChzKSxuLnB1c2goci5vTmV4dCgpKSxuLnB1c2goci5zeW0oKS5vTmV4dCgpKSxpLmFkZChyKSxpLmFkZChyLnN5bSgpKX19cmV0dXJuIGV9LGRlbGV0ZTpmdW5jdGlvbih0KXticy5zcGxpY2UodCx0Lm9QcmV2KCkpLGJzLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7dmFyIGU9dC5zeW0oKSxuPXQucm90KCksaT10LnJvdCgpLnN5bSgpO3RoaXMucXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLnF1YWRFZGdlcy5yZW1vdmUoZSksdGhpcy5xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMucXVhZEVkZ2VzLnJlbW92ZShpKSx0LmRlbGV0ZSgpLGUuZGVsZXRlKCksbi5kZWxldGUoKSxpLmRlbGV0ZSgpfSxsb2NhdGVGcm9tRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLGk9dGhpcy5xdWFkRWRnZXMuc2l6ZSgpLHI9ZTs7KXtpZihuKyssbj5pKXRocm93IG5ldyBEcyhyLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoci5vcmlnKCkpfHx0LmVxdWFscyhyLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKHIpKXI9ci5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihyLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2Yoci5kUHJldigpKSlicmVhaztyPXIuZFByZXYoKX1lbHNlIHI9ci5vTmV4dCgpfXJldHVybiByfSxnZXRUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2xlcmFuY2V9LGdldFZvcm9ub2lDZWxsUG9seWdvbnM6ZnVuY3Rpb24odCl7dGhpcy52aXNpdFRyaWFuZ2xlcyhuZXcgR3MsITApO2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMuZ2V0VmVydGV4VW5pcXVlRWRnZXMoITEpLGk9bi5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocix0KSl9cmV0dXJuIGV9LGdldFZvcm9ub2lEaWFncmFtOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGUpKX0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmdldFRyaWFuZ2xlQ29vcmRpbmF0ZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpLGk9MCxyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO25baSsrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKHMpLG51bGwpfXJldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX0saW5zZXJ0U2l0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLnRvbGVyYW5jZSl8fHQuZXF1YWxzKGUuZGVzdCgpLHRoaXMudG9sZXJhbmNlKSlyZXR1cm4gZTt2YXIgbj10aGlzLm1ha2VFZGdlKGUub3JpZygpLHQpO2JzLnNwbGljZShuLGUpO3ZhciBpPW47ZG8gbj10aGlzLmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKTt3aGlsZShlLmxOZXh0KCkhPT1pKTtyZXR1cm4gaX0sbG9jYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5sb2NhdG9yLmxvY2F0ZShuZXcgVHMoZSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj10aGlzLmxvY2F0b3IubG9jYXRlKG5ldyBUcyhuKSk7aWYobnVsbD09PXIpcmV0dXJuIG51bGw7dmFyIHM9cjtyLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQobikmJihzPXIuc3ltKCkpO3ZhciBvPXM7ZG97aWYoby5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGkpKXJldHVybiBvO289by5vTmV4dCgpfXdoaWxlKG8hPT1zKTtyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZzfX0pLEZzLmdldFRyaWFuZ2xlRWRnZXM9ZnVuY3Rpb24odCxlKXtpZihlWzBdPXQsZVsxXT1lWzBdLmxOZXh0KCksZVsyXT1lWzFdLmxOZXh0KCksZVsyXS5sTmV4dCgpIT09ZVswXSl0aHJvdyBuZXcgaShcIkVkZ2VzIGRvIG5vdCBmb3JtIGEgdHJpYW5nbGVcIil9LGUoR3MucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dFswXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLG49dFsxXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGk9dFsyXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHI9U2kuY2lyY3VtY2VudHJlKGUsbixpKSxzPW5ldyBUcyhyKSxvPTA7bzwzO28rKyl0W29dLnJvdCgpLnNldE9yaWcocyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3N9fSksZShxcy5wcm90b3R5cGUse2dldFRyaWFuZ2xlRWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlMaXN0fSx2aXNpdDpmdW5jdGlvbih0KXt0aGlzLnRyaUxpc3QuYWRkKHQuY2xvbmUoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXN9fSksZShCcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe3RoaXMudHJpTGlzdC5hZGQoW3RbMF0ub3JpZygpLHRbMV0ub3JpZygpLHRbMl0ub3JpZygpXSl9LGdldFRyaWFuZ2xlVmVydGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJzfX0pLGUoenMucHJvdG90eXBlLHtjaGVja1RyaWFuZ2xlU2l6ZTpmdW5jdGlvbih0KXt2YXIgZT1cIlwiO3QubGVuZ3RoPj0yP2U9c2UudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSk6dC5sZW5ndGg+PTEmJihlPXNlLnRvUG9pbnQodFswXSkpfSx2aXNpdDpmdW5jdGlvbih0KXt0aGlzLmNvb3JkTGlzdC5jbGVhcigpO2Zvcih2YXIgZT0wO2U8MztlKyspe3ZhciBuPXRbZV0ub3JpZygpO3RoaXMuY29vcmRMaXN0LmFkZChuLmdldENvb3JkaW5hdGUoKSl9aWYodGhpcy5jb29yZExpc3Quc2l6ZSgpPjApe3RoaXMuY29vcmRMaXN0LmNsb3NlUmluZygpO3ZhciBpPXRoaXMuY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7aWYoNCE9PWkubGVuZ3RoKXJldHVybiBudWxsO3RoaXMudHJpQ29vcmRzLmFkZChpKX19LGdldFRyaWFuZ2xlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUNvb3Jkc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6c319KSxGcy5UcmlhbmdsZUNpcmN1bWNlbnRyZVZpc2l0b3I9R3MsRnMuVHJpYW5nbGVFZGdlc0xpc3RWaXNpdG9yPXFzLEZzLlRyaWFuZ2xlVmVydGV4TGlzdFZpc2l0b3I9QnMsRnMuVHJpYW5nbGVDb29yZGluYXRlc1Zpc2l0b3I9enMsRnMuRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SPTFlMyxlKFZzLnByb3RvdHlwZSx7Z2V0TGluZVNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sc30sZ2V0RW5kWjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC56fSxnZXRTdGFydFo6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQuen0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxzLmludGVyc2VjdGlvbih0LmdldExpbmVTZWdtZW50KCkpfSxnZXRTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLmdldENvb3JkaW5hdGUoMCl9LGdldEVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLmdldENvb3JkaW5hdGUoMSl9LGdldEVuZFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQueX0sZ2V0U3RhcnRYOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDApO3JldHVybiB0Lnh9LGVxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubHMuZXF1YWxzVG9wbyh0LmdldExpbmVTZWdtZW50KCkpfSxnZXRTdGFydFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQueX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGdldEVuZFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQueH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5scy50b1N0cmluZygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWc319KSxlKGtzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrc319KSxlKFlzLnByb3RvdHlwZSx7aXNSZXBlYXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvdW50PjF9LGdldFJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHR9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wfSxzZXRMZWZ0OmZ1bmN0aW9uKHQpe3RoaXMubGVmdD10fSxnZXRYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC54fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZ2V0Q291bnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3VudH0sZ2V0TGVmdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnR9LGdldFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnl9LGluY3JlbWVudDpmdW5jdGlvbigpe3RoaXMuY291bnQ9dGhpcy5jb3VudCsxfSxzZXRSaWdodDpmdW5jdGlvbih0KXt0aGlzLnJpZ2h0PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlzfX0pLGUoVXMucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluc2VydCh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYobnVsbD09PXRoaXMucm9vdClyZXR1cm4gdGhpcy5yb290PW5ldyBZcyhlLG4pLHRoaXMucm9vdDtpZih0aGlzLnRvbGVyYW5jZT4wKXt2YXIgaT10aGlzLmZpbmRCZXN0TWF0Y2hOb2RlKGUpO2lmKG51bGwhPT1pKXJldHVybiBpLmluY3JlbWVudCgpLGl9cmV0dXJuIHRoaXMuaW5zZXJ0RXhhY3QoZSxuKX19LHF1ZXJ5OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLGU9dGhpcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9bmV3IEk7cmV0dXJuIHRoaXMucXVlcnkobixpKSxpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyYmUihhcmd1bWVudHNbMV0seSkpIWZ1bmN0aW9uKCl7dmFyIG49dFswXSxpPXRbMV07ZS5xdWVyeU5vZGUoZS5yb290LG4sITAse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2tzXX0sdmlzaXQ6ZnVuY3Rpb24odCl7aS5hZGQodCl9fSl9KCk7ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMmJlIoYXJndW1lbnRzWzFdLGtzKSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMucm9vdCxyLCEwLHMpfX0scXVlcnlOb2RlOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciByPW51bGwscz1udWxsLG89bnVsbDtuPyhyPWUuZ2V0TWluWCgpLHM9ZS5nZXRNYXhYKCksbz10LmdldFgoKSk6KHI9ZS5nZXRNaW5ZKCkscz1lLmdldE1heFkoKSxvPXQuZ2V0WSgpKTt2YXIgYT1yPG8sdT1vPD1zO2EmJnRoaXMucXVlcnlOb2RlKHQuZ2V0TGVmdCgpLGUsIW4saSksZS5jb250YWlucyh0LmdldENvb3JkaW5hdGUoKSkmJmkudmlzaXQodCksdSYmdGhpcy5xdWVyeU5vZGUodC5nZXRSaWdodCgpLGUsIW4saSl9LGZpbmRCZXN0TWF0Y2hOb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBYcyh0LHRoaXMudG9sZXJhbmNlKTtyZXR1cm4gdGhpcy5xdWVyeShlLnF1ZXJ5RW52ZWxvcGUoKSxlKSxlLmdldE5vZGUoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnNlcnRFeGFjdDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLnJvb3QsaT10aGlzLnJvb3Qscj0hMCxzPSEwO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe3ZhciBvPXQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLnRvbGVyYW5jZTtpZihvKXJldHVybiBuLmluY3JlbWVudCgpLG59cz1yP3QueDxuLmdldFgoKTp0Lnk8bi5nZXRZKCksaT1uLG49cz9uLmdldExlZnQoKTpuLmdldFJpZ2h0KCkscj0hcn10aGlzLm51bWJlck9mTm9kZXM9dGhpcy5udW1iZXJPZk5vZGVzKzE7dmFyIGE9bmV3IFlzKHQsZSk7cmV0dXJuIHM/aS5zZXRMZWZ0KGEpOmkuc2V0UmlnaHQoYSksYX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVXN9fSksVXMudG9Db29yZGluYXRlcz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIFVzLnRvQ29vcmRpbmF0ZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uZXcgTixyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspZm9yKHZhciBzPXIubmV4dCgpLG89bj9zLmdldENvdW50KCk6MSxhPTA7YTxvO2ErKylpLmFkZChzLmdldENvb3JkaW5hdGUoKSwhMCk7cmV0dXJuIGkudG9Db29yZGluYXRlQXJyYXkoKX19LGUoWHMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnAuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpLG49ZTw9dGhpcy50b2xlcmFuY2U7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGk9ITE7KG51bGw9PT10aGlzLm1hdGNoTm9kZXx8ZTx0aGlzLm1hdGNoRGlzdHx8bnVsbCE9PXRoaXMubWF0Y2hOb2RlJiZlPT09dGhpcy5tYXRjaERpc3QmJnQuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLm1hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYoaT0hMCksaSYmKHRoaXMubWF0Y2hOb2RlPXQsdGhpcy5tYXRjaERpc3Q9ZSl9LHF1ZXJ5RW52ZWxvcGU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQyh0aGlzLnApO3JldHVybiB0LmV4cGFuZEJ5KHRoaXMudG9sZXJhbmNlKSx0fSxnZXROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0Y2hOb2RlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltrc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhzfX0pLFVzLkJlc3RNYXRjaFZpc2l0b3I9WHMsZShIcy5wcm90b3R5cGUse2dldEluaXRpYWxWZXJ0aWNlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXRpYWxWZXJ0aWNlc30sZ2V0S0RUOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2R0fSxlbmZvcmNlQ29uc3RyYWludHM6ZnVuY3Rpb24oKXt0aGlzLmFkZENvbnN0cmFpbnRWZXJ0aWNlcygpO3ZhciB0PTAsZT0wO2RvIGU9dGhpcy5lbmZvcmNlR2FicmllbCh0aGlzLnNlZ21lbnRzKSx0Kys7d2hpbGUoZT4wJiZ0PEhzLk1BWF9TUExJVF9JVEVSKX0saW5zZXJ0U2l0ZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZShuKX19LGdldFZlcnRleEZhY3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXhGYWN0b3J5fSxnZXRQb2ludEFycmF5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmluaXRpYWxWZXJ0aWNlcy5zaXplKCkrdGhpcy5zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCksZT0wLG49dGhpcy5pbml0aWFsVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RbZSsrXT1pLmdldENvb3JkaW5hdGUoKX1mb3IodmFyIHI9dGhpcy5zZWdWZXJ0aWNlcy5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIGk9ci5uZXh0KCk7dFtlKytdPWkuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fSxzZXRDb25zdHJhaW50czpmdW5jdGlvbih0LGUpe3RoaXMuc2VnbWVudHM9dCx0aGlzLnNlZ1ZlcnRpY2VzPWV9LGNvbXB1dGVDb252ZXhIdWxsOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGllLGU9dGhpcy5nZXRQb2ludEFycmF5KCksbj1uZXcgbWUoZSx0KTt0aGlzLmNvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9LGFkZENvbnN0cmFpbnRWZXJ0aWNlczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZUNvbnZleEh1bGwoKSx0aGlzLmluc2VydFNpdGVzKHRoaXMuc2VnVmVydGljZXMpfSxmaW5kTm9uR2FicmllbFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0U3RhcnQoKSxuPXQuZ2V0RW5kKCksaT1uZXcgZygoZS54K24ueCkvMiwoZS55K24ueSkvMikscz1lLmRpc3RhbmNlKGkpLG89bmV3IEMoaSk7by5leHBhbmRCeShzKTtmb3IodmFyIGE9dGhpcy5rZHQucXVlcnkobyksdT1udWxsLGw9ci5NQVhfVkFMVUUsaD1hLml0ZXJhdG9yKCk7aC5oYXNOZXh0KCk7KXt2YXIgYz1oLm5leHQoKSxmPWMuZ2V0Q29vcmRpbmF0ZSgpO2lmKCFmLmVxdWFsczJEKGUpJiYhZi5lcXVhbHMyRChuKSl7dmFyIGQ9aS5kaXN0YW5jZShmKTtpZihkPHMpe3ZhciBwPWQ7KG51bGw9PT11fHxwPGwpJiYodT1mLGw9cCl9fX1yZXR1cm4gdX0sZ2V0Q29uc3RyYWludFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnbWVudHN9LHNldFNwbGl0UG9pbnRGaW5kZXI6ZnVuY3Rpb24odCl7dGhpcy5zcGxpdEZpbmRlcj10fSxnZXRDb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udmV4SHVsbH0sZ2V0VG9sZXJhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9sZXJhbmNlfSxlbmZvcmNlR2FicmllbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wLGk9bmV3IEkscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludChzKTtpZihudWxsIT09byl7dGhpcy5zcGxpdFB0PXRoaXMuc3BsaXRGaW5kZXIuZmluZFNwbGl0UG9pbnQocyxvKTt2YXIgYT10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLnNwbGl0UHQscyksdT0odGhpcy5pbnNlcnRTaXRlKGEpLG5ldyBWcyhzLmdldFN0YXJ0WCgpLHMuZ2V0U3RhcnRZKCkscy5nZXRTdGFydFooKSxhLmdldFgoKSxhLmdldFkoKSxhLmdldFooKSxzLmdldERhdGEoKSkpLGw9bmV3IFZzKGEuZ2V0WCgpLGEuZ2V0WSgpLGEuZ2V0WigpLHMuZ2V0RW5kWCgpLHMuZ2V0RW5kWSgpLHMuZ2V0RW5kWigpLHMuZ2V0RGF0YSgpKTtlLmFkZCh1KSxlLmFkZChsKSxpLmFkZChzKSxuKz0xfX1yZXR1cm4gdC5yZW1vdmVBbGwoaSksdC5hZGRBbGwoZSksbn0sY3JlYXRlVmVydGV4OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMudmVydGV4RmFjdG9yeT90aGlzLnZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IFBzKHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLnZlcnRleEZhY3Rvcnk/dGhpcy52ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleChuLGkpOm5ldyBQcyhuKSxlLnNldE9uQ29uc3RyYWludCghMCksZX19LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ViZGl2fSxjb21wdXRlQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXt2YXIgdD1Icy5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5pbml0aWFsVmVydGljZXMpLGU9SHMuY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuc2VnVmVydGljZXMpLG49bmV3IEModCk7bi5leHBhbmRUb0luY2x1ZGUoZSk7dmFyIGk9LjIqbi5nZXRXaWR0aCgpLHI9LjIqbi5nZXRIZWlnaHQoKSxzPU1hdGgubWF4KGkscik7dGhpcy5jb21wdXRlQXJlYUVudj1uZXcgQyhuKSx0aGlzLmNvbXB1dGVBcmVhRW52LmV4cGFuZEJ5KHMpfSxzZXRWZXJ0ZXhGYWN0b3J5OmZ1bmN0aW9uKHQpe3RoaXMudmVydGV4RmFjdG9yeT10fSxmb3JtSW5pdGlhbERlbGF1bmF5OmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLnN1YmRpdj1uZXcgRnModGhpcy5jb21wdXRlQXJlYUVudix0aGlzLnRvbGVyYW5jZSksdGhpcy5zdWJkaXYuc2V0TG9jYXRvcihuZXcgTXModGhpcy5zdWJkaXYpKSx0aGlzLmluY0RlbD1uZXcgT3ModGhpcy5zdWJkaXYpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5pbml0aWFsVmVydGljZXMpfSxpbnNlcnRTaXRlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQcyl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5rZHQuaW5zZXJ0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpO2lmKGUuaXNSZXBlYXRlZCgpKXt2YXIgbj1lLmdldERhdGEoKTtyZXR1cm4gbi5tZXJnZSh0KSxufXJldHVybiB0aGlzLmluY0RlbC5pbnNlcnRTaXRlKHQpLHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRTaXRlKHRoaXMuY3JlYXRlVmVydGV4KGkpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhzfX0pLEhzLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEMsbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZShpLmdldENvb3JkaW5hdGUoKSl9cmV0dXJuIGV9LEhzLk1BWF9TUExJVF9JVEVSPTk5LGUoV3MucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKSxlPVdzLnRvVmVydGljZXModGhpcy5zaXRlQ29vcmRzKTt0aGlzLnN1YmRpdj1uZXcgRnModCx0aGlzLnRvbGVyYW5jZSk7dmFyIG49bmV3IE9zKHRoaXMuc3ViZGl2KTtuLmluc2VydFNpdGVzKGUpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MudW5pcXVlKEgudG9Db29yZGluYXRlQXJyYXkoZSkpfX0sZ2V0RWRnZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0RWRnZXModCl9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRUcmlhbmdsZXModCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdzfX0pLFdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcz1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IE47dmFyIGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBXcy51bmlxdWUoZSl9LFdzLmVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKGkpfXJldHVybiBlfSxXcy51bmlxdWU9ZnVuY3Rpb24odCl7dmFyIGU9SC5jb3B5RGVlcCh0KTt1dC5zb3J0KGUpO3ZhciBuPW5ldyBOKGUsKCExKSk7cmV0dXJuIG59LFdzLnRvVmVydGljZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5hZGQobmV3IFRzKGkpKX1yZXR1cm4gZX0sZShqcy5wcm90b3R5cGUse2NyZWF0ZVNpdGVWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXAuY29udGFpbnNLZXkoaSl8fGUuYWRkKG5ldyBQcyhpKSl9cmV0dXJuIGV9LGNyZWF0ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnN1YmRpdilyZXR1cm4gbnVsbDt2YXIgdD1Xcy5lbnZlbG9wZSh0aGlzLnNpdGVDb29yZHMpLGU9bmV3IEk7bnVsbCE9PXRoaXMuY29uc3RyYWludExpbmVzJiYodC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb25zdHJhaW50TGluZXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSx0aGlzLmNyZWF0ZVZlcnRpY2VzKHRoaXMuY29uc3RyYWludExpbmVzKSxlPWpzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLmNvbnN0cmFpbnRMaW5lcykpO3ZhciBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuc2l0ZUNvb3JkcyksaT1uZXcgSHMobix0aGlzLnRvbGVyYW5jZSk7aS5zZXRDb25zdHJhaW50cyhlLG5ldyBJKHRoaXMuY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLGkuZm9ybUluaXRpYWxEZWxhdW5heSgpLGkuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5zdWJkaXY9aS5nZXRTdWJkaXZpc2lvbigpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0Q29uc3RyYWludHM6ZnVuY3Rpb24odCl7dGhpcy5jb25zdHJhaW50TGluZXM9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24odCl7dGhpcy5zaXRlQ29vcmRzPVdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0RWRnZXModCl9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRUcmlhbmdsZXModCl9LGNyZWF0ZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVzKCksbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1uZXcgUHMoZVtuXSk7dGhpcy5jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW25dLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ganN9fSksanMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1rbi5nZXRMaW5lcyh0KSxuPW5ldyBJLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7anMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKHIsbil9cmV0dXJuIG59aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPXMuZ2V0Q29vcmRpbmF0ZXMoKSxpPTE7aTxhLmxlbmd0aDtpKyspby5hZGQobmV3IFZzKGFbaS0xXSxhW2ldKSl9LGUoS3MucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKTt0aGlzLmRpYWdyYW1FbnY9dDt2YXIgZT1NYXRoLm1heCh0aGlzLmRpYWdyYW1FbnYuZ2V0V2lkdGgoKSx0aGlzLmRpYWdyYW1FbnYuZ2V0SGVpZ2h0KCkpO3RoaXMuZGlhZ3JhbUVudi5leHBhbmRCeShlKSxudWxsIT09dGhpcy5jbGlwRW52JiZ0aGlzLmRpYWdyYW1FbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY2xpcEVudik7dmFyIG49V3MudG9WZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpO3RoaXMuc3ViZGl2PW5ldyBGcyh0LHRoaXMudG9sZXJhbmNlKTt2YXIgaT1uZXcgT3ModGhpcy5zdWJkaXYpO2kuaW5zZXJ0U2l0ZXMobil9LGdldERpYWdyYW06ZnVuY3Rpb24odCl7dGhpcy5jcmVhdGUoKTt2YXIgZT10aGlzLnN1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gS3MuY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuZGlhZ3JhbUVudil9LHNldFRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLnRvbGVyYW5jZT10fSxzZXRTaXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy51bmlxdWUoSC50b0Nvb3JkaW5hdGVBcnJheShlKSl9fSxzZXRDbGlwRW52ZWxvcGU6ZnVuY3Rpb24odCl7dGhpcy5jbGlwRW52PXR9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtzfX0pLEtzLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb249ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShlKSxpPW5ldyBJLHI9MDtyPHQuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9dC5nZXRHZW9tZXRyeU4ociksbz1udWxsO2UuY29udGFpbnMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpP289czplLmludGVyc2VjdHMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz1uLmludGVyc2VjdGlvbihzKSxvLnNldFVzZXJEYXRhKHMuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8aS5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkoaSkpfTt2YXIgQW89T2JqZWN0LmZyZWV6ZSh7VmVydGV4OlRzfSksRm89T2JqZWN0LmZyZWV6ZSh7Q29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6anMsRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpXcyxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6S3MscXVhZGVkZ2U6QW99KTtlKFpzLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWnN9fSksWnMudW5pb249ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LGUoQi5wcm90b3R5cGUse2VxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuISF0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZycy5yZWxhdGUodGhpcyx0KS5pc0VxdWFscyh0aGlzLmdldERpbWVuc2lvbigpLHQuZ2V0RGltZW5zaW9uKCkpfSx1bmlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBscy51bmlvbih0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBacy51bmlvbih0aGlzLHQpfX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiBVci5pc1ZhbGlkKHRoaXMpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7aWYodGhpcy5pc0VtcHR5KCl8fHQuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5JTlRFUlNFQ1RJT04sdGhpcyx0LHRoaXMuZmFjdG9yeSk7aWYodGhpcy5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXt2YXIgZT10O3JldHVybiBobi5tYXAodGhpcyx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTWFwT3BdfSxtYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpfX0pfXJldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksc2kub3ZlcmxheU9wKHRoaXMsdCxpaS5JTlRFUlNFQ1RJT04pfSxjb3ZlcnM6ZnVuY3Rpb24odCl7cmV0dXJuIHJzLmNvdmVycyh0aGlzLHQpfSxjb3ZlcmVkQnk6ZnVuY3Rpb24odCl7cmV0dXJuIHJzLmNvdmVyZWRCeSh0aGlzLHQpfSx0b3VjaGVzOmZ1bmN0aW9uKHQpe3JldHVybiBycy50b3VjaGVzKHRoaXMsdCl9LGludGVyc2VjdHM6ZnVuY3Rpb24odCl7cmV0dXJuIHJzLmludGVyc2VjdHModGhpcyx0KX0sd2l0aGluOmZ1bmN0aW9uKHQpe3JldHVybiBycy53aXRoaW4odGhpcyx0KX0sb3ZlcmxhcHM6ZnVuY3Rpb24odCl7cmV0dXJuIHJzLm92ZXJsYXBzKHRoaXMsdCl9LGRpc2pvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBycy5kaXNqb2ludCh0aGlzLHQpfSxjcm9zc2VzOmZ1bmN0aW9uKHQpe3JldHVybiBycy5jcm9zc2VzKHRoaXMsdCl9LGJ1ZmZlcjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIGRyLmJ1ZmZlck9wKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZHIuYnVmZmVyT3AodGhpcyxlLG4pfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07cmV0dXJuIGRyLmJ1ZmZlck9wKHRoaXMsaSxyLHMpfX0sY29udmV4SHVsbDpmdW5jdGlvbigpe3JldHVybiBuZXcgbWUodGhpcykuZ2V0Q29udmV4SHVsbCgpfSxyZWxhdGU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPUFycmF5KHQpLG49MDtuPHQ7bisrKWVbbl09YXJndW1lbnRzW25dO3JldHVybiBycy5yZWxhdGUuYXBwbHkocnMsW3RoaXNdLmNvbmNhdChlKSl9LGdldENlbnRyb2lkOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2ludCgpO3ZhciB0PWdlLmdldENlbnRyb2lkKHRoaXMpO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0sZ2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgdD1udWxsLGU9dGhpcy5nZXREaW1lbnNpb24oKTtpZigwPT09ZSl7dmFyIG49bmV3IGxpKHRoaXMpO3Q9bi5nZXRJbnRlcmlvclBvaW50KCl9ZWxzZSBpZigxPT09ZSl7dmFyIG49bmV3IHVpKHRoaXMpO3Q9bi5nZXRJbnRlcmlvclBvaW50KCl9ZWxzZXt2YXIgbj1uZXcgb2kodGhpcyk7dD1uLmdldEludGVyaW9yUG9pbnQoKX1yZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LHN5bURpZmZlcmVuY2U6ZnVuY3Rpb24odCl7aWYodGhpcy5pc0VtcHR5KCl8fHQuaXNFbXB0eSgpKXtpZih0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlNZTURJRkZFUkVOQ0UsdGhpcyx0LHRoaXMuZmFjdG9yeSk7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpO2lmKHQuaXNFbXB0eSgpKXJldHVybiB0aGlzLmNvcHkoKX1yZXR1cm4gdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHNpLm92ZXJsYXlPcCh0aGlzLHQsaWkuU1lNRElGRkVSRU5DRSl9LGNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSx0b1RleHQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgc2U7cmV0dXJuIHQud3JpdGUodGhpcyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dGhpcy50b1RleHQoKX0sY29udGFpbnM6ZnVuY3Rpb24odCl7cmV0dXJuIHJzLmNvbnRhaW5zKHRoaXMsdCl9LGRpZmZlcmVuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2lpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLkRJRkZFUkVOQ0UsdGhpcyx0LHRoaXMuZmFjdG9yeSk6dC5pc0VtcHR5KCk/dGhpcy5jb3B5KCk6KHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxzaS5vdmVybGF5T3AodGhpcyx0LGlpLkRJRkZFUkVOQ0UpKX0saXNTaW1wbGU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgV2kodGhpcyk7cmV0dXJuIHQuaXNTaW1wbGUoKX0saXNXaXRoaW5EaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4hKG4+ZSkmJnhyLmlzV2l0aGluRGlzdGFuY2UodGhpcyx0LGUpfSxkaXN0YW5jZTpmdW5jdGlvbih0KXtyZXR1cm4geHIuZGlzdGFuY2UodGhpcyx0KX0saXNFcXVpdmFsZW50Q2xhc3M6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0Q2xhc3MoKT09PXQuZ2V0Q2xhc3MoKX19KTt2YXIgR289XCIxLjMuMCAoNmU2NWFkYilcIjt0LnZlcnNpb249R28sdC5hbGdvcml0aG09Y28sdC5kZW5zaWZ5PWZvLHQuZGlzc29sdmU9Z28sdC5nZW9tPWxvLHQuZ2VvbWdyYXBoPXBvLHQuaW5kZXg9eW8sdC5pbz1Obyx0Lm5vZGluZz1Dbyx0Lm9wZXJhdGlvbj1fbyx0LnByZWNpc2lvbj1Nbyx0LnNpbXBsaWZ5PURvLHQudHJpYW5ndWxhdGU9Rm8sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBsaW5lY2xpcDtcblxubGluZWNsaXAucG9seWxpbmUgPSBsaW5lY2xpcDtcbmxpbmVjbGlwLnBvbHlnb24gPSBwb2x5Z29uY2xpcDtcblxuXG4vLyBDb2hlbi1TdXRoZXJsYW5kIGxpbmUgY2xpcHBpZ24gYWxnb3JpdGhtLCBhZGFwdGVkIHRvIGVmZmljaWVudGx5XG4vLyBoYW5kbGUgcG9seWxpbmVzIHJhdGhlciB0aGFuIGp1c3Qgc2VnbWVudHNcblxuZnVuY3Rpb24gbGluZWNsaXAocG9pbnRzLCBiYm94LCByZXN1bHQpIHtcblxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBjb2RlQSA9IGJpdENvZGUocG9pbnRzWzBdLCBiYm94KSxcbiAgICAgICAgcGFydCA9IFtdLFxuICAgICAgICBpLCBhLCBiLCBjb2RlQiwgbGFzdENvZGU7XG5cbiAgICBpZiAoIXJlc3VsdCkgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYSA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgIGIgPSBwb2ludHNbaV07XG4gICAgICAgIGNvZGVCID0gbGFzdENvZGUgPSBiaXRDb2RlKGIsIGJib3gpO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgIGlmICghKGNvZGVBIHwgY29kZUIpKSB7IC8vIGFjY2VwdFxuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2RlQiAhPT0gbGFzdENvZGUpIHsgLy8gc2VnbWVudCB3ZW50IG91dHNpZGVcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wdXNoKGIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSkgeyAvLyBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVBICYgY29kZUIpIHsgLy8gdHJpdmlhbCByZWplY3RcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlQSkgeyAvLyBhIG91dHNpZGUsIGludGVyc2VjdCB3aXRoIGNsaXAgZWRnZVxuICAgICAgICAgICAgICAgIGEgPSBpbnRlcnNlY3QoYSwgYiwgY29kZUEsIGJib3gpO1xuICAgICAgICAgICAgICAgIGNvZGVBID0gYml0Q29kZShhLCBiYm94KTtcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gYiBvdXRzaWRlXG4gICAgICAgICAgICAgICAgYiA9IGludGVyc2VjdChhLCBiLCBjb2RlQiwgYmJveCk7XG4gICAgICAgICAgICAgICAgY29kZUIgPSBiaXRDb2RlKGIsIGJib3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29kZUEgPSBsYXN0Q29kZTtcbiAgICB9XG5cbiAgICBpZiAocGFydC5sZW5ndGgpIHJlc3VsdC5wdXNoKHBhcnQpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gU3V0aGVybGFuZC1Ib2RnZW1hbiBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobVxuXG5mdW5jdGlvbiBwb2x5Z29uY2xpcChwb2ludHMsIGJib3gpIHtcblxuICAgIHZhciByZXN1bHQsIGVkZ2UsIHByZXYsIHByZXZJbnNpZGUsIGksIHAsIGluc2lkZTtcblxuICAgIC8vIGNsaXAgYWdhaW5zdCBlYWNoIHNpZGUgb2YgdGhlIGNsaXAgcmVjdGFuZ2xlXG4gICAgZm9yIChlZGdlID0gMTsgZWRnZSA8PSA4OyBlZGdlICo9IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIHByZXYgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBwcmV2SW5zaWRlID0gIShiaXRDb2RlKHByZXYsIGJib3gpICYgZWRnZSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGluc2lkZSA9ICEoYml0Q29kZShwLCBiYm94KSAmIGVkZ2UpO1xuXG4gICAgICAgICAgICAvLyBpZiBzZWdtZW50IGdvZXMgdGhyb3VnaCB0aGUgY2xpcCB3aW5kb3csIGFkZCBhbiBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIGlmIChpbnNpZGUgIT09IHByZXZJbnNpZGUpIHJlc3VsdC5wdXNoKGludGVyc2VjdChwcmV2LCBwLCBlZGdlLCBiYm94KSk7XG5cbiAgICAgICAgICAgIGlmIChpbnNpZGUpIHJlc3VsdC5wdXNoKHApOyAvLyBhZGQgYSBwb2ludCBpZiBpdCdzIGluc2lkZVxuXG4gICAgICAgICAgICBwcmV2ID0gcDtcbiAgICAgICAgICAgIHByZXZJbnNpZGUgPSBpbnNpZGU7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludHMgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCFwb2ludHMubGVuZ3RoKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBpbnRlcnNlY3QgYSBzZWdtZW50IGFnYWluc3Qgb25lIG9mIHRoZSA0IGxpbmVzIHRoYXQgbWFrZSB1cCB0aGUgYmJveFxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgZWRnZSwgYmJveCkge1xuICAgIHJldHVybiBlZGdlICYgOCA/IFthWzBdICsgKGJbMF0gLSBhWzBdKSAqIChiYm94WzNdIC0gYVsxXSkgLyAoYlsxXSAtIGFbMV0pLCBiYm94WzNdXSA6IC8vIHRvcFxuICAgICAgICAgICBlZGdlICYgNCA/IFthWzBdICsgKGJbMF0gLSBhWzBdKSAqIChiYm94WzFdIC0gYVsxXSkgLyAoYlsxXSAtIGFbMV0pLCBiYm94WzFdXSA6IC8vIGJvdHRvbVxuICAgICAgICAgICBlZGdlICYgMiA/IFtiYm94WzJdLCBhWzFdICsgKGJbMV0gLSBhWzFdKSAqIChiYm94WzJdIC0gYVswXSkgLyAoYlswXSAtIGFbMF0pXSA6IC8vIHJpZ2h0XG4gICAgICAgICAgIGVkZ2UgJiAxID8gW2Jib3hbMF0sIGFbMV0gKyAoYlsxXSAtIGFbMV0pICogKGJib3hbMF0gLSBhWzBdKSAvIChiWzBdIC0gYVswXSldIDogLy8gbGVmdFxuICAgICAgICAgICBudWxsO1xufVxuXG4vLyBiaXQgY29kZSByZWZsZWN0cyB0aGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJib3g6XG5cbi8vICAgICAgICAgbGVmdCAgbWlkICByaWdodFxuLy8gICAgdG9wICAxMDAxICAxMDAwICAxMDEwXG4vLyAgICBtaWQgIDAwMDEgIDAwMDAgIDAwMTBcbi8vIGJvdHRvbSAgMDEwMSAgMDEwMCAgMDExMFxuXG5mdW5jdGlvbiBiaXRDb2RlKHAsIGJib3gpIHtcbiAgICB2YXIgY29kZSA9IDA7XG5cbiAgICBpZiAocFswXSA8IGJib3hbMF0pIGNvZGUgfD0gMTsgLy8gbGVmdFxuICAgIGVsc2UgaWYgKHBbMF0gPiBiYm94WzJdKSBjb2RlIHw9IDI7IC8vIHJpZ2h0XG5cbiAgICBpZiAocFsxXSA8IGJib3hbMV0pIGNvZGUgfD0gNDsgLy8gYm90dG9tXG4gICAgZWxzZSBpZiAocFsxXSA+IGJib3hbM10pIGNvZGUgfD0gODsgLy8gdG9wXG5cbiAgICByZXR1cm4gY29kZTtcbn1cbiIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gbW9ub3RvbmVDb252ZXhIdWxsMkRcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpWzNdXG5cbmZ1bmN0aW9uIG1vbm90b25lQ29udmV4SHVsbDJEKHBvaW50cykge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcblxuICBpZihuIDwgMykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGlcbiAgICB9XG5cbiAgICBpZihuID09PSAyICYmXG4gICAgICAgcG9pbnRzWzBdWzBdID09PSBwb2ludHNbMV1bMF0gJiZcbiAgICAgICBwb2ludHNbMF1bMV0gPT09IHBvaW50c1sxXVsxXSkge1xuICAgICAgcmV0dXJuIFswXVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vU29ydCBwb2ludCBpbmRpY2VzIGFsb25nIHgtYXhpc1xuICB2YXIgc29ydGVkID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHNvcnRlZFtpXSA9IGlcbiAgfVxuICBzb3J0ZWQuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgZCA9IHBvaW50c1thXVswXS1wb2ludHNbYl1bMF1cbiAgICBpZihkKSB7XG4gICAgICByZXR1cm4gZFxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzW2FdWzFdIC0gcG9pbnRzW2JdWzFdXG4gIH0pXG5cbiAgLy9Db25zdHJ1Y3QgdXBwZXIgYW5kIGxvd2VyIGh1bGxzXG4gIHZhciBsb3dlciA9IFtzb3J0ZWRbMF0sIHNvcnRlZFsxXV1cbiAgdmFyIHVwcGVyID0gW3NvcnRlZFswXSwgc29ydGVkWzFdXVxuXG4gIGZvcih2YXIgaT0yOyBpPG47ICsraSkge1xuICAgIHZhciBpZHggPSBzb3J0ZWRbaV1cbiAgICB2YXIgcCAgID0gcG9pbnRzW2lkeF1cblxuICAgIC8vSW5zZXJ0IGludG8gbG93ZXIgbGlzdFxuICAgIHZhciBtID0gbG93ZXIubGVuZ3RoXG4gICAgd2hpbGUobSA+IDEgJiYgb3JpZW50KFxuICAgICAgICBwb2ludHNbbG93ZXJbbS0yXV0sIFxuICAgICAgICBwb2ludHNbbG93ZXJbbS0xXV0sIFxuICAgICAgICBwKSA8PSAwKSB7XG4gICAgICBtIC09IDFcbiAgICAgIGxvd2VyLnBvcCgpXG4gICAgfVxuICAgIGxvd2VyLnB1c2goaWR4KVxuXG4gICAgLy9JbnNlcnQgaW50byB1cHBlciBsaXN0XG4gICAgbSA9IHVwcGVyLmxlbmd0aFxuICAgIHdoaWxlKG0gPiAxICYmIG9yaWVudChcbiAgICAgICAgcG9pbnRzW3VwcGVyW20tMl1dLCBcbiAgICAgICAgcG9pbnRzW3VwcGVyW20tMV1dLCBcbiAgICAgICAgcCkgPj0gMCkge1xuICAgICAgbSAtPSAxXG4gICAgICB1cHBlci5wb3AoKVxuICAgIH1cbiAgICB1cHBlci5wdXNoKGlkeClcbiAgfVxuXG4gIC8vTWVyZ2UgbGlzdHMgdG9nZXRoZXJcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh1cHBlci5sZW5ndGggKyBsb3dlci5sZW5ndGggLSAyKVxuICB2YXIgcHRyICAgID0gMFxuICBmb3IodmFyIGk9MCwgbmw9bG93ZXIubGVuZ3RoOyBpPG5sOyArK2kpIHtcbiAgICByZXN1bHRbcHRyKytdID0gbG93ZXJbaV1cbiAgfVxuICBmb3IodmFyIGo9dXBwZXIubGVuZ3RoLTI7IGo+MDsgLS1qKSB7XG4gICAgcmVzdWx0W3B0cisrXSA9IHVwcGVyW2pdXG4gIH1cblxuICAvL1JldHVybiByZXN1bHRcbiAgcmV0dXJuIHJlc3VsdFxufSIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDBcbnZhciBtID0gcyAqIDYwXG52YXIgaCA9IG0gKiA2MFxudmFyIGQgPSBoICogMjRcbnZhciB5ID0gZCAqIDM2NS4yNVxuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbFxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/XG5cdFx0XHRmbXRMb25nKHZhbCkgOlxuXHRcdFx0Zm10U2hvcnQodmFsKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcigndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICsgSlNPTi5zdHJpbmdpZnkodmFsKSlcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cilcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHlcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkXG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoXG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtXG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJ1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJ1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJ1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJ1xuICB9XG4gIHJldHVybiBtcyArICdtcydcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcydcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZVxuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncydcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIGFkZDogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHApOyAgICAgfSxcbiAgICBzdWI6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihwKTsgICAgIH0sXG4gICAgbXVsdDogICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspOyAgICB9LFxuICAgIGRpdjogICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KGspOyAgICAgfSxcbiAgICByb3RhdGU6ICBmdW5jdGlvbihhKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdGF0ZShhKTsgIH0sXG4gICAgbWF0TXVsdDogZnVuY3Rpb24obSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KG0pOyB9LFxuICAgIHVuaXQ6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl91bml0KCk7IH0sXG4gICAgcGVycDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTsgfSxcbiAgICByb3VuZDogICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTsgfSxcblxuICAgIG1hZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICAgIH0sXG5cbiAgICBkaXN0U3FyOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVXaXRoOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuZ2xlV2l0aFNlcChiLngsIGIueSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3IgdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoXG4gICAgICAgICAgICB0aGlzLnggKiB5IC0gdGhpcy55ICogeCxcbiAgICAgICAgICAgIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgICB9LFxuXG4gICAgX21hdE11bHQ6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHggPSBtWzBdICogdGhpcy54ICsgbVsxXSAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBtWzJdICogdGhpcy54ICsgbVszXSAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54ICs9IHAueDtcbiAgICAgICAgdGhpcy55ICs9IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54IC09IHAueDtcbiAgICAgICAgdGhpcy55IC09IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tdWx0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAqPSBrO1xuICAgICAgICB0aGlzLnkgKj0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXY6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54IC89IGs7XG4gICAgICAgIHRoaXMueSAvPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXYodGhpcy5tYWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcGVycDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCA9IC15O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBjb3MgKiB0aGlzLnggLSBzaW4gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gc2luICogdGhpcy54ICsgY29zICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgUG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblBvaW50LmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYVswXSwgYVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFydGlhbFNvcnQ7XG5cbi8vIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOlxuLy8gUmVhcnJhbmdlIGl0ZW1zIHNvIHRoYXQgYWxsIGl0ZW1zIGluIHRoZSBbbGVmdCwga10gcmFuZ2UgYXJlIHNtYWxsZXIgdGhhbiBhbGwgaXRlbXMgaW4gKGssIHJpZ2h0XTtcbi8vIFRoZSBrLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSAoayAtIGxlZnQgKyAxKXRoIHNtYWxsZXN0IHZhbHVlIGluIFtsZWZ0LCByaWdodF1cblxuZnVuY3Rpb24gcGFydGlhbFNvcnQoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgcmlnaHQgPSByaWdodCB8fCAoYXJyLmxlbmd0aCAtIDEpO1xuICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHBhcnRpYWxTb3J0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcblxudmFyIHF1aWNrc2VsZWN0ID0gcmVxdWlyZSgncXVpY2tzZWxlY3QnKTtcblxuZnVuY3Rpb24gcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHJidXNoKSkgcmV0dXJuIG5ldyByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpO1xuXG4gICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyB8fCA5KTtcbiAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxucmJ1c2gucHJvdG90eXBlID0ge1xuXG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfSxcblxuICAgIHNlYXJjaDogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb2xsaWRlczogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtLCBlcXVhbHNGbikge1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgcGF0aCA9IFtdLFxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgaSwgcGFyZW50LCBpbmRleCwgZ29pbmdVcDtcblxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7IC8vIGdvIHVwXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGkgPSBpbmRleGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7IC8vIGNoZWNrIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGluZGV4ID0gZmluZEl0ZW0oaXRlbSwgbm9kZS5jaGlsZHJlbiwgZXF1YWxzRm4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnb2luZ1VwICYmICFub2RlLmxlYWYgJiYgY29udGFpbnMobm9kZSwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXG5cbiAgICBjb21wYXJlTWluWDogY29tcGFyZU5vZGVNaW5YLFxuICAgIGNvbXBhcmVNaW5ZOiBjb21wYXJlTm9kZU1pblksXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZShpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpKTtcbiAgICAgICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICBub2RlLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICAgICAgdmFyIE4yID0gTWF0aC5jZWlsKE4gLyBNKSxcbiAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcbiAgICAgICAgICAgIGksIGosIHJpZ2h0MiwgcmlnaHQzO1xuXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkgKz0gTjEpIHtcblxuICAgICAgICAgICAgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVN1YnRyZWU6IGZ1bmN0aW9uIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZSB8fCBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgYmJveCA9IGlzTm9kZSA/IGl0ZW0gOiB0b0JCb3goaXRlbSksXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICBleHRlbmQobm9kZSwgYmJveCk7XG5cbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0UGF0aFtsZXZlbF0uY2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5fbWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gdGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSk7XG4gICAgICAgIG5ld05vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICAgIG5ld05vZGUubGVhZiA9IG5vZGUubGVhZjtcblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICB9LFxuXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW25vZGUsIG5ld05vZGVdKTtcbiAgICAgICAgdGhpcy5kYXRhLmhlaWdodCA9IG5vZGUuaGVpZ2h0ICsgMTtcbiAgICAgICAgdGhpcy5kYXRhLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgX2Nob29zZVNwbGl0QXhpczogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxuICAgICAgICAgICAgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZLFxuICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxuICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgfSxcblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGxlZnRCQm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbSwgdG9CQm94KSxcbiAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxuICAgICAgICAgICAgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCksXG4gICAgICAgICAgICBpLCBjaGlsZDtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG5cbiAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdEZvcm1hdDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAvLyBkYXRhIGZvcm1hdCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSBhY2Nlc3NvcnMpXG5cbiAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBhbGdvcml0aG1zIGFyZSB2ZXJ5IHNlbnNpdGl2ZSB0byBzb3J0aW5nIGZ1bmN0aW9ucyBwZXJmb3JtYW5jZSxcbiAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLFxuICAgICAgICAgICAgJ3JldHVybiB7bWluWDogYScgKyBmb3JtYXRbMF0gK1xuICAgICAgICAgICAgJywgbWluWTogYScgKyBmb3JtYXRbMV0gK1xuICAgICAgICAgICAgJywgbWF4WDogYScgKyBmb3JtYXRbMl0gK1xuICAgICAgICAgICAgJywgbWF4WTogYScgKyBmb3JtYXRbM10gKyAnfTsnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSXRlbShpdGVtLCBpdGVtcywgZXF1YWxzRm4pIHtcbiAgICBpZiAoIWVxdWFsc0ZuKSByZXR1cm4gaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFsc0ZuKGl0ZW0sIGl0ZW1zW2ldKSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZSwgdG9CQm94KSB7XG4gICAgZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCwgbm9kZSk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gsIGRlc3ROb2RlKSB7XG4gICAgaWYgKCFkZXN0Tm9kZSkgZGVzdE5vZGUgPSBjcmVhdGVOb2RlKG51bGwpO1xuICAgIGRlc3ROb2RlLm1pblggPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5taW5ZID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WCA9IC1JbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IGssIGNoaWxkOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCksXG4gICAgICAgIG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSksXG4gICAgICAgIG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluWCA8PSBiLm1pblggJiZcbiAgICAgICAgICAgYS5taW5ZIDw9IGIubWluWSAmJlxuICAgICAgICAgICBiLm1heFggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWF4WSA8PSBhLm1heFk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICAgIHJldHVybiBiLm1pblggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWluWSA8PSBhLm1heFkgJiZcbiAgICAgICAgICAgYi5tYXhYID49IGEubWluWCAmJlxuICAgICAgICAgICBiLm1heFkgPj0gYS5taW5ZO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcbiAgICB9O1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgbWlkO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBtaWQsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHR3b1Byb2R1Y3QgPSByZXF1aXJlKFwidHdvLXByb2R1Y3RcIilcbnZhciByb2J1c3RTdW0gPSByZXF1aXJlKFwicm9idXN0LXN1bVwiKVxudmFyIHJvYnVzdFNjYWxlID0gcmVxdWlyZShcInJvYnVzdC1zY2FsZVwiKVxudmFyIHJvYnVzdFN1YnRyYWN0ID0gcmVxdWlyZShcInJvYnVzdC1zdWJ0cmFjdFwiKVxuXG52YXIgTlVNX0VYUEFORCA9IDVcblxudmFyIEVQU0lMT04gICAgID0gMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNlxudmFyIEVSUkJPVU5EMyAgID0gKDMuMCArIDE2LjAgKiBFUFNJTE9OKSAqIEVQU0lMT05cbnZhciBFUlJCT1VORDQgICA9ICg3LjAgKyA1Ni4wICogRVBTSUxPTikgKiBFUFNJTE9OXG5cbmZ1bmN0aW9uIGNvZmFjdG9yKG0sIGMpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShtLmxlbmd0aC0xKVxuICBmb3IodmFyIGk9MTsgaTxtLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHIgPSByZXN1bHRbaS0xXSA9IG5ldyBBcnJheShtLmxlbmd0aC0xKVxuICAgIGZvcih2YXIgaj0wLGs9MDsgajxtLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihqID09PSBjKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICByW2srK10gPSBtW2ldW2pdXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gbWF0cml4KG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBuZXcgQXJyYXkobilcbiAgICBmb3IodmFyIGo9MDsgajxuOyArK2opIHtcbiAgICAgIHJlc3VsdFtpXVtqXSA9IFtcIm1cIiwgaiwgXCJbXCIsIChuLWktMSksIFwiXVwiXS5qb2luKFwiXCIpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gc2lnbihuKSB7XG4gIGlmKG4gJiAxKSB7XG4gICAgcmV0dXJuIFwiLVwiXG4gIH1cbiAgcmV0dXJuIFwiXCJcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTdW0oZXhwcikge1xuICBpZihleHByLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBleHByWzBdXG4gIH0gZWxzZSBpZihleHByLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBbXCJzdW0oXCIsIGV4cHJbMF0sIFwiLFwiLCBleHByWzFdLCBcIilcIl0uam9pbihcIlwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBtID0gZXhwci5sZW5ndGg+PjFcbiAgICByZXR1cm4gW1wic3VtKFwiLCBnZW5lcmF0ZVN1bShleHByLnNsaWNlKDAsIG0pKSwgXCIsXCIsIGdlbmVyYXRlU3VtKGV4cHIuc2xpY2UobSkpLCBcIilcIl0uam9pbihcIlwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluYW50KG0pIHtcbiAgaWYobS5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gW1tcInN1bShwcm9kKFwiLCBtWzBdWzBdLCBcIixcIiwgbVsxXVsxXSwgXCIpLHByb2QoLVwiLCBtWzBdWzFdLCBcIixcIiwgbVsxXVswXSwgXCIpKVwiXS5qb2luKFwiXCIpXVxuICB9IGVsc2Uge1xuICAgIHZhciBleHByID0gW11cbiAgICBmb3IodmFyIGk9MDsgaTxtLmxlbmd0aDsgKytpKSB7XG4gICAgICBleHByLnB1c2goW1wic2NhbGUoXCIsIGdlbmVyYXRlU3VtKGRldGVybWluYW50KGNvZmFjdG9yKG0sIGkpKSksIFwiLFwiLCBzaWduKGkpLCBtWzBdW2ldLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbihuKSB7XG4gIHZhciBwb3MgPSBbXVxuICB2YXIgbmVnID0gW11cbiAgdmFyIG0gPSBtYXRyaXgobilcbiAgdmFyIGFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICBpZigoaSYxKT09PTApIHtcbiAgICAgIHBvcy5wdXNoLmFwcGx5KHBvcywgZGV0ZXJtaW5hbnQoY29mYWN0b3IobSwgaSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZWcucHVzaC5hcHBseShuZWcsIGRldGVybWluYW50KGNvZmFjdG9yKG0sIGkpKSlcbiAgICB9XG4gICAgYXJncy5wdXNoKFwibVwiICsgaSlcbiAgfVxuICB2YXIgcG9zRXhwciA9IGdlbmVyYXRlU3VtKHBvcylcbiAgdmFyIG5lZ0V4cHIgPSBnZW5lcmF0ZVN1bShuZWcpXG4gIHZhciBmdW5jTmFtZSA9IFwib3JpZW50YXRpb25cIiArIG4gKyBcIkV4YWN0XCJcbiAgdmFyIGNvZGUgPSBbXCJmdW5jdGlvbiBcIiwgZnVuY05hbWUsIFwiKFwiLCBhcmdzLmpvaW4oKSwgXCIpe3ZhciBwPVwiLCBwb3NFeHByLCBcIixuPVwiLCBuZWdFeHByLCBcIixkPXN1YihwLG4pO1xcXG5yZXR1cm4gZFtkLmxlbmd0aC0xXTt9O3JldHVybiBcIiwgZnVuY05hbWVdLmpvaW4oXCJcIilcbiAgdmFyIHByb2MgPSBuZXcgRnVuY3Rpb24oXCJzdW1cIiwgXCJwcm9kXCIsIFwic2NhbGVcIiwgXCJzdWJcIiwgY29kZSlcbiAgcmV0dXJuIHByb2Mocm9idXN0U3VtLCB0d29Qcm9kdWN0LCByb2J1c3RTY2FsZSwgcm9idXN0U3VidHJhY3QpXG59XG5cbnZhciBvcmllbnRhdGlvbjNFeGFjdCA9IG9yaWVudGF0aW9uKDMpXG52YXIgb3JpZW50YXRpb240RXhhY3QgPSBvcmllbnRhdGlvbig0KVxuXG52YXIgQ0FDSEVEID0gW1xuICBmdW5jdGlvbiBvcmllbnRhdGlvbjAoKSB7IHJldHVybiAwIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMSgpIHsgcmV0dXJuIDAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24yKGEsIGIpIHsgXG4gICAgcmV0dXJuIGJbMF0gLSBhWzBdXG4gIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMyhhLCBiLCBjKSB7XG4gICAgdmFyIGwgPSAoYVsxXSAtIGNbMV0pICogKGJbMF0gLSBjWzBdKVxuICAgIHZhciByID0gKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gY1sxXSlcbiAgICB2YXIgZGV0ID0gbCAtIHJcbiAgICB2YXIgc1xuICAgIGlmKGwgPiAwKSB7XG4gICAgICBpZihyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGRldFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGwgKyByXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGwgPCAwKSB7XG4gICAgICBpZihyID49IDApIHtcbiAgICAgICAgcmV0dXJuIGRldFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IC0obCArIHIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgdmFyIHRvbCA9IEVSUkJPVU5EMyAqIHNcbiAgICBpZihkZXQgPj0gdG9sIHx8IGRldCA8PSAtdG9sKSB7XG4gICAgICByZXR1cm4gZGV0XG4gICAgfVxuICAgIHJldHVybiBvcmllbnRhdGlvbjNFeGFjdChhLCBiLCBjKVxuICB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjQoYSxiLGMsZCkge1xuICAgIHZhciBhZHggPSBhWzBdIC0gZFswXVxuICAgIHZhciBiZHggPSBiWzBdIC0gZFswXVxuICAgIHZhciBjZHggPSBjWzBdIC0gZFswXVxuICAgIHZhciBhZHkgPSBhWzFdIC0gZFsxXVxuICAgIHZhciBiZHkgPSBiWzFdIC0gZFsxXVxuICAgIHZhciBjZHkgPSBjWzFdIC0gZFsxXVxuICAgIHZhciBhZHogPSBhWzJdIC0gZFsyXVxuICAgIHZhciBiZHogPSBiWzJdIC0gZFsyXVxuICAgIHZhciBjZHogPSBjWzJdIC0gZFsyXVxuICAgIHZhciBiZHhjZHkgPSBiZHggKiBjZHlcbiAgICB2YXIgY2R4YmR5ID0gY2R4ICogYmR5XG4gICAgdmFyIGNkeGFkeSA9IGNkeCAqIGFkeVxuICAgIHZhciBhZHhjZHkgPSBhZHggKiBjZHlcbiAgICB2YXIgYWR4YmR5ID0gYWR4ICogYmR5XG4gICAgdmFyIGJkeGFkeSA9IGJkeCAqIGFkeVxuICAgIHZhciBkZXQgPSBhZHogKiAoYmR4Y2R5IC0gY2R4YmR5KSBcbiAgICAgICAgICAgICsgYmR6ICogKGNkeGFkeSAtIGFkeGNkeSlcbiAgICAgICAgICAgICsgY2R6ICogKGFkeGJkeSAtIGJkeGFkeSlcbiAgICB2YXIgcGVybWFuZW50ID0gKE1hdGguYWJzKGJkeGNkeSkgKyBNYXRoLmFicyhjZHhiZHkpKSAqIE1hdGguYWJzKGFkeilcbiAgICAgICAgICAgICAgICAgICsgKE1hdGguYWJzKGNkeGFkeSkgKyBNYXRoLmFicyhhZHhjZHkpKSAqIE1hdGguYWJzKGJkeilcbiAgICAgICAgICAgICAgICAgICsgKE1hdGguYWJzKGFkeGJkeSkgKyBNYXRoLmFicyhiZHhhZHkpKSAqIE1hdGguYWJzKGNkeilcbiAgICB2YXIgdG9sID0gRVJSQk9VTkQ0ICogcGVybWFuZW50XG4gICAgaWYgKChkZXQgPiB0b2wpIHx8ICgtZGV0ID4gdG9sKSkge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICByZXR1cm4gb3JpZW50YXRpb240RXhhY3QoYSxiLGMsZClcbiAgfVxuXVxuXG5mdW5jdGlvbiBzbG93T3JpZW50KGFyZ3MpIHtcbiAgdmFyIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdXG4gIGlmKCFwcm9jKSB7XG4gICAgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF0gPSBvcmllbnRhdGlvbihhcmdzLmxlbmd0aClcbiAgfVxuICByZXR1cm4gcHJvYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3JpZW50YXRpb25Qcm9jKCkge1xuICB3aGlsZShDQUNIRUQubGVuZ3RoIDw9IE5VTV9FWFBBTkQpIHtcbiAgICBDQUNIRUQucHVzaChvcmllbnRhdGlvbihDQUNIRUQubGVuZ3RoKSlcbiAgfVxuICB2YXIgYXJncyA9IFtdXG4gIHZhciBwcm9jQXJncyA9IFtcInNsb3dcIl1cbiAgZm9yKHZhciBpPTA7IGk8PU5VTV9FWFBBTkQ7ICsraSkge1xuICAgIGFyZ3MucHVzaChcImFcIiArIGkpXG4gICAgcHJvY0FyZ3MucHVzaChcIm9cIiArIGkpXG4gIH1cbiAgdmFyIGNvZGUgPSBbXG4gICAgXCJmdW5jdGlvbiBnZXRPcmllbnRhdGlvbihcIiwgYXJncy5qb2luKCksIFwiKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOmNhc2UgMTpyZXR1cm4gMDtcIlxuICBdXG4gIGZvcih2YXIgaT0yOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJjYXNlIFwiLCBpLCBcIjpyZXR1cm4gb1wiLCBpLCBcIihcIiwgYXJncy5zbGljZSgwLCBpKS5qb2luKCksIFwiKTtcIilcbiAgfVxuICBjb2RlLnB1c2goXCJ9dmFyIHM9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDsrK2kpe3NbaV09YXJndW1lbnRzW2ldfTtyZXR1cm4gc2xvdyhzKTt9cmV0dXJuIGdldE9yaWVudGF0aW9uXCIpXG4gIHByb2NBcmdzLnB1c2goY29kZS5qb2luKFwiXCIpKVxuXG4gIHZhciBwcm9jID0gRnVuY3Rpb24uYXBwbHkodW5kZWZpbmVkLCBwcm9jQXJncylcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jLmFwcGx5KHVuZGVmaW5lZCwgW3Nsb3dPcmllbnRdLmNvbmNhdChDQUNIRUQpKVxuICBmb3IodmFyIGk9MDsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbaV0gPSBDQUNIRURbaV1cbiAgfVxufVxuXG5nZW5lcmF0ZU9yaWVudGF0aW9uUHJvYygpIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHR3b1Byb2R1Y3QgPSByZXF1aXJlKFwidHdvLXByb2R1Y3RcIilcbnZhciB0d29TdW0gPSByZXF1aXJlKFwidHdvLXN1bVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNjYWxlTGluZWFyRXhwYW5zaW9uXG5cbmZ1bmN0aW9uIHNjYWxlTGluZWFyRXhwYW5zaW9uKGUsIHNjYWxlKSB7XG4gIHZhciBuID0gZS5sZW5ndGhcbiAgaWYobiA9PT0gMSkge1xuICAgIHZhciB0cyA9IHR3b1Byb2R1Y3QoZVswXSwgc2NhbGUpXG4gICAgaWYodHNbMF0pIHtcbiAgICAgIHJldHVybiB0c1xuICAgIH1cbiAgICByZXR1cm4gWyB0c1sxXSBdXG4gIH1cbiAgdmFyIGcgPSBuZXcgQXJyYXkoMiAqIG4pXG4gIHZhciBxID0gWzAuMSwgMC4xXVxuICB2YXIgdCA9IFswLjEsIDAuMV1cbiAgdmFyIGNvdW50ID0gMFxuICB0d29Qcm9kdWN0KGVbMF0sIHNjYWxlLCBxKVxuICBpZihxWzBdKSB7XG4gICAgZ1tjb3VudCsrXSA9IHFbMF1cbiAgfVxuICBmb3IodmFyIGk9MTsgaTxuOyArK2kpIHtcbiAgICB0d29Qcm9kdWN0KGVbaV0sIHNjYWxlLCB0KVxuICAgIHZhciBwcSA9IHFbMV1cbiAgICB0d29TdW0ocHEsIHRbMF0sIHEpXG4gICAgaWYocVswXSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHFbMF1cbiAgICB9XG4gICAgdmFyIGEgPSB0WzFdXG4gICAgdmFyIGIgPSBxWzFdXG4gICAgdmFyIHggPSBhICsgYlxuICAgIHZhciBidiA9IHggLSBhXG4gICAgdmFyIHkgPSBiIC0gYnZcbiAgICBxWzFdID0geFxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICB9XG4gIGlmKHFbMV0pIHtcbiAgICBnW2NvdW50KytdID0gcVsxXVxuICB9XG4gIGlmKGNvdW50ID09PSAwKSB7XG4gICAgZ1tjb3VudCsrXSA9IDAuMFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJvYnVzdFN1YnRyYWN0XG5cbi8vRWFzeSBjYXNlOiBBZGQgdHdvIHNjYWxhcnNcbmZ1bmN0aW9uIHNjYWxhclNjYWxhcihhLCBiKSB7XG4gIHZhciB4ID0gYSArIGJcbiAgdmFyIGJ2ID0geCAtIGFcbiAgdmFyIGF2ID0geCAtIGJ2XG4gIHZhciBiciA9IGIgLSBidlxuICB2YXIgYXIgPSBhIC0gYXZcbiAgdmFyIHkgPSBhciArIGJyXG4gIGlmKHkpIHtcbiAgICByZXR1cm4gW3ksIHhdXG4gIH1cbiAgcmV0dXJuIFt4XVxufVxuXG5mdW5jdGlvbiByb2J1c3RTdWJ0cmFjdChlLCBmKSB7XG4gIHZhciBuZSA9IGUubGVuZ3RofDBcbiAgdmFyIG5mID0gZi5sZW5ndGh8MFxuICBpZihuZSA9PT0gMSAmJiBuZiA9PT0gMSkge1xuICAgIHJldHVybiBzY2FsYXJTY2FsYXIoZVswXSwgLWZbMF0pXG4gIH1cbiAgdmFyIG4gPSBuZSArIG5mXG4gIHZhciBnID0gbmV3IEFycmF5KG4pXG4gIHZhciBjb3VudCA9IDBcbiAgdmFyIGVwdHIgPSAwXG4gIHZhciBmcHRyID0gMFxuICB2YXIgYWJzID0gTWF0aC5hYnNcbiAgdmFyIGVpID0gZVtlcHRyXVxuICB2YXIgZWEgPSBhYnMoZWkpXG4gIHZhciBmaSA9IC1mW2ZwdHJdXG4gIHZhciBmYSA9IGFicyhmaSlcbiAgdmFyIGEsIGJcbiAgaWYoZWEgPCBmYSkge1xuICAgIGIgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYiA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgaWYoKGVwdHIgPCBuZSAmJiBlYSA8IGZhKSB8fCAoZnB0ciA+PSBuZikpIHtcbiAgICBhID0gZWlcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgZWEgPSBhYnMoZWkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGEgPSBmaVxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSAtZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIHZhciB4ID0gYSArIGJcbiAgdmFyIGJ2ID0geCAtIGFcbiAgdmFyIHkgPSBiIC0gYnZcbiAgdmFyIHEwID0geVxuICB2YXIgcTEgPSB4XG4gIHZhciBfeCwgX2J2LCBfYXYsIF9iciwgX2FyXG4gIHdoaWxlKGVwdHIgPCBuZSAmJiBmcHRyIDwgbmYpIHtcbiAgICBpZihlYSA8IGZhKSB7XG4gICAgICBhID0gZWlcbiAgICAgIGVwdHIgKz0gMVxuICAgICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgICBlYSA9IGFicyhlaSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGZpXG4gICAgICBmcHRyICs9IDFcbiAgICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgICAgIGZhID0gYWJzKGZpKVxuICAgICAgfVxuICAgIH1cbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gIH1cbiAgd2hpbGUoZXB0ciA8IG5lKSB7XG4gICAgYSA9IGVpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgfVxuICB9XG4gIHdoaWxlKGZwdHIgPCBuZikge1xuICAgIGEgPSBmaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9IFxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgfVxuICB9XG4gIGlmKHEwKSB7XG4gICAgZ1tjb3VudCsrXSA9IHEwXG4gIH1cbiAgaWYocTEpIHtcbiAgICBnW2NvdW50KytdID0gcTFcbiAgfVxuICBpZighY291bnQpIHtcbiAgICBnW2NvdW50KytdID0gMC4wICBcbiAgfVxuICBnLmxlbmd0aCA9IGNvdW50XG4gIHJldHVybiBnXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBsaW5lYXJFeHBhbnNpb25TdW1cblxuLy9FYXN5IGNhc2U6IEFkZCB0d28gc2NhbGFyc1xuZnVuY3Rpb24gc2NhbGFyU2NhbGFyKGEsIGIpIHtcbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgYXYgPSB4IC0gYnZcbiAgdmFyIGJyID0gYiAtIGJ2XG4gIHZhciBhciA9IGEgLSBhdlxuICB2YXIgeSA9IGFyICsgYnJcbiAgaWYoeSkge1xuICAgIHJldHVybiBbeSwgeF1cbiAgfVxuICByZXR1cm4gW3hdXG59XG5cbmZ1bmN0aW9uIGxpbmVhckV4cGFuc2lvblN1bShlLCBmKSB7XG4gIHZhciBuZSA9IGUubGVuZ3RofDBcbiAgdmFyIG5mID0gZi5sZW5ndGh8MFxuICBpZihuZSA9PT0gMSAmJiBuZiA9PT0gMSkge1xuICAgIHJldHVybiBzY2FsYXJTY2FsYXIoZVswXSwgZlswXSlcbiAgfVxuICB2YXIgbiA9IG5lICsgbmZcbiAgdmFyIGcgPSBuZXcgQXJyYXkobilcbiAgdmFyIGNvdW50ID0gMFxuICB2YXIgZXB0ciA9IDBcbiAgdmFyIGZwdHIgPSAwXG4gIHZhciBhYnMgPSBNYXRoLmFic1xuICB2YXIgZWkgPSBlW2VwdHJdXG4gIHZhciBlYSA9IGFicyhlaSlcbiAgdmFyIGZpID0gZltmcHRyXVxuICB2YXIgZmEgPSBhYnMoZmkpXG4gIHZhciBhLCBiXG4gIGlmKGVhIDwgZmEpIHtcbiAgICBiID0gZWlcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgZWEgPSBhYnMoZWkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGIgPSBmaVxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgaWYoKGVwdHIgPCBuZSAmJiBlYSA8IGZhKSB8fCAoZnB0ciA+PSBuZikpIHtcbiAgICBhID0gZWlcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgZWEgPSBhYnMoZWkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGEgPSBmaVxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgeSA9IGIgLSBidlxuICB2YXIgcTAgPSB5XG4gIHZhciBxMSA9IHhcbiAgdmFyIF94LCBfYnYsIF9hdiwgX2JyLCBfYXJcbiAgd2hpbGUoZXB0ciA8IG5lICYmIGZwdHIgPCBuZikge1xuICAgIGlmKGVhIDwgZmEpIHtcbiAgICAgIGEgPSBlaVxuICAgICAgZXB0ciArPSAxXG4gICAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICAgIGVhID0gYWJzKGVpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gZmlcbiAgICAgIGZwdHIgKz0gMVxuICAgICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICAgIGZpID0gZltmcHRyXVxuICAgICAgICBmYSA9IGFicyhmaSlcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICB9XG4gIHdoaWxlKGVwdHIgPCBuZSkge1xuICAgIGEgPSBlaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgIH1cbiAgfVxuICB3aGlsZShmcHRyIDwgbmYpIHtcbiAgICBhID0gZmlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfSBcbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgfVxuICB9XG4gIGlmKHEwKSB7XG4gICAgZ1tjb3VudCsrXSA9IHEwXG4gIH1cbiAgaWYocTEpIHtcbiAgICBnW2NvdW50KytdID0gcTFcbiAgfVxuICBpZighY291bnQpIHtcbiAgICBnW2NvdW50KytdID0gMC4wICBcbiAgfVxuICBnLmxlbmd0aCA9IGNvdW50XG4gIHJldHVybiBnXG59IiwidmFyIGlzZWN0cyA9IHJlcXVpcmUoJ2dlb2pzb24tcG9seWdvbi1zZWxmLWludGVyc2VjdGlvbnMnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnQHR1cmYvaGVscGVycycpO1xudmFyIHdpdGhpbiA9IHJlcXVpcmUoJ0B0dXJmL3dpdGhpbicpO1xudmFyIGFyZWEgPSByZXF1aXJlKCdAdHVyZi9hcmVhJyk7XG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlcG9seWdvbicpO1xudmFyIGRlYnVnQWxsID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlcG9seWdvbjphbGwnKTtcblxuLyoqXG4qIFRha2VzIGEgY29tcGxleCAoaS5lLiBzZWxmLWludGVyc2VjdGluZykgZ2VvanNvbiBwb2x5Z29uLCBhbmQgYnJlYWtzIGl0IGRvd24gaW50byBpdHMgY29tcG9zaXRlIHNpbXBsZSwgbm9uLXNlbGYtaW50ZXJzZWN0aW5nIG9uZS1yaW5nIHBvbHlnb25zLlxuKlxuKiBAbW9kdWxlIHNpbXBsZXBvbHlnb25cbiogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIElucHV0IHBvbHlnb24uIFRoaXMgcG9seWdvbiBtYXkgYmUgdW5jb25mb3JtIHRoZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2ltcGxlX0ZlYXR1cmVzfFNpbXBsZSBGZWF0dXJlcyBzdGFuZGFyZH0gaW4gdGhlIHNlbnNlIHRoYXQgaXQncyBpbm5lciBhbmQgb3V0ZXIgcmluZ3MgbWF5IGNyb3NzLWludGVyc2VjdCBvciBzZWxmLWludGVyc2VjdCwgdGhhdCB0aGUgb3V0ZXIgcmluZyBtdXN0IG5vdCBjb250YWluIHRoZSBvcHRpb25hbCBpbm5lciByaW5ncyBhbmQgdGhhdCB0aGUgd2luZGluZyBudW1iZXIgbXVzdCBub3QgYmUgcG9zaXRpdmUgZm9yIHRoZSBvdXRlciBhbmQgbmVnYXRpdmUgZm9yIHRoZSBpbm5lciByaW5ncy5cbiogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb259IEZlYXR1cmUgY29sbGVjdGlvbiBjb250YWluaW5nIHRoZSBzaW1wbGUsIG5vbi1zZWxmLWludGVyc2VjdGluZyBvbmUtcmluZyBwb2x5Z29uIGZlYXR1cmVzIHRoYXQgdGhlIGNvbXBsZXggcG9seWdvbiBpcyBjb21wb3NlZCBvZi4gVGhlc2Ugc2ltcGxlIHBvbHlnb25zIGhhdmUgcHJvcGVydGllcyBzdWNoIGFzIHRoZWlyIHBhcmVudCBwb2x5Z29uLCB3aW5kaW5nIG51bWJlciBhbmQgbmV0IHdpbmRpbmcgbnVtYmVyLlxuKlxuKiBAZXhhbXBsZVxuKiB2YXIgcG9seSA9IHtcbiogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4qICAgXCJnZW9tZXRyeVwiOiB7XG4qICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4qICAgICBcImNvb3JkaW5hdGVzXCI6IFtbWzAsMF0sWzIsMF0sWzAsMl0sWzIsMl0sWzAsMF1dXVxuKiAgIH1cbiogfTtcbipcbiogdmFyIHJlc3VsdCA9IHNpbXBsZXBvbHlnb24ocG9seSk7XG4qXG4qIC8vID1yZXN1bHRcbiogLy8gd2hpY2ggd2lsbCBiZSBhIGZlYXR1cmVDb2xsZWN0aW9uIG9mIHR3byBwb2x5Z29ucywgb25lIHdpdGggY29vcmRpbmF0ZXMgW1tbMCwwXSxbMiwwXSxbMSwxXSxbMCwwXV1dLCBwYXJlbnQgLTEsIHdpbmRpbmcgMSBhbmQgbmV0IHdpbmRpbmcgMSwgYW5kIG9uZSB3aXRoIGNvb3JkaW5hdGVzIFtbWzEsMV0sWzAsMl0sWzIsMl0sWzEsMV1dXSwgcGFyZW50IC0xLCB3aW5kaW5nIC0xIGFuZCBuZXQgd2luZGluZyAtMVxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gIC8vIENoZWNrIGlucHV0XG4gIGlmIChmZWF0dXJlLnR5cGUgIT0gXCJGZWF0dXJlXCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbnB1dCBtdXN0IGEgZ2VvanNvbiBvYmplY3Qgb2YgdHlwZSBGZWF0dXJlXCIpO1xuICBpZiAoKGZlYXR1cmUuZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkgfHwgKGZlYXR1cmUuZ2VvbWV0cnkgPT0gbnVsbCkpIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbnB1dCBtdXN0IGEgZ2VvanNvbiBvYmplY3Qgd2l0aCBhIG5vbi1lbXB0eSBnZW9tZXRyeVwiKTtcbiAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSAhPSBcIlBvbHlnb25cIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGlucHV0IG11c3QgYmUgYSBnZW9qc29uIFBvbHlnb25cIik7XG5cbiAgLy8gUHJvY2VzcyBpbnB1dFxuICB2YXIgbnVtUmluZ3MgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgdmFyIHZlcnRpY2VzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUmluZ3M7IGkrKykge1xuICAgIHZhciByaW5nID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1tpXTtcbiAgICBpZiAoIWVxdWFsQXJyYXlzKHJpbmdbMF0scmluZ1tyaW5nLmxlbmd0aC0xXSkpIHtcbiAgICAgIHJpbmcucHVzaChyaW5nWzBdKSAvLyBDbG9zZSBpbnB1dCByaW5nIGlmIGl0IGlzIG5vdFxuICAgIH1cbiAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLHJpbmcuc2xpY2UoMCxyaW5nLmxlbmd0aC0xKSk7XG4gIH1cbiAgaWYgKCFpc1VuaXF1ZSh2ZXJ0aWNlcykpIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbnB1dCBwb2x5Z29uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgdmVydGljZXMgKGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IHZlcnRleCBvZiBlYWNoIHJpbmcpXCIpO1xuICB2YXIgbnVtdmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7IC8vIG51bWJlciBvZiBpbnB1dCByaW5nIHZlcnRpY2VzLCB3aXRoIHRoZSBsYXN0IGNsb3NpbmcgdmVydGljZXMgbm90IGNvdW50ZWRcbiAgZGVidWcoXCJQcm9jZXNzaW5nIGlucHV0XCIpO1xuXG4gIC8vIENvbXB1dGUgc2VsZi1pbnRlcnNlY3Rpb25zXG4gIHZhciBzZWxmSXNlY3RzRGF0YSA9IGlzZWN0cyhmZWF0dXJlLCBmdW5jdGlvbiBmaWx0ZXJGbihpc2VjdCwgcmluZzAsIGVkZ2UwLCBzdGFydDAsIGVuZDAsIGZyYWMwLCByaW5nMSwgZWRnZTEsIHN0YXJ0MSwgZW5kMSwgZnJhYzEsIHVuaXF1ZSl7XG4gICAgcmV0dXJuIFtpc2VjdCwgcmluZzAsIGVkZ2UwLCBzdGFydDAsIGVuZDAsIGZyYWMwLCByaW5nMSwgZWRnZTEsIHN0YXJ0MSwgZW5kMSwgZnJhYzEsIHVuaXF1ZV07XG4gIH0pO1xuICB2YXIgbnVtU2VsZklzZWN0ID0gc2VsZklzZWN0c0RhdGEubGVuZ3RoO1xuICBkZWJ1ZyhcIkNvbXB1dGluZyBzZWxmLWludGVyc2VjdGlvbnNcIik7XG5cbiAgLy8gSWYgbm8gc2VsZi1pbnRlcnNlY3Rpb25zIGFyZSBmb3VuZCwgdGhlIGlucHV0IHJpbmdzIGFyZSB0aGUgb3V0cHV0IHJpbmdzLiBIZW5jZSwgd2UgbXVzdCBvbmx5IGNvbXB1dGUgdGhlaXIgd2luZGluZyBudW1iZXJzLCBuZXQgd2luZGluZyBudW1iZXJzIGFuZCAoc2luY2Ugb2hlcnMgcmluZ3MgY291bGQgbGllIG91dHNpZGUgdGhlIGZpcnN0IHJpbmcpIHBhcmVudHMuXG4gIGlmIChudW1TZWxmSXNlY3QgPT0gMCkge1xuICAgIHZhciBvdXRwdXRGZWF0dXJlQXJyYXkgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtUmluZ3M7IGkrKykge1xuICAgICAgb3V0cHV0RmVhdHVyZUFycmF5LnB1c2goaGVscGVycy5wb2x5Z29uKFtmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldXSx7cGFyZW50OiAtMSwgd2luZGluZzogd2luZGluZ09mUmluZyhmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldKX0pKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb24ob3V0cHV0RmVhdHVyZUFycmF5KVxuICAgIGRldGVybWluZVBhcmVudHMoKTtcbiAgICBzZXROZXRXaW5kaW5nKCk7XG4gICAgZGVidWdBbGwoXCJObyBzZWxmLWludGVyc2VjdGlvbnMgZm91bmQuIElucHV0IHJpbmdzIGFyZSBvdXRwdXQgcmluZ3MuIENvbXB1dGVkIHdpbmRpbmcgbnVtYmVycywgbmV0IHdpbmRpbmcgbnVtYmVycyBhbmQgcGFyZW50c1wiKTtcbiAgICBkZWJ1ZyhcIkZpbmlzaGluZyB3aXRob3V0IHNlbGYtaW50ZXJzZWN0aW9uc1wiKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLy8gSWYgc2VsZi1pbnRlcnNlY3Rpb25zIGFyZSBmb3VuZCwgd2Ugd2lsbCBjb21wdXRlIHRoZSBvdXRwdXQgcmluZ3Mgd2l0aCB0aGUgaGVscCBvZiB0d28gaW50ZXJtZWRpYXRlIHZhcmlhYmxlc1xuICAvLyBGaXJzdCwgd2UgYnVpbGQgdGhlIHBzZXVkbyB2ZXJ0ZXggbGlzdCBhbmQgaW50ZXJzZWN0aW9uIGxpc3RcbiAgLy8gVGhlIFBzZXVkbyB2ZXJ0ZXggbGlzdCBpcyBhbiBhcnJheSB3aXRoIGZvciBlYWNoIHJpbmcgYW4gYXJyYXkgd2l0aCBmb3IgZWFjaCBlZGdlIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBzZXVkby12ZXJ0aWNlcyAoYXMgbWFkZSBieSB0aGVpciBjb25zdHJ1Y3RvcikgdGhhdCBoYXZlIHRoaXMgcmluZyBhbmQgZWRnZSBhcyByaW5nQW5kRWRnZUluLCBzb3J0ZWQgZm9yIGVhY2ggZWRnZSBieSB0aGVpciBmcmFjdGlvbmFsIGRpc3RhbmNlIG9uIHRoaXMgZWRnZS4gSXQncyBsZW5ndGggaGVuY2UgZXF1YWxzIG51bVJpbmdzLlxuICB2YXIgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2UgPSBbXTtcbiAgLy8gVGhlIGludGVyc2VjdGlvbiBsaXN0IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgaW50ZXJzZWN0aW9ucyAoYXMgbWFkZSBieSB0aGVpciBjb25zdHJ1Y3RvcikuIEZpcnN0IGFsbCBudW12ZXJ0aWNlcyByaW5nLXZlcnRleC1pbnRlcnNlY3Rpb25zLCB0aGVuIGFsbCBzZWxmLWludGVyc2VjdGlvbnMgKGludHJhLSBhbmQgaW50ZXItcmluZykuIFRoZSBvcmRlciBvZiB0aGUgbGF0dGVyIGlzIG5vdCBpbXBvcnRhbnQgYnV0IGlzIHBlcm1hbmVudCBvbmNlIGdpdmVuLlxuICB2YXIgaXNlY3RMaXN0ID0gW107XG4gIC8vIEFkZGluZyByaW5nLXBzZXVkby12ZXJ0aWNlcyB0byBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZSBhbmQgcmluZy12ZXJ0ZXgtaW50ZXJzZWN0aW9ucyB0byBpc2VjdExpc3RcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1SaW5nczsgaSsrKSB7XG4gICAgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2UucHVzaChbXSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldLmxlbmd0aC0xOyBqKyspIHtcbiAgICAgIC8vIEVhY2ggZWRnZSB3aWxsIGZlYXR1cmUgb25lIHJpbmctcHNldWRvLXZlcnRleCBpbiBpdHMgYXJyYXksIG9uIHRoZSBsYXN0IHBvc2l0aW9uLiBpLmUuIGVkZ2UgaiBmZWF0dXJlcyB0aGUgcmluZy1wc2V1ZG8tdmVydGV4IG9mIHRoZSByaW5nIHZlcnRleCBqKzEsIHdoaWNoIGhhcyByaW5nQW5kRWRnZUluID0gW2ksal0sIG9uIHRoZSBsYXN0IHBvc2l0aW9uLlxuICAgICAgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2VbaV0ucHVzaChbbmV3IFBzZXVkb1Z0eChmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldWyhqKzEpLm1vZHVsbyhmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldLmxlbmd0aC0xKV0sIDEsIFtpLCBqXSwgW2ksIChqKzEpLm1vZHVsbyhmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldLmxlbmd0aC0xKV0sIHVuZGVmaW5lZCldKTtcbiAgICAgIC8vIFRoZSBmaXJzdCBudW12ZXJ0aWNlcyBlbGVtZW50cyBpbiBpc2VjdExpc3QgY29ycmVzcG9uZCB0byB0aGUgcmluZy12ZXJ0ZXgtaW50ZXJzZWN0aW9uc1xuICAgICAgaXNlY3RMaXN0LnB1c2gobmV3IElzZWN0KGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1bal0sIFtpLCAoai0xKS5tb2R1bG8oZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1tpXS5sZW5ndGgtMSldLCBbaSwgal0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH1cbiAgfVxuICAvLyBBZGRpbmcgaW50ZXJzZWN0aW9uLXBzZXVkby12ZXJ0aWNlcyB0byBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZSBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIHRvIGlzZWN0TGlzdFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlbGZJc2VjdDsgaSsrKSB7XG4gICAgLy8gQWRkaW5nIGludGVyc2VjdGlvbi1wc2V1ZG8tdmVydGljZXMgbWFkZSB1c2luZyBzZWxmSXNlY3RzRGF0YSB0byBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZSdzIGFycmF5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGluY29tbWluZyByaW5nIGFuZCBlZGdlXG4gICAgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2Vbc2VsZklzZWN0c0RhdGFbaV1bMV1dW3NlbGZJc2VjdHNEYXRhW2ldWzJdXS5wdXNoKG5ldyBQc2V1ZG9WdHgoc2VsZklzZWN0c0RhdGFbaV1bMF0sIHNlbGZJc2VjdHNEYXRhW2ldWzVdLCBbc2VsZklzZWN0c0RhdGFbaV1bMV0sIHNlbGZJc2VjdHNEYXRhW2ldWzJdXSwgW3NlbGZJc2VjdHNEYXRhW2ldWzZdLCBzZWxmSXNlY3RzRGF0YVtpXVs3XV0sIHVuZGVmaW5lZCkpO1xuICAgIC8vIHNlbGZJc2VjdHNEYXRhIGNvbnRhaW5zIGRvdWJsZSBtZW50aW9ucyBvZiBlYWNoIGludGVyc2VjdGlvbiwgYnV0IHdlIG9ubHkgd2FudCB0byBhZGQgdGhlbSBvbmNlIHRvIGlzZWN0TGlzdFxuICAgIGlmIChzZWxmSXNlY3RzRGF0YVtpXVsxMV0pIGlzZWN0TGlzdC5wdXNoKG5ldyBJc2VjdChzZWxmSXNlY3RzRGF0YVtpXVswXSwgW3NlbGZJc2VjdHNEYXRhW2ldWzFdLCBzZWxmSXNlY3RzRGF0YVtpXVsyXV0sIFtzZWxmSXNlY3RzRGF0YVtpXVs2XSwgc2VsZklzZWN0c0RhdGFbaV1bN11dLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgdHJ1ZSkpO1xuICB9XG4gIHZhciBudW1Jc2VjdCA9IGlzZWN0TGlzdC5sZW5ndGg7XG4gIC8vIFNvcnQgZWRnZSBhcnJheXMgb2YgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2UgYnkgdGhlIGZyYWN0aW9uYWwgZGlzdGFuY2UgJ3BhcmFtJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2VbaV1bal0uc29ydChmdW5jdGlvbihhLCBiKXsgcmV0dXJuIChhLnBhcmFtIDwgYi5wYXJhbSkgPyAtMSA6IDEgOyB9ICk7XG4gICAgfVxuICB9XG4gIGRlYnVnKFwiU2V0dGluZyB1cCBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZSBhbmQgaXNlY3RMaXN0XCIpO1xuXG4gIC8vIE1ha2UgYSBzcGF0aWFsIGluZGV4IG9mIGludGVyc2VjdGlvbnMsIGluIHByZXBlcmF0aW9uIGZvciB0aGUgZm9sbG93aW5nIHR3byBzdGVwc1xuICBhbGxJc2VjdHNBc0lzZWN0UmJ1c2hUcmVlSXRlbSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUlzZWN0OyBpKyspIHtcbiAgICBhbGxJc2VjdHNBc0lzZWN0UmJ1c2hUcmVlSXRlbS5wdXNoKHttaW5YOiBpc2VjdExpc3RbaV0uY29vcmRbMF0sIG1pblk6IGlzZWN0TGlzdFtpXS5jb29yZFsxXSwgbWF4WDogaXNlY3RMaXN0W2ldLmNvb3JkWzBdLCBtYXhZOiBpc2VjdExpc3RbaV0uY29vcmRbMV0sIGluZGV4OiBpfSk7IC8vIGNvdWxkIHBhc3MgaXNlY3Q6IGlzZWN0TGlzdFtpXSwgYnV0IG5vdCBuZWNlc3NhcnlcbiAgfVxuICB2YXIgaXNlY3RSYnVzaFRyZWUgPSByYnVzaCgpO1xuICBpc2VjdFJidXNoVHJlZS5sb2FkKGFsbElzZWN0c0FzSXNlY3RSYnVzaFRyZWVJdGVtKTtcblxuICAvLyBOb3cgd2Ugd2lsbCB0ZWFjaCBlYWNoIGludGVyc2VjdGlvbiBpbiBpc2VjdExpc3Qgd2hpY2ggaXMgdGhlIG5leHQgaW50ZXJzZWN0aW9uIGFsb25nIGJvdGggaXQncyBbcmluZywgZWRnZV0ncywgaW4gdHdvIHN0ZXBzLlxuICAvLyBGaXJzdCwgd2UgZmluZCB0aGUgbmV4dCBpbnRlcnNlY3Rpb24gZm9yIGVhY2ggcHNldWRvLXZlcnRleCBpbiBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZTpcbiAgLy8gRm9yIGVhY2ggcHNldWRvdmVydGV4IGluIHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlICgzIGxvb3BzKSBsb29rIGF0IHRoZSBuZXh0IHBzZXVkb3ZlcnRleCBvbiB0aGF0IGVkZ2UgYW5kIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgaW50ZXJzZWN0aW9uIGJ5IGNvbXBhcmluZyBjb29yZGluYXRlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlLmxlbmd0aDsgaSsrKXtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2VbaV1bal0ubGVuZ3RoOyBrKyspe1xuICAgICAgICB2YXIgY29vcmRUb0ZpbmQ7XG4gICAgICAgIGlmIChrID09IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlW2ldW2pdLmxlbmd0aC0xKSB7IC8vIElmIGl0J3MgdGhlIGxhc3QgcHNldWRvVmVydGV4IG9uIHRoYXQgZWRnZSwgdGhlbiB0aGUgbmV4dCBwc2V1ZG9WZXJ0ZXggaXMgdGhlIGZpcnN0IG9uZSBvbiB0aGUgbmV4dCBlZGdlIG9mIHRoYXQgcmluZy5cbiAgICAgICAgICBjb29yZFRvRmluZCA9IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlW2ldWyhqKzEpLm1vZHVsbyhmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldLmxlbmd0aC0xKV1bMF0uY29vcmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRUb0ZpbmQgPSBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZVtpXVtqXVtrKzFdLmNvb3JkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBJc2VjdFJidXNoVHJlZUl0ZW1Gb3VuZCA9IGlzZWN0UmJ1c2hUcmVlLnNlYXJjaCh7bWluWDogY29vcmRUb0ZpbmRbMF0sIG1pblk6IGNvb3JkVG9GaW5kWzFdLCBtYXhYOiBjb29yZFRvRmluZFswXSwgbWF4WTogY29vcmRUb0ZpbmRbMV19KVswXTsgLy8gV2UgY2FuIHRha2UgWzBdIG9mIHRoZSByZXN1bHQsIGJlY2F1c2UgdGhlcmUgaXMgb25seSBvbmUgaXNlY3QgY29ycmVwb25kaW5nIHRvIGEgcHNldWRvLXZlcnRleFxuICAgICAgICBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZVtpXVtqXVtrXS5ueHRJc2VjdEFsb25nRWRnZUluID0gSXNlY3RSYnVzaFRyZWVJdGVtRm91bmQuaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlYnVnKFwiQ29tcHV0aW5nIG5leHRJc2VjdCBmb3IgcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2VcIik7XG5cbiAgLy8gU2Vjb25kLCB3ZSBwb3J0IHRoaXMga25vd2xlZGdlIG9mIHRoZSBuZXh0IGludGVyc2VjdGlvbiBvdmVyIHRvIHRoZSBpbnRlcnNlY3Rpb25zIGluIGlzZWN0TGlzdCwgYnkgZmluZGluZyB0aGUgaW50ZXJzZWN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBwc2V1ZG8tdmVydGV4IGFuZCBjb3B5aW5nIHRoZSBwc2V1ZG8tdmVydGV4JyBrbm93bmxlZGdlIG9mIHRoZSBuZXh0LWludGVyc2VjdGlvbiBvdmVyIHRvIHRoZSBpbnRlcnNlY3Rpb25cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZS5sZW5ndGg7IGkrKyl7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZVtpXS5sZW5ndGg7IGorKyl7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlW2ldW2pdLmxlbmd0aDsgaysrKXtcbiAgICAgICAgdmFyIGNvb3JkVG9GaW5kID0gcHNldWRvVnR4TGlzdEJ5UmluZ0FuZEVkZ2VbaV1bal1ba10uY29vcmQ7XG4gICAgICAgIHZhciBJc2VjdFJidXNoVHJlZUl0ZW1Gb3VuZCA9IGlzZWN0UmJ1c2hUcmVlLnNlYXJjaCh7bWluWDogY29vcmRUb0ZpbmRbMF0sIG1pblk6IGNvb3JkVG9GaW5kWzFdLCBtYXhYOiBjb29yZFRvRmluZFswXSwgbWF4WTogY29vcmRUb0ZpbmRbMV19KVswXTsgLy8gV2UgY2FuIHRha2UgWzBdIG9mIHRoZSByZXN1bHQsIGJlY2F1c2UgdGhlcmUgaXMgb25seSBvbmUgaXNlY3QgY29ycmVwb25kaW5nIHRvIGEgcHNldWRvLXZlcnRleFxuICAgICAgICB2YXIgbCA9IElzZWN0UmJ1c2hUcmVlSXRlbUZvdW5kLmluZGV4O1xuICAgICAgICBpZiAobCA8IG51bXZlcnRpY2VzKSB7IC8vIFNwZWNpYWwgdHJlYXRtZW50IGF0IHJpbmctdmVydGljZXM6IHdlIGNvcnJlY3QgdGhlIG1pc25hbWluZyB0aGF0IGhhcHBlbmVkIGluIHRoZSBwcmV2aW91cyBibG9jaywgc2luY2UgcmluZ0FuZEVkZ2VPdXQgPSByaW5nQW5kRWRnZTIgZm9yIHJpbmcgdmVydGljZXMuXG4gICAgICAgICAgICBpc2VjdExpc3RbbF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMiA9IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlW2ldW2pdW2tdLm54dElzZWN0QWxvbmdFZGdlSW47XG4gICAgICAgIH0gZWxzZSB7IC8vIFBvcnQgdGhlIGtub3dsZWRnZSBvZiB0aGUgbmV4dCBpbnRlcnNlY3Rpb24gZnJvbSB0aGUgcHNldWRvLXZlcnRpY2VzIHRvIHRoZSBpbnRlcnNlY3Rpb25zLCBkZXBlbmRpbmcgb24gaG93IHRoZSBlZGdlcyBhcmUgbGFiZWxlZCBpbiB0aGUgcHNldWRvLXZlcnRleCBhbmQgaW50ZXJzZWN0aW9uLlxuICAgICAgICAgIGlmIChlcXVhbEFycmF5cyhpc2VjdExpc3RbbF0ucmluZ0FuZEVkZ2UxLCBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZVtpXVtqXVtrXS5yaW5nQW5kRWRnZUluKSkge1xuICAgICAgICAgICAgaXNlY3RMaXN0W2xdLm54dElzZWN0QWxvbmdSaW5nQW5kRWRnZTEgPSBwc2V1ZG9WdHhMaXN0QnlSaW5nQW5kRWRnZVtpXVtqXVtrXS5ueHRJc2VjdEFsb25nRWRnZUluO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc2VjdExpc3RbbF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMiA9IHBzZXVkb1Z0eExpc3RCeVJpbmdBbmRFZGdlW2ldW2pdW2tdLm54dElzZWN0QWxvbmdFZGdlSW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRoaXMgZXhwbGFpbnMgd2h5LCBldmVudGhvdWdoIHdoZW4gd2Ugd2lsbCB3YWxrIGF3YXkgZnJvbSBhbiBpbnRlcnNlY3Rpb24sIHdlIHdpbGwgd2FsayB3YXkgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwc2V1ZG8tdmVydGV4IGFsb25nIGVkZ2VPdXQsIHBzZXVkby12ZXJ0aWNlcyBoYXZlIHRoZSBwcm9wZXJ0eSAnbnh0SXNlY3RBbG9uZ0VkZ2VJbicgaW4gc3RlYWQgb2Ygc29tZSBwcm9wZXJ5ICdueHRQc2V1ZG9WdHhBbG9uZ0VkZ2VPdXQnLiBUaGlzIGlzIGJlY2F1c2UgdGhpcyBwcm9wZXJ0eSAod2hpY2ggaXMgZWFzeSB0byBmaW5kIG91dCkgaXMgdXNlZCBpbiB0aGUgYWJvdmUgZm9yIG54dElzZWN0QWxvbmdSaW5nQW5kRWRnZTEgYW5kIG54dElzZWN0QWxvbmdSaW5nQW5kRWRnZTIhXG4gIGRlYnVnKFwiUG9ydGluZyBuZXh0SXNlY3QgdG8gaXNlY3RMaXN0XCIpO1xuXG4gIC8vIEJlZm9yZSB3ZSBzdGFydCB3YWxraW5nIG92ZXIgdGhlIGludGVyc2VjdGlvbnMgdG8gYnVpbGQgdGhlIG91dHB1dCByaW5ncywgd2UgcHJlcGFyZSBhIHF1ZXVlIHRoYXQgc3RvcmVzIGluZm9ybWF0aW9uIG9uIGludGVyc2VjdGlvbnMgd2Ugc3RpbGwgaGF2ZSB0byBkZWFsIHdpdGgsIGFuZCBwdXQgYXQgbGVhc3Qgb25lIGludGVyc2VjdGlvbiBpbiBpdC5cbiAgLy8gVGhpcyBxdWV1ZSB3aWxsIGNvbnRhaW4gaW5mb3JtYXRpb24gb24gaW50ZXJzZWN0aW9ucyB3aGVyZSB3ZSBjYW4gc3RhcnQgd2Fsa2luZyBmcm9tIG9uY2UgdGhlIGN1cnJlbnQgd2FsayBpcyBmaW5pc2hlZCwgYW5kIGl0cyBwYXJlbnQgb3V0cHV0IHJpbmcgKHRoZSBzbWFsbGVzdCBvdXRwdXQgcmluZyBpdCBsaWVzIHdpdGhpbiwgLTEgaWYgbm8gcGFyZW50IG9yIHBhcmVudCB1bmtub3duIHlldCkgYW5kIGl0cyB3aW5kaW5nIG51bWJlciAod2hpY2ggd2UgY2FuIGFscmVhZHkgZGV0ZXJtaW5lKS5cbiAgdmFyIHF1ZXVlID0gW11cbiAgLy8gRm9yIGVhY2ggb3V0cHV0IHJpbmcsIGFkZCB0aGUgcmluZy12ZXJ0ZXgtaW50ZXJzZWN0aW9uIHdpdGggdGhlIHNtYWxsZXMgeC12YWx1ZSAoaS5lLiB0aGUgbGVmdC1tb3N0KSBhcyBhIHN0YXJ0IGludGVyc2VjdGlvbi4gQnkgY2hvb3Npbmcgc3VjaCBhbiBleHRyZW1hbCBpbnRlcnNlY3Rpb25zLCB3ZSBhcmUgc3VyZSB0byBzdGFydCBhdCBhbiBpbnRlcnNlY3Rpb24gdGhhdCBpcyBhIGNvbnZleCB2ZXJ0ZXggb2YgaXRzIG91dHB1dCByaW5nLiBCeSBhZGRpbmcgdGhlbSBhbGwgdG8gdGhlIHF1ZXVlLCB3ZSBhcmUgc3VyZSB0aGF0IG5vIHJpbmdzIHdpbGwgYmUgZm9yZ290dGVuLiBJZiBkdWUgdG8gcmluZy1pbnRlcnNlY3Rpb25zIHN1Y2ggYW4gaW50ZXJzZWN0aW9uIHdpbGwgYmUgZW5jb3VudGVyZWQgd2hpbGUgd2Fsa2luZywgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHF1ZXVlLlxuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmluZ3M7IGorKykge1xuICAgIHZhciBsZWZ0SXNlY3QgPSBpO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1tqXS5sZW5ndGgtMTsgaysrKSB7XG4gICAgICBpZiAoaXNlY3RMaXN0W2ldLmNvb3JkWzBdIDwgaXNlY3RMaXN0W2xlZnRJc2VjdF0uY29vcmRbMF0pIHtcbiAgICAgICAgbGVmdElzZWN0ID0gaTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB3aW5kaW5nIGF0IHRoaXMgbGVmdC1tb3N0IHJpbmctdmVydGV4LWludGVyc2VjdGlvbi4gV2UgdGh1cyB0aGlzIGJ5IHVzaW5nIG91ciBrbm93bGVkZ2UgdGhhdCB0aGlzIGV4dHJlbWFsIHZlcnRleCBtdXN0IGJlIGEgY29udmV4IHZlcnRleC5cbiAgICAvLyBXZSBmaXJzdCBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gYmVmb3JlIGFuZCBhZnRlciBpdCwgYW5kIHRoZW4gdXNlIHRoZW0gdG8gZGV0ZXJtaW5lIHRoZSB3aW5kaW5nIG51bWJlciBvZiB0aGUgY29ycmVzcG9uZGluZyBvdXRwdXQgcmluZywgc2luY2Ugd2Uga25vdyB0aGF0IGFuIGV4dHJlbWFsIHZlcnRleCBvZiBhIHNpbXBsZSwgbm9uLXNlbGYtaW50ZXJzZWN0aW5nIHJpbmcgaXMgYWx3YXlzIGNvbnZleCwgc28gdGhlIG9ubHkgcmVhc29uIGl0IHdvdWxkIG5vdCBiZSBpcyBiZWNhdXNlIHRoZSB3aW5kaW5nIG51bWJlciB3ZSB1c2UgdG8gY29tcHV0ZSBpdCBpcyB3cm9uZ1xuICAgIHZhciBpc2VjdEFmdGVyTGVmdElzZWN0ID0gaXNlY3RMaXN0W2xlZnRJc2VjdF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGlzZWN0TGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgaWYgKChpc2VjdExpc3Rba10ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMSA9PSBsZWZ0SXNlY3QpIHx8IChpc2VjdExpc3Rba10ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMiA9PSBsZWZ0SXNlY3QpKSB7XG4gICAgICAgIHZhciBpc2VjdEJlZm9yZUxlZnRJc2VjdCA9IGs7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHZhciB3aW5kaW5nQXRJc2VjdCA9IGlzQ29udmV4KFtpc2VjdExpc3RbaXNlY3RCZWZvcmVMZWZ0SXNlY3RdLmNvb3JkLGlzZWN0TGlzdFtsZWZ0SXNlY3RdLmNvb3JkLGlzZWN0TGlzdFtpc2VjdEFmdGVyTGVmdElzZWN0XS5jb29yZF0sdHJ1ZSkgPyAxIDogLTE7XG5cbiAgICBxdWV1ZS5wdXNoKHtpc2VjdDogbGVmdElzZWN0LCBwYXJlbnQ6IC0xLCB3aW5kaW5nOiB3aW5kaW5nQXRJc2VjdH0pXG4gIH1cbiAgLy8gU29ydCB0aGUgcXVldWUgYnkgdGhlIHNhbWUgY3JpdGVyaW9uIHVzZWQgdG8gZmluZCB0aGUgbGVmdElzZWN0OiB0aGUgbGVmdC1tb3N0IGxlZnRJc2VjdCBtdXN0IGJlIGxhc3QgaW4gdGhlIHF1ZXVlLCBzdWNoIHRoYXQgaXQgd2lsbCBiZSBwb3BwZWQgZmlyc3QsIHN1Y2ggdGhhdCB3ZSB3aWxsIHdvcmsgZnJvbSBvdXQgdG8gaW4gcmVnYXJkaW5nIGlucHV0IHJpbmdzLiBUaGlzIGFzc3VtdGlvbiBpcyB1c2VkIHdoZW4gcHJlZGljdGluZyB0aGUgd2luZGluZyBudW1iZXIgYW5kIHBhcmVudCBvZiBhIG5ldyBxdWV1ZSBtZW1iZXIuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24oYSwgYil7IHJldHVybiAoaXNlY3RMaXN0W2EuaXNlY3RdLmNvb3JkID4gaXNlY3RMaXN0W2IuaXNlY3RdLmNvb3JkKSA/IC0xIDogMSB9KTtcbiAgZGVidWdBbGwoXCJJbml0aWFsIHN0YXRlIG9mIHRoZSBxdWV1ZTogXCIgKyBKU09OLnN0cmluZ2lmeShxdWV1ZSkpO1xuICBkZWJ1ZyhcIlNldHRpbmcgdXAgcXVldWVcIik7XG5cbiAgLy8gSW5pdGlhbGlzZSBvdXRwdXRcbiAgdmFyIG91dHB1dEZlYXR1cmVBcnJheSA9IFtdO1xuXG4gIC8vIFdoaWxlIHRoZSBxdWV1ZSBpcyBub3QgZW1wdHksIHRha2UgdGhlIGxhc3Qgb2JqZWN0IChpLmUuIGl0cyBpbnRlcnNlY3Rpb24pIG91dCBhbmQgc3RhcnQgbWFraW5nIGFuIG91dHB1dCByaW5nIGJ5IHdhbGtpbmcgaW4gdGhlIGRpcmVjdGlvbiB0aGF0IGhhcyBub3QgYmVlbiB3YWxrZWQgYXdheSBvdmVyIHlldC5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aD4wKSB7XG4gICAgLy8gR2V0IHRoZSBsYXN0IG9iamVjdCBvdXQgb2YgdGhlIHF1ZXVlXG4gICAgdmFyIHBvcHBlZCA9IHF1ZXVlLnBvcCgpO1xuICAgIHZhciBzdGFydElzZWN0ID0gcG9wcGVkLmlzZWN0O1xuICAgIHZhciBjdXJyZW50T3V0cHV0UmluZ1BhcmVudCA9IHBvcHBlZC5wYXJlbnQ7XG4gICAgdmFyIGN1cnJlbnRPdXRwdXRSaW5nV2luZGluZyA9IHBvcHBlZC53aW5kaW5nO1xuICAgIC8vIE1ha2UgbmV3IG91dHB1dCByaW5nIGFuZCBhZGQgdmVydGV4IGZyb20gc3RhcnRpbmcgaW50ZXJzZWN0aW9uXG4gICAgdmFyIGN1cnJlbnRPdXRwdXRSaW5nID0gb3V0cHV0RmVhdHVyZUFycmF5Lmxlbmd0aDtcbiAgICB2YXIgY3VycmVudE91dHB1dFJpbmdDb29yZHMgPSBbaXNlY3RMaXN0W3N0YXJ0SXNlY3RdLmNvb3JkXTtcbiAgICBkZWJ1Z0FsbChcIiMgU3RhcnRpbmcgb3V0cHV0IHJpbmcgbnVtYmVyIFwiICsgb3V0cHV0RmVhdHVyZUFycmF5Lmxlbmd0aCArIFwiIHdpdGggd2luZGluZyBcIiArIGN1cnJlbnRPdXRwdXRSaW5nV2luZGluZyArIFwiIGZyb20gaW50ZXJzZWN0aW9uIFwiICsgc3RhcnRJc2VjdCk7XG4gICAgaWYgKHN0YXJ0SXNlY3QgPCBudW12ZXJ0aWNlcykgZGVidWdBbGwoXCJUaGlzIGlzIGEgcmluZy12ZXJ0ZXgtaW50ZXJzZWN0aW9ucywgd2hpY2ggbWVhbnMgdGhpcyBvdXRwdXQgcmluZyBkb2VzIG5vdCB0b3VjaCBleGlzdGluZyBvdXRwdXQgcmluZ3NcIik7XG4gICAgLy8gU2V0IHVwIHRoZSB2YXJpYWJsZXMgdXNlZCB3aGlsZSB3YWxraW5nIG92ZXIgaW50ZXJzZWN0aW9uczogJ2N1cnJlbnRJc2VjdCcsICdueHRJc2VjdCcgYW5kICd3YWxraW5nUmluZ0FuZEVkZ2UnXG4gICAgdmFyIGN1cnJlbnRJc2VjdCA9IHN0YXJ0SXNlY3Q7XG4gICAgaWYgKGlzZWN0TGlzdFtzdGFydElzZWN0XS5yaW5nQW5kRWRnZTFXYWxrYWJsZSkge1xuICAgICAgdmFyIHdhbGtpbmdSaW5nQW5kRWRnZSA9IGlzZWN0TGlzdFtzdGFydElzZWN0XS5yaW5nQW5kRWRnZTE7XG4gICAgICB2YXIgbnh0SXNlY3QgPSBpc2VjdExpc3Rbc3RhcnRJc2VjdF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdhbGtpbmdSaW5nQW5kRWRnZSA9IGlzZWN0TGlzdFtzdGFydElzZWN0XS5yaW5nQW5kRWRnZTI7XG4gICAgICB2YXIgbnh0SXNlY3QgPSBpc2VjdExpc3Rbc3RhcnRJc2VjdF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMjtcbiAgICB9XG4gICAgLy8gV2hpbGUgd2UgaGF2ZSBub3QgYXJyaXZlZCBiYWNrIGF0IHRoZSBzYW1lIGludGVyc2VjdGlvbiwga2VlcCB3YWxraW5nXG4gICAgd2hpbGUgKCFlcXVhbEFycmF5cyhpc2VjdExpc3Rbc3RhcnRJc2VjdF0uY29vcmQsaXNlY3RMaXN0W254dElzZWN0XS5jb29yZCkpe1xuICAgICAgZGVidWdBbGwoXCJXYWxraW5nIGZyb20gaW50ZXJzZWN0aW9uIFwiICsgY3VycmVudElzZWN0ICsgXCIgdG8gXCIgKyBueHRJc2VjdCArIFwiIG92ZXIgcmluZyBcIiArIHdhbGtpbmdSaW5nQW5kRWRnZVswXSArIFwiIGFuZCBlZGdlIFwiICsgd2Fsa2luZ1JpbmdBbmRFZGdlWzFdKTtcbiAgICAgIGN1cnJlbnRPdXRwdXRSaW5nQ29vcmRzLnB1c2goaXNlY3RMaXN0W254dElzZWN0XS5jb29yZCk7XG4gICAgICBkZWJ1Z0FsbChcIkFkZGluZyBpbnRlcnNlY3Rpb24gXCIgKyBueHRJc2VjdCArIFwiIHRvIGN1cnJlbnQgb3V0cHV0IHJpbmdcIik7XG4gICAgICAvLyBJZiB0aGUgbmV4dCBpbnRlcnNlY3Rpb24gaXMgcXVldWVkLCB3ZSBjYW4gcmVtb3ZlIGl0LCBiZWNhdXNlIHdlIHdpbGwgZ28gdGhlcmUgbm93LlxuICAgICAgdmFyIG54dElzZWN0SW5RdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykgeyBpZiAocXVldWVbaV0uaXNlY3QgPT0gbnh0SXNlY3QpIHtueHRJc2VjdEluUXVldWUgPSBpOyBicmVhazsgfSB9XG4gICAgICBpZiAobnh0SXNlY3RJblF1ZXVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWJ1Z0FsbChcIlJlbW92aW5nIGludGVyc2VjdGlvbiBcIiArIG54dElzZWN0ICsgXCIgZnJvbSBxdWV1ZVwiKTtcbiAgICAgICAgcXVldWUuc3BsaWNlKG54dElzZWN0SW5RdWV1ZSwxKTtcbiAgICAgIH1cbiAgICAgIC8vIEFycml2aW5nIGF0IHRoaXMgbmV3IGludGVyc2VjdGlvbiwgd2Uga25vdyB3aGljaCB3aWxsIGJlIG91ciBuZXh0IHdhbGtpbmcgcmluZyBhbmQgZWRnZSAoaWYgd2UgY2FtZSBmcm9tIDEgd2Ugd2lsbCB3YWxrIGF3YXkgZnJvbSAyIGFuZCB2aWNlIHZlcnNhKSxcbiAgICAgIC8vIFNvIHdlIGNhbiBzZXQgaXQgYXMgb3VyIG5ldyB3YWxraW5nIHJpbmcgYW5kIGludGVyc2VjdGlvbiBhbmQgcmVtZW1iZXIgdGhhdCB3ZSAod2lsbCkgaGF2ZSB3YWxrZWQgb3ZlciBpdFxuICAgICAgLy8gSWYgd2UgaGF2ZSBuZXZlciB3YWxrZWQgYXdheSBmcm9tIHRoaXMgbmV3IGludGVyc2VjdGlvbiBhbG9uZyB0aGUgb3RoZXIgcmluZyBhbmQgZWRnZSB0aGVuIHdlIHdpbGwgc29vbiBkbywgYWRkIHRoZSBpbnRlcnNlY3Rpb24gKGFuZCB0aGUgcGFyZW50IHdhbmQgd2luZGluZyBudW1iZXIpIHRvIHRoZSBxdWV1ZVxuICAgICAgLy8gKFdlIGNhbiBwcmVkaWN0IHRoZSB3aW5kaW5nIG51bWJlciBhbmQgcGFyZW50IGFzIGZvbGxvd3M6IGlmIHRoZSBlZGdlIGlzIGNvbnZleCwgdGhlIG90aGVyIG91dHB1dCByaW5nIHN0YXJ0ZWQgZnJvbSB0aGVyZSB3aWxsIGhhdmUgdGhlIGFsdGVybmF0ZSB3aW5kaW5nIGFuZCBsaWUgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBvbmUsIGFuZCB0aHVzIGhhdmUgdGhlIHNhbWUgcGFyZW50IHJpbmcgYXMgdGhlIGN1cnJlbnQgcmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGhhdmUgdGhlIHNhbWUgd2luZGluZyBudW1iZXIgYW5kIGxpZSBpbnNpZGUgb2YgdGhlIGN1cnJlbnQgcmluZy4gV2UgYXJlLCBob3dldmVyLCBvbmx5IHN1cmUgb2YgdGhpcyBvZiBhbiBvdXRwdXQgcmluZyBzdGFydGVkIGZyb20gdGhlcmUgZG9lcyBub3QgZW5jbG9zZSB0aGUgY3VycmVudCByaW5nLiBUaGlzIGlzIHdoeSB0aGUgaW5pdGlhbCBxdWV1ZSdzIGludGVyc2VjdGlvbnMgbXVzdCBiZSBzb3J0ZWQgc3VjaCB0aGF0IG91dGVyIG9uZXMgY29tZSBvdXQgZmlyc3QuKVxuICAgICAgLy8gV2UgdGhlbiB1cGRhdGUgdGhlIG90aGVyIHR3byB3YWxraW5nIHZhcmlhYmxlcy5cbiAgICAgIGlmIChlcXVhbEFycmF5cyh3YWxraW5nUmluZ0FuZEVkZ2UsaXNlY3RMaXN0W254dElzZWN0XS5yaW5nQW5kRWRnZTEpKSB7XG4gICAgICAgIHdhbGtpbmdSaW5nQW5kRWRnZSA9IGlzZWN0TGlzdFtueHRJc2VjdF0ucmluZ0FuZEVkZ2UyO1xuICAgICAgICBpc2VjdExpc3Rbbnh0SXNlY3RdLnJpbmdBbmRFZGdlMldhbGthYmxlID0gZmFsc2U7XG4gICAgICAgIGlmIChpc2VjdExpc3Rbbnh0SXNlY3RdLnJpbmdBbmRFZGdlMVdhbGthYmxlKSB7XG4gICAgICAgICAgZGVidWdBbGwoXCJBZGRpbmcgaW50ZXJzZWN0aW9uIFwiICsgbnh0SXNlY3QgKyBcIiB0byBxdWV1ZVwiKTtcbiAgICAgICAgICB2YXIgcHVzaGluZyA9IHtpc2VjdDogbnh0SXNlY3R9O1xuICAgICAgICAgIGlmIChpc0NvbnZleChbaXNlY3RMaXN0W2N1cnJlbnRJc2VjdF0uY29vcmQsIGlzZWN0TGlzdFtueHRJc2VjdF0uY29vcmQsIGlzZWN0TGlzdFtpc2VjdExpc3Rbbnh0SXNlY3RdLm54dElzZWN0QWxvbmdSaW5nQW5kRWRnZTJdLmNvb3JkXSxjdXJyZW50T3V0cHV0UmluZ1dpbmRpbmcgPT0gMSkpIHtcbiAgICAgICAgICAgIHB1c2hpbmcucGFyZW50ID0gY3VycmVudE91dHB1dFJpbmdQYXJlbnQ7XG4gICAgICAgICAgICBwdXNoaW5nLndpbmRpbmcgPSAtY3VycmVudE91dHB1dFJpbmdXaW5kaW5nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoaW5nLnBhcmVudCA9IGN1cnJlbnRPdXRwdXRSaW5nO1xuICAgICAgICAgICAgcHVzaGluZy53aW5kaW5nID0gY3VycmVudE91dHB1dFJpbmdXaW5kaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5wdXNoKHB1c2hpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJc2VjdCA9IG54dElzZWN0O1xuICAgICAgICBueHRJc2VjdCA9IGlzZWN0TGlzdFtueHRJc2VjdF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbGtpbmdSaW5nQW5kRWRnZSA9IGlzZWN0TGlzdFtueHRJc2VjdF0ucmluZ0FuZEVkZ2UxO1xuICAgICAgICBpc2VjdExpc3Rbbnh0SXNlY3RdLnJpbmdBbmRFZGdlMVdhbGthYmxlID0gZmFsc2U7XG4gICAgICAgIGlmIChpc2VjdExpc3Rbbnh0SXNlY3RdLnJpbmdBbmRFZGdlMldhbGthYmxlKSB7XG4gICAgICAgICAgZGVidWdBbGwoXCJBZGRpbmcgaW50ZXJzZWN0aW9uIFwiICsgbnh0SXNlY3QgKyBcIiB0byBxdWV1ZVwiKTtcbiAgICAgICAgICB2YXIgcHVzaGluZyA9IHtpc2VjdDogbnh0SXNlY3R9O1xuICAgICAgICAgIGlmIChpc0NvbnZleChbaXNlY3RMaXN0W2N1cnJlbnRJc2VjdF0uY29vcmQsIGlzZWN0TGlzdFtueHRJc2VjdF0uY29vcmQsIGlzZWN0TGlzdFtpc2VjdExpc3Rbbnh0SXNlY3RdLm54dElzZWN0QWxvbmdSaW5nQW5kRWRnZTFdLmNvb3JkXSxjdXJyZW50T3V0cHV0UmluZ1dpbmRpbmcgPT0gMSkpIHtcbiAgICAgICAgICAgIHB1c2hpbmcucGFyZW50ID0gY3VycmVudE91dHB1dFJpbmdQYXJlbnQ7XG4gICAgICAgICAgICBwdXNoaW5nLndpbmRpbmcgPSAtY3VycmVudE91dHB1dFJpbmdXaW5kaW5nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoaW5nLnBhcmVudCA9IGN1cnJlbnRPdXRwdXRSaW5nO1xuICAgICAgICAgICAgcHVzaGluZy53aW5kaW5nID0gY3VycmVudE91dHB1dFJpbmdXaW5kaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5wdXNoKHB1c2hpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJc2VjdCA9IG54dElzZWN0O1xuICAgICAgICBueHRJc2VjdCA9IGlzZWN0TGlzdFtueHRJc2VjdF0ubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMTtcbiAgICAgIH1cbiAgICAgIGRlYnVnQWxsKFwiQ3VycmVudCBzdGF0ZSBvZiB0aGUgcXVldWU6IFwiICsgSlNPTi5zdHJpbmdpZnkocXVldWUpKTtcbiAgICB9XG4gICAgZGVidWdBbGwoXCJXYWxraW5nIGZyb20gaW50ZXJzZWN0aW9uIFwiICsgY3VycmVudElzZWN0ICsgXCIgdG8gXCIgKyBueHRJc2VjdCArIFwiIG92ZXIgcmluZyBcIiArIHdhbGtpbmdSaW5nQW5kRWRnZVswXSArIFwiIGFuZCBlZGdlIFwiICsgd2Fsa2luZ1JpbmdBbmRFZGdlWzFdICsgXCIgYW5kIGNsb3NpbmcgcmluZ1wiKTtcbiAgICAvLyBDbG9zZSBvdXRwdXQgcmluZ1xuICAgIGN1cnJlbnRPdXRwdXRSaW5nQ29vcmRzLnB1c2goaXNlY3RMaXN0W254dElzZWN0XS5jb29yZCk7XG4gICAgLy8gUHVzaCBvdXRwdXQgcmluZyB0byBvdXRwdXRcbiAgICBvdXRwdXRGZWF0dXJlQXJyYXkucHVzaChoZWxwZXJzLnBvbHlnb24oW2N1cnJlbnRPdXRwdXRSaW5nQ29vcmRzXSx7aW5kZXg6IGN1cnJlbnRPdXRwdXRSaW5nLCBwYXJlbnQ6IGN1cnJlbnRPdXRwdXRSaW5nUGFyZW50LCB3aW5kaW5nOiBjdXJyZW50T3V0cHV0UmluZ1dpbmRpbmcsIG5ldFdpbmRpbmc6IHVuZGVmaW5lZH0pKTtcbiAgfVxuXG4gIHZhciBvdXRwdXQgPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uKG91dHB1dEZlYXR1cmVBcnJheSk7XG4gIGRlYnVnKFwiV2Fsa2luZ1wiKTtcblxuICBkZXRlcm1pbmVQYXJlbnRzKCk7XG4gIGRlYnVnKFwiRGV0ZXJtaW5pbmcgcGFyZW50c1wiKTtcblxuICBzZXROZXRXaW5kaW5nKCk7XG4gIGRlYnVnKFwiU2V0dGluZyB3aW5kaW5nIG51bWJlclwiKTtcblxuICAvLyBUaGVzZSBmdW5jdGlvbnMgYXJlIGFsc28gdXNlZCBpZiBubyBpbnRlcnNlY3Rpb25zIGFyZSBmb3VuZFxuICBmdW5jdGlvbiBkZXRlcm1pbmVQYXJlbnRzKCkge1xuICAgIHZhciBmZWF0dXJlc1dpdGhvdXRQYXJlbnQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWdBbGwoXCJPdXRwdXQgcmluZyBcIiArIGkgKyBcIiBoYXMgcGFyZW50IFwiICsgb3V0cHV0LmZlYXR1cmVzW2ldLnByb3BlcnRpZXMucGFyZW50KTtcbiAgICAgIGlmIChvdXRwdXQuZmVhdHVyZXNbaV0ucHJvcGVydGllcy5wYXJlbnQgPT0gLTEpIGZlYXR1cmVzV2l0aG91dFBhcmVudC5wdXNoKGkpO1xuICAgIH1cbiAgICBkZWJ1Z0FsbChcIlRoZSBmb2xsb3dpbmcgb3V0cHV0IHJpbmcocykgaGF2ZSBubyBwYXJlbnQ6IFwiICsgZmVhdHVyZXNXaXRob3V0UGFyZW50KTtcbiAgICBpZiAoZmVhdHVyZXNXaXRob3V0UGFyZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXNXaXRob3V0UGFyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSAtMTtcbiAgICAgICAgdmFyIHBhcmVudEFyZWEgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRwdXQuZmVhdHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoZmVhdHVyZXNXaXRob3V0UGFyZW50W2ldID09IGopIGNvbnRpbnVlXG4gICAgICAgICAgaWYgKHdpdGhpbihoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uKFtoZWxwZXJzLnBvaW50KG91dHB1dC5mZWF0dXJlc1tmZWF0dXJlc1dpdGhvdXRQYXJlbnRbaV1dLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdKV0pLGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb24oW291dHB1dC5mZWF0dXJlc1tqXV0pKS5mZWF0dXJlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKGFyZWEob3V0cHV0LmZlYXR1cmVzW2pdKSA8IHBhcmVudEFyZWEpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gajtcbiAgICAgICAgICAgICAgZGVidWdBbGwoXCJSaW5nIFwiK2ZlYXR1cmVzV2l0aG91dFBhcmVudFtpXStcIiBsaWVzIHdpdGhpbiBvdXRwdXQgcmluZyBcIitqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LmZlYXR1cmVzW2ZlYXR1cmVzV2l0aG91dFBhcmVudFtpXV0ucHJvcGVydGllcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGRlYnVnQWxsKFwiUmluZyBcIitmZWF0dXJlc1dpdGhvdXRQYXJlbnRbaV0rXCIgaXMgYXNzaWduZWQgcGFyZW50IFwiK3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TmV0V2luZGluZygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG91dHB1dC5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLnBhcmVudCA9PSAtMSkge1xuICAgICAgICB2YXIgbmV0V2luZGluZyA9IG91dHB1dC5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLndpbmRpbmdcbiAgICAgICAgb3V0cHV0LmZlYXR1cmVzW2ldLnByb3BlcnRpZXMubmV0V2luZGluZyA9IG5ldFdpbmRpbmc7XG4gICAgICAgIHNldE5ldFdpbmRpbmdPZkNoaWxkcmVuKGksbmV0V2luZGluZylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXROZXRXaW5kaW5nT2ZDaGlsZHJlbihwYXJlbnQsUGFyZW50TmV0V2luZGluZyl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvdXRwdXQuZmVhdHVyZXNbaV0ucHJvcGVydGllcy5wYXJlbnQgPT0gcGFyZW50KXtcbiAgICAgICAgdmFyIG5ldFdpbmRpbmcgPSBQYXJlbnROZXRXaW5kaW5nICsgb3V0cHV0LmZlYXR1cmVzW2ldLnByb3BlcnRpZXMud2luZGluZ1xuICAgICAgICBvdXRwdXQuZmVhdHVyZXNbaV0ucHJvcGVydGllcy5uZXRXaW5kaW5nID0gbmV0V2luZGluZztcbiAgICAgICAgc2V0TmV0V2luZGluZ09mQ2hpbGRyZW4oaSxuZXRXaW5kaW5nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnQWxsKFwiIyBUb3RhbCBvZiBcIiArIG91dHB1dC5mZWF0dXJlcy5sZW5ndGggKyBcIiByaW5nc1wiKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cblxuLy8gQ29uc3RydWN0b3IgZm9yIChyaW5nLSBvciBpbnRlcnNlY3Rpb24tKSBwc2V1ZG8tdmVydGljZXMuXG52YXIgUHNldWRvVnR4ID0gZnVuY3Rpb24gKGNvb3JkLCBwYXJhbSwgcmluZ0FuZEVkZ2VJbiwgcmluZ0FuZEVkZ2VPdXQsIG54dElzZWN0QWxvbmdFZGdlSW4pIHtcbiAgdGhpcy5jb29yZCA9IGNvb3JkOyAvLyBbeCx5XSBvZiB0aGlzIHBzZXVkby12ZXJ0ZXhcbiAgdGhpcy5wYXJhbSA9IHBhcmFtOyAvLyBmcmFjdGlvbmFsIGRpc3RhbmNlIG9mIHRoaXMgaW50ZXJzZWN0aW9uIG9uIGluY29tbWluZyBlZGdlXG4gIHRoaXMucmluZ0FuZEVkZ2VJbiA9IHJpbmdBbmRFZGdlSW47IC8vIFtyaW5nIGluZGV4LCBlZGdlIGluZGV4XSBvZiBpbmNvbW1pbmcgZWRnZVxuICB0aGlzLnJpbmdBbmRFZGdlT3V0ID0gcmluZ0FuZEVkZ2VPdXQ7IC8vIFtyaW5nIGluZGV4LCBlZGdlIGluZGV4XSBvZiBvdXRnb2luZyBlZGdlXG4gIHRoaXMubnh0SXNlY3RBbG9uZ0VkZ2VJbiA9IG54dElzZWN0QWxvbmdFZGdlSW47IC8vIFRoZSBuZXh0IGludGVyc2VjdGlvbiB3aGVuIGZvbGxvd2luZyB0aGUgaW5jb21taW5nIGVkZ2UgKHNvIG5vdCB3aGVuIGZvbGxvd2luZyByaW5nQW5kRWRnZU91dCEpXG59XG5cbi8vIENvbnN0cnVjdG9yIGZvciBhbiBpbnRlcnNlY3Rpb24uIFRoZXJlIGFyZSB0d28gaW50ZXJzZWN0aW9uLXBzZXVkby12ZXJ0aWNlcyBwZXIgc2VsZi1pbnRlcnNlY3Rpb24gYW5kIG9uZSByaW5nLXBzZXVkby12ZXJ0ZXggcGVyIHJpbmctdmVydGV4LWludGVyc2VjdGlvbi4gVGhlaXIgbGFiZWxzIDEgYW5kIDIgYXJlIG5vdCBhc3NpZ25lZCBhIHBhcnRpY3VsYXIgbWVhbmluZyBidXQgYXJlIHBlcm1hbmVudCBvbmNlIGdpdmVuLlxudmFyIElzZWN0ID0gZnVuY3Rpb24gKGNvb3JkLCByaW5nQW5kRWRnZTEsIHJpbmdBbmRFZGdlMiwgbnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMSwgbnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMiwgcmluZ0FuZEVkZ2UxV2Fsa2FibGUsIHJpbmdBbmRFZGdlMldhbGthYmxlKSB7XG4gIHRoaXMuY29vcmQgPSBjb29yZDsgLy8gW3gseV0gb2YgdGhpcyBpbnRlcnNlY3Rpb25cbiAgdGhpcy5yaW5nQW5kRWRnZTEgPSByaW5nQW5kRWRnZTE7IC8vIGZpcnN0IGVkZ2Ugb2YgdGhpcyBpbnRlcnNlY3Rpb25cbiAgdGhpcy5yaW5nQW5kRWRnZTIgPSByaW5nQW5kRWRnZTI7IC8vIHNlY29uZCBlZGdlIG9mIHRoaXMgaW50ZXJzZWN0aW9uXG4gIHRoaXMubnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMSA9IG54dElzZWN0QWxvbmdSaW5nQW5kRWRnZTE7IC8vIHRoZSBuZXh0IGludGVyc2VjdGlvbiB3aGVuIGZvbGxvd2luZyByaW5nQW5kRWRnZTFcbiAgdGhpcy5ueHRJc2VjdEFsb25nUmluZ0FuZEVkZ2UyID0gbnh0SXNlY3RBbG9uZ1JpbmdBbmRFZGdlMjsgLy8gdGhlIG5leHQgaW50ZXJzZWN0aW9uIHdoZW4gZm9sbG93aW5nIHJpbmdBbmRFZGdlMlxuICB0aGlzLnJpbmdBbmRFZGdlMVdhbGthYmxlID0gcmluZ0FuZEVkZ2UxV2Fsa2FibGU7IC8vIE1heSB3ZSAoc3RpbGwpIHdhbGsgYXdheSBmcm9tIHRoaXMgaW50ZXJzZWN0aW9uIG92ZXIgcmluZ0FuZEVkZ2UxP1xuICB0aGlzLnJpbmdBbmRFZGdlMldhbGthYmxlID0gcmluZ0FuZEVkZ2UyV2Fsa2FibGU7IC8vIE1heSB3ZSAoc3RpbGwpIHdhbGsgYXdheSBmcm9tIHRoaXMgaW50ZXJzZWN0aW9uIG92ZXIgcmluZ0FuZEVkZ2UyP1xufVxuXG4vLyBGdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgdGhyZWUgY29uc2VjdXRpdmUgcG9pbnRzIG9mIGEgc2ltcGxlLCBub24tc2VsZi1pbnRlcnNlY3RpbmcgcmluZyBtYWtlIHVwIGEgY29udmV4IHZlcnRleCwgYXNzdW1pbmcgdGhlIHJpbmcgaXMgcmlnaHQtIG9yIGxlZnRoYW5kZWRcbmZ1bmN0aW9uIGlzQ29udmV4KHB0cywgcmlnaHRoYW5kZWQpe1xuICAvLyAncHRzJyBpcyBhbiBbeCx5XSBwYWlyXG4gIC8vICdyaWdodGhhbmRlZCcgaXMgYSBib29sZWFuXG4gIGlmICh0eXBlb2YocmlnaHRoYW5kZWQpID09PSAndW5kZWZpbmVkJykgcmlnaHRoYW5kZWQgPSB0cnVlO1xuICBpZiAocHRzLmxlbmd0aCAhPSAzKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGZ1bmN0aW9uIHJlcXVpcmVzIGFuIGFycmF5IG9mIHRocmVlIHBvaW50cyBbeCx5XVwiKTtcbiAgdmFyIGQgPSAocHRzWzFdWzBdIC0gcHRzWzBdWzBdKSAqIChwdHNbMl1bMV0gLSBwdHNbMF1bMV0pIC0gKHB0c1sxXVsxXSAtIHB0c1swXVsxXSkgKiAocHRzWzJdWzBdIC0gcHRzWzBdWzBdKTtcbiAgcmV0dXJuIChkID49IDApID09IHJpZ2h0aGFuZGVkO1xufVxuXG4vLyBGdW5jdGlvbiB0byBjb21wdXRlIHdpbmRpbmcgb2Ygc2ltcGxlLCBub24tc2VsZi1pbnRlcnNlY3RpbmcgcmluZ1xuZnVuY3Rpb24gd2luZGluZ09mUmluZyhyaW5nKXtcbiAgLy8gJ3JpbmcnIGlzIGFuIGFycmF5IG9mIFt4LHldIHBhaXJzIHdpdGggdGhlIGxhc3QgZXF1YWwgdG8gdGhlIGZpcnN0XG4gIC8vIENvbXB1dGUgdGhlIHdpbmRpbmcgbnVtYmVyIGJhc2VkIG9uIHRoZSB2ZXJ0ZXggd2l0aCB0aGUgc21hbGxlc3QgeC12YWx1ZSwgaXQgcHJlY2Vzc29yIGFuZCBzdWNjZXNzb3IuIEFuIGV4dHJlbWFsIHZlcnRleCBvZiBhIHNpbXBsZSwgbm9uLXNlbGYtaW50ZXJzZWN0aW5nIHJpbmcgaXMgYWx3YXlzIGNvbnZleCwgc28gdGhlIG9ubHkgcmVhc29uIGl0IGlzIG5vdCBpcyBiZWNhdXNlIHRoZSB3aW5kaW5nIG51bWJlciB3ZSB1c2UgdG8gY29tcHV0ZSBpdCBpcyB3cm9uZ1xuICB2YXIgbGVmdFZ0eCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZy5sZW5ndGgtMTsgaSsrKSB7IGlmIChyaW5nW2ldWzBdIDwgcmluZ1tsZWZ0VnR4XVswXSkgbGVmdFZ0eCA9IGk7IH1cbiAgaWYgKGlzQ29udmV4KFtyaW5nWyhsZWZ0VnR4LTEpLm1vZHVsbyhyaW5nLmxlbmd0aC0xKV0scmluZ1tsZWZ0VnR4XSxyaW5nWyhsZWZ0VnR4KzEpLm1vZHVsbyhyaW5nLmxlbmd0aC0xKV1dLHRydWUpKSB7XG4gICAgdmFyIHdpbmRpbmcgPSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciB3aW5kaW5nID0gLTE7XG4gIH1cbiAgcmV0dXJuIHdpbmRpbmdcbn1cblxuLy8gRnVuY3Rpb24gdG8gY29tcGFyZSBBcnJheXMgb2YgbnVtYmVycy4gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4Mzc0NTYvaG93LXRvLWNvbXBhcmUtYXJyYXlzLWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5MSwgYXJyYXkyKSB7XG4gIC8vIGlmIHRoZSBvdGhlciBhcnJheSBpcyBhIGZhbHN5IHZhbHVlLCByZXR1cm5cbiAgaWYgKCFhcnJheTEgfHwgIWFycmF5MilcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBjb21wYXJlIGxlbmd0aHMgLSBjYW4gc2F2ZSBhIGxvdCBvZiB0aW1lXG4gIGlmIChhcnJheTEubGVuZ3RoICE9IGFycmF5Mi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGw9YXJyYXkxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBuZXN0ZWQgYXJyYXlzXG4gICAgICBpZiAoYXJyYXkxW2ldIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXkyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAvLyByZWN1cnNlIGludG8gdGhlIG5lc3RlZCBhcnJheXNcbiAgICAgICAgICBpZiAoIWVxdWFsQXJyYXlzKGFycmF5MVtpXSxhcnJheTJbaV0pKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnJheTFbaV0gIT0gYXJyYXkyW2ldKSB7XG4gICAgICAgICAgLy8gV2FybmluZyAtIHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBGaXggSmF2YXNjcmlwdCBtb2R1bG8gZm9yIG5lZ2F0aXZlIG51bWJlci4gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ0Njc1MzkvamF2YXNjcmlwdC1tb2R1bG8tbm90LWJlaGF2aW5nXG5OdW1iZXIucHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuICgodGhpcyAlIG4pICsgbikgJSBuO1xufVxuXG4vLyBGdW5jdGlvbiB0byBnZXQgYXJyYXkgd2l0aCBvbmx5IHVuaXF1ZSBlbGVtZW50cy4gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NjA0NzMvdW5pcXVlLXZhbHVlcy1pbi1hbi1hcnJheVxuZnVuY3Rpb24gZ2V0VW5pcXVlKGFycmF5KSB7XG4gdmFyIHUgPSB7fSwgYSA9IFtdO1xuIGZvcih2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kpe1xuICAgIGlmKHUuaGFzT3duUHJvcGVydHkoYXJyYXlbaV0pKSB7XG4gICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGEucHVzaChhcnJheVtpXSk7XG4gICAgdVthcnJheVtpXV0gPSAxO1xuIH1cbiByZXR1cm4gYTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY2hlY2sgaWYgYXJyYXkgaXMgdW5pcXVlIChpLmUuIGFsbCB1bmlxdWUgZWxlbWVudHMsIGkuZS4gbm8gZHVwbGljYXRlIGVsZW1lbnRzKVxuZnVuY3Rpb24gaXNVbmlxdWUoYXJyYXkpIHtcbiB2YXIgdSA9IHt9LCBhID0gW107XG4gdmFyIGlzVW5pcXVlID0gMTtcbiBmb3IodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKytpKXtcbiAgICBpZih1Lmhhc093blByb3BlcnR5KGFycmF5W2ldKSkge1xuICAgICAgaXNVbmlxdWUgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHVbYXJyYXlbaV1dID0gMTtcbiB9XG4gcmV0dXJuIGlzVW5pcXVlO1xufVxuIiwiLyoqXG4gKiBVbndyYXAgYSBjb29yZGluYXRlIGZyb20gYSBQb2ludCBGZWF0dXJlLCBHZW9tZXRyeSBvciBhIHNpbmdsZSBjb29yZGluYXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55PnxHZW9tZXRyeXxGZWF0dXJlPFBvaW50Pn0gb2JqIGFueSB2YWx1ZVxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gKi9cbmZ1bmN0aW9uIGdldENvb3JkKG9iaikge1xuICAgIGlmICghb2JqKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG9iaiBwYXNzZWQnKTtcblxuICAgIHZhciBjb29yZGluYXRlcyA9IGdldENvb3JkcyhvYmopO1xuXG4gICAgLy8gZ2V0Q29vcmQoKSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgdHdvIG51bWJlcnMgKFBvaW50KVxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxICYmXG4gICAgICAgIHR5cGVvZiBjb29yZGluYXRlc1swXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGNvb3JkaW5hdGVzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlIGlzIG5vdCBhIHZhbGlkIFBvaW50Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVud3JhcCBjb29yZGluYXRlcyBmcm9tIGEgRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5IG9mIG51bWJlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT58R2VvbWV0cnl8RmVhdHVyZTxhbnk+fSBvYmogYW55IHZhbHVlXG4gKiBAcmV0dXJucyB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q29vcmRzKG9iaikge1xuICAgIGlmICghb2JqKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG9iaiBwYXNzZWQnKTtcbiAgICB2YXIgY29vcmRpbmF0ZXM7XG5cbiAgICAvLyBBcnJheSBvZiBudW1iZXJzXG4gICAgaWYgKG9iai5sZW5ndGgpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBvYmo7XG5cbiAgICAvLyBHZW9tZXRyeSBPYmplY3RcbiAgICB9IGVsc2UgaWYgKG9iai5jb29yZGluYXRlcykge1xuICAgICAgICBjb29yZGluYXRlcyA9IG9iai5jb29yZGluYXRlcztcblxuICAgIC8vIEZlYXR1cmVcbiAgICB9IGVsc2UgaWYgKG9iai5nZW9tZXRyeSAmJiBvYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBvYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBjb29yZGluYXRlcyBjb250YWlucyBhIG51bWJlclxuICAgIGlmIChjb29yZGluYXRlcykge1xuICAgICAgICBjb250YWluc051bWJlcihjb29yZGluYXRlcyk7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBjb29yZGluYXRlcycpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBjb29yZGluYXRlcyBjb250YWlucyBhIG51bWJlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGNvb3JkaW5hdGVzIEdlb0pTT04gQ29vcmRpbmF0ZXNcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIEFycmF5IGNvbnRhaW5zIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTnVtYmVyKGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgdHlwZW9mIGNvb3JkaW5hdGVzWzBdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgY29vcmRpbmF0ZXNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29vcmRpbmF0ZXNbMF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb250YWluc051bWJlcihjb29yZGluYXRlc1swXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY29vcmRpbmF0ZXMgbXVzdCBvbmx5IGNvbnRhaW4gbnVtYmVycycpO1xufVxuXG4vKipcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIEdlb0pTT04gb2JqZWN0cyBmb3IgVHVyZi5cbiAqXG4gKiBAYWxpYXMgZ2VvanNvblR5cGVcbiAqIEBwYXJhbSB7R2VvSlNPTn0gdmFsdWUgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBleHBlY3RlZCBHZW9KU09OIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxuICogQHRocm93cyB7RXJyb3J9IGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2VvanNvblR5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBpZiAoIXR5cGUgfHwgIW5hbWUpIHRocm93IG5ldyBFcnJvcigndHlwZSBhbmQgbmFtZSByZXF1aXJlZCcpO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICc6IG11c3QgYmUgYSAnICsgdHlwZSArICcsIGdpdmVuICcgKyB2YWx1ZS50eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmV9IGlucHV0cyBmb3IgVHVyZi5cbiAqIEludGVybmFsbHkgdGhpcyB1c2VzIHtAbGluayBnZW9qc29uVHlwZX0gdG8ganVkZ2UgZ2VvbWV0cnkgdHlwZXMuXG4gKlxuICogQGFsaWFzIGZlYXR1cmVPZlxuICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIGEgZmVhdHVyZSB3aXRoIGFuIGV4cGVjdGVkIGdlb21ldHJ5IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBjYWxsaW5nIGZ1bmN0aW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gZXJyb3IgaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5mdW5jdGlvbiBmZWF0dXJlT2YoZmVhdHVyZSwgdHlwZSwgbmFtZSkge1xuICAgIGlmICghZmVhdHVyZSkgdGhyb3cgbmV3IEVycm9yKCdObyBmZWF0dXJlIHBhc3NlZCcpO1xuICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCcuZmVhdHVyZU9mKCkgcmVxdWlyZXMgYSBuYW1lJyk7XG4gICAgaWYgKCFmZWF0dXJlIHx8IGZlYXR1cmUudHlwZSAhPT0gJ0ZlYXR1cmUnIHx8ICFmZWF0dXJlLmdlb21ldHJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICcsIEZlYXR1cmUgd2l0aCBnZW9tZXRyeSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICc6IG11c3QgYmUgYSAnICsgdHlwZSArICcsIGdpdmVuICcgKyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFbmZvcmNlIGV4cGVjdGF0aW9ucyBhYm91dCB0eXBlcyBvZiB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGlucHV0cyBmb3IgVHVyZi5cbiAqIEludGVybmFsbHkgdGhpcyB1c2VzIHtAbGluayBnZW9qc29uVHlwZX0gdG8ganVkZ2UgZ2VvbWV0cnkgdHlwZXMuXG4gKlxuICogQGFsaWFzIGNvbGxlY3Rpb25PZlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbn0gZmVhdHVyZUNvbGxlY3Rpb24gYSBGZWF0dXJlQ29sbGVjdGlvbiBmb3Igd2hpY2ggZmVhdHVyZXMgd2lsbCBiZSBqdWRnZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBjYWxsaW5nIGZ1bmN0aW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5mdW5jdGlvbiBjb2xsZWN0aW9uT2YoZmVhdHVyZUNvbGxlY3Rpb24sIHR5cGUsIG5hbWUpIHtcbiAgICBpZiAoIWZlYXR1cmVDb2xsZWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGZlYXR1cmVDb2xsZWN0aW9uIHBhc3NlZCcpO1xuICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCcuY29sbGVjdGlvbk9mKCkgcmVxdWlyZXMgYSBuYW1lJyk7XG4gICAgaWYgKCFmZWF0dXJlQ29sbGVjdGlvbiB8fCBmZWF0dXJlQ29sbGVjdGlvbi50eXBlICE9PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICcsIEZlYXR1cmVDb2xsZWN0aW9uIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8IGZlYXR1cmUudHlwZSAhPT0gJ0ZlYXR1cmUnIHx8ICFmZWF0dXJlLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnLCBGZWF0dXJlIHdpdGggZ2VvbWV0cnkgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnOiBtdXN0IGJlIGEgJyArIHR5cGUgKyAnLCBnaXZlbiAnICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuZ2VvanNvblR5cGUgPSBnZW9qc29uVHlwZTtcbm1vZHVsZS5leHBvcnRzLmNvbGxlY3Rpb25PZiA9IGNvbGxlY3Rpb25PZjtcbm1vZHVsZS5leHBvcnRzLmZlYXR1cmVPZiA9IGZlYXR1cmVPZjtcbm1vZHVsZS5leHBvcnRzLmdldENvb3JkID0gZ2V0Q29vcmQ7XG5tb2R1bGUuZXhwb3J0cy5nZXRDb29yZHMgPSBnZXRDb29yZHM7XG4iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxudmFyIGJpdHMgICAgICA9IHJlcXVpcmUoXCJiaXQtdHdpZGRsZVwiKVxuICAsIFVuaW9uRmluZCA9IHJlcXVpcmUoXCJ1bmlvbi1maW5kXCIpXG5cbi8vUmV0dXJucyB0aGUgZGltZW5zaW9uIG9mIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBkaW1lbnNpb24oY2VsbHMpIHtcbiAgdmFyIGQgPSAwXG4gICAgLCBtYXggPSBNYXRoLm1heFxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICBkID0gbWF4KGQsIGNlbGxzW2ldLmxlbmd0aClcbiAgfVxuICByZXR1cm4gZC0xXG59XG5leHBvcnRzLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuXG4vL0NvdW50cyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIGZhY2VzXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKGNlbGxzKSB7XG4gIHZhciB2YyA9IC0xXG4gICAgLCBtYXggPSBNYXRoLm1heFxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTAsIGpsPWMubGVuZ3RoOyBqPGpsOyArK2opIHtcbiAgICAgIHZjID0gbWF4KHZjLCBjW2pdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmMrMVxufVxuZXhwb3J0cy5jb3VudFZlcnRpY2VzID0gY291bnRWZXJ0aWNlc1xuXG4vL1JldHVybnMgYSBkZWVwIGNvcHkgb2YgY2VsbHNcbmZ1bmN0aW9uIGNsb25lQ2VsbHMoY2VsbHMpIHtcbiAgdmFyIG5jZWxscyA9IG5ldyBBcnJheShjZWxscy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIG5jZWxsc1tpXSA9IGNlbGxzW2ldLnNsaWNlKDApXG4gIH1cbiAgcmV0dXJuIG5jZWxsc1xufVxuZXhwb3J0cy5jbG9uZUNlbGxzID0gY2xvbmVDZWxsc1xuXG4vL1JhbmtzIGEgcGFpciBvZiBjZWxscyB1cCB0byBwZXJtdXRhdGlvblxuZnVuY3Rpb24gY29tcGFyZUNlbGxzKGEsIGIpIHtcbiAgdmFyIG4gPSBhLmxlbmd0aFxuICAgICwgdCA9IGEubGVuZ3RoIC0gYi5sZW5ndGhcbiAgICAsIG1pbiA9IE1hdGgubWluXG4gIGlmKHQpIHtcbiAgICByZXR1cm4gdFxuICB9XG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHZhciBkID0gYVswXSthWzFdLWJbMF0tYlsxXVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbihhWzBdLGFbMV0pIC0gbWluKGJbMF0sYlsxXSlcbiAgICBjYXNlIDM6XG4gICAgICB2YXIgbDEgPSBhWzBdK2FbMV1cbiAgICAgICAgLCBtMSA9IGJbMF0rYlsxXVxuICAgICAgZCA9IGwxK2FbMl0gLSAobTErYlsyXSlcbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHZhciBsMCA9IG1pbihhWzBdLCBhWzFdKVxuICAgICAgICAsIG0wID0gbWluKGJbMF0sIGJbMV0pXG4gICAgICAgICwgZCAgPSBtaW4obDAsIGFbMl0pIC0gbWluKG0wLCBiWzJdKVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbihsMCthWzJdLCBsMSkgLSBtaW4obTArYlsyXSwgbTEpXG4gICAgXG4gICAgLy9UT0RPOiBNYXliZSBvcHRpbWl6ZSBuPTQgYXMgd2VsbD9cbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGFzID0gYS5zbGljZSgwKVxuICAgICAgYXMuc29ydCgpXG4gICAgICB2YXIgYnMgPSBiLnNsaWNlKDApXG4gICAgICBicy5zb3J0KClcbiAgICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgICB0ID0gYXNbaV0gLSBic1tpXVxuICAgICAgICBpZih0KSB7XG4gICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgfVxufVxuZXhwb3J0cy5jb21wYXJlQ2VsbHMgPSBjb21wYXJlQ2VsbHNcblxuZnVuY3Rpb24gY29tcGFyZVppcHBlZChhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlQ2VsbHMoYVswXSwgYlswXSlcbn1cblxuLy9QdXRzIGEgY2VsbCBjb21wbGV4IGludG8gbm9ybWFsIG9yZGVyIGZvciB0aGUgcHVycG9zZXMgb2YgZmluZENlbGwgcXVlcmllc1xuZnVuY3Rpb24gbm9ybWFsaXplKGNlbGxzLCBhdHRyKSB7XG4gIGlmKGF0dHIpIHtcbiAgICB2YXIgbGVuID0gY2VsbHMubGVuZ3RoXG4gICAgdmFyIHppcHBlZCA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgIHppcHBlZFtpXSA9IFtjZWxsc1tpXSwgYXR0cltpXV1cbiAgICB9XG4gICAgemlwcGVkLnNvcnQoY29tcGFyZVppcHBlZClcbiAgICBmb3IodmFyIGk9MDsgaTxsZW47ICsraSkge1xuICAgICAgY2VsbHNbaV0gPSB6aXBwZWRbaV1bMF1cbiAgICAgIGF0dHJbaV0gPSB6aXBwZWRbaV1bMV1cbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzXG4gIH0gZWxzZSB7XG4gICAgY2VsbHMuc29ydChjb21wYXJlQ2VsbHMpXG4gICAgcmV0dXJuIGNlbGxzXG4gIH1cbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplXG5cbi8vUmVtb3ZlcyBhbGwgZHVwbGljYXRlIGNlbGxzIGluIHRoZSBjb21wbGV4XG5mdW5jdGlvbiB1bmlxdWUoY2VsbHMpIHtcbiAgaWYoY2VsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGNlbGxzLmxlbmd0aFxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIHZhciBhID0gY2VsbHNbaV1cbiAgICBpZihjb21wYXJlQ2VsbHMoYSwgY2VsbHNbaS0xXSkpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY2VsbHNbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBjZWxscy5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGNlbGxzXG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcblxuLy9GaW5kcyBhIGNlbGwgaW4gYSBub3JtYWxpemVkIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gZmluZENlbGwoY2VsbHMsIGMpIHtcbiAgdmFyIGxvID0gMFxuICAgICwgaGkgPSBjZWxscy5sZW5ndGgtMVxuICAgICwgciAgPSAtMVxuICB3aGlsZSAobG8gPD0gaGkpIHtcbiAgICB2YXIgbWlkID0gKGxvICsgaGkpID4+IDFcbiAgICAgICwgcyAgID0gY29tcGFyZUNlbGxzKGNlbGxzW21pZF0sIGMpXG4gICAgaWYocyA8PSAwKSB7XG4gICAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBtaWRcbiAgICAgIH1cbiAgICAgIGxvID0gbWlkICsgMVxuICAgIH0gZWxzZSBpZihzID4gMCkge1xuICAgICAgaGkgPSBtaWQgLSAxXG4gICAgfVxuICB9XG4gIHJldHVybiByXG59XG5leHBvcnRzLmZpbmRDZWxsID0gZmluZENlbGw7XG5cbi8vQnVpbGRzIGFuIGluZGV4IGZvciBhbiBuLWNlbGwuICBUaGlzIGlzIG1vcmUgZ2VuZXJhbCB0aGFuIGR1YWwsIGJ1dCBsZXNzIGVmZmljaWVudFxuZnVuY3Rpb24gaW5jaWRlbmNlKGZyb21fY2VsbHMsIHRvX2NlbGxzKSB7XG4gIHZhciBpbmRleCA9IG5ldyBBcnJheShmcm9tX2NlbGxzLmxlbmd0aClcbiAgZm9yKHZhciBpPTAsIGlsPWluZGV4Lmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgaW5kZXhbaV0gPSBbXVxuICB9XG4gIHZhciBiID0gW11cbiAgZm9yKHZhciBpPTAsIG49dG9fY2VsbHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBjID0gdG9fY2VsbHNbaV1cbiAgICB2YXIgY2wgPSBjLmxlbmd0aFxuICAgIGZvcih2YXIgaz0xLCBrbj0oMTw8Y2wpOyBrPGtuOyArK2spIHtcbiAgICAgIGIubGVuZ3RoID0gYml0cy5wb3BDb3VudChrKVxuICAgICAgdmFyIGwgPSAwXG4gICAgICBmb3IodmFyIGo9MDsgajxjbDsgKytqKSB7XG4gICAgICAgIGlmKGsgJiAoMTw8aikpIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2pdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpZHg9ZmluZENlbGwoZnJvbV9jZWxscywgYilcbiAgICAgIGlmKGlkeCA8IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgaW5kZXhbaWR4KytdLnB1c2goaSlcbiAgICAgICAgaWYoaWR4ID49IGZyb21fY2VsbHMubGVuZ3RoIHx8IGNvbXBhcmVDZWxscyhmcm9tX2NlbGxzW2lkeF0sIGIpICE9PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cbmV4cG9ydHMuaW5jaWRlbmNlID0gaW5jaWRlbmNlXG5cbi8vQ29tcHV0ZXMgdGhlIGR1YWwgb2YgdGhlIG1lc2guICBUaGlzIGlzIGJhc2ljYWxseSBhbiBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBidWlsZEluZGV4IGZvciB0aGUgc2l0dWF0aW9uIHdoZXJlIGZyb21fY2VsbHMgaXMganVzdCB0aGUgbGlzdCBvZiB2ZXJ0aWNlc1xuZnVuY3Rpb24gZHVhbChjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIGlmKCF2ZXJ0ZXhfY291bnQpIHtcbiAgICByZXR1cm4gaW5jaWRlbmNlKHVuaXF1ZShza2VsZXRvbihjZWxscywgMCkpLCBjZWxscywgMClcbiAgfVxuICB2YXIgcmVzID0gbmV3IEFycmF5KHZlcnRleF9jb3VudClcbiAgZm9yKHZhciBpPTA7IGk8dmVydGV4X2NvdW50OyArK2kpIHtcbiAgICByZXNbaV0gPSBbXVxuICB9XG4gIGZvcih2YXIgaT0wLCBsZW49Y2VsbHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wLCBjbD1jLmxlbmd0aDsgajxjbDsgKytqKSB7XG4gICAgICByZXNbY1tqXV0ucHVzaChpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5leHBvcnRzLmR1YWwgPSBkdWFsXG5cbi8vRW51bWVyYXRlcyBhbGwgY2VsbHMgaW4gdGhlIGNvbXBsZXhcbmZ1bmN0aW9uIGV4cGxvZGUoY2VsbHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICAgICwgY2wgPSBjLmxlbmd0aHwwXG4gICAgZm9yKHZhciBqPTEsIGpsPSgxPDxjbCk7IGo8amw7ICsraikge1xuICAgICAgdmFyIGIgPSBbXVxuICAgICAgZm9yKHZhciBrPTA7IGs8Y2w7ICsraykge1xuICAgICAgICBpZigoaiA+Pj4gaykgJiAxKSB7XG4gICAgICAgICAgYi5wdXNoKGNba10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzdWx0KVxufVxuZXhwb3J0cy5leHBsb2RlID0gZXhwbG9kZVxuXG4vL0VudW1lcmF0ZXMgYWxsIG9mIHRoZSBuLWNlbGxzIG9mIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBza2VsZXRvbihjZWxscywgbikge1xuICBpZihuIDwgMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBbXVxuICAgICwgazAgICAgID0gKDE8PChuKzEpKS0xXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaz1rMDsgazwoMTw8Yy5sZW5ndGgpOyBrPWJpdHMubmV4dENvbWJpbmF0aW9uKGspKSB7XG4gICAgICB2YXIgYiA9IG5ldyBBcnJheShuKzEpXG4gICAgICAgICwgbCA9IDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYoayAmICgxPDxqKSkge1xuICAgICAgICAgIGJbbCsrXSA9IGNbal1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goYilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZShyZXN1bHQpXG59XG5leHBvcnRzLnNrZWxldG9uID0gc2tlbGV0b247XG5cbi8vQ29tcHV0ZXMgdGhlIGJvdW5kYXJ5IG9mIGFsbCBjZWxscywgZG9lcyBub3QgcmVtb3ZlIGR1cGxpY2F0ZXNcbmZ1bmN0aW9uIGJvdW5kYXJ5KGNlbGxzKSB7XG4gIHZhciByZXMgPSBbXVxuICBmb3IodmFyIGk9MCxpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MCxjbD1jLmxlbmd0aDsgajxjbDsgKytqKSB7XG4gICAgICB2YXIgYiA9IG5ldyBBcnJheShjLmxlbmd0aC0xKVxuICAgICAgZm9yKHZhciBrPTAsIGw9MDsgazxjbDsgKytrKSB7XG4gICAgICAgIGlmKGsgIT09IGopIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2tdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcy5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzKVxufVxuZXhwb3J0cy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIGRlbnNlIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50c19kZW5zZShjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIHZhciBsYWJlbHMgPSBuZXcgVW5pb25GaW5kKHZlcnRleF9jb3VudClcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8Yy5sZW5ndGg7ICsraikge1xuICAgICAgZm9yKHZhciBrPWorMTsgazxjLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxhYmVscy5saW5rKGNbal0sIGNba10pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBjb21wb25lbnRzID0gW11cbiAgICAsIGNvbXBvbmVudF9sYWJlbHMgPSBsYWJlbHMucmFua3NcbiAgZm9yKHZhciBpPTA7IGk8Y29tcG9uZW50X2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIGNvbXBvbmVudF9sYWJlbHNbaV0gPSAtMVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGwgPSBsYWJlbHMuZmluZChjZWxsc1tpXVswXSlcbiAgICBpZihjb21wb25lbnRfbGFiZWxzW2xdIDwgMCkge1xuICAgICAgY29tcG9uZW50X2xhYmVsc1tsXSA9IGNvbXBvbmVudHMubGVuZ3RoXG4gICAgICBjb21wb25lbnRzLnB1c2goW2NlbGxzW2ldLnNsaWNlKDApXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRfbGFiZWxzW2xdXS5wdXNoKGNlbGxzW2ldLnNsaWNlKDApKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIHNwYXJzZSBncmFwaFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50c19zcGFyc2UoY2VsbHMpIHtcbiAgdmFyIHZlcnRpY2VzICA9IHVuaXF1ZShub3JtYWxpemUoc2tlbGV0b24oY2VsbHMsIDApKSlcbiAgICAsIGxhYmVscyAgICA9IG5ldyBVbmlvbkZpbmQodmVydGljZXMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgdmogPSBmaW5kQ2VsbCh2ZXJ0aWNlcywgW2Nbal1dKVxuICAgICAgZm9yKHZhciBrPWorMTsgazxjLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxhYmVscy5saW5rKHZqLCBmaW5kQ2VsbCh2ZXJ0aWNlcywgW2Nba11dKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGNvbXBvbmVudHMgICAgICAgID0gW11cbiAgICAsIGNvbXBvbmVudF9sYWJlbHMgID0gbGFiZWxzLnJhbmtzXG4gIGZvcih2YXIgaT0wOyBpPGNvbXBvbmVudF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb21wb25lbnRfbGFiZWxzW2ldID0gLTFcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsID0gbGFiZWxzLmZpbmQoZmluZENlbGwodmVydGljZXMsIFtjZWxsc1tpXVswXV0pKTtcbiAgICBpZihjb21wb25lbnRfbGFiZWxzW2xdIDwgMCkge1xuICAgICAgY29tcG9uZW50X2xhYmVsc1tsXSA9IGNvbXBvbmVudHMubGVuZ3RoXG4gICAgICBjb21wb25lbnRzLnB1c2goW2NlbGxzW2ldLnNsaWNlKDApXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRfbGFiZWxzW2xdXS5wdXNoKGNlbGxzW2ldLnNsaWNlKDApKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50cyhjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIGlmKHZlcnRleF9jb3VudCkge1xuICAgIHJldHVybiBjb25uZWN0ZWRDb21wb25lbnRzX2RlbnNlKGNlbGxzLCB2ZXJ0ZXhfY291bnQpXG4gIH1cbiAgcmV0dXJuIGNvbm5lY3RlZENvbXBvbmVudHNfc3BhcnNlKGNlbGxzKVxufVxuZXhwb3J0cy5jb25uZWN0ZWRDb21wb25lbnRzID0gY29ubmVjdGVkQ29tcG9uZW50c1xuIiwiLypcbiAoYykgMjAxMywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG4vLyBzaW1wbGlmaWNhdGlvbiB1c2luZyBvcHRpbWl6ZWQgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobSB3aXRoIHJlY3Vyc2lvbiBlbGltaW5hdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG5cbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgTWFya2VyQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXksXG4gICAgICAgIG1hcmtlcnMgPSBuZXcgTWFya2VyQXJyYXkobGVuKSxcbiAgICAgICAgZmlyc3QgPSAwLFxuICAgICAgICBsYXN0ID0gbGVuIC0gMSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgbmV3UG9pbnRzID0gW10sXG4gICAgICAgIGksIG1heFNxRGlzdCwgc3FEaXN0LCBpbmRleDtcblxuICAgIG1hcmtlcnNbZmlyc3RdID0gbWFya2Vyc1tsYXN0XSA9IDE7XG5cbiAgICB3aGlsZSAobGFzdCkge1xuXG4gICAgICAgIG1heFNxRGlzdCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgbWFya2Vyc1tpbmRleF0gPSAxO1xuICAgICAgICAgICAgc3RhY2sucHVzaChmaXJzdCwgaW5kZXgsIGluZGV4LCBsYXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgZmlyc3QgPSBzdGFjay5wb3AoKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmtlcnNbaV0pIG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuLy8gYm90aCBhbGdvcml0aG1zIGNvbWJpbmVkIGZvciBhd2Vzb21lIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSwgaGlnaGVzdFF1YWxpdHkpIHtcblxuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID8gdG9sZXJhbmNlICogdG9sZXJhbmNlIDogMTtcblxuICAgIHBvaW50cyA9IGhpZ2hlc3RRdWFsaXR5ID8gcG9pbnRzIDogc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpO1xuICAgIHBvaW50cyA9IHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG5cbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG4vLyBleHBvcnQgYXMgQU1EIG1vZHVsZSAvIE5vZGUgbW9kdWxlIC8gYnJvd3NlciBvciB3b3JrZXIgdmFyaWFibGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNpbXBsaWZ5OyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwidmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG5ldyBUcmF2ZXJzZShvYmopO1xufTtcblxuZnVuY3Rpb24gVHJhdmVyc2UgKG9iaikge1xuICAgIHRoaXMudmFsdWUgPSBvYmo7XG59XG5cblRyYXZlcnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBzLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aCAtIDE7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkgbm9kZVtrZXldID0ge307XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIG5vZGVbcHNbaV1dID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiB3YWxrKHRoaXMudmFsdWUsIGNiLCB0cnVlKTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy52YWx1ZSA9IHdhbGsodGhpcy52YWx1ZSwgY2IsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2IsIGluaXQpIHtcbiAgICB2YXIgc2tpcCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgdmFyIGFjYyA9IHNraXAgPyB0aGlzLnZhbHVlIDogaW5pdDtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCB8fCAhc2tpcCkge1xuICAgICAgICAgICAgYWNjID0gY2IuY2FsbCh0aGlzLCBhY2MsIHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5wYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucGF0aCk7IFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLm5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXSwgbm9kZXMgPSBbXTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNsb25lIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXSA9PT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0gY29weShzcmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3JjKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZHN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0pKHRoaXMudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gd2FsayAocm9vdCwgY2IsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgYWxpdmUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gd2Fsa2VyIChub2RlXykge1xuICAgICAgICB2YXIgbm9kZSA9IGltbXV0YWJsZSA/IGNvcHkobm9kZV8pIDogbm9kZV87XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBrZWVwR29pbmcgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgbm9kZSA6IG5vZGUsXG4gICAgICAgICAgICBub2RlXyA6IG5vZGVfLFxuICAgICAgICAgICAgcGF0aCA6IFtdLmNvbmNhdChwYXRoKSxcbiAgICAgICAgICAgIHBhcmVudCA6IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudHMgOiBwYXJlbnRzLFxuICAgICAgICAgICAga2V5IDogcGF0aC5zbGljZSgtMSlbMF0sXG4gICAgICAgICAgICBpc1Jvb3QgOiBwYXRoLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIGxldmVsIDogcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjaXJjdWxhciA6IG51bGwsXG4gICAgICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbiAoeCwgc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVsZXRlJyA6IGZ1bmN0aW9uIChzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3RhdGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlLnNwbGljZShzdGF0ZS5rZXksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5cyA6IG51bGwsXG4gICAgICAgICAgICBiZWZvcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYmVmb3JlID0gZiB9LFxuICAgICAgICAgICAgYWZ0ZXIgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYWZ0ZXIgPSBmIH0sXG4gICAgICAgICAgICBwcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucHJlID0gZiB9LFxuICAgICAgICAgICAgcG9zdCA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wb3N0ID0gZiB9LFxuICAgICAgICAgICAgc3RvcCA6IGZ1bmN0aW9uICgpIHsgYWxpdmUgPSBmYWxzZSB9LFxuICAgICAgICAgICAgYmxvY2sgOiBmdW5jdGlvbiAoKSB7IGtlZXBHb2luZyA9IGZhbHNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICghYWxpdmUpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09PSAnb2JqZWN0JyAmJiBzdGF0ZS5ub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5rZXlzIHx8IHN0YXRlLm5vZGVfICE9PSBzdGF0ZS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBvYmplY3RLZXlzKHN0YXRlLm5vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHN0YXRlLmtleXMubGVuZ3RoID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldLm5vZGVfID09PSBub2RlXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2lyY3VsYXIgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGF0ZS5ub3RMZWFmID0gIXN0YXRlLmlzTGVhZjtcbiAgICAgICAgICAgIHN0YXRlLm5vdFJvb3QgPSAhc3RhdGUuaXNSb290O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gdXNlIHJldHVybiB2YWx1ZXMgdG8gdXBkYXRlIGlmIGRlZmluZWRcbiAgICAgICAgdmFyIHJldCA9IGNiLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgc3RhdGUudXBkYXRlKSBzdGF0ZS51cGRhdGUocmV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYmVmb3JlKSBtb2RpZmllcnMuYmVmb3JlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFrZWVwR29pbmcpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PSAnb2JqZWN0J1xuICAgICAgICAmJiBzdGF0ZS5ub2RlICE9PSBudWxsICYmICFzdGF0ZS5jaXJjdWxhcikge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChzdGF0ZS5rZXlzLCBmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcmUpIG1vZGlmaWVycy5wcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHdhbGtlcihzdGF0ZS5ub2RlW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5ub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5vZGVba2V5XSA9IGNoaWxkLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoaWxkLmlzTGFzdCA9IGkgPT0gc3RhdGUua2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLmlzRmlyc3QgPSBpID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wb3N0KSBtb2RpZmllcnMucG9zdC5jYWxsKHN0YXRlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5hZnRlcikgbW9kaWZpZXJzLmFmdGVyLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pKHJvb3QpLm5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvcHkgKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRzdDtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgRGF0ZShzcmMuZ2V0VGltZSA/IHNyYy5nZXRUaW1lKCkgOiBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IHsgbWVzc2FnZTogc3JjLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IEJvb2xlYW4oc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlcihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgTnVtYmVyKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBkc3QgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZHN0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPVxuICAgICAgICAgICAgICAgIChzcmMuY29uc3RydWN0b3IgJiYgc3JjLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICB8fCBzcmMuX19wcm90b19fXG4gICAgICAgICAgICAgICAgfHwge31cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBUID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBULnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgZHN0ID0gbmV3IFQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyhzcmMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gc3JjO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHRvUyAob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSB9XG5mdW5jdGlvbiBpc0RhdGUgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyB9XG5mdW5jdGlvbiBpc1JlZ0V4cCAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuZnVuY3Rpb24gaXNFcnJvciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4gKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyB9XG5mdW5jdGlvbiBpc051bWJlciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgfVxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nIH1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkgKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFRyYXZlcnNlLnByb3RvdHlwZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0cmF2ZXJzZVtrZXldID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIHQgPSBuZXcgVHJhdmVyc2Uob2JqKTtcbiAgICAgICAgcmV0dXJuIHRba2V5XS5hcHBseSh0LCBhcmdzKTtcbiAgICB9O1xufSk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJpbmcpe1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgbGVuID0gcmluZy5sZW5ndGg7XG4gIHZhciBwcmV2LGN1cjtcbiAgd2hpbGUoaTxsZW4pe1xuICAgIHByZXYgPSBjdXJ8fHJpbmdbMF07XG4gICAgY3VyID0gcmluZ1tpXTtcbiAgICBzdW0gKz0gKChjdXJbMF0tcHJldlswXSkqKGN1clsxXStwcmV2WzFdKSk7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBzdW0gPiAwO1xufSIsInZhciBjbG9ja3dpc2UgPSByZXF1aXJlKCd0dXJmLWlzLWNsb2Nrd2lzZScpO1xuXG5mdW5jdGlvbiBkb0xpbmVzSW50ZXJzZWN0KGxpbmUxLCBsaW5lMikge1xuICB2YXIgcDEgPSBsaW5lMVswXSxcbiAgICBwMiA9IGxpbmUxWzFdLFxuICAgIHAzID0gbGluZTJbMF0sXG4gICAgcDQgPSBsaW5lMlsxXTtcblxuICByZXR1cm4gKGNsb2Nrd2lzZShbcDEsIHAzLCBwNCwgcDFdKSAhPSBjbG9ja3dpc2UoW3AyLCBwMywgcDQsIHAyXSkpXG4gICAgJiYgKGNsb2Nrd2lzZShbcDEsIHAyLCBwMywgcDFdKSAhPSBjbG9ja3dpc2UoW3AxLCBwMiwgcDQsIHAxXSkpO1xufVxuXG5mdW5jdGlvbiB0ZXN0TGluZXMocmluZzEsIHJpbmcyKSB7XG4gIGZvciAodmFyIHAxX2luZCA9IDA7IHAxX2luZCA8IChyaW5nMS5sZW5ndGggLSAxKTsgcDFfaW5kKyspIHtcbiAgICB2YXIgcDFfbGluZSA9IFtyaW5nMVtwMV9pbmRdLCByaW5nMVtwMV9pbmQgKyAxXV07XG4gICAgZm9yICh2YXIgcDJfaW5kID0gMDsgcDJfaW5kIDwgKHJpbmcyLmxlbmd0aCAtIDEpOyBwMl9pbmQrKykge1xuICAgICAgdmFyIHAyX2xpbmUgPSBbcmluZzJbcDJfaW5kXSwgcmluZzJbcDJfaW5kICsgMV1dO1xuXG4gICAgICBpZiAoZG9MaW5lc0ludGVyc2VjdChwMV9saW5lLCBwMl9saW5lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlcyhwb2x5Z29uKSB7XG4gIHZhciBjb29yZHMgPSBbW1tdXV07XG5cbiAgc3dpdGNoIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIGNvb3JkcyA9IFtbcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc11dO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICBjb29yZHMgPSBbcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgY29vcmRzID0gcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogU2luY2Ugd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGUgb3ZlcmxhcCBhbW91bnQsXG4gKiBvciBpdCdzIGdlb21ldHJ5LCBidXQgcmF0aGVyIGp1c3Qgd2hldGhlciBvdmVybGFwXG4gKiBvY2N1cnMsIHBvbHlnb24gb3ZlcmxhcCBjYW4gbW9zdCBzaW1wbHkgYmUgZXhwcmVzc2VkXG4gKiBieSB0ZXN0aW5nIHdoZXRoZXIgYW55IHBhaXIgb2YgZWRnZXMgb24gdGhlIHR3byBwb2x5Z29uc1xuICogaW50ZXJzZWN0LiBJZiB0aGVyZSBhcmUgYW55IGVkZ2UgaW50ZXJzZWN0aW9ucywgdGhlXG4gKiBwb2x5Z29ucyBvdmVybGFwLlxuICpcbiAqIEBwYXJhbSAge1t0eXBlXX0gcG9seTEgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBwb2x5MiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9seTEsIHBvbHkyKSB7XG4gIHZhciBjb29yZHMxID0gZ2V0Q29vcmRpbmF0ZXMocG9seTEpLFxuICAgIGNvb3JkczIgPSBnZXRDb29yZGluYXRlcyhwb2x5Mik7XG5cbiAgLy8gVGhpcyBsb29rcyBjb21wbGV0ZWx5IHN0dXBpZCByaWRpY3Vsb3VzIHRvXG4gIC8vIGhhdmUgc28gbWFueSBuZXN0ZWQgbG9vcHMsIGJ1dCBpdCBzdXBwb3J0c1xuICAvLyBtdWx0aXBvbHlnb25zIG5pY2VseS4gSW4gdGhlIGNhc2Ugb2YgcG9seWdvbnNcbiAgLy8gb3IgbGluZXN0cmluZ3MsIHRoZSBvdXRlciBsb29wcyBhcmUgb25seSBvbmVcbiAgLy8gaXRlcmF0aW9uLlxuICByZXR1cm4gY29vcmRzMS5zb21lKGZ1bmN0aW9uIChyaW5nczEpIHtcbiAgICByZXR1cm4gY29vcmRzMi5zb21lKGZ1bmN0aW9uIChyaW5nczIpIHtcbiAgICAgIHJldHVybiByaW5nczEuc29tZShmdW5jdGlvbihyaW5nMSkge1xuICAgICAgICByZXR1cm4gcmluZ3MyLnNvbWUoZnVuY3Rpb24ocmluZzIpIHtcbiAgICAgICAgICByZXR1cm4gdGVzdExpbmVzKHJpbmcxLCByaW5nMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gdHdvUHJvZHVjdFxuXG52YXIgU1BMSVRURVIgPSArKE1hdGgucG93KDIsIDI3KSArIDEuMClcblxuZnVuY3Rpb24gdHdvUHJvZHVjdChhLCBiLCByZXN1bHQpIHtcbiAgdmFyIHggPSBhICogYlxuXG4gIHZhciBjID0gU1BMSVRURVIgKiBhXG4gIHZhciBhYmlnID0gYyAtIGFcbiAgdmFyIGFoaSA9IGMgLSBhYmlnXG4gIHZhciBhbG8gPSBhIC0gYWhpXG5cbiAgdmFyIGQgPSBTUExJVFRFUiAqIGJcbiAgdmFyIGJiaWcgPSBkIC0gYlxuICB2YXIgYmhpID0gZCAtIGJiaWdcbiAgdmFyIGJsbyA9IGIgLSBiaGlcblxuICB2YXIgZXJyMSA9IHggLSAoYWhpICogYmhpKVxuICB2YXIgZXJyMiA9IGVycjEgLSAoYWxvICogYmhpKVxuICB2YXIgZXJyMyA9IGVycjIgLSAoYWhpICogYmxvKVxuXG4gIHZhciB5ID0gYWxvICogYmxvIC0gZXJyM1xuXG4gIGlmKHJlc3VsdCkge1xuICAgIHJlc3VsdFswXSA9IHlcbiAgICByZXN1bHRbMV0gPSB4XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIFsgeSwgeCBdXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VHdvU3VtXG5cbmZ1bmN0aW9uIGZhc3RUd29TdW0oYSwgYiwgcmVzdWx0KSB7XG5cdHZhciB4ID0gYSArIGJcblx0dmFyIGJ2ID0geCAtIGFcblx0dmFyIGF2ID0geCAtIGJ2XG5cdHZhciBiciA9IGIgLSBidlxuXHR2YXIgYXIgPSBhIC0gYXZcblx0aWYocmVzdWx0KSB7XG5cdFx0cmVzdWx0WzBdID0gYXIgKyBiclxuXHRcdHJlc3VsdFsxXSA9IHhcblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0cmV0dXJuIFthciticiwgeF1cbn0iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbkZpbmQ7XG5cbmZ1bmN0aW9uIFVuaW9uRmluZChjb3VudCkge1xuICB0aGlzLnJvb3RzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgdGhpcy5yYW5rcyA9IG5ldyBBcnJheShjb3VudCk7XG4gIFxuICBmb3IodmFyIGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgdGhpcy5yb290c1tpXSA9IGk7XG4gICAgdGhpcy5yYW5rc1tpXSA9IDA7XG4gIH1cbn1cblxudmFyIHByb3RvID0gVW5pb25GaW5kLnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwibGVuZ3RoXCIsIHtcbiAgXCJnZXRcIjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdHMubGVuZ3RoXG4gIH1cbn0pXG5cbnByb3RvLm1ha2VTZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSB0aGlzLnJvb3RzLmxlbmd0aDtcbiAgdGhpcy5yb290cy5wdXNoKG4pO1xuICB0aGlzLnJhbmtzLnB1c2goMCk7XG4gIHJldHVybiBuO1xufVxuXG5wcm90by5maW5kID0gZnVuY3Rpb24oeCkge1xuICB2YXIgeDAgPSB4XG4gIHZhciByb290cyA9IHRoaXMucm9vdHM7XG4gIHdoaWxlKHJvb3RzW3hdICE9PSB4KSB7XG4gICAgeCA9IHJvb3RzW3hdXG4gIH1cbiAgd2hpbGUocm9vdHNbeDBdICE9PSB4KSB7XG4gICAgdmFyIHkgPSByb290c1t4MF1cbiAgICByb290c1t4MF0gPSB4XG4gICAgeDAgPSB5XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbnByb3RvLmxpbmsgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB4ciA9IHRoaXMuZmluZCh4KVxuICAgICwgeXIgPSB0aGlzLmZpbmQoeSk7XG4gIGlmKHhyID09PSB5cikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmFua3MgPSB0aGlzLnJhbmtzXG4gICAgLCByb290cyA9IHRoaXMucm9vdHNcbiAgICAsIHhkICAgID0gcmFua3NbeHJdXG4gICAgLCB5ZCAgICA9IHJhbmtzW3lyXTtcbiAgaWYoeGQgPCB5ZCkge1xuICAgIHJvb3RzW3hyXSA9IHlyO1xuICB9IGVsc2UgaWYoeWQgPCB4ZCkge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICAgICsrcmFua3NbeHJdO1xuICB9XG59IiwibW9kdWxlLmV4cG9ydHMuUkFESVVTID0gNjM3ODEzNztcbm1vZHVsZS5leHBvcnRzLkZMQVRURU5JTkcgPSAxLzI5OC4yNTcyMjM1NjM7XG5tb2R1bGUuZXhwb3J0cy5QT0xBUl9SQURJVVMgPSA2MzU2NzUyLjMxNDI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiY29uc3QgaXNFcXVhbCA9IHJlcXVpcmUoJ2xvZGFzaC5pc2VxdWFsJyk7XG5jb25zdCBub3JtYWxpemUgPSByZXF1aXJlKCdAbWFwYm94L2dlb2pzb24tbm9ybWFsaXplJyk7XG5jb25zdCBoYXQgPSByZXF1aXJlKCdoYXQnKTtcbmNvbnN0IGZlYXR1cmVzQXQgPSByZXF1aXJlKCcuL2xpYi9mZWF0dXJlc19hdCcpO1xuY29uc3Qgc3RyaW5nU2V0c0FyZUVxdWFsID0gcmVxdWlyZSgnLi9saWIvc3RyaW5nX3NldHNfYXJlX2VxdWFsJyk7XG5jb25zdCBnZW9qc29uaGludCA9IHJlcXVpcmUoJ0BtYXBib3gvZ2VvanNvbmhpbnQnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBTdHJpbmdTZXQgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdfc2V0Jyk7XG5cbmNvbnN0IGZlYXR1cmVUeXBlcyA9IHtcbiAgUG9seWdvbjogcmVxdWlyZSgnLi9mZWF0dXJlX3R5cGVzL3BvbHlnb24nKSxcbiAgTGluZVN0cmluZzogcmVxdWlyZSgnLi9mZWF0dXJlX3R5cGVzL2xpbmVfc3RyaW5nJyksXG4gIFBvaW50OiByZXF1aXJlKCcuL2ZlYXR1cmVfdHlwZXMvcG9pbnQnKSxcbiAgTXVsdGlQb2x5Z29uOiByZXF1aXJlKCcuL2ZlYXR1cmVfdHlwZXMvbXVsdGlfZmVhdHVyZScpLFxuICBNdWx0aUxpbmVTdHJpbmc6IHJlcXVpcmUoJy4vZmVhdHVyZV90eXBlcy9tdWx0aV9mZWF0dXJlJyksXG4gIE11bHRpUG9pbnQ6IHJlcXVpcmUoJy4vZmVhdHVyZV90eXBlcy9tdWx0aV9mZWF0dXJlJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3R4LCBhcGkpIHtcblxuICBhcGkubW9kZXMgPSBDb25zdGFudHMubW9kZXM7XG5cbiAgYXBpLmdldEZlYXR1cmVJZHNBdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBmZWF0dXJlc0F0LmNsaWNrKHsgcG9pbnQgfSwgbnVsbCwgY3R4KTtcbiAgICByZXR1cm4gZmVhdHVyZXMubWFwKGZlYXR1cmUgPT4gZmVhdHVyZS5wcm9wZXJ0aWVzLmlkKTtcbiAgfTtcblxuICBhcGkuZ2V0U2VsZWN0ZWRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGN0eC5zdG9yZS5nZXRTZWxlY3RlZElkcygpO1xuICB9O1xuXG4gIGFwaS5nZXRTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5GRUFUVVJFX0NPTExFQ1RJT04sXG4gICAgICBmZWF0dXJlczogY3R4LnN0b3JlLmdldFNlbGVjdGVkSWRzKCkubWFwKGlkID0+IGN0eC5zdG9yZS5nZXQoaWQpKS5tYXAoZmVhdHVyZSA9PiBmZWF0dXJlLnRvR2VvSlNPTigpKVxuICAgIH07XG4gIH07XG5cbiAgYXBpLmdldFNlbGVjdGVkUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkVfQ09MTEVDVElPTixcbiAgICAgIGZlYXR1cmVzOiBjdHguc3RvcmUuZ2V0U2VsZWN0ZWRDb29yZGluYXRlcygpLm1hcChjb29yZGluYXRlID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9JTlQsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZS5jb29yZGluYXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBhcGkuc2V0ID0gZnVuY3Rpb24oZmVhdHVyZUNvbGxlY3Rpb24pIHtcbiAgICBpZiAoZmVhdHVyZUNvbGxlY3Rpb24udHlwZSA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmVDb2xsZWN0aW9uLnR5cGUgIT09IENvbnN0YW50cy5nZW9qc29uVHlwZXMuRkVBVFVSRV9DT0xMRUNUSU9OIHx8ICFBcnJheS5pc0FycmF5KGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEZlYXR1cmVDb2xsZWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlckJhdGNoID0gY3R4LnN0b3JlLmNyZWF0ZVJlbmRlckJhdGNoKCk7XG4gICAgbGV0IHRvRGVsZXRlID0gY3R4LnN0b3JlLmdldEFsbElkcygpLnNsaWNlKCk7XG4gICAgY29uc3QgbmV3SWRzID0gYXBpLmFkZChmZWF0dXJlQ29sbGVjdGlvbik7XG4gICAgY29uc3QgbmV3SWRzTG9va3VwID0gbmV3IFN0cmluZ1NldChuZXdJZHMpO1xuXG4gICAgdG9EZWxldGUgPSB0b0RlbGV0ZS5maWx0ZXIoaWQgPT4gIW5ld0lkc0xvb2t1cC5oYXMoaWQpKTtcbiAgICBpZiAodG9EZWxldGUubGVuZ3RoKSB7XG4gICAgICBhcGkuZGVsZXRlKHRvRGVsZXRlKTtcbiAgICB9XG5cbiAgICByZW5kZXJCYXRjaCgpO1xuICAgIHJldHVybiBuZXdJZHM7XG4gIH07XG5cbiAgYXBpLmFkZCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgY29uc3QgZXJyb3JzID0gZ2VvanNvbmhpbnQuaGludChnZW9qc29uLCB7IHByZWNpc2lvbldhcm5pbmc6IGZhbHNlIH0pLmZpbHRlcihlID0+IGUubGV2ZWwgIT09ICdtZXNzYWdlJyk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnNbMF0ubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZlYXR1cmVDb2xsZWN0aW9uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShub3JtYWxpemUoZ2VvanNvbikpKTtcblxuICAgIGNvbnN0IGlkcyA9IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLm1hcChmZWF0dXJlID0+IHtcbiAgICAgIGZlYXR1cmUuaWQgPSBmZWF0dXJlLmlkIHx8IGhhdCgpO1xuXG4gICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2VvbWV0cnk6IG51bGwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5zdG9yZS5nZXQoZmVhdHVyZS5pZCkgPT09IHVuZGVmaW5lZCB8fCBjdHguc3RvcmUuZ2V0KGZlYXR1cmUuaWQpLnR5cGUgIT09IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSkge1xuICAgICAgICAvLyBJZiB0aGUgZmVhdHVyZSBoYXMgbm90IHlldCBiZWVuIGNyZWF0ZWQgLi4uXG4gICAgICAgIGNvbnN0IE1vZGVsID0gZmVhdHVyZVR5cGVzW2ZlYXR1cmUuZ2VvbWV0cnkudHlwZV07XG4gICAgICAgIGlmIChNb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGdlb21ldHJ5IHR5cGU6ICR7ZmVhdHVyZS5nZW9tZXRyeS50eXBlfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcm5hbEZlYXR1cmUgPSBuZXcgTW9kZWwoY3R4LCBmZWF0dXJlKTtcbiAgICAgICAgY3R4LnN0b3JlLmFkZChpbnRlcm5hbEZlYXR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgYSBmZWF0dXJlIG9mIHRoYXQgaWQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkLCBhbmQgd2UgYXJlIHN3YXBwaW5nIGl0IG91dCAuLi5cbiAgICAgICAgY29uc3QgaW50ZXJuYWxGZWF0dXJlID0gY3R4LnN0b3JlLmdldChmZWF0dXJlLmlkKTtcbiAgICAgICAgaW50ZXJuYWxGZWF0dXJlLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgICAgIGlmICghaXNFcXVhbChpbnRlcm5hbEZlYXR1cmUuZ2V0Q29vcmRpbmF0ZXMoKSwgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICBpbnRlcm5hbEZlYXR1cmUuaW5jb21pbmdDb29yZHMoZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmZWF0dXJlLmlkO1xuICAgIH0pO1xuXG4gICAgY3R4LnN0b3JlLnJlbmRlcigpO1xuICAgIHJldHVybiBpZHM7XG4gIH07XG5cblxuICBhcGkuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGN0eC5zdG9yZS5nZXQoaWQpO1xuICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gZmVhdHVyZS50b0dlb0pTT04oKTtcbiAgICB9XG4gIH07XG5cbiAgYXBpLmdldEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkVfQ09MTEVDVElPTixcbiAgICAgIGZlYXR1cmVzOiBjdHguc3RvcmUuZ2V0QWxsKCkubWFwKGZlYXR1cmUgPT4gZmVhdHVyZS50b0dlb0pTT04oKSlcbiAgICB9O1xuICB9O1xuXG4gIGFwaS5kZWxldGUgPSBmdW5jdGlvbihmZWF0dXJlSWRzKSB7XG4gICAgY3R4LnN0b3JlLmRlbGV0ZShmZWF0dXJlSWRzLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAvLyBJZiB3ZSB3ZXJlIGluIGRpcmVjdCBzZWxlY3QgbW9kZSBhbmQgb3VyIHNlbGVjdGVkIGZlYXR1cmUgbm8gbG9uZ2VyIGV4aXN0c1xuICAgIC8vIChiZWNhdXNlIGl0IHdhcyBkZWxldGVkKSwgd2UgbmVlZCB0byBnZXQgb3V0IG9mIHRoYXQgbW9kZS5cbiAgICBpZiAoYXBpLmdldE1vZGUoKSA9PT0gQ29uc3RhbnRzLm1vZGVzLkRJUkVDVF9TRUxFQ1QgJiYgIWN0eC5zdG9yZS5nZXRTZWxlY3RlZElkcygpLmxlbmd0aCkge1xuICAgICAgY3R4LmV2ZW50cy5jaGFuZ2VNb2RlKENvbnN0YW50cy5tb2Rlcy5TSU1QTEVfU0VMRUNULCB1bmRlZmluZWQsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc3RvcmUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICBhcGkuZGVsZXRlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgY3R4LnN0b3JlLmRlbGV0ZShjdHguc3RvcmUuZ2V0QWxsSWRzKCksIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIC8vIElmIHdlIHdlcmUgaW4gZGlyZWN0IHNlbGVjdCBtb2RlLCBub3cgb3VyIHNlbGVjdGVkIGZlYXR1cmUgbm8gbG9uZ2VyIGV4aXN0cyxcbiAgICAvLyBzbyBlc2NhcGUgdGhhdCBtb2RlLlxuICAgIGlmIChhcGkuZ2V0TW9kZSgpID09PSBDb25zdGFudHMubW9kZXMuRElSRUNUX1NFTEVDVCkge1xuICAgICAgY3R4LmV2ZW50cy5jaGFuZ2VNb2RlKENvbnN0YW50cy5tb2Rlcy5TSU1QTEVfU0VMRUNULCB1bmRlZmluZWQsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc3RvcmUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICBhcGkuY2hhbmdlTW9kZSA9IGZ1bmN0aW9uKG1vZGUsIG1vZGVPcHRpb25zID0ge30pIHtcbiAgICAvLyBBdm9pZCBjaGFuZ2luZyBtb2RlcyBqdXN0IHRvIHJlLXNlbGVjdCB3aGF0J3MgYWxyZWFkeSBzZWxlY3RlZFxuICAgIGlmIChtb2RlID09PSBDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCAmJiBhcGkuZ2V0TW9kZSgpID09PSBDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCkge1xuICAgICAgaWYgKHN0cmluZ1NldHNBcmVFcXVhbCgobW9kZU9wdGlvbnMuZmVhdHVyZUlkcyB8fCBbXSksIGN0eC5zdG9yZS5nZXRTZWxlY3RlZElkcygpKSkgcmV0dXJuIGFwaTtcbiAgICAgIC8vIEFuZCBpZiB3ZSBhcmUgY2hhbmdpbmcgdGhlIHNlbGVjdGlvbiB3aXRoaW4gc2ltcGxlX3NlbGVjdCBtb2RlLCBqdXN0IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxuICAgICAgLy8gaW5zdGVhZCBvZiBzdG9wcGluZyBhbmQgcmUtc3RhcnRpbmcgdGhlIG1vZGVcbiAgICAgIGN0eC5zdG9yZS5zZXRTZWxlY3RlZChtb2RlT3B0aW9ucy5mZWF0dXJlSWRzLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgIGN0eC5zdG9yZS5yZW5kZXIoKTtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09IENvbnN0YW50cy5tb2Rlcy5ESVJFQ1RfU0VMRUNUICYmIGFwaS5nZXRNb2RlKCkgPT09IENvbnN0YW50cy5tb2Rlcy5ESVJFQ1RfU0VMRUNUICYmXG4gICAgICBtb2RlT3B0aW9ucy5mZWF0dXJlSWQgPT09IGN0eC5zdG9yZS5nZXRTZWxlY3RlZElkcygpWzBdKSB7XG4gICAgICByZXR1cm4gYXBpO1xuICAgIH1cblxuICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShtb2RlLCBtb2RlT3B0aW9ucywgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICBhcGkuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjdHguZXZlbnRzLmdldE1vZGUoKTtcbiAgfTtcblxuICBhcGkudHJhc2ggPSBmdW5jdGlvbigpIHtcbiAgICBjdHguZXZlbnRzLnRyYXNoKHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgYXBpLmNvbWJpbmVGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGN0eC5ldmVudHMuY29tYmluZUZlYXR1cmVzKHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgYXBpLnVuY29tYmluZUZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgY3R4LmV2ZW50cy51bmNvbWJpbmVGZWF0dXJlcyh7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIGFwaS5zZXRGZWF0dXJlUHJvcGVydHkgPSBmdW5jdGlvbihmZWF0dXJlSWQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGN0eC5zdG9yZS5zZXRGZWF0dXJlUHJvcGVydHkoZmVhdHVyZUlkLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgcmV0dXJuIGFwaTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xhc3Nlczoge1xuICAgIENPTlRST0xfQkFTRTogJ21hcGJveGdsLWN0cmwnLFxuICAgIENPTlRST0xfUFJFRklYOiAnbWFwYm94Z2wtY3RybC0nLFxuICAgIENPTlRST0xfQlVUVE9OOiAnbWFwYm94LWdsLWRyYXdfY3RybC1kcmF3LWJ0bicsXG4gICAgQ09OVFJPTF9CVVRUT05fTElORTogJ21hcGJveC1nbC1kcmF3X2xpbmUnLFxuICAgIENPTlRST0xfQlVUVE9OX1BPTFlHT046ICdtYXBib3gtZ2wtZHJhd19wb2x5Z29uJyxcbiAgICBDT05UUk9MX0JVVFRPTl9QT0lOVDogJ21hcGJveC1nbC1kcmF3X3BvaW50JyxcbiAgICBDT05UUk9MX0JVVFRPTl9UUkFTSDogJ21hcGJveC1nbC1kcmF3X3RyYXNoJyxcbiAgICBDT05UUk9MX0JVVFRPTl9DT01CSU5FX0ZFQVRVUkVTOiAnbWFwYm94LWdsLWRyYXdfY29tYmluZScsXG4gICAgQ09OVFJPTF9CVVRUT05fVU5DT01CSU5FX0ZFQVRVUkVTOiAnbWFwYm94LWdsLWRyYXdfdW5jb21iaW5lJyxcbiAgICBDT05UUk9MX0dST1VQOiAnbWFwYm94Z2wtY3RybC1ncm91cCcsXG4gICAgQVRUUklCVVRJT046ICdtYXBib3hnbC1jdHJsLWF0dHJpYicsXG4gICAgQUNUSVZFX0JVVFRPTjogJ2FjdGl2ZScsXG4gICAgQk9YX1NFTEVDVDogJ21hcGJveC1nbC1kcmF3X2JveHNlbGVjdCdcbiAgfSxcbiAgc291cmNlczoge1xuICAgIEhPVDogJ21hcGJveC1nbC1kcmF3LWhvdCcsXG4gICAgQ09MRDogJ21hcGJveC1nbC1kcmF3LWNvbGQnXG4gIH0sXG4gIGN1cnNvcnM6IHtcbiAgICBBREQ6ICdhZGQnLFxuICAgIE1PVkU6ICdtb3ZlJyxcbiAgICBEUkFHOiAnZHJhZycsXG4gICAgUE9JTlRFUjogJ3BvaW50ZXInLFxuICAgIE5PTkU6ICdub25lJ1xuICB9LFxuICB0eXBlczoge1xuICAgIFBPTFlHT046ICdwb2x5Z29uJyxcbiAgICBMSU5FOiAnbGluZV9zdHJpbmcnLFxuICAgIFBPSU5UOiAncG9pbnQnXG4gIH0sXG4gIGdlb2pzb25UeXBlczoge1xuICAgIEZFQVRVUkU6ICdGZWF0dXJlJyxcbiAgICBQT0xZR09OOiAnUG9seWdvbicsXG4gICAgTElORV9TVFJJTkc6ICdMaW5lU3RyaW5nJyxcbiAgICBQT0lOVDogJ1BvaW50JyxcbiAgICBGRUFUVVJFX0NPTExFQ1RJT046ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgTVVMVElfUFJFRklYOiAnTXVsdGknLFxuICAgIE1VTFRJX1BPSU5UOiAnTXVsdGlQb2ludCcsXG4gICAgTVVMVElfTElORV9TVFJJTkc6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgIE1VTFRJX1BPTFlHT046ICdNdWx0aVBvbHlnb24nXG4gIH0sXG4gIG1vZGVzOiB7XG4gICAgRFJBV19MSU5FX1NUUklORzogJ2RyYXdfbGluZV9zdHJpbmcnLFxuICAgIERSQVdfUE9MWUdPTjogJ2RyYXdfcG9seWdvbicsXG4gICAgRFJBV19QT0lOVDogJ2RyYXdfcG9pbnQnLFxuICAgIFNJTVBMRV9TRUxFQ1Q6ICdzaW1wbGVfc2VsZWN0JyxcbiAgICBESVJFQ1RfU0VMRUNUOiAnZGlyZWN0X3NlbGVjdCcsXG4gICAgU1RBVElDOiAnc3RhdGljJ1xuICB9LFxuICBldmVudHM6IHtcbiAgICBDUkVBVEU6ICdkcmF3LmNyZWF0ZScsXG4gICAgREVMRVRFOiAnZHJhdy5kZWxldGUnLFxuICAgIFVQREFURTogJ2RyYXcudXBkYXRlJyxcbiAgICBTRUxFQ1RJT05fQ0hBTkdFOiAnZHJhdy5zZWxlY3Rpb25jaGFuZ2UnLFxuICAgIE1PREVfQ0hBTkdFOiAnZHJhdy5tb2RlY2hhbmdlJyxcbiAgICBBQ1RJT05BQkxFOiAnZHJhdy5hY3Rpb25hYmxlJyxcbiAgICBSRU5ERVI6ICdkcmF3LnJlbmRlcicsXG4gICAgQ09NQklORV9GRUFUVVJFUzogJ2RyYXcuY29tYmluZScsXG4gICAgVU5DT01CSU5FX0ZFQVRVUkVTOiAnZHJhdy51bmNvbWJpbmUnXG4gIH0sXG4gIHVwZGF0ZUFjdGlvbnM6IHtcbiAgICBNT1ZFOiAnbW92ZScsXG4gICAgQ0hBTkdFX0NPT1JESU5BVEVTOiAnY2hhbmdlX2Nvb3JkaW5hdGVzJ1xuICB9LFxuICBtZXRhOiB7XG4gICAgRkVBVFVSRTogJ2ZlYXR1cmUnLFxuICAgIE1JRFBPSU5UOiAnbWlkcG9pbnQnLFxuICAgIFZFUlRFWDogJ3ZlcnRleCdcbiAgfSxcbiAgYWN0aXZlU3RhdGVzOiB7XG4gICAgQUNUSVZFOiAndHJ1ZScsXG4gICAgSU5BQ1RJVkU6ICdmYWxzZSdcbiAgfSxcbiAgTEFUX01JTjogLTkwLFxuICBMQVRfUkVOREVSRURfTUlOOiAtODUsXG4gIExBVF9NQVg6IDkwLFxuICBMQVRfUkVOREVSRURfTUFYOiA4NSxcbiAgTE5HX01JTjogLTI3MCxcbiAgTE5HX01BWDogMjcwXG59O1xuIiwiY29uc3Qgc2V0dXBNb2RlSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL21vZGVfaGFuZGxlcicpO1xuY29uc3QgZ2V0RmVhdHVyZXNBbmRTZXRDdXJzb3IgPSByZXF1aXJlKCcuL2xpYi9nZXRfZmVhdHVyZXNfYW5kX3NldF9jdXJzb3InKTtcbmNvbnN0IGZlYXR1cmVzQXQgPSByZXF1aXJlKCcuL2xpYi9mZWF0dXJlc19hdCcpO1xuY29uc3QgaXNDbGljayA9IHJlcXVpcmUoJy4vbGliL2lzX2NsaWNrJyk7XG5jb25zdCBpc1RhcCA9IHJlcXVpcmUoJy4vbGliL2lzX3RhcCcpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgbW9kZXMgPSB7XG4gIFtDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVF06IHJlcXVpcmUoJy4vbW9kZXMvc2ltcGxlX3NlbGVjdCcpLFxuICBbQ29uc3RhbnRzLm1vZGVzLkRJUkVDVF9TRUxFQ1RdOiByZXF1aXJlKCcuL21vZGVzL2RpcmVjdF9zZWxlY3QnKSxcbiAgW0NvbnN0YW50cy5tb2Rlcy5EUkFXX1BPSU5UXTogcmVxdWlyZSgnLi9tb2Rlcy9kcmF3X3BvaW50JyksXG4gIFtDb25zdGFudHMubW9kZXMuRFJBV19MSU5FX1NUUklOR106IHJlcXVpcmUoJy4vbW9kZXMvZHJhd19saW5lX3N0cmluZycpLFxuICBbQ29uc3RhbnRzLm1vZGVzLkRSQVdfUE9MWUdPTl06IHJlcXVpcmUoJy4vbW9kZXMvZHJhd19wb2x5Z29uJyksXG4gIFtDb25zdGFudHMubW9kZXMuU1RBVElDXTogcmVxdWlyZSgnLi9tb2Rlcy9zdGF0aWMnKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgpIHtcblxuICBsZXQgbW91c2VEb3duSW5mbyA9IHt9O1xuICBsZXQgdG91Y2hTdGFydEluZm8gPSB7fTtcbiAgY29uc3QgZXZlbnRzID0ge307XG4gIGxldCBjdXJyZW50TW9kZU5hbWUgPSBDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVDtcbiAgbGV0IGN1cnJlbnRNb2RlID0gc2V0dXBNb2RlSGFuZGxlcihtb2Rlcy5zaW1wbGVfc2VsZWN0KGN0eCksIGN0eCk7XG5cbiAgZXZlbnRzLmRyYWcgPSBmdW5jdGlvbihldmVudCwgaXNEcmFnKSB7XG4gICAgaWYgKGlzRHJhZyh7XG4gICAgICBwb2ludDogZXZlbnQucG9pbnQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgIH0pKSB7XG4gICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLkRSQUcgfSk7XG4gICAgICBjdXJyZW50TW9kZS5kcmFnKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgZXZlbnRzLm1vdXNlZHJhZyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnRzLmRyYWcoZXZlbnQsIChlbmRJbmZvKSA9PiAhaXNDbGljayhtb3VzZURvd25JbmZvLCBlbmRJbmZvKSk7XG4gIH07XG5cbiAgZXZlbnRzLnRvdWNoZHJhZyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnRzLmRyYWcoZXZlbnQsIChlbmRJbmZvKSA9PiAhaXNUYXAodG91Y2hTdGFydEluZm8sIGVuZEluZm8pKTtcbiAgfTtcblxuICBldmVudHMubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjb25zdCBidXR0b24gPSBldmVudC5vcmlnaW5hbEV2ZW50LmJ1dHRvbnMgIT09IHVuZGVmaW5lZCA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQuYnV0dG9ucyA6IGV2ZW50Lm9yaWdpbmFsRXZlbnQud2hpY2g7XG4gICAgaWYgKGJ1dHRvbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGV2ZW50cy5tb3VzZWRyYWcoZXZlbnQpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRGZWF0dXJlc0FuZFNldEN1cnNvcihldmVudCwgY3R4KTtcbiAgICBldmVudC5mZWF0dXJlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGN1cnJlbnRNb2RlLm1vdXNlbW92ZShldmVudCk7XG4gIH07XG5cbiAgZXZlbnRzLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbW91c2VEb3duSW5mbyA9IHtcbiAgICAgIHRpbWU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgcG9pbnQ6IGV2ZW50LnBvaW50XG4gICAgfTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRGZWF0dXJlc0FuZFNldEN1cnNvcihldmVudCwgY3R4KTtcbiAgICBldmVudC5mZWF0dXJlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGN1cnJlbnRNb2RlLm1vdXNlZG93bihldmVudCk7XG4gIH07XG5cbiAgZXZlbnRzLm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEZlYXR1cmVzQW5kU2V0Q3Vyc29yKGV2ZW50LCBjdHgpO1xuICAgIGV2ZW50LmZlYXR1cmVUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBpZiAoaXNDbGljayhtb3VzZURvd25JbmZvLCB7XG4gICAgICBwb2ludDogZXZlbnQucG9pbnQsXG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgIH0pKSB7XG4gICAgICBjdXJyZW50TW9kZS5jbGljayhldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRNb2RlLm1vdXNldXAoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBldmVudHMubW91c2VvdXQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGN1cnJlbnRNb2RlLm1vdXNlb3V0KGV2ZW50KTtcbiAgfTtcblxuICBldmVudHMudG91Y2hzdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gUHJldmVudCBlbXVsYXRlZCBtb3VzZSBldmVudHMgYmVjYXVzZSB3ZSB3aWxsIGZ1bGx5IGhhbmRsZSB0aGUgdG91Y2ggaGVyZS5cbiAgICAvLyBUaGlzIGRvZXMgbm90IHN0b3AgdGhlIHRvdWNoIGV2ZW50cyBmcm9tIHByb3BvZ2F0aW5nIHRvIG1hcGJveCB0aG91Z2guXG4gICAgZXZlbnQub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghY3R4Lm9wdGlvbnMudG91Y2hFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG91Y2hTdGFydEluZm8gPSB7XG4gICAgICB0aW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgIHBvaW50OiBldmVudC5wb2ludFxuICAgIH07XG4gICAgY29uc3QgdGFyZ2V0ID0gZmVhdHVyZXNBdC50b3VjaChldmVudCwgbnVsbCwgY3R4KVswXTtcbiAgICBldmVudC5mZWF0dXJlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGN1cnJlbnRNb2RlLnRvdWNoc3RhcnQoZXZlbnQpO1xuICB9O1xuXG4gIGV2ZW50cy50b3VjaG1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIWN0eC5vcHRpb25zLnRvdWNoRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRNb2RlLnRvdWNobW92ZShldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50cy50b3VjaGRyYWcoZXZlbnQpO1xuICB9O1xuXG4gIGV2ZW50cy50b3VjaGVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgZXZlbnQub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghY3R4Lm9wdGlvbnMudG91Y2hFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZmVhdHVyZXNBdC50b3VjaChldmVudCwgbnVsbCwgY3R4KVswXTtcbiAgICBldmVudC5mZWF0dXJlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChpc1RhcCh0b3VjaFN0YXJ0SW5mbywge1xuICAgICAgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICBwb2ludDogZXZlbnQucG9pbnRcbiAgICB9KSkge1xuICAgICAgY3VycmVudE1vZGUudGFwKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE1vZGUudG91Y2hlbmQoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvLyA4IC0gQmFja3NwYWNlXG4gIC8vIDQ2IC0gRGVsZXRlXG4gIGNvbnN0IGlzS2V5TW9kZVZhbGlkID0gKGNvZGUpID0+ICEoY29kZSA9PT0gOCB8fCBjb2RlID09PSA0NiB8fCAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSk7XG5cbiAgZXZlbnRzLmtleWRvd24gPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKChldmVudC5rZXlDb2RlID09PSA4IHx8IGV2ZW50LmtleUNvZGUgPT09IDQ2KSAmJiBjdHgub3B0aW9ucy5jb250cm9scy50cmFzaCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGN1cnJlbnRNb2RlLnRyYXNoKCk7XG4gICAgfSBlbHNlIGlmIChpc0tleU1vZGVWYWxpZChldmVudC5rZXlDb2RlKSkge1xuICAgICAgY3VycmVudE1vZGUua2V5ZG93bihldmVudCk7XG4gICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA0OSAmJiBjdHgub3B0aW9ucy5jb250cm9scy5wb2ludCkge1xuICAgICAgY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuRFJBV19QT0lOVCk7XG4gICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA1MCAmJiBjdHgub3B0aW9ucy5jb250cm9scy5saW5lX3N0cmluZykge1xuICAgICAgY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuRFJBV19MSU5FX1NUUklORyk7XG4gICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA1MSAmJiBjdHgub3B0aW9ucy5jb250cm9scy5wb2x5Z29uKSB7XG4gICAgICBjaGFuZ2VNb2RlKENvbnN0YW50cy5tb2Rlcy5EUkFXX1BPTFlHT04pO1xuICAgIH1cblxuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxNykge1xuICAgICAgY3R4LnNuYXBUb092ZXJyaWRlID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZXZlbnRzLmtleXVwID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoaXNLZXlNb2RlVmFsaWQoZXZlbnQua2V5Q29kZSkpIHtcbiAgICAgIGN1cnJlbnRNb2RlLmtleXVwKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTcpIHtcbiAgICAgIGN0eC5zbmFwVG9PdmVycmlkZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBldmVudHMuem9vbWVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGN0eC5zdG9yZS5jaGFuZ2Vab29tKCk7XG4gIH07XG5cbiAgZXZlbnRzLmRhdGEgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhVHlwZSA9PT0gJ3N0eWxlJykge1xuICAgICAgY29uc3QgeyBzZXR1cCwgbWFwLCBvcHRpb25zLCBzdG9yZSB9ID0gY3R4O1xuICAgICAgY29uc3QgaGFzTGF5ZXJzID0gb3B0aW9ucy5zdHlsZXMuc29tZShzdHlsZSA9PiBtYXAuZ2V0TGF5ZXIoc3R5bGUuaWQpKTtcbiAgICAgIGlmICghaGFzTGF5ZXJzKSB7XG4gICAgICAgIHNldHVwLmFkZExheWVycygpO1xuICAgICAgICBzdG9yZS5zZXREaXJ0eSgpO1xuICAgICAgICBzdG9yZS5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hhbmdlTW9kZShtb2RlbmFtZSwgbmV4dE1vZGVPcHRpb25zLCBldmVudE9wdGlvbnMgPSB7fSkge1xuICAgIGN1cnJlbnRNb2RlLnN0b3AoKTtcblxuICAgIGNvbnN0IG1vZGVidWlsZGVyID0gbW9kZXNbbW9kZW5hbWVdO1xuICAgIGlmIChtb2RlYnVpbGRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bW9kZW5hbWV9IGlzIG5vdCB2YWxpZGApO1xuICAgIH1cbiAgICBjdXJyZW50TW9kZU5hbWUgPSBtb2RlbmFtZTtcbiAgICBjb25zdCBtb2RlID0gbW9kZWJ1aWxkZXIoY3R4LCBuZXh0TW9kZU9wdGlvbnMpO1xuICAgIGN1cnJlbnRNb2RlID0gc2V0dXBNb2RlSGFuZGxlcihtb2RlLCBjdHgpO1xuXG4gICAgaWYgKCFldmVudE9wdGlvbnMuc2lsZW50KSB7XG4gICAgICBjdHgubWFwLmZpcmUoQ29uc3RhbnRzLmV2ZW50cy5NT0RFX0NIQU5HRSwgeyBtb2RlOiBtb2RlbmFtZX0pO1xuICAgIH1cblxuICAgIGN0eC5zdG9yZS5zZXREaXJ0eSgpO1xuICAgIGN0eC5zdG9yZS5yZW5kZXIoKTtcbiAgfVxuXG4gIGNvbnN0IGFjdGlvblN0YXRlID0ge1xuICAgIHRyYXNoOiBmYWxzZSxcbiAgICBjb21iaW5lRmVhdHVyZXM6IGZhbHNlLFxuICAgIHVuY29tYmluZUZlYXR1cmVzOiBmYWxzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFjdGlvbmFibGUoYWN0aW9ucykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgaWYgKGFjdGlvblN0YXRlW2FjdGlvbl0gPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFjdGlvbiB0eXBlJyk7XG4gICAgICBpZiAoYWN0aW9uU3RhdGVbYWN0aW9uXSAhPT0gYWN0aW9uc1thY3Rpb25dKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGFjdGlvblN0YXRlW2FjdGlvbl0gPSBhY3Rpb25zW2FjdGlvbl07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWQpIGN0eC5tYXAuZmlyZShDb25zdGFudHMuZXZlbnRzLkFDVElPTkFCTEUsIHsgYWN0aW9uczogYWN0aW9uU3RhdGUgfSk7XG4gIH1cblxuICBjb25zdCBhcGkgPSB7XG4gICAgY2hhbmdlTW9kZSxcbiAgICBhY3Rpb25hYmxlLFxuICAgIGN1cnJlbnRNb2RlTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3VycmVudE1vZGVOYW1lO1xuICAgIH0sXG4gICAgY3VycmVudE1vZGVSZW5kZXI6IGZ1bmN0aW9uKGdlb2pzb24sIHB1c2gpIHtcbiAgICAgIHJldHVybiBjdXJyZW50TW9kZS5yZW5kZXIoZ2VvanNvbiwgcHVzaCk7XG4gICAgfSxcbiAgICBmaXJlOiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgaWYgKGV2ZW50c1tuYW1lXSkge1xuICAgICAgICBldmVudHNbbmFtZV0oZXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgY3R4Lm1hcC5vbignbW91c2Vtb3ZlJywgZXZlbnRzLm1vdXNlbW92ZSk7XG4gICAgICBjdHgubWFwLm9uKCdtb3VzZWRvd24nLCBldmVudHMubW91c2Vkb3duKTtcbiAgICAgIGN0eC5tYXAub24oJ21vdXNldXAnLCBldmVudHMubW91c2V1cCk7XG4gICAgICBjdHgubWFwLm9uKCdkYXRhJywgZXZlbnRzLmRhdGEpO1xuXG4gICAgICBjdHgubWFwLm9uKCd0b3VjaG1vdmUnLCBldmVudHMudG91Y2htb3ZlKTtcbiAgICAgIGN0eC5tYXAub24oJ3RvdWNoc3RhcnQnLCBldmVudHMudG91Y2hzdGFydCk7XG4gICAgICBjdHgubWFwLm9uKCd0b3VjaGVuZCcsIGV2ZW50cy50b3VjaGVuZCk7XG5cbiAgICAgIGN0eC5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBldmVudHMubW91c2VvdXQpO1xuXG4gICAgICBpZiAoY3R4Lm9wdGlvbnMua2V5YmluZGluZ3MpIHtcbiAgICAgICAgY3R4LmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnRzLmtleWRvd24pO1xuICAgICAgICBjdHguY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZXZlbnRzLmtleXVwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIGN0eC5tYXAub2ZmKCdtb3VzZW1vdmUnLCBldmVudHMubW91c2Vtb3ZlKTtcbiAgICAgIGN0eC5tYXAub2ZmKCdtb3VzZWRvd24nLCBldmVudHMubW91c2Vkb3duKTtcbiAgICAgIGN0eC5tYXAub2ZmKCdtb3VzZXVwJywgZXZlbnRzLm1vdXNldXApO1xuICAgICAgY3R4Lm1hcC5vZmYoJ2RhdGEnLCBldmVudHMuZGF0YSk7XG5cbiAgICAgIGN0eC5tYXAub2ZmKCd0b3VjaG1vdmUnLCBldmVudHMudG91Y2htb3ZlKTtcbiAgICAgIGN0eC5tYXAub2ZmKCd0b3VjaHN0YXJ0JywgZXZlbnRzLnRvdWNoc3RhcnQpO1xuICAgICAgY3R4Lm1hcC5vZmYoJ3RvdWNoZW5kJywgZXZlbnRzLnRvdWNoZW5kKTtcblxuICAgICAgY3R4LmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGV2ZW50cy5tb3VzZW91dCk7XG5cbiAgICAgIGlmIChjdHgub3B0aW9ucy5rZXliaW5kaW5ncykge1xuICAgICAgICBjdHguY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBldmVudHMua2V5ZG93bik7XG4gICAgICAgIGN0eC5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBldmVudHMua2V5dXApO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHJhc2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGN1cnJlbnRNb2RlLnRyYXNoKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgY29tYmluZUZlYXR1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGN1cnJlbnRNb2RlLmNvbWJpbmVGZWF0dXJlcygpO1xuICAgIH0sXG4gICAgdW5jb21iaW5lRmVhdHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgY3VycmVudE1vZGUudW5jb21iaW5lRmVhdHVyZXMoKTtcbiAgICB9LFxuICAgIGdldE1vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRNb2RlTmFtZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGFwaTtcbn07XG4iLCJjb25zdCBoYXQgPSByZXF1aXJlKCdoYXQnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5jb25zdCBGZWF0dXJlID0gZnVuY3Rpb24oY3R4LCBnZW9qc29uKSB7XG4gIHRoaXMuY3R4ID0gY3R4O1xuICB0aGlzLnByb3BlcnRpZXMgPSBnZW9qc29uLnByb3BlcnRpZXMgfHwge307XG4gIHRoaXMuY29vcmRpbmF0ZXMgPSBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICB0aGlzLmlkID0gZ2VvanNvbi5pZCB8fCBoYXQoKTtcbiAgdGhpcy50eXBlID0gZ2VvanNvbi5nZW9tZXRyeS50eXBlO1xufTtcblxuRmVhdHVyZS5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN0eC5zdG9yZS5mZWF0dXJlQ2hhbmdlZCh0aGlzLmlkKTtcbn07XG5cbkZlYXR1cmUucHJvdG90eXBlLmluY29taW5nQ29vcmRzID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gIHRoaXMuc2V0Q29vcmRpbmF0ZXMoY29vcmRzKTtcbn07XG5cbkZlYXR1cmUucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gIHRoaXMuY29vcmRpbmF0ZXMgPSBjb29yZHM7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuRmVhdHVyZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jb29yZGluYXRlcykpO1xufTtcblxuRmVhdHVyZS5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IHZhbHVlO1xufTtcblxuRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtcbiAgICBpZDogdGhpcy5pZCxcbiAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICBjb29yZGluYXRlczogdGhpcy5nZXRDb29yZGluYXRlcygpLFxuICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgfVxuICB9KSk7XG59O1xuXG5GZWF0dXJlLnByb3RvdHlwZS5pbnRlcm5hbCA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICBpZDogdGhpcy5pZCxcbiAgICBtZXRhOiBDb25zdGFudHMubWV0YS5GRUFUVVJFLFxuICAgICdtZXRhOnR5cGUnOiB0aGlzLnR5cGUsXG4gICAgYWN0aXZlOiBDb25zdGFudHMuYWN0aXZlU3RhdGVzLklOQUNUSVZFLFxuICAgIG1vZGU6IG1vZGVcbiAgfTtcblxuICBpZiAodGhpcy5jdHgub3B0aW9ucy51c2VyUHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIHByb3BlcnRpZXNbYHVzZXJfJHtuYW1lfWBdID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5GRUFUVVJFLFxuICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmdldENvb3JkaW5hdGVzKCksXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmU7XG4iLCJjb25zdCBGZWF0dXJlID0gcmVxdWlyZSgnLi9mZWF0dXJlJyk7XG5cbmNvbnN0IExpbmVTdHJpbmcgPSBmdW5jdGlvbihjdHgsIGdlb2pzb24pIHtcbiAgRmVhdHVyZS5jYWxsKHRoaXMsIGN0eCwgZ2VvanNvbik7XG59O1xuXG5MaW5lU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmVhdHVyZS5wcm90b3R5cGUpO1xuXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDE7XG59O1xuXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5hZGRDb29yZGluYXRlID0gZnVuY3Rpb24ocGF0aCwgbG5nLCBsYXQpIHtcbiAgdGhpcy5jaGFuZ2VkKCk7XG4gIGNvbnN0IGlkID0gcGFyc2VJbnQocGF0aCwgMTApO1xuICB0aGlzLmNvb3JkaW5hdGVzLnNwbGljZShpZCwgMCwgW2xuZywgbGF0XSk7XG59O1xuXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBpZCA9IHBhcnNlSW50KHBhdGgsIDEwKTtcbiAgY29uc3QgY29vcmRzID0gdGhpcy5jb29yZGluYXRlc1tpZF07XG4gIGlmIChjb29yZHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29vcmRzKSk7XG59O1xuXG5MaW5lU3RyaW5nLnByb3RvdHlwZS5yZW1vdmVDb29yZGluYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICB0aGlzLmNoYW5nZWQoKTtcbiAgdGhpcy5jb29yZGluYXRlcy5zcGxpY2UocGFyc2VJbnQocGF0aCwgMTApLCAxKTtcbn07XG5cbkxpbmVTdHJpbmcucHJvdG90eXBlLnVwZGF0ZUNvb3JkaW5hdGUgPSBmdW5jdGlvbihwYXRoLCBsbmcsIGxhdCkge1xuICBjb25zdCBpZCA9IHBhcnNlSW50KHBhdGgsIDEwKTtcbiAgdGhpcy5jb29yZGluYXRlc1tpZF0gPSBbbG5nLCBsYXRdO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVN0cmluZztcbiIsImNvbnN0IEZlYXR1cmUgPSByZXF1aXJlKCcuL2ZlYXR1cmUnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgaGF0ID0gcmVxdWlyZSgnaGF0Jyk7XG5cbmNvbnN0IG1vZGVscyA9IHtcbiAgTXVsdGlQb2ludDogcmVxdWlyZSgnLi9wb2ludCcpLFxuICBNdWx0aUxpbmVTdHJpbmc6IHJlcXVpcmUoJy4vbGluZV9zdHJpbmcnKSxcbiAgTXVsdGlQb2x5Z29uOiByZXF1aXJlKCcuL3BvbHlnb24nKVxufTtcblxuY29uc3QgdGFrZUFjdGlvbiA9IChmZWF0dXJlcywgYWN0aW9uLCBwYXRoLCBsbmcsIGxhdCkgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgY29uc3QgaWR4ID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgY29uc3QgdGFpbCA9ICghcGFydHNbMV0pID8gbnVsbCA6IHBhcnRzLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgcmV0dXJuIGZlYXR1cmVzW2lkeF1bYWN0aW9uXSh0YWlsLCBsbmcsIGxhdCk7XG59O1xuXG5jb25zdCBNdWx0aUZlYXR1cmUgPSBmdW5jdGlvbihjdHgsIGdlb2pzb24pIHtcbiAgRmVhdHVyZS5jYWxsKHRoaXMsIGN0eCwgZ2VvanNvbik7XG5cbiAgZGVsZXRlIHRoaXMuY29vcmRpbmF0ZXM7XG4gIHRoaXMubW9kZWwgPSBtb2RlbHNbZ2VvanNvbi5nZW9tZXRyeS50eXBlXTtcbiAgaWYgKHRoaXMubW9kZWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtnZW9qc29uLmdlb21ldHJ5LnR5cGV9IGlzIG5vdCBhIHZhbGlkIHR5cGVgKTtcbiAgdGhpcy5mZWF0dXJlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzVG9GZWF0dXJlcyhnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmUucHJvdG90eXBlKTtcblxuTXVsdGlGZWF0dXJlLnByb3RvdHlwZS5fY29vcmRpbmF0ZXNUb0ZlYXR1cmVzID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgY29uc3QgTW9kZWwgPSB0aGlzLm1vZGVsLmJpbmQodGhpcyk7XG4gIHJldHVybiBjb29yZGluYXRlcy5tYXAoY29vcmRzID0+IG5ldyBNb2RlbCh0aGlzLmN0eCwge1xuICAgIGlkOiBoYXQoKSxcbiAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHMsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUucmVwbGFjZSgnTXVsdGknLCAnJylcbiAgICB9XG4gIH0pKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5mZWF0dXJlcy5ldmVyeShmID0+IGYuaXNWYWxpZCgpKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgdGhpcy5mZWF0dXJlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzVG9GZWF0dXJlcyhjb29yZHMpO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHRha2VBY3Rpb24odGhpcy5mZWF0dXJlcywgJ2dldENvb3JkaW5hdGUnLCBwYXRoKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5mZWF0dXJlcy5tYXAoZiA9PiB7XG4gICAgaWYgKGYudHlwZSA9PT0gQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5QT0xZR09OKSByZXR1cm4gZi5nZXRDb29yZGluYXRlcygpO1xuICAgIHJldHVybiBmLmNvb3JkaW5hdGVzO1xuICB9KSkpO1xufTtcblxuTXVsdGlGZWF0dXJlLnByb3RvdHlwZS51cGRhdGVDb29yZGluYXRlID0gZnVuY3Rpb24ocGF0aCwgbG5nLCBsYXQpIHtcbiAgdGFrZUFjdGlvbih0aGlzLmZlYXR1cmVzLCAndXBkYXRlQ29vcmRpbmF0ZScsIHBhdGgsIGxuZywgbGF0KTtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5NdWx0aUZlYXR1cmUucHJvdG90eXBlLmFkZENvb3JkaW5hdGUgPSBmdW5jdGlvbihwYXRoLCBsbmcsIGxhdCkge1xuICB0YWtlQWN0aW9uKHRoaXMuZmVhdHVyZXMsICdhZGRDb29yZGluYXRlJywgcGF0aCwgbG5nLCBsYXQpO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUucmVtb3ZlQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdGFrZUFjdGlvbih0aGlzLmZlYXR1cmVzLCAncmVtb3ZlQ29vcmRpbmF0ZScsIHBhdGgpO1xuICB0aGlzLmNoYW5nZWQoKTtcbn07XG5cbk11bHRpRmVhdHVyZS5wcm90b3R5cGUuZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmVhdHVyZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpRmVhdHVyZTtcbiIsImNvbnN0IEZlYXR1cmUgPSByZXF1aXJlKCcuL2ZlYXR1cmUnKTtcblxuY29uc3QgUG9pbnQgPSBmdW5jdGlvbihjdHgsIGdlb2pzb24pIHtcbiAgRmVhdHVyZS5jYWxsKHRoaXMsIGN0eCwgZ2VvanNvbik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmUucHJvdG90eXBlKTtcblxuUG9pbnQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzLmNvb3JkaW5hdGVzWzBdID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiB0aGlzLmNvb3JkaW5hdGVzWzFdID09PSAnbnVtYmVyJztcbn07XG5cblBvaW50LnByb3RvdHlwZS51cGRhdGVDb29yZGluYXRlID0gZnVuY3Rpb24ocGF0aE9yTG5nLCBsbmdPckxhdCwgbGF0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdGhpcy5jb29yZGluYXRlcyA9IFtsbmdPckxhdCwgbGF0XTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gW3BhdGhPckxuZywgbG5nT3JMYXRdO1xuICB9XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG4iLCJjb25zdCBGZWF0dXJlID0gcmVxdWlyZSgnLi9mZWF0dXJlJyk7XG5cbmNvbnN0IFBvbHlnb24gPSBmdW5jdGlvbihjdHgsIGdlb2pzb24pIHtcbiAgRmVhdHVyZS5jYWxsKHRoaXMsIGN0eCwgZ2VvanNvbik7XG4gIHRoaXMuY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzLm1hcChyaW5nID0+IHJpbmcuc2xpY2UoMCwgLTEpKTtcbn07XG5cblBvbHlnb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlLnByb3RvdHlwZSk7XG5cblBvbHlnb24ucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLmV2ZXJ5KHJpbmcgPT4gcmluZy5sZW5ndGggPiAyKTtcbn07XG5cbi8vIEV4cGVjdHMgdmFsaWQgZ2VvSlNPTiBwb2x5Z29uIGdlb21ldHJ5OiBmaXJzdCBhbmQgbGFzdCBwb3NpdGlvbnMgbXVzdCBiZSBlcXVpdmFsZW50LlxuUG9seWdvbi5wcm90b3R5cGUuaW5jb21pbmdDb29yZHMgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3Jkcy5tYXAocmluZyA9PiByaW5nLnNsaWNlKDAsIC0xKSk7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuLy8gRG9lcyBOT1QgZXhwZWN0IHZhbGlkIGdlb0pTT04gcG9seWdvbiBnZW9tZXRyeTogZmlyc3QgYW5kIGxhc3QgcG9zaXRpb25zIHNob3VsZCBub3QgYmUgZXF1aXZhbGVudC5cblBvbHlnb24ucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gIHRoaXMuY29vcmRpbmF0ZXMgPSBjb29yZHM7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuUG9seWdvbi5wcm90b3R5cGUuYWRkQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHBhdGgsIGxuZywgbGF0KSB7XG4gIHRoaXMuY2hhbmdlZCgpO1xuICBjb25zdCBpZHMgPSBwYXRoLnNwbGl0KCcuJykubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKTtcblxuICBjb25zdCByaW5nID0gdGhpcy5jb29yZGluYXRlc1tpZHNbMF1dO1xuXG4gIHJpbmcuc3BsaWNlKGlkc1sxXSwgMCwgW2xuZywgbGF0XSk7XG59O1xuXG5Qb2x5Z29uLnByb3RvdHlwZS5yZW1vdmVDb29yZGluYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICB0aGlzLmNoYW5nZWQoKTtcbiAgY29uc3QgaWRzID0gcGF0aC5zcGxpdCgnLicpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSk7XG4gIGNvbnN0IHJpbmcgPSB0aGlzLmNvb3JkaW5hdGVzW2lkc1swXV07XG4gIGlmIChyaW5nKSB7XG4gICAgcmluZy5zcGxpY2UoaWRzWzFdLCAxKTtcbiAgICBpZiAocmluZy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzLnNwbGljZShpZHNbMV0sIDApO1xuICAgIH1cbiAgfVxufTtcblxuUG9seWdvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgaWRzID0gcGF0aC5zcGxpdCgnLicpLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSk7XG4gIGNvbnN0IHJpbmcgPSB0aGlzLmNvb3JkaW5hdGVzW2lkc1swXV07XG4gIGNvbnN0IGNvb3JkcyA9IHJpbmdbaWRzWzFdXTtcbiAgaWYgKGNvb3JkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb29yZHMpKTtcbn07XG5cblBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLm1hcChjb29yZHMgPT4gY29vcmRzLmNvbmNhdChbY29vcmRzWzBdXSkpO1xufTtcblxuUG9seWdvbi5wcm90b3R5cGUudXBkYXRlQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHBhdGgsIGxuZywgbGF0KSB7XG4gIHRoaXMuY2hhbmdlZCgpO1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgY29uc3QgcmluZ0lkID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgY29uc3QgY29vcmRJZCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG5cbiAgaWYgKHRoaXMuY29vcmRpbmF0ZXNbcmluZ0lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5jb29yZGluYXRlc1tyaW5nSWRdID0gW107XG4gIH1cblxuICB0aGlzLmNvb3JkaW5hdGVzW3JpbmdJZF1bY29vcmRJZF0gPSBbbG5nLCBsYXRdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuIiwiY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09mTWV0YVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgY29uc3QgZmVhdHVyZVRhcmdldCA9IGUuZmVhdHVyZVRhcmdldDtcbiAgICAgIGlmICghZmVhdHVyZVRhcmdldCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFmZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBmZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMubWV0YSA9PT0gdHlwZTtcbiAgICB9O1xuICB9LFxuICBpc1NoaWZ0TW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBlLm9yaWdpbmFsRXZlbnQuYnV0dG9uID09PSAwO1xuICB9LFxuICBpc0FjdGl2ZUZlYXR1cmU6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWUuZmVhdHVyZVRhcmdldCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMuYWN0aXZlID09PSBDb25zdGFudHMuYWN0aXZlU3RhdGVzLkFDVElWRSAmJlxuICAgICAgZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMubWV0YSA9PT0gQ29uc3RhbnRzLm1ldGEuRkVBVFVSRTtcbiAgfSxcbiAgaXNJbmFjdGl2ZUZlYXR1cmU6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWUuZmVhdHVyZVRhcmdldCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMuYWN0aXZlID09PSBDb25zdGFudHMuYWN0aXZlU3RhdGVzLklOQUNUSVZFICYmXG4gICAgICBlLmZlYXR1cmVUYXJnZXQucHJvcGVydGllcy5tZXRhID09PSBDb25zdGFudHMubWV0YS5GRUFUVVJFO1xuICB9LFxuICBub1RhcmdldDogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmZlYXR1cmVUYXJnZXQgPT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgaXNGZWF0dXJlOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFlLmZlYXR1cmVUYXJnZXQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWUuZmVhdHVyZVRhcmdldC5wcm9wZXJ0aWVzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGUuZmVhdHVyZVRhcmdldC5wcm9wZXJ0aWVzLm1ldGEgPT09IENvbnN0YW50cy5tZXRhLkZFQVRVUkU7XG4gIH0sXG4gIGlzVmVydGV4OiBmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgZmVhdHVyZVRhcmdldCA9IGUuZmVhdHVyZVRhcmdldDtcbiAgICBpZiAoIWZlYXR1cmVUYXJnZXQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWZlYXR1cmVUYXJnZXQucHJvcGVydGllcykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBmZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMubWV0YSA9PT0gQ29uc3RhbnRzLm1ldGEuVkVSVEVYO1xuICB9LFxuICBpc1NoaWZ0RG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghZS5vcmlnaW5hbEV2ZW50KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNFc2NhcGVLZXk6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZS5rZXlDb2RlID09PSAyNztcbiAgfSxcbiAgaXNFbnRlcktleTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBlLmtleUNvZGUgPT09IDEzO1xuICB9LFxuICB0cnVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsImNvbnN0IGV4dGVudCA9IHJlcXVpcmUoJ2dlb2pzb24tZXh0ZW50Jyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuY29uc3Qge1xuICBMQVRfTUlOLFxuICBMQVRfTUFYLFxuICBMQVRfUkVOREVSRURfTUlOLFxuICBMQVRfUkVOREVSRURfTUFYLFxuICBMTkdfTUlOLFxuICBMTkdfTUFYXG59ID0gQ29uc3RhbnRzO1xuXG4vLyBFbnN1cmUgdGhhdCB3ZSBkbyBub3QgZHJhZyBub3J0aC1zb3V0aCBmYXIgZW5vdWdoIGZvclxuLy8gLSBhbnkgcGFydCBvZiBhbnkgZmVhdHVyZSB0byBleGNlZWQgdGhlIHBvbGVzXG4vLyAtIGFueSBmZWF0dXJlIHRvIGJlIGNvbXBsZXRlbHkgbG9zdCBpbiB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgcHJvamVjdGlvbidzXG4vLyAgIGVkZ2UgYW5kIHRoZSBwb2xlcywgc3VjaCB0aGF0IGl0IGNvdWxkbid0IGJlIHJlLXNlbGVjdGVkIGFuZCBtb3ZlZCBiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdlb2pzb25GZWF0dXJlcywgZGVsdGEpIHtcbiAgLy8gXCJpbm5lciBlZGdlXCIgPSBhIGZlYXR1cmUncyBsYXRpdHVkZSBjbG9zZXN0IHRvIHRoZSBlcXVhdG9yXG4gIGxldCBub3J0aElubmVyRWRnZSA9IExBVF9NSU47XG4gIGxldCBzb3V0aElubmVyRWRnZSA9IExBVF9NQVg7XG4gIC8vIFwib3V0ZXIgZWRnZVwiID0gYSBmZWF0dXJlJ3MgbGF0aXR1ZGUgZnVydGhlc3QgZnJvbSB0aGUgZXF1YXRvclxuICBsZXQgbm9ydGhPdXRlckVkZ2UgPSBMQVRfTUlOO1xuICBsZXQgc291dGhPdXRlckVkZ2UgPSBMQVRfTUFYO1xuXG4gIGxldCB3ZXN0RWRnZSA9IExOR19NQVg7XG4gIGxldCBlYXN0RWRnZSA9IExOR19NSU47XG5cbiAgZ2VvanNvbkZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgY29uc3QgYm91bmRzID0gZXh0ZW50KGZlYXR1cmUpO1xuICAgIGNvbnN0IGZlYXR1cmVTb3V0aEVkZ2UgPSBib3VuZHNbMV07XG4gICAgY29uc3QgZmVhdHVyZU5vcnRoRWRnZSA9IGJvdW5kc1szXTtcbiAgICBjb25zdCBmZWF0dXJlV2VzdEVkZ2UgPSBib3VuZHNbMF07XG4gICAgY29uc3QgZmVhdHVyZUVhc3RFZGdlID0gYm91bmRzWzJdO1xuICAgIGlmIChmZWF0dXJlU291dGhFZGdlID4gbm9ydGhJbm5lckVkZ2UpIG5vcnRoSW5uZXJFZGdlID0gZmVhdHVyZVNvdXRoRWRnZTtcbiAgICBpZiAoZmVhdHVyZU5vcnRoRWRnZSA8IHNvdXRoSW5uZXJFZGdlKSBzb3V0aElubmVyRWRnZSA9IGZlYXR1cmVOb3J0aEVkZ2U7XG4gICAgaWYgKGZlYXR1cmVOb3J0aEVkZ2UgPiBub3J0aE91dGVyRWRnZSkgbm9ydGhPdXRlckVkZ2UgPSBmZWF0dXJlTm9ydGhFZGdlO1xuICAgIGlmIChmZWF0dXJlU291dGhFZGdlIDwgc291dGhPdXRlckVkZ2UpIHNvdXRoT3V0ZXJFZGdlID0gZmVhdHVyZVNvdXRoRWRnZTtcbiAgICBpZiAoZmVhdHVyZVdlc3RFZGdlIDwgd2VzdEVkZ2UpIHdlc3RFZGdlID0gZmVhdHVyZVdlc3RFZGdlO1xuICAgIGlmIChmZWF0dXJlRWFzdEVkZ2UgPiBlYXN0RWRnZSkgZWFzdEVkZ2UgPSBmZWF0dXJlRWFzdEVkZ2U7XG4gIH0pO1xuXG5cbiAgLy8gVGhlc2UgY2hhbmdlcyBhcmUgbm90IG11dHVhbGx5IGV4Y2x1c2l2ZTogd2UgbWlnaHQgaGl0IHRoZSBpbm5lclxuICAvLyBlZGdlIGJ1dCBhbHNvIGhhdmUgaGl0IHRoZSBvdXRlciBlZGdlIGFuZCB0aGVyZWZvcmUgbmVlZFxuICAvLyBhbm90aGVyIHJlYWRqdXN0bWVudFxuICBjb25zdCBjb25zdHJhaW5lZERlbHRhID0gZGVsdGE7XG4gIGlmIChub3J0aElubmVyRWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubGF0ID4gTEFUX1JFTkRFUkVEX01BWCkge1xuICAgIGNvbnN0cmFpbmVkRGVsdGEubGF0ID0gTEFUX1JFTkRFUkVEX01BWCAtIG5vcnRoSW5uZXJFZGdlO1xuICB9XG4gIGlmIChub3J0aE91dGVyRWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubGF0ID4gTEFUX01BWCkge1xuICAgIGNvbnN0cmFpbmVkRGVsdGEubGF0ID0gTEFUX01BWCAtIG5vcnRoT3V0ZXJFZGdlO1xuICB9XG4gIGlmIChzb3V0aElubmVyRWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubGF0IDwgTEFUX1JFTkRFUkVEX01JTikge1xuICAgIGNvbnN0cmFpbmVkRGVsdGEubGF0ID0gTEFUX1JFTkRFUkVEX01JTiAtIHNvdXRoSW5uZXJFZGdlO1xuICB9XG4gIGlmIChzb3V0aE91dGVyRWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubGF0IDwgTEFUX01JTikge1xuICAgIGNvbnN0cmFpbmVkRGVsdGEubGF0ID0gTEFUX01JTiAtIHNvdXRoT3V0ZXJFZGdlO1xuICB9XG4gIGlmICh3ZXN0RWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubG5nIDw9IExOR19NSU4pIHtcbiAgICBjb25zdHJhaW5lZERlbHRhLmxuZyArPSBNYXRoLmNlaWwoTWF0aC5hYnMoY29uc3RyYWluZWREZWx0YS5sbmcpIC8gMzYwKSAqIDM2MDtcbiAgfVxuICBpZiAoZWFzdEVkZ2UgKyBjb25zdHJhaW5lZERlbHRhLmxuZyA+PSBMTkdfTUFYKSB7XG4gICAgY29uc3RyYWluZWREZWx0YS5sbmcgLT0gTWF0aC5jZWlsKE1hdGguYWJzKGNvbnN0cmFpbmVkRGVsdGEubG5nKSAvIDM2MCkgKiAzNjA7XG4gIH1cblxuICByZXR1cm4gY29uc3RyYWluZWREZWx0YTtcbn07XG4iLCJjb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXJlbnQsIHN0YXJ0VmVydGV4LCBlbmRWZXJ0ZXgsIG1hcCkge1xuICBjb25zdCBzdGFydENvb3JkID0gc3RhcnRWZXJ0ZXguZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gIGNvbnN0IGVuZENvb3JkID0gZW5kVmVydGV4Lmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gIC8vIElmIGEgY29vcmRpbmF0ZSBleGNlZWRzIHRoZSBwcm9qZWN0aW9uLCB3ZSBjYW4ndCBjYWxjdWxhdGUgYSBtaWRwb2ludCxcbiAgLy8gc28gcnVuIGF3YXlcbiAgaWYgKHN0YXJ0Q29vcmRbMV0gPiBDb25zdGFudHMuTEFUX1JFTkRFUkVEX01BWCB8fFxuICAgIHN0YXJ0Q29vcmRbMV0gPCBDb25zdGFudHMuTEFUX1JFTkRFUkVEX01JTiB8fFxuICAgIGVuZENvb3JkWzFdID4gQ29uc3RhbnRzLkxBVF9SRU5ERVJFRF9NQVggfHxcbiAgICBlbmRDb29yZFsxXSA8IENvbnN0YW50cy5MQVRfUkVOREVSRURfTUlOKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBwdEEgPSBtYXAucHJvamVjdChbIHN0YXJ0Q29vcmRbMF0sIHN0YXJ0Q29vcmRbMV0gXSk7XG4gIGNvbnN0IHB0QiA9IG1hcC5wcm9qZWN0KFsgZW5kQ29vcmRbMF0sIGVuZENvb3JkWzFdIF0pO1xuICBjb25zdCBtaWQgPSBtYXAudW5wcm9qZWN0KFsgKHB0QS54ICsgcHRCLngpIC8gMiwgKHB0QS55ICsgcHRCLnkpIC8gMiBdKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuRkVBVFVSRSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBtZXRhOiBDb25zdGFudHMubWV0YS5NSURQT0lOVCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgbG5nOiBtaWQubG5nLFxuICAgICAgbGF0OiBtaWQubGF0LFxuICAgICAgY29vcmRfcGF0aDogZW5kVmVydGV4LnByb3BlcnRpZXMuY29vcmRfcGF0aFxuICAgIH0sXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9JTlQsXG4gICAgICBjb29yZGluYXRlczogW21pZC5sbmcsIG1pZC5sYXRdXG4gICAgfVxuICB9O1xufTtcbiIsImNvbnN0IGNyZWF0ZVZlcnRleCA9IHJlcXVpcmUoJy4vY3JlYXRlX3ZlcnRleCcpO1xuY29uc3QgY3JlYXRlTWlkcG9pbnQgPSByZXF1aXJlKCcuL2NyZWF0ZV9taWRwb2ludCcpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1cHBsZW1lbnRhcnlQb2ludHMoZ2VvanNvbiwgb3B0aW9ucyA9IHt9LCBiYXNlUGF0aCA9IG51bGwpIHtcbiAgY29uc3QgeyB0eXBlLCBjb29yZGluYXRlcyB9ID0gZ2VvanNvbi5nZW9tZXRyeTtcbiAgY29uc3QgZmVhdHVyZUlkID0gZ2VvanNvbi5wcm9wZXJ0aWVzICYmIGdlb2pzb24ucHJvcGVydGllcy5pZDtcblxuICBsZXQgc3VwcGxlbWVudGFyeVBvaW50cyA9IFtdO1xuXG4gIGlmICh0eXBlID09PSBDb25zdGFudHMuZ2VvanNvblR5cGVzLlBPSU5UKSB7XG4gICAgLy8gRm9yIHBvaW50cywganVzdCBjcmVhdGUgYSB2ZXJ0ZXhcbiAgICBzdXBwbGVtZW50YXJ5UG9pbnRzLnB1c2goY3JlYXRlVmVydGV4KGZlYXR1cmVJZCwgY29vcmRpbmF0ZXMsIGJhc2VQYXRoLCBpc1NlbGVjdGVkUGF0aChiYXNlUGF0aCkpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBDb25zdGFudHMuZ2VvanNvblR5cGVzLlBPTFlHT04pIHtcbiAgICAvLyBDeWNsZSB0aHJvdWdoIGEgUG9seWdvbidzIHJpbmdzIGFuZFxuICAgIC8vIHByb2Nlc3MgZWFjaCBsaW5lXG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaCgobGluZSwgbGluZUluZGV4KSA9PiB7XG4gICAgICBwcm9jZXNzTGluZShsaW5lLCAoYmFzZVBhdGggIT09IG51bGwpID8gYCR7YmFzZVBhdGh9LiR7bGluZUluZGV4fWAgOiBTdHJpbmcobGluZUluZGV4KSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5MSU5FX1NUUklORykge1xuICAgIHByb2Nlc3NMaW5lKGNvb3JkaW5hdGVzLCBiYXNlUGF0aCk7XG4gIH0gZWxzZSBpZiAodHlwZS5pbmRleE9mKENvbnN0YW50cy5nZW9qc29uVHlwZXMuTVVMVElfUFJFRklYKSA9PT0gMCkge1xuICAgIHByb2Nlc3NNdWx0aUdlb21ldHJ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShsaW5lLCBsaW5lQmFzZVBhdGgpIHtcbiAgICBsZXQgZmlyc3RQb2ludFN0cmluZyA9ICcnO1xuICAgIGxldCBsYXN0VmVydGV4ID0gbnVsbDtcbiAgICBsaW5lLmZvckVhY2goKHBvaW50LCBwb2ludEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwb2ludFBhdGggPSAobGluZUJhc2VQYXRoICE9PSB1bmRlZmluZWQgJiYgbGluZUJhc2VQYXRoICE9PSBudWxsKSA/IGAke2xpbmVCYXNlUGF0aH0uJHtwb2ludEluZGV4fWAgOiBTdHJpbmcocG9pbnRJbmRleCk7XG4gICAgICBjb25zdCB2ZXJ0ZXggPSBjcmVhdGVWZXJ0ZXgoZmVhdHVyZUlkLCBwb2ludCwgcG9pbnRQYXRoLCBpc1NlbGVjdGVkUGF0aChwb2ludFBhdGgpKTtcblxuICAgICAgLy8gSWYgd2UncmUgY3JlYXRpbmcgbWlkcG9pbnRzLCBjaGVjayBpZiB0aGVyZSB3YXMgYVxuICAgICAgLy8gdmVydGV4IGJlZm9yZSB0aGlzIG9uZS4gSWYgc28sIGFkZCBhIG1pZHBvaW50XG4gICAgICAvLyBiZXR3ZWVuIHRoYXQgdmVydGV4IGFuZCB0aGlzIG9uZS5cbiAgICAgIGlmIChvcHRpb25zLm1pZHBvaW50cyAmJiBsYXN0VmVydGV4KSB7XG4gICAgICAgIGNvbnN0IG1pZHBvaW50ID0gY3JlYXRlTWlkcG9pbnQoZmVhdHVyZUlkLCBsYXN0VmVydGV4LCB2ZXJ0ZXgsIG9wdGlvbnMubWFwKTtcbiAgICAgICAgaWYgKG1pZHBvaW50KSB7XG4gICAgICAgICAgc3VwcGxlbWVudGFyeVBvaW50cy5wdXNoKG1pZHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFZlcnRleCA9IHZlcnRleDtcblxuICAgICAgLy8gQSBQb2x5Z29uIGxpbmUncyBsYXN0IHBvaW50IGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBwb2ludC4gSWYgd2UncmUgb24gdGhlIGxhc3RcbiAgICAgIC8vIHBvaW50LCB3ZSB3YW50IHRvIGRyYXcgYSBtaWRwb2ludCBiZWZvcmUgaXQgYnV0IG5vdCBhbm90aGVyIHZlcnRleCBvbiBpdFxuICAgICAgLy8gKHNpbmNlIHdlIGFscmVhZHkgYSB2ZXJ0ZXggdGhlcmUsIGZyb20gdGhlIGZpcnN0IHBvaW50KS5cbiAgICAgIGNvbnN0IHN0cmluZ2lmaWVkUG9pbnQgPSBKU09OLnN0cmluZ2lmeShwb2ludCk7XG4gICAgICBpZiAoZmlyc3RQb2ludFN0cmluZyAhPT0gc3RyaW5naWZpZWRQb2ludCkge1xuICAgICAgICBzdXBwbGVtZW50YXJ5UG9pbnRzLnB1c2godmVydGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChwb2ludEluZGV4ID09PSAwKSB7XG4gICAgICAgIGZpcnN0UG9pbnRTdHJpbmcgPSBzdHJpbmdpZmllZFBvaW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWxlY3RlZFBhdGgocGF0aCkge1xuICAgIGlmICghb3B0aW9ucy5zZWxlY3RlZFBhdGhzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRQYXRocy5pbmRleE9mKHBhdGgpICE9PSAtMTtcbiAgfVxuXG4gIC8vIFNwbGl0IGEgbXVsdGktZ2VvbWV0cnkgaW50byBjb25zdGl0dWVudFxuICAvLyBnZW9tZXRyaWVzLCBhbmQgYWNjdW11bGF0ZSB0aGUgc3VwcGxlbWVudGFyeSBwb2ludHNcbiAgLy8gZm9yIGVhY2ggb2YgdGhvc2UgY29uc3RpdHVlbnRzXG4gIGZ1bmN0aW9uIHByb2Nlc3NNdWx0aUdlb21ldHJ5KCkge1xuICAgIGNvbnN0IHN1YlR5cGUgPSB0eXBlLnJlcGxhY2UoQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5NVUxUSV9QUkVGSVgsICcnKTtcbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKChzdWJDb29yZGluYXRlcywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHN1YkZlYXR1cmUgPSB7XG4gICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuRkVBVFVSRSxcbiAgICAgICAgcHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IHN1YlR5cGUsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHN1YkNvb3JkaW5hdGVzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzdXBwbGVtZW50YXJ5UG9pbnRzID0gc3VwcGxlbWVudGFyeVBvaW50cy5jb25jYXQoY3JlYXRlU3VwcGxlbWVudGFyeVBvaW50cyhzdWJGZWF0dXJlLCBvcHRpb25zLCBpbmRleCkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBsZW1lbnRhcnlQb2ludHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3VwcGxlbWVudGFyeVBvaW50cztcbiIsImNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIFJldHVybnMgR2VvSlNPTiBmb3IgYSBQb2ludCByZXByZXNlbnRpbmcgdGhlXG4gKiB2ZXJ0ZXggb2YgYW5vdGhlciBmZWF0dXJlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBEb3Qtc2VwYXJhdGVkIG51bWJlcnMgaW5kaWNhdGluZyBleGFjdGx5XG4gKiAgIHdoZXJlIHRoZSBwb2ludCBleGlzdHMgd2l0aGluIGl0cyBwYXJlbnQgZmVhdHVyZSdzIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICogQHJldHVybiB7R2VvSlNPTn0gUG9pbnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXJlbnRJZCwgY29vcmRpbmF0ZXMsIHBhdGgsIHNlbGVjdGVkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5GRUFUVVJFLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIG1ldGE6IENvbnN0YW50cy5tZXRhLlZFUlRFWCxcbiAgICAgIHBhcmVudDogcGFyZW50SWQsXG4gICAgICBjb29yZF9wYXRoOiBwYXRoLFxuICAgICAgYWN0aXZlOiAoc2VsZWN0ZWQpID8gQ29uc3RhbnRzLmFjdGl2ZVN0YXRlcy5BQ1RJVkUgOiBDb25zdGFudHMuYWN0aXZlU3RhdGVzLklOQUNUSVZFXG4gICAgfSxcbiAgICBnZW9tZXRyeToge1xuICAgICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5QT0lOVCxcbiAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH1cbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5hYmxlKGN0eCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFjdHgubWFwIHx8ICFjdHgubWFwLmRvdWJsZUNsaWNrWm9vbSkgcmV0dXJuO1xuICAgICAgY3R4Lm1hcC5kb3VibGVDbGlja1pvb20uZW5hYmxlKCk7XG4gICAgfSwgMCk7XG4gIH0sXG4gIGRpc2FibGUoY3R4KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWN0eC5tYXAgfHwgIWN0eC5tYXAuZG91YmxlQ2xpY2tab29tKSByZXR1cm47XG4gICAgICBjdHgubWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgY29uc3QgeCA9IGEueCAtIGIueDtcbiAgY29uc3QgeSA9IGEueSAtIGIueTtcbiAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59O1xuIiwiY29uc3Qgc29ydEZlYXR1cmVzID0gcmVxdWlyZSgnLi9zb3J0X2ZlYXR1cmVzJyk7XG5jb25zdCBtYXBFdmVudFRvQm91bmRpbmdCb3ggPSByZXF1aXJlKCcuL21hcF9ldmVudF90b19ib3VuZGluZ19ib3gnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgU3RyaW5nU2V0ID0gcmVxdWlyZSgnLi9zdHJpbmdfc2V0Jyk7XG5cbmNvbnN0IE1FVEFfVFlQRVMgPSBbXG4gIENvbnN0YW50cy5tZXRhLkZFQVRVUkUsXG4gIENvbnN0YW50cy5tZXRhLk1JRFBPSU5ULFxuICBDb25zdGFudHMubWV0YS5WRVJURVhcbl07XG5cbi8vIFJlcXVpcmVzIGVpdGhlciBldmVudCBvciBiYm94XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xpY2s6IGZlYXR1cmVzQXRDbGljayxcbiAgdG91Y2g6IGZlYXR1cmVzQXRUb3VjaFxufTtcblxuZnVuY3Rpb24gZmVhdHVyZXNBdENsaWNrKGV2ZW50LCBiYm94LCBjdHgpIHtcbiAgcmV0dXJuIGZlYXR1cmVzQXQoZXZlbnQsIGJib3gsIGN0eCwgY3R4Lm9wdGlvbnMuY2xpY2tCdWZmZXIpO1xufVxuXG5mdW5jdGlvbiBmZWF0dXJlc0F0VG91Y2goZXZlbnQsIGJib3gsIGN0eCkge1xuICByZXR1cm4gZmVhdHVyZXNBdChldmVudCwgYmJveCwgY3R4LCBjdHgub3B0aW9ucy50b3VjaEJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmVzQXQoZXZlbnQsIGJib3gsIGN0eCwgYnVmZmVyKSB7XG4gIGlmIChjdHgubWFwID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgY29uc3QgYm94ID0gKGV2ZW50KSA/IG1hcEV2ZW50VG9Cb3VuZGluZ0JveChldmVudCwgYnVmZmVyKSA6IGJib3g7XG5cbiAgY29uc3QgcXVlcnlQYXJhbXMgPSB7fTtcbiAgaWYgKGN0eC5vcHRpb25zLnN0eWxlcykgcXVlcnlQYXJhbXMubGF5ZXJzID0gY3R4Lm9wdGlvbnMuc3R5bGVzLm1hcChzID0+IHMuaWQpO1xuXG4gIGNvbnN0IGZlYXR1cmVzID0gY3R4Lm1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYm94LCBxdWVyeVBhcmFtcylcbiAgICAuZmlsdGVyKChmZWF0dXJlKSA9PiB7XG4gICAgICByZXR1cm4gTUVUQV9UWVBFUy5pbmRleE9mKGZlYXR1cmUucHJvcGVydGllcy5tZXRhKSAhPT0gLTE7XG4gICAgfSk7XG5cbiAgY29uc3QgZmVhdHVyZUlkcyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgY29uc3QgdW5pcXVlRmVhdHVyZXMgPSBbXTtcbiAgZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgIGNvbnN0IGZlYXR1cmVJZCA9IGZlYXR1cmUucHJvcGVydGllcy5pZDtcbiAgICBpZiAoZmVhdHVyZUlkcy5oYXMoZmVhdHVyZUlkKSkgcmV0dXJuO1xuICAgIGZlYXR1cmVJZHMuYWRkKGZlYXR1cmVJZCk7XG4gICAgdW5pcXVlRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNvcnRGZWF0dXJlcyh1bmlxdWVGZWF0dXJlcyk7XG59XG4iLCJjb25zdCBmZWF0dXJlc0F0ID0gcmVxdWlyZSgnLi9mZWF0dXJlc19hdCcpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmVhdHVyZUF0QW5kU2V0Q3Vyc29ycyhldmVudCwgY3R4KSB7XG4gIGNvbnN0IGZlYXR1cmVzID0gZmVhdHVyZXNBdC5jbGljayhldmVudCwgbnVsbCwgY3R4KTtcbiAgY29uc3QgY2xhc3NlcyA9IHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLk5PTkUgfTtcblxuICBpZiAoZmVhdHVyZXNbMF0pIHtcbiAgICBjbGFzc2VzLm1vdXNlID0gKGZlYXR1cmVzWzBdLnByb3BlcnRpZXMuYWN0aXZlID09PSBDb25zdGFudHMuYWN0aXZlU3RhdGVzLkFDVElWRSkgP1xuICAgICAgQ29uc3RhbnRzLmN1cnNvcnMuTU9WRSA6IENvbnN0YW50cy5jdXJzb3JzLlBPSU5URVI7XG4gICAgY2xhc3Nlcy5mZWF0dXJlID0gZmVhdHVyZXNbMF0ucHJvcGVydGllcy5tZXRhO1xuICB9XG5cbiAgaWYgKGN0eC5ldmVudHMuY3VycmVudE1vZGVOYW1lKCkuaW5kZXhPZignZHJhdycpICE9PSAtMSkge1xuICAgIGNsYXNzZXMubW91c2UgPSBDb25zdGFudHMuY3Vyc29ycy5BREQ7XG4gIH1cblxuICBjdHgudWkucXVldWVNYXBDbGFzc2VzKGNsYXNzZXMpO1xuICBjdHgudWkudXBkYXRlTWFwQ2xhc3NlcygpO1xuXG4gIHJldHVybiBmZWF0dXJlc1swXTtcbn07XG4iLCJjb25zdCBldWNsaWRlYW5EaXN0YW5jZSA9IHJlcXVpcmUoJy4vZXVjbGlkZWFuX2Rpc3RhbmNlJyk7XG5cbmNvbnN0IEZJTkVfVE9MRVJBTkNFID0gNDtcbmNvbnN0IEdST1NTX1RPTEVSQU5DRSA9IDEyO1xuY29uc3QgSU5URVJWQUwgPSA1MDA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDbGljayhzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZmluZVRvbGVyYW5jZSA9IChvcHRpb25zLmZpbmVUb2xlcmFuY2UgIT0gbnVsbCkgPyBvcHRpb25zLmZpbmVUb2xlcmFuY2UgOiBGSU5FX1RPTEVSQU5DRTtcbiAgY29uc3QgZ3Jvc3NUb2xlcmFuY2UgPSAob3B0aW9ucy5ncm9zc1RvbGVyYW5jZSAhPSBudWxsKSA/IG9wdGlvbnMuZ3Jvc3NUb2xlcmFuY2UgOiBHUk9TU19UT0xFUkFOQ0U7XG4gIGNvbnN0IGludGVydmFsID0gKG9wdGlvbnMuaW50ZXJ2YWwgIT0gbnVsbCkgPyBvcHRpb25zLmludGVydmFsIDogSU5URVJWQUw7XG5cbiAgc3RhcnQucG9pbnQgPSBzdGFydC5wb2ludCB8fCBlbmQucG9pbnQ7XG4gIHN0YXJ0LnRpbWUgPSBzdGFydC50aW1lIHx8IGVuZC50aW1lO1xuICBjb25zdCBtb3ZlRGlzdGFuY2UgPSBldWNsaWRlYW5EaXN0YW5jZShzdGFydC5wb2ludCwgZW5kLnBvaW50KTtcblxuICByZXR1cm4gbW92ZURpc3RhbmNlIDwgZmluZVRvbGVyYW5jZSB8fFxuICAgIChtb3ZlRGlzdGFuY2UgPCBncm9zc1RvbGVyYW5jZSAmJiAoZW5kLnRpbWUgLSBzdGFydC50aW1lKSA8IGludGVydmFsKTtcbn07XG4iLCJmdW5jdGlvbiBpc0V2ZW50QXRDb29yZGluYXRlcyhldmVudCwgY29vcmRpbmF0ZXMpIHtcbiAgaWYgKCFldmVudC5sbmdMYXQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGV2ZW50LmxuZ0xhdC5sbmcgPT09IGNvb3JkaW5hdGVzWzBdICYmIGV2ZW50LmxuZ0xhdC5sYXQgPT09IGNvb3JkaW5hdGVzWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRBdENvb3JkaW5hdGVzO1xuIiwiY29uc3QgZXVjbGlkZWFuRGlzdGFuY2UgPSByZXF1aXJlKCcuL2V1Y2xpZGVhbl9kaXN0YW5jZScpO1xuXG5jb25zdCBUT0xFUkFOQ0UgPSAyNTtcbmNvbnN0IElOVEVSVkFMID0gMjUwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVGFwKHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0b2xlcmFuY2UgPSAob3B0aW9ucy50b2xlcmFuY2UgIT0gbnVsbCkgPyBvcHRpb25zLnRvbGVyYW5jZSA6IFRPTEVSQU5DRTtcbiAgY29uc3QgaW50ZXJ2YWwgPSAob3B0aW9ucy5pbnRlcnZhbCAhPSBudWxsKSA/IG9wdGlvbnMuaW50ZXJ2YWwgOiBJTlRFUlZBTDtcblxuICBzdGFydC5wb2ludCA9IHN0YXJ0LnBvaW50IHx8IGVuZC5wb2ludDtcbiAgc3RhcnQudGltZSA9IHN0YXJ0LnRpbWUgfHwgZW5kLnRpbWU7XG4gIGNvbnN0IG1vdmVEaXN0YW5jZSA9IGV1Y2xpZGVhbkRpc3RhbmNlKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpO1xuXG4gIHJldHVybiBtb3ZlRGlzdGFuY2UgPCB0b2xlcmFuY2UgJiYgKGVuZC50aW1lIC0gc3RhcnQudGltZSkgPCBpbnRlcnZhbDtcbn07XG4iLCIvKipcbiAqIFJldHVybnMgYSBib3VuZGluZyBib3ggcmVwcmVzZW50aW5nIHRoZSBldmVudCdzIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IG1hcEV2ZW50IC0gTWFwYm94IEdMIEpTIG1hcCBldmVudCwgd2l0aCBhIHBvaW50IHByb3BlcnRpZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gQm91bmRpbmcgYm94LlxuICovXG5mdW5jdGlvbiBtYXBFdmVudFRvQm91bmRpbmdCb3gobWFwRXZlbnQsIGJ1ZmZlciA9IDApIHtcbiAgcmV0dXJuIFtcbiAgICBbbWFwRXZlbnQucG9pbnQueCAtIGJ1ZmZlciwgbWFwRXZlbnQucG9pbnQueSAtIGJ1ZmZlcl0sXG4gICAgW21hcEV2ZW50LnBvaW50LnggKyBidWZmZXIsIG1hcEV2ZW50LnBvaW50LnkgKyBidWZmZXJdXG4gIF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwRXZlbnRUb0JvdW5kaW5nQm94O1xuIiwiXG5jb25zdCBNb2RlSGFuZGxlciA9IGZ1bmN0aW9uKG1vZGUsIERyYXdDb250ZXh0KSB7XG5cbiAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgZHJhZzogW10sXG4gICAgY2xpY2s6IFtdLFxuICAgIG1vdXNlbW92ZTogW10sXG4gICAgbW91c2Vkb3duOiBbXSxcbiAgICBtb3VzZXVwOiBbXSxcbiAgICBtb3VzZW91dDogW10sXG4gICAga2V5ZG93bjogW10sXG4gICAga2V5dXA6IFtdLFxuICAgIHRvdWNoc3RhcnQ6IFtdLFxuICAgIHRvdWNobW92ZTogW10sXG4gICAgdG91Y2hlbmQ6IFtdLFxuICAgIHRhcDogW11cbiAgfTtcblxuICBjb25zdCBjdHggPSB7XG4gICAgb246IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgZm4pIHtcbiAgICAgIGlmIChoYW5kbGVyc1tldmVudF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXZlbnQgdHlwZTogJHtldmVudH1gKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICBmbjogZm5cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgRHJhd0NvbnRleHQuc3RvcmUuZmVhdHVyZUNoYW5nZWQoaWQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBkZWxlZ2F0ZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgY29uc3QgaGFuZGxlcyA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgbGV0IGlIYW5kbGUgPSBoYW5kbGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaUhhbmRsZS0tKSB7XG4gICAgICBjb25zdCBoYW5kbGUgPSBoYW5kbGVzW2lIYW5kbGVdO1xuICAgICAgaWYgKGhhbmRsZS5zZWxlY3RvcihldmVudCkpIHtcbiAgICAgICAgaGFuZGxlLmZuLmNhbGwoY3R4LCBldmVudCk7XG4gICAgICAgIERyYXdDb250ZXh0LnN0b3JlLnJlbmRlcigpO1xuICAgICAgICBEcmF3Q29udGV4dC51aS51cGRhdGVNYXBDbGFzc2VzKCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIGFuIGV2ZW50IGlzIG9ubHkgaGFuZGxlZCBvbmNlXG4gICAgICAgIC8vIHdlIGRvIHRoaXMgdG8gbGV0IG1vZGVzIGhhdmUgbXVsdGlwbGUgb3ZlcmxhcHBpbmcgc2VsZWN0b3JzXG4gICAgICAgIC8vIGFuZCByZWxheSBvbiBvcmRlciBvZiBvcHBlcnRhdGlvbnMgdG8gZmlsdGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBtb2RlLnN0YXJ0LmNhbGwoY3R4KTtcblxuICByZXR1cm4ge1xuICAgIHJlbmRlcjogbW9kZS5yZW5kZXIsXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobW9kZS5zdG9wKSBtb2RlLnN0b3AoKTtcbiAgICB9LFxuICAgIHRyYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChtb2RlLnRyYXNoKSB7XG4gICAgICAgIG1vZGUudHJhc2goKTtcbiAgICAgICAgRHJhd0NvbnRleHQuc3RvcmUucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21iaW5lRmVhdHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG1vZGUuY29tYmluZUZlYXR1cmVzKSB7XG4gICAgICAgIG1vZGUuY29tYmluZUZlYXR1cmVzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmNvbWJpbmVGZWF0dXJlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobW9kZS51bmNvbWJpbmVGZWF0dXJlcykge1xuICAgICAgICBtb2RlLnVuY29tYmluZUZlYXR1cmVzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcmFnOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZWdhdGUoJ2RyYWcnLCBldmVudCk7XG4gICAgfSxcbiAgICBjbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCdjbGljaycsIGV2ZW50KTtcbiAgICB9LFxuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgfSxcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkZWxlZ2F0ZSgnbW91c2Vkb3duJywgZXZlbnQpO1xuICAgIH0sXG4gICAgbW91c2V1cDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCdtb3VzZXVwJywgZXZlbnQpO1xuICAgIH0sXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkZWxlZ2F0ZSgnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSxcbiAgICBrZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZWdhdGUoJ2tleWRvd24nLCBldmVudCk7XG4gICAgfSxcbiAgICBrZXl1cDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCdrZXl1cCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkZWxlZ2F0ZSgndG91Y2hzdGFydCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIHRvdWNobW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCd0b3VjaG1vdmUnLCBldmVudCk7XG4gICAgfSxcbiAgICB0b3VjaGVuZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCd0b3VjaGVuZCcsIGV2ZW50KTtcbiAgICB9LFxuICAgIHRhcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGVnYXRlKCd0YXAnLCBldmVudCk7XG4gICAgfVxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlSGFuZGxlcjtcbiIsImNvbnN0IFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUG9pbnQgcmVwcmVzZW50aW5nIGEgbW91c2UgZXZlbnQncyBwb3NpdGlvblxuICogcmVsYXRpdmUgdG8gYSBjb250YWluaW5nIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50XG4gKiBAcGFyYW0ge05vZGV9IGNvbnRhaW5lclxuICogQHJldHVybnMge1BvaW50fVxuICovXG5mdW5jdGlvbiBtb3VzZUV2ZW50UG9pbnQobW91c2VFdmVudCwgY29udGFpbmVyKSB7XG4gIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBuZXcgUG9pbnQoXG4gICAgbW91c2VFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gKGNvbnRhaW5lci5jbGllbnRMZWZ0IHx8IDApLFxuICAgIG1vdXNlRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gKGNvbnRhaW5lci5jbGllbnRUb3AgfHwgMClcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb3VzZUV2ZW50UG9pbnQ7XG4iLCJjb25zdCBjb25zdHJhaW5GZWF0dXJlTW92ZW1lbnQgPSByZXF1aXJlKCcuL2NvbnN0cmFpbl9mZWF0dXJlX21vdmVtZW50Jyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmZWF0dXJlcywgZGVsdGEpIHtcbiAgY29uc3QgY29uc3RyYWluZWREZWx0YSA9IGNvbnN0cmFpbkZlYXR1cmVNb3ZlbWVudChmZWF0dXJlcy5tYXAoZmVhdHVyZSA9PiBmZWF0dXJlLnRvR2VvSlNPTigpKSwgZGVsdGEpO1xuXG4gIGZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgY29uc3QgY3VycmVudENvb3JkaW5hdGVzID0gZmVhdHVyZS5nZXRDb29yZGluYXRlcygpO1xuXG4gICAgY29uc3QgbW92ZUNvb3JkaW5hdGUgPSAoY29vcmQpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICBsbmc6IGNvb3JkWzBdICsgY29uc3RyYWluZWREZWx0YS5sbmcsXG4gICAgICAgIGxhdDogY29vcmRbMV0gKyBjb25zdHJhaW5lZERlbHRhLmxhdFxuICAgICAgfTtcbiAgICAgIHJldHVybiBbcG9pbnQubG5nLCBwb2ludC5sYXRdO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVJpbmcgPSAocmluZykgPT4gcmluZy5tYXAoY29vcmQgPT4gbW92ZUNvb3JkaW5hdGUoY29vcmQpKTtcbiAgICBjb25zdCBtb3ZlTXVsdGlQb2x5Z29uID0gKG11bHRpKSA9PiBtdWx0aS5tYXAocmluZyA9PiBtb3ZlUmluZyhyaW5nKSk7XG5cbiAgICBsZXQgbmV4dENvb3JkaW5hdGVzO1xuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9JTlQpIHtcbiAgICAgIG5leHRDb29yZGluYXRlcyA9IG1vdmVDb29yZGluYXRlKGN1cnJlbnRDb29yZGluYXRlcyk7XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09IENvbnN0YW50cy5nZW9qc29uVHlwZXMuTElORV9TVFJJTkcgfHwgZmVhdHVyZS50eXBlID09PSBDb25zdGFudHMuZ2VvanNvblR5cGVzLk1VTFRJX1BPSU5UKSB7XG4gICAgICBuZXh0Q29vcmRpbmF0ZXMgPSBjdXJyZW50Q29vcmRpbmF0ZXMubWFwKG1vdmVDb29yZGluYXRlKTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUudHlwZSA9PT0gQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5QT0xZR09OIHx8IGZlYXR1cmUudHlwZSA9PT0gQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5NVUxUSV9MSU5FX1NUUklORykge1xuICAgICAgbmV4dENvb3JkaW5hdGVzID0gY3VycmVudENvb3JkaW5hdGVzLm1hcChtb3ZlUmluZyk7XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09IENvbnN0YW50cy5nZW9qc29uVHlwZXMuTVVMVElfUE9MWUdPTikge1xuICAgICAgbmV4dENvb3JkaW5hdGVzID0gY3VycmVudENvb3JkaW5hdGVzLm1hcChtb3ZlTXVsdGlQb2x5Z29uKTtcbiAgICB9XG5cbiAgICBmZWF0dXJlLmluY29taW5nQ29vcmRzKG5leHRDb29yZGluYXRlcyk7XG4gIH0pO1xufTtcbiIsImNvbnN0IFN0cmluZ1NldCA9IHJlcXVpcmUoJy4uL2xpYi9zdHJpbmdfc2V0Jyk7XG5jb25zdCBjb29yZEVhY2ggPSByZXF1aXJlKCdAdHVyZi9tZXRhJykuY29vcmRFYWNoO1xuY29uc3QgdHVyZiA9IHJlcXVpcmUoJ0B0dXJmL3R1cmYnKTtcbmNvbnN0IGNoZWFwUnVsZXIgPSByZXF1aXJlKCdjaGVhcC1ydWxlcicpO1xuXG5jb25zdCBERUJVR19TTkFQID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHRvUG9pbnRBcnJheShmZWF0dXJlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0dXJmLmNvb3JkQWxsKGZlYXR1cmUpLmZvckVhY2goKGNvb3JkcykgPT4ge1xuICAgIHJlc3VsdC5wdXNoKHR1cmYucG9pbnQoY29vcmRzKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIEFsbCBhcmUgcmVxdWlyZWRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc25hcFRvKGV2dCwgY3R4LCBpZCkge1xuICBpZiAoY3R4Lm1hcCA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIC8vY29uc29sZS5sb2coXCItLS1cIik7XG4gIGNvbnN0IGJ1ZmZlciA9IDIwOyAvLyBjdHgub3B0aW9ucy5zbmFwQnVmZmVyO1xuICBjb25zdCBib3ggPSBbXG4gICAgW2V2dC5wb2ludC54IC0gYnVmZmVyLCBldnQucG9pbnQueSAtIGJ1ZmZlcl0sXG4gICAgW2V2dC5wb2ludC54ICsgYnVmZmVyLCBldnQucG9pbnQueSArIGJ1ZmZlcl1cbiAgXTtcblxuICAvL2NvbnNvbGUubG9nKFwiQm94OiBcIiwgYm94KTtcblxuICAvL2NvbnN0IHNuYXBGaWx0ZXIgPSB7bGF5ZXJzOiBbXCJyb2FkLXN0cmVldFwiLCBcInJvYWQtc2VydmljZS1saW5rLXRyYWNrXCIsIFwicm9hZC1wYXRoXCIsIFwicm9hZC1zZWNvbmRhcnktdGVydGlhcnlcIiwgXCJyb2FkLW1vdG9yd2F5XCJdfTtcbiAgY29uc3Qgc25hcEZpbHRlciA9IHtsYXllcnM6IFsnZGVtb2RhdGEnLCAnZ2wtZHJhdy1wb2x5Z29uLXN0cm9rZS1pbmFjdGl2ZS5jb2xkJywgJ2dsLWRyYXctbGluZS1pbmFjdGl2ZS5jb2xkJywgJ2dsLWRyYXctcG9pbnQtaW5hY3RpdmUuY29sZCddfTtcbiAgLy9jb25zdCBzbmFwRmlsdGVyID0ge2ZpbHRlcjogW1wiYW55XCIsIFtcImhhc1wiLCBcImdlb2h1YlwiXSwgW1wiaW5cIiwgXCJjbGFzc1wiLCBcInN0cmVldF9tYWpvclwiLCBcInN0cmVldF9taW5vclwiLCBcInN0cmVldF9saW1pdGVkXCIsIFwic2VydmljZVwiLCBcImxpbmtcIiwgXCJ0cmFja1wiLCBcInN0cmVldFwiLCBcInBhdGhcIiwgXCJzZWNvbmRhcnlcIiwgXCJwcmltYXJ5XCIsIFwidGVydGlhcnlcIiwgXCJtb3RvcndheVwiXV19O1xuICBjb25zdCBmZWF0dXJlSWRzID0gbmV3IFN0cmluZ1NldCgpO1xuICBjb25zdCB1bmlxdWVGZWF0dXJlcyA9IFtdO1xuICBjb25zdCBldnRDb29yZHMgPSAoZXZ0LmxuZ0xhdC50b0FycmF5ICE9PSB1bmRlZmluZWQpID8gZXZ0LmxuZ0xhdC50b0FycmF5KCkgOiB1bmRlZmluZWQ7XG4gIC8vY29uc29sZS5sb2coXCJldnRDb29yczogXCIsIGV2dENvb3Jkcyk7XG5cbiAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IG51bGw7XG4gIGxldCBjbG9zZXN0Q29vcmQ7XG4gIGxldCBjbG9zZXN0RmVhdHVyZTtcblxuICBjb25zdCBldmVudFBvaW50ID0ge1xuICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAgICBcInByb3BlcnRpZXNcIjoge30sXG4gICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICAgICAgXCJjb29yZGluYXRlc1wiOiBbMCwgMF1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50cyA9IHtcbiAgICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgIFwiZmVhdHVyZXNcIjogW11cbiAgfTtcblxuICBpZiAoY3R4Lm1hcC5nZXRTb3VyY2UoXCJzbmFwLXNvdXJjZVwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS5sb2coXCJhZGRpbmcgc25hcC1zb3VyY2VcIik7XG4gICAgY3R4Lm1hcC5hZGRTb3VyY2UoJ3NuYXAtc291cmNlJywge1xuICAgICAgdHlwZTogJ2dlb2pzb24nLFxuICAgICAgZGF0YTogZXZlbnRQb2ludFxuICAgIH0pO1xuICB9XG4gIGlmIChjdHgubWFwLmdldExheWVyKFwic25hcC1sYXllclwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS5sb2coXCJhZGRpbmcgc25hcC1sYXllclwiKTtcbiAgICBjdHgubWFwLmFkZExheWVyKHtcbiAgICAgIGlkOiBcInNuYXAtbGF5ZXJcIixcbiAgICAgIHNvdXJjZTogXCJzbmFwLXNvdXJjZVwiLFxuICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgIHBhaW50OiB7XG4gICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IFwiI2ZmMDAwMFwiLFxuICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogN1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChERUJVR19TTkFQKSB7XG4gICAgaWYgKGN0eC5tYXAuZ2V0U291cmNlKFwic25hcC1lbGVtZW50c1wiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImFkZGluZyBzbmFwLWVsZW1lbnRzXCIpO1xuICAgICAgY3R4Lm1hcC5hZGRTb3VyY2UoJ3NuYXAtZWxlbWVudHMnLCB7XG4gICAgICAgIHR5cGU6ICdnZW9qc29uJyxcbiAgICAgICAgZGF0YTogc2VsZWN0ZWRFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjdHgubWFwLmdldExheWVyKFwic25hcC1lbGVtZW50c1wiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImFkZGluZyBzbmFwLWVsZW1lbnRzXCIpO1xuICAgICAgY3R4Lm1hcC5hZGRMYXllcih7XG4gICAgICAgIGlkOiBcInNuYXAtZWxlbWVudHNcIixcbiAgICAgICAgc291cmNlOiBcInNuYXAtZWxlbWVudHNcIixcbiAgICAgICAgdHlwZTogXCJjaXJjbGVcIixcbiAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiBcIiMwMDAwZmZcIixcbiAgICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjogNFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZW5kZXJlZEZlYXR1cmVzID0gY3R4Lm1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYm94LCBzbmFwRmlsdGVyKTtcbiAgLy9jb25zb2xlLmxvZyhcInJlbmRlcmVkRmVhdHVyZXM6IFwiLCByZW5kZXJlZEZlYXR1cmVzKTtcbiAgcmVuZGVyZWRGZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgY29uc3QgZmVhdHVyZUlkID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmlkO1xuICAgIC8vY29uc29sZS5sb2coXCJjaGVja2luZyBmZWF0dXJlSWQ6IFwiLCBmZWF0dXJlSWQsIFwiIGN1cnJlbnRJZDogXCIsIGlkKTtcblxuICAgIGlmIChmZWF0dXJlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGZlYXR1cmVJZHMuaGFzKGZlYXR1cmVJZCkgfHwgU3RyaW5nKGZlYXR1cmVJZCkgPT09IGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVJZHMuYWRkKGZlYXR1cmVJZCk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50cyA9IHRvUG9pbnRBcnJheShmZWF0dXJlKTtcbiAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgIHNlbGVjdGVkRWxlbWVudHMuZmVhdHVyZXMucHVzaChwb2ludCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuaXF1ZUZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gIH0pO1xuXG4gIGlmIChldnRDb29yZHMgPT09IHVuZGVmaW5lZCB8fCB1bmlxdWVGZWF0dXJlcy5sZW5ndGggPCAxKSB7XG4gICAgLy9yZW1vdmUgcG9pbnRcbiAgICBjdHgubWFwLmdldFNvdXJjZShcInNuYXAtc291cmNlXCIpLnNldERhdGEoe1xuICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIFwiZmVhdHVyZXNcIjogW11cbiAgICB9KTtcbiAgICBpZiAoREVCVUdfU05BUCkge1xuICAgICAgY3R4Lm1hcC5nZXRTb3VyY2UoXCJzbmFwLWVsZW1lbnRzXCIpLnNldERhdGEoe1xuICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgICBcImZlYXR1cmVzXCI6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2dDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoREVCVUdfU05BUCkge1xuICAgICAgY3R4Lm1hcC5nZXRTb3VyY2UoXCJzbmFwLWVsZW1lbnRzXCIpLnNldERhdGEoc2VsZWN0ZWRFbGVtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2xvc2VzdFBvaW50cyA9IGZ1bmN0aW9uIChydWxlciwgY29vcmRpbmF0ZXMsIGV2dENvb3Jkcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHBvaW50SW5kZXggPSBydWxlci5wb2ludE9uTGluZShjb29yZGluYXRlcywgZXZ0Q29vcmRzKTtcbiAgICByZXN1bHQucHVzaCh7dHlwZTogXCJsaW5lcG9pbnRcIiwgY29vcmRzOiBwb2ludEluZGV4LnBvaW50fSk7XG4gICAgbGV0IHZlcnRleCA9IG51bGw7XG4gICAgaWYgKHBvaW50SW5kZXguaW5kZXggPT09IGNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgdmVydGV4ID0gY29vcmRpbmF0ZXNbcG9pbnRJbmRleC5pbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHAxID0gY29vcmRpbmF0ZXNbcG9pbnRJbmRleC5pbmRleF07XG4gICAgICBjb25zdCBwMiA9IGNvb3JkaW5hdGVzW3BvaW50SW5kZXguaW5kZXggKyAxXTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlMSA9IHJ1bGVyLmRpc3RhbmNlKHAxLCBldnRDb29yZHMpO1xuICAgICAgY29uc3QgZGlzdGFuY2UyID0gcnVsZXIuZGlzdGFuY2UocDIsIGV2dENvb3Jkcyk7XG4gICAgICB2ZXJ0ZXggPSBkaXN0YW5jZTEgPCBkaXN0YW5jZTIgPyBwMSA6IHAyO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7dHlwZTogXCJ2ZXJ0ZXhcIiwgY29vcmRzOiB2ZXJ0ZXh9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vY29uc29sZS5sb2coXCJVbmlxdWUgZmVhdHVyZXM6IFwiLCB1bmlxdWVGZWF0dXJlcyk7XG4gIC8vc25hcHRvIGxpbmVcbiAgdW5pcXVlRmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgY29uc3QgY29vcmRzID0gW107XG4gICAgY29uc3QgcnVsZXIgPSBjaGVhcFJ1bGVyLmZyb21UaWxlKGZlYXR1cmUuX3ZlY3RvclRpbGVGZWF0dXJlLl95LCBmZWF0dXJlLl92ZWN0b3JUaWxlRmVhdHVyZS5feik7IC8veiBpcyBtYXggbWFwIHpvb20gb2YgMjBcblxuICAgIGlmICh0eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgY2xvc2VzdFBvaW50cyhydWxlciwgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgZXZ0Q29vcmRzKS5mb3JFYWNoKChwb2ludFR5cGUpID0+IHtcbiAgICAgICAgY29vcmRzLnB1c2gocG9pbnRUeXBlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICBjb29yZHMucHVzaCh7dHlwZTogXCJ2ZXJ0ZXhcIiwgY29vcmRzOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiIHx8IHR5cGUgPT09IFwiUG9seWdvblwiKSB7XG4gICAgICBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goKGNvb3JkaW5hdGVzKSA9PiB7XG4gICAgICAgIGNsb3Nlc3RQb2ludHMocnVsZXIsIGNvb3JkaW5hdGVzLCBldnRDb29yZHMpLmZvckVhY2goKHBvaW50VHlwZSkgPT4ge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKHBvaW50VHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY29vcmRzIGVtcHR5IGZvciBmZWF0dXJlOiBcIiwgZmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3Jkcy5mb3JFYWNoKChwb2ludFR5cGUpID0+IHtcbiAgICAgICAgY29uc3Qgc2luZ2xlQ29vcmRzID0gcG9pbnRUeXBlLmNvb3JkcztcbiAgICAgICAgY29uc3QgZGlzdCA9IHJ1bGVyLmRpc3RhbmNlKHNpbmdsZUNvb3JkcywgZXZ0Q29vcmRzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInR5cGU6IFwiLCBwb2ludFR5cGUudHlwZSwgXCIgZGlzdDogXCIsIGRpc3QpO1xuICAgICAgICBpZiAoZGlzdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2UgPT09IG51bGwgfHwgKChwb2ludFR5cGUudHlwZSA9PT0gXCJ2ZXJ0ZXhcIiAmJiBkaXN0IDwgMC4wMDQpIHx8XG4gICAgICAgICAgICAoZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSkpKSB7XG4gICAgICAgICAgICBmZWF0dXJlLmRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgIGNsb3Nlc3RGZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICAgIGNsb3Nlc3RDb29yZCA9IHNpbmdsZUNvb3JkcztcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2xvc3Rlc3QgdHlwZTogXCIsIHBvaW50VHlwZS50eXBlLCBcIiBkaXN0OiBcIiwgZGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjbG9zZXN0RGlzdGFuY2UgIT09IG51bGwpIHtcbiAgICBldnQubG5nTGF0LmxuZyA9IGNsb3Nlc3RDb29yZFswXTtcbiAgICBldnQubG5nTGF0LmxhdCA9IGNsb3Nlc3RDb29yZFsxXTtcbiAgICBldnQucG9pbnQgPSBjdHgubWFwLnByb2plY3QoY2xvc2VzdENvb3JkKTtcbiAgICBldnQuc25hcCA9IHRydWU7XG4gICAgZXZlbnRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGNsb3Nlc3RDb29yZDtcbiAgICBjdHgubWFwLmdldFNvdXJjZShcInNuYXAtc291cmNlXCIpLnNldERhdGEoZXZlbnRQb2ludCk7XG4gIH1cbiAgcmV0dXJuIGV2dDtcbn07XG4iLCJjb25zdCBhcmVhID0gcmVxdWlyZSgnQG1hcGJveC9nZW9qc29uLWFyZWEnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5jb25zdCBGRUFUVVJFX1NPUlRfUkFOS1MgPSB7XG4gIFBvaW50OiAwLFxuICBMaW5lU3RyaW5nOiAxLFxuICBQb2x5Z29uOiAyXG59O1xuXG5mdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIpIHtcbiAgY29uc3Qgc2NvcmUgPSBGRUFUVVJFX1NPUlRfUkFOS1NbYS5nZW9tZXRyeS50eXBlXSAtIEZFQVRVUkVfU09SVF9SQU5LU1tiLmdlb21ldHJ5LnR5cGVdO1xuXG4gIGlmIChzY29yZSA9PT0gMCAmJiBhLmdlb21ldHJ5LnR5cGUgPT09IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9MWUdPTikge1xuICAgIHJldHVybiBhLmFyZWEgLSBiLmFyZWE7XG4gIH1cblxuICByZXR1cm4gc2NvcmU7XG59XG5cbi8vIFNvcnQgaW4gdGhlIG9yZGVyIGFib3ZlLCB0aGVuIHNvcnQgcG9seWdvbnMgYnkgYXJlYSBhc2NlbmRpbmcuXG5mdW5jdGlvbiBzb3J0RmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgcmV0dXJuIGZlYXR1cmVzLm1hcChmZWF0dXJlID0+IHtcbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBDb25zdGFudHMuZ2VvanNvblR5cGVzLlBPTFlHT04pIHtcbiAgICAgIGZlYXR1cmUuYXJlYSA9IGFyZWEuZ2VvbWV0cnkoe1xuICAgICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgICAgIHByb3BlcnR5OiB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IGZlYXR1cmUuZ2VvbWV0cnlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZTtcbiAgfSlcbiAgLnNvcnQoY29tcGFyYXRvcilcbiAgLm1hcChmZWF0dXJlID0+IHtcbiAgICBkZWxldGUgZmVhdHVyZS5hcmVhO1xuICAgIHJldHVybiBmZWF0dXJlO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0RmVhdHVyZXM7XG4iLCJmdW5jdGlvbiBTdHJpbmdTZXQoaXRlbXMpIHtcbiAgdGhpcy5faXRlbXMgPSB7fTtcbiAgdGhpcy5fbGVuZ3RoID0gaXRlbXMgPyBpdGVtcy5sZW5ndGggOiAwO1xuICBpZiAoIWl0ZW1zKSByZXR1cm47XG4gIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGl0ZW1zW2ldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIHRoaXMuX2l0ZW1zW2l0ZW1zW2ldXSA9IGk7XG4gIH1cbn1cblxuU3RyaW5nU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2l0ZW1zW3hdID8gdGhpcy5fbGVuZ3RoIDogdGhpcy5fbGVuZ3RoICsgMTtcbiAgdGhpcy5faXRlbXNbeF0gPSB0aGlzLl9pdGVtc1t4XSA/IHRoaXMuX2l0ZW1zW3hdIDogdGhpcy5fbGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07XG5cblN0cmluZ1NldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9sZW5ndGggPSB0aGlzLl9pdGVtc1t4XSA/IHRoaXMuX2xlbmd0aCAtIDEgOiB0aGlzLl9sZW5ndGg7XG4gIGRlbGV0ZSB0aGlzLl9pdGVtc1t4XTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TdHJpbmdTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW1zW3hdICE9PSB1bmRlZmluZWQ7XG59O1xuXG5TdHJpbmdTZXQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcmRlcmVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2l0ZW1zKS5zb3J0KChhLCBiKSA9PiB0aGlzLl9pdGVtc1thXSAtIHRoaXMuX2l0ZW1zW2JdKTtcbiAgcmV0dXJuIG9yZGVyZWRLZXlzO1xufTtcblxuU3RyaW5nU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9sZW5ndGggPSAwO1xuICB0aGlzLl9pdGVtcyA9IHt9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nU2V0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEubWFwKGlkID0+IGlkKS5zb3J0KCkpID09PSBKU09OLnN0cmluZ2lmeShiLm1hcChpZCA9PiBpZCkuc29ydCgpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvbHlnb24tZmlsbC1pbmFjdGl2ZScsXG4gICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgIFsnPT0nLCAnYWN0aXZlJywgJ2ZhbHNlJ10sXG4gICAgICBbJz09JywgJyR0eXBlJywgJ1BvbHlnb24nXSxcbiAgICAgIFsnIT0nLCAnbW9kZScsICdzdGF0aWMnXVxuICAgIF0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2ZpbGwtY29sb3InOiAnIzNiYjJkMCcsXG4gICAgICAnZmlsbC1vdXRsaW5lLWNvbG9yJzogJyMzYmIyZDAnLFxuICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuMVxuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvbHlnb24tZmlsbC1hY3RpdmUnLFxuICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICdmaWx0ZXInOiBbJ2FsbCcsIFsnPT0nLCAnYWN0aXZlJywgJ3RydWUnXSwgWyc9PScsICckdHlwZScsICdQb2x5Z29uJ11dLFxuICAgICdwYWludCc6IHtcbiAgICAgICdmaWxsLWNvbG9yJzogJyNmYmIwM2InLFxuICAgICAgJ2ZpbGwtb3V0bGluZS1jb2xvcic6ICcjZmJiMDNiJyxcbiAgICAgICdmaWxsLW9wYWNpdHknOiAwLjFcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnaWQnOiAnZ2wtZHJhdy1wb2x5Z29uLW1pZHBvaW50JyxcbiAgICAndHlwZSc6ICdjaXJjbGUnLFxuICAgICdmaWx0ZXInOiBbJ2FsbCcsXG4gICAgICBbJz09JywgJyR0eXBlJywgJ1BvaW50J10sXG4gICAgICBbJz09JywgJ21ldGEnLCAnbWlkcG9pbnQnXV0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2NpcmNsZS1yYWRpdXMnOiAzLFxuICAgICAgJ2NpcmNsZS1jb2xvcic6ICcjZmJiMDNiJ1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvbHlnb24tc3Ryb2tlLWluYWN0aXZlJyxcbiAgICAndHlwZSc6ICdsaW5lJyxcbiAgICAnZmlsdGVyJzogWydhbGwnLFxuICAgICAgWyc9PScsICdhY3RpdmUnLCAnZmFsc2UnXSxcbiAgICAgIFsnPT0nLCAnJHR5cGUnLCAnUG9seWdvbiddLFxuICAgICAgWychPScsICdtb2RlJywgJ3N0YXRpYyddXG4gICAgXSxcbiAgICAnbGF5b3V0Jzoge1xuICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJyxcbiAgICAgICdsaW5lLWpvaW4nOiAncm91bmQnXG4gICAgfSxcbiAgICAncGFpbnQnOiB7XG4gICAgICAnbGluZS1jb2xvcic6ICcjM2JiMmQwJyxcbiAgICAgICdsaW5lLXdpZHRoJzogMlxuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvbHlnb24tc3Ryb2tlLWFjdGl2ZScsXG4gICAgJ3R5cGUnOiAnbGluZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJywgWyc9PScsICdhY3RpdmUnLCAndHJ1ZSddLCBbJz09JywgJyR0eXBlJywgJ1BvbHlnb24nXV0sXG4gICAgJ2xheW91dCc6IHtcbiAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xuICAgIH0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2xpbmUtY29sb3InOiAnI2ZiYjAzYicsXG4gICAgICAnbGluZS1kYXNoYXJyYXknOiBbMC4yLCAyXSxcbiAgICAgICdsaW5lLXdpZHRoJzogMlxuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LWxpbmUtaW5hY3RpdmUnLFxuICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICdmaWx0ZXInOiBbJ2FsbCcsXG4gICAgICBbJz09JywgJ2FjdGl2ZScsICdmYWxzZSddLFxuICAgICAgWyc9PScsICckdHlwZScsICdMaW5lU3RyaW5nJ10sXG4gICAgICBbJyE9JywgJ21vZGUnLCAnc3RhdGljJ11cbiAgICBdLFxuICAgICdsYXlvdXQnOiB7XG4gICAgICAnbGluZS1jYXAnOiAncm91bmQnLFxuICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCdcbiAgICB9LFxuICAgICdwYWludCc6IHtcbiAgICAgICdsaW5lLWNvbG9yJzogJyMzYmIyZDAnLFxuICAgICAgJ2xpbmUtd2lkdGgnOiAyXG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2lkJzogJ2dsLWRyYXctbGluZS1hY3RpdmUnLFxuICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICdmaWx0ZXInOiBbJ2FsbCcsXG4gICAgICBbJz09JywgJyR0eXBlJywgJ0xpbmVTdHJpbmcnXSxcbiAgICAgIFsnPT0nLCAnYWN0aXZlJywgJ3RydWUnXVxuICAgIF0sXG4gICAgJ2xheW91dCc6IHtcbiAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xuICAgIH0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2xpbmUtY29sb3InOiAnI2ZiYjAzYicsXG4gICAgICAnbGluZS1kYXNoYXJyYXknOiBbMC4yLCAyXSxcbiAgICAgICdsaW5lLXdpZHRoJzogMlxuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvbHlnb24tYW5kLWxpbmUtdmVydGV4LXN0cm9rZS1pbmFjdGl2ZScsXG4gICAgJ3R5cGUnOiAnY2lyY2xlJyxcbiAgICAnZmlsdGVyJzogWydhbGwnLFxuICAgICAgWyc9PScsICdtZXRhJywgJ3ZlcnRleCddLFxuICAgICAgWyc9PScsICckdHlwZScsICdQb2ludCddLFxuICAgICAgWychPScsICdtb2RlJywgJ3N0YXRpYyddXG4gICAgXSxcbiAgICAncGFpbnQnOiB7XG4gICAgICAnY2lyY2xlLXJhZGl1cyc6IDUsXG4gICAgICAnY2lyY2xlLWNvbG9yJzogJyNmZmYnXG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2lkJzogJ2dsLWRyYXctcG9seWdvbi1hbmQtbGluZS12ZXJ0ZXgtaW5hY3RpdmUnLFxuICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgIFsnPT0nLCAnbWV0YScsICd2ZXJ0ZXgnXSxcbiAgICAgIFsnPT0nLCAnJHR5cGUnLCAnUG9pbnQnXSxcbiAgICAgIFsnIT0nLCAnbW9kZScsICdzdGF0aWMnXVxuICAgIF0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2NpcmNsZS1yYWRpdXMnOiAzLFxuICAgICAgJ2NpcmNsZS1jb2xvcic6ICcjZmJiMDNiJ1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvaW50LXBvaW50LXN0cm9rZS1pbmFjdGl2ZScsXG4gICAgJ3R5cGUnOiAnY2lyY2xlJyxcbiAgICAnZmlsdGVyJzogWydhbGwnLFxuICAgICAgWyc9PScsICdhY3RpdmUnLCAnZmFsc2UnXSxcbiAgICAgIFsnPT0nLCAnJHR5cGUnLCAnUG9pbnQnXSxcbiAgICAgIFsnPT0nLCAnbWV0YScsICdmZWF0dXJlJ10sXG4gICAgICBbJyE9JywgJ21vZGUnLCAnc3RhdGljJ11cbiAgICBdLFxuICAgICdwYWludCc6IHtcbiAgICAgICdjaXJjbGUtcmFkaXVzJzogNSxcbiAgICAgICdjaXJjbGUtb3BhY2l0eSc6IDEsXG4gICAgICAnY2lyY2xlLWNvbG9yJzogJyNmZmYnXG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2lkJzogJ2dsLWRyYXctcG9pbnQtaW5hY3RpdmUnLFxuICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgIFsnPT0nLCAnYWN0aXZlJywgJ2ZhbHNlJ10sXG4gICAgICBbJz09JywgJyR0eXBlJywgJ1BvaW50J10sXG4gICAgICBbJz09JywgJ21ldGEnLCAnZmVhdHVyZSddLFxuICAgICAgWychPScsICdtb2RlJywgJ3N0YXRpYyddXG4gICAgXSxcbiAgICAncGFpbnQnOiB7XG4gICAgICAnY2lyY2xlLXJhZGl1cyc6IDMsXG4gICAgICAnY2lyY2xlLWNvbG9yJzogJyMzYmIyZDAnXG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2lkJzogJ2dsLWRyYXctcG9pbnQtc3Ryb2tlLWFjdGl2ZScsXG4gICAgJ3R5cGUnOiAnY2lyY2xlJyxcbiAgICAnZmlsdGVyJzogWydhbGwnLFxuICAgICAgWyc9PScsICckdHlwZScsICdQb2ludCddLFxuICAgICAgWyc9PScsICdhY3RpdmUnLCAndHJ1ZSddLFxuICAgICAgWychPScsICdtZXRhJywgJ21pZHBvaW50J11cbiAgICBdLFxuICAgICdwYWludCc6IHtcbiAgICAgICdjaXJjbGUtcmFkaXVzJzogNyxcbiAgICAgICdjaXJjbGUtY29sb3InOiAnI2ZmZidcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnaWQnOiAnZ2wtZHJhdy1wb2ludC1hY3RpdmUnLFxuICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJyxcbiAgICAgIFsnPT0nLCAnJHR5cGUnLCAnUG9pbnQnXSxcbiAgICAgIFsnIT0nLCAnbWV0YScsICdtaWRwb2ludCddLFxuICAgICAgWyc9PScsICdhY3RpdmUnLCAndHJ1ZSddXSxcbiAgICAncGFpbnQnOiB7XG4gICAgICAnY2lyY2xlLXJhZGl1cyc6IDUsXG4gICAgICAnY2lyY2xlLWNvbG9yJzogJyNmYmIwM2InXG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2lkJzogJ2dsLWRyYXctcG9seWdvbi1maWxsLXN0YXRpYycsXG4gICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJywgWyc9PScsICdtb2RlJywgJ3N0YXRpYyddLCBbJz09JywgJyR0eXBlJywgJ1BvbHlnb24nXV0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2ZpbGwtY29sb3InOiAnIzQwNDA0MCcsXG4gICAgICAnZmlsbC1vdXRsaW5lLWNvbG9yJzogJyM0MDQwNDAnLFxuICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuMVxuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdnbC1kcmF3LXBvbHlnb24tc3Ryb2tlLXN0YXRpYycsXG4gICAgJ3R5cGUnOiAnbGluZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJywgWyc9PScsICdtb2RlJywgJ3N0YXRpYyddLCBbJz09JywgJyR0eXBlJywgJ1BvbHlnb24nXV0sXG4gICAgJ2xheW91dCc6IHtcbiAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xuICAgIH0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2xpbmUtY29sb3InOiAnIzQwNDA0MCcsXG4gICAgICAnbGluZS13aWR0aCc6IDJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnaWQnOiAnZ2wtZHJhdy1saW5lLXN0YXRpYycsXG4gICAgJ3R5cGUnOiAnbGluZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJywgWyc9PScsICdtb2RlJywgJ3N0YXRpYyddLCBbJz09JywgJyR0eXBlJywgJ0xpbmVTdHJpbmcnXV0sXG4gICAgJ2xheW91dCc6IHtcbiAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xuICAgIH0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2xpbmUtY29sb3InOiAnIzQwNDA0MCcsXG4gICAgICAnbGluZS13aWR0aCc6IDJcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnaWQnOiAnZ2wtZHJhdy1wb2ludC1zdGF0aWMnLFxuICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgJ2ZpbHRlcic6IFsnYWxsJywgWyc9PScsICdtb2RlJywgJ3N0YXRpYyddLCBbJz09JywgJyR0eXBlJywgJ1BvaW50J11dLFxuICAgICdwYWludCc6IHtcbiAgICAgICdjaXJjbGUtcmFkaXVzJzogNSxcbiAgICAgICdjaXJjbGUtY29sb3InOiAnIzQwNDA0MCdcbiAgICB9XG4gIH1cbl07XG4iLCJmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xuICBsZXQgbG9jaywgYXJncztcblxuICBmdW5jdGlvbiBsYXRlciAoKSB7XG4gICAgLy8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcbiAgICBsb2NrID0gZmFsc2U7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGFyZ3MgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVyRm4gKCkge1xuICAgIGlmIChsb2NrKSB7XG4gICAgICAvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9jayB1bnRpbCBsYXRlciB0aGVuIGNhbGxcbiAgICAgIGxvY2sgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgIHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyRm47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCIvKipcbiAqIERlcml2ZSBhIGRlbnNlIGFycmF5IChubyBgdW5kZWZpbmVkYHMpIGZyb20gYSBzaW5nbGUgdmFsdWUgb3IgYXJyYXkuXG4gKlxuICogQHBhcmFtIHthbnl9IHhcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKi9cbmZ1bmN0aW9uIHRvRGVuc2VBcnJheSh4KSB7XG4gIHJldHVybiBbXS5jb25jYXQoeCkuZmlsdGVyKHkgPT4geSAhPT0gdW5kZWZpbmVkKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0RlbnNlQXJyYXk7XG4iLCJjb25zdCB7bm9UYXJnZXQsIGlzT2ZNZXRhVHlwZSwgaXNJbmFjdGl2ZUZlYXR1cmUsIGlzU2hpZnREb3dufSA9IHJlcXVpcmUoJy4uL2xpYi9jb21tb25fc2VsZWN0b3JzJyk7XG5jb25zdCBjcmVhdGVTdXBwbGVtZW50YXJ5UG9pbnRzID0gcmVxdWlyZSgnLi4vbGliL2NyZWF0ZV9zdXBwbGVtZW50YXJ5X3BvaW50cycpO1xuY29uc3QgY29uc3RyYWluRmVhdHVyZU1vdmVtZW50ID0gcmVxdWlyZSgnLi4vbGliL2NvbnN0cmFpbl9mZWF0dXJlX21vdmVtZW50Jyk7XG5jb25zdCBkb3VibGVDbGlja1pvb20gPSByZXF1aXJlKCcuLi9saWIvZG91YmxlX2NsaWNrX3pvb20nKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgQ29tbW9uU2VsZWN0b3JzID0gcmVxdWlyZSgnLi4vbGliL2NvbW1vbl9zZWxlY3RvcnMnKTtcbmNvbnN0IG1vdmVGZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2xpYi9tb3ZlX2ZlYXR1cmVzJyk7XG5jb25zdCBzbmFwVG8gPSByZXF1aXJlKCcuLi9saWIvc25hcF90bycpO1xuXG5jb25zdCBpc1ZlcnRleCA9IGlzT2ZNZXRhVHlwZShDb25zdGFudHMubWV0YS5WRVJURVgpO1xuY29uc3QgaXNNaWRwb2ludCA9IGlzT2ZNZXRhVHlwZShDb25zdGFudHMubWV0YS5NSURQT0lOVCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3R4LCBvcHRzKSB7XG4gIGNvbnN0IGZlYXR1cmVJZCA9IG9wdHMuZmVhdHVyZUlkO1xuICBjb25zdCBmZWF0dXJlID0gY3R4LnN0b3JlLmdldChmZWF0dXJlSWQpO1xuXG4gIGlmICghZmVhdHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIGZlYXR1cmVJZCB0byBlbnRlciBkaXJlY3Rfc2VsZWN0IG1vZGUnKTtcbiAgfVxuXG4gIGlmIChmZWF0dXJlLnR5cGUgPT09IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9JTlQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXJlY3Rfc2VsZWN0IG1vZGUgZG9lc25cXCd0IGhhbmRsZSBwb2ludCBmZWF0dXJlcycpO1xuICB9XG5cbiAgbGV0IGRyYWdNb3ZlTG9jYXRpb24gPSBvcHRzLnN0YXJ0UG9zIHx8IG51bGw7XG4gIGxldCBkcmFnTW92aW5nID0gZmFsc2U7XG4gIGxldCBjYW5EcmFnTW92ZSA9IGZhbHNlO1xuXG4gIGxldCBzZWxlY3RlZENvb3JkUGF0aHMgPSBvcHRzLmNvb3JkUGF0aCA/IFtvcHRzLmNvb3JkUGF0aF0gOiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRDb29yZGluYXRlcyA9IHBhdGhzVG9Db29yZGluYXRlcyhmZWF0dXJlSWQsIHNlbGVjdGVkQ29vcmRQYXRocyk7XG4gIGN0eC5zdG9yZS5zZXRTZWxlY3RlZENvb3JkaW5hdGVzKHNlbGVjdGVkQ29vcmRpbmF0ZXMpO1xuXG4gIGNvbnN0IGZpcmVVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBjdHgubWFwLmZpcmUoQ29uc3RhbnRzLmV2ZW50cy5VUERBVEUsIHtcbiAgICAgIGFjdGlvbjogQ29uc3RhbnRzLnVwZGF0ZUFjdGlvbnMuQ0hBTkdFX0NPT1JESU5BVEVTLFxuICAgICAgZmVhdHVyZXM6IGN0eC5zdG9yZS5nZXRTZWxlY3RlZCgpLm1hcChmID0+IGYudG9HZW9KU09OKCkpXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZmlyZUFjdGlvbmFibGUgPSAoKSA9PiBjdHguZXZlbnRzLmFjdGlvbmFibGUoe1xuICAgIGNvbWJpbmVGZWF0dXJlczogZmFsc2UsXG4gICAgdW5jb21iaW5lRmVhdHVyZXM6IGZhbHNlLFxuICAgIHRyYXNoOiBzZWxlY3RlZENvb3JkUGF0aHMubGVuZ3RoID4gMFxuICB9KTtcblxuICBjb25zdCBzdGFydERyYWdnaW5nID0gZnVuY3Rpb24oZSkge1xuICAgIGN0eC5tYXAuZHJhZ1Bhbi5kaXNhYmxlKCk7XG4gICAgY2FuRHJhZ01vdmUgPSB0cnVlO1xuICAgIGRyYWdNb3ZlTG9jYXRpb24gPSBlLmxuZ0xhdDtcbiAgfTtcblxuICBjb25zdCBzdG9wRHJhZ2dpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBjdHgubWFwLmRyYWdQYW4uZW5hYmxlKCk7XG4gICAgZHJhZ01vdmluZyA9IGZhbHNlO1xuICAgIGNhbkRyYWdNb3ZlID0gZmFsc2U7XG4gICAgZHJhZ01vdmVMb2NhdGlvbiA9IG51bGw7XG4gIH07XG5cbiAgY29uc3Qgb25WZXJ0ZXggPSBmdW5jdGlvbihlKSB7XG4gICAgc3RhcnREcmFnZ2luZyhlKTtcbiAgICBjb25zdCBhYm91dCA9IGUuZmVhdHVyZVRhcmdldC5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZENvb3JkUGF0aHMuaW5kZXhPZihhYm91dC5jb29yZF9wYXRoKTtcbiAgICBpZiAoIWlzU2hpZnREb3duKGUpICYmIHNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICBzZWxlY3RlZENvb3JkUGF0aHMgPSBbYWJvdXQuY29vcmRfcGF0aF07XG4gICAgfSBlbHNlIGlmIChpc1NoaWZ0RG93bihlKSAmJiBzZWxlY3RlZEluZGV4ID09PSAtMSkge1xuICAgICAgc2VsZWN0ZWRDb29yZFBhdGhzLnB1c2goYWJvdXQuY29vcmRfcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkQ29vcmRpbmF0ZXMgPSBwYXRoc1RvQ29vcmRpbmF0ZXMoZmVhdHVyZUlkLCBzZWxlY3RlZENvb3JkUGF0aHMpO1xuICAgIGN0eC5zdG9yZS5zZXRTZWxlY3RlZENvb3JkaW5hdGVzKHNlbGVjdGVkQ29vcmRpbmF0ZXMpO1xuICAgIGZlYXR1cmUuY2hhbmdlZCgpO1xuICB9O1xuXG4gIGNvbnN0IG9uTWlkcG9pbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgc3RhcnREcmFnZ2luZyhlKTtcbiAgICBjb25zdCBhYm91dCA9IGUuZmVhdHVyZVRhcmdldC5wcm9wZXJ0aWVzO1xuICAgIGZlYXR1cmUuYWRkQ29vcmRpbmF0ZShhYm91dC5jb29yZF9wYXRoLCBhYm91dC5sbmcsIGFib3V0LmxhdCk7XG4gICAgZmlyZVVwZGF0ZSgpO1xuICAgIHNlbGVjdGVkQ29vcmRQYXRocyA9IFthYm91dC5jb29yZF9wYXRoXTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXRoc1RvQ29vcmRpbmF0ZXMoZmVhdHVyZUlkLCBwYXRocykge1xuICAgIHJldHVybiBwYXRocy5tYXAoY29vcmRfcGF0aCA9PiB7IHJldHVybiB7IGZlYXR1cmVfaWQ6IGZlYXR1cmVJZCwgY29vcmRfcGF0aCwgY29vcmRpbmF0ZXM6IGZlYXR1cmUuZ2V0Q29vcmRpbmF0ZShjb29yZF9wYXRoKSB9OyB9KTtcbiAgfVxuXG4gIGNvbnN0IG9uRmVhdHVyZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoc2VsZWN0ZWRDb29yZFBhdGhzLmxlbmd0aCA9PT0gMCkgc3RhcnREcmFnZ2luZyhlKTtcbiAgICBlbHNlIHN0b3BEcmFnZ2luZygpO1xuICB9O1xuXG4gIGNvbnN0IGRyYWdGZWF0dXJlID0gKGUsIGRlbHRhKSA9PiB7XG4gICAgbW92ZUZlYXR1cmVzKGN0eC5zdG9yZS5nZXRTZWxlY3RlZCgpLCBkZWx0YSk7XG4gICAgZHJhZ01vdmVMb2NhdGlvbiA9IGUubG5nTGF0O1xuICB9O1xuXG4gIGNvbnN0IGRyYWdWZXJ0ZXggPSAoZSwgZGVsdGEpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZENvb3JkcyA9IHNlbGVjdGVkQ29vcmRQYXRocy5tYXAoY29vcmRfcGF0aCA9PiBmZWF0dXJlLmdldENvb3JkaW5hdGUoY29vcmRfcGF0aCkpO1xuICAgIGNvbnN0IHNlbGVjdGVkQ29vcmRQb2ludHMgPSBzZWxlY3RlZENvb3Jkcy5tYXAoY29vcmRzID0+ICh7XG4gICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9JTlQsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBjb25zdCBjb25zdHJhaW5lZERlbHRhID0gY29uc3RyYWluRmVhdHVyZU1vdmVtZW50KHNlbGVjdGVkQ29vcmRQb2ludHMsIGRlbHRhKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGVkQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb29yZCA9IHNlbGVjdGVkQ29vcmRzW2ldO1xuICAgICAgbGV0IGxuZyA9IGNvb3JkWzBdICsgY29uc3RyYWluZWREZWx0YS5sbmc7XG4gICAgICBsZXQgbGF0ID0gY29vcmRbMV0gKyBjb25zdHJhaW5lZERlbHRhLmxhdDtcbiAgICAgIGlmIChlLnNuYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsbmcgPSBlLmxuZ0xhdC5sbmc7XG4gICAgICAgIGxhdCA9IGUubG5nTGF0LmxhdDtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmUudXBkYXRlQ29vcmRpbmF0ZShzZWxlY3RlZENvb3JkUGF0aHNbaV0sIGxuZywgbGF0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBjdHguc3RvcmUuc2V0U2VsZWN0ZWQoZmVhdHVyZUlkKTtcbiAgICAgIGRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKGN0eCk7XG5cbiAgICAgIC8vIE9uIG1vdXNlbW92ZSB0aGF0IGlzIG5vdCBhIGRyYWcsIHN0b3AgdmVydGV4IG1vdmVtZW50LlxuICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgQ29tbW9uU2VsZWN0b3JzLnRydWUsIGUgPT4ge1xuICAgICAgICBjb25zdCBpc0ZlYXR1cmUgPSBDb21tb25TZWxlY3RvcnMuaXNBY3RpdmVGZWF0dXJlKGUpO1xuICAgICAgICBjb25zdCBvblZlcnRleCA9IGlzVmVydGV4KGUpO1xuICAgICAgICBjb25zdCBub0Nvb3JkcyA9IHNlbGVjdGVkQ29vcmRQYXRocy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmIChpc0ZlYXR1cmUgJiYgbm9Db29yZHMpIGN0eC51aS5xdWV1ZU1hcENsYXNzZXMoeyBtb3VzZTogQ29uc3RhbnRzLmN1cnNvcnMuTU9WRSB9KTtcbiAgICAgICAgZWxzZSBpZiAob25WZXJ0ZXggJiYgIW5vQ29vcmRzKSBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLk1PVkUgfSk7XG4gICAgICAgIGVsc2UgY3R4LnVpLnF1ZXVlTWFwQ2xhc3Nlcyh7IG1vdXNlOiBDb25zdGFudHMuY3Vyc29ycy5OT05FIH0pO1xuICAgICAgICBzdG9wRHJhZ2dpbmcoZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQXMgc29vbiBhcyB5b3UgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHVwZGF0ZSB0aGUgZmVhdHVyZVxuICAgICAgdGhpcy5vbignbW91c2VvdXQnLCAoKSA9PiBkcmFnTW92aW5nLCBmaXJlVXBkYXRlKTtcbiAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIGlzVmVydGV4LCBvblZlcnRleCk7XG4gICAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgaXNWZXJ0ZXgsIG9uVmVydGV4KTtcbiAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIENvbW1vblNlbGVjdG9ycy5pc0FjdGl2ZUZlYXR1cmUsIG9uRmVhdHVyZSk7XG4gICAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgQ29tbW9uU2VsZWN0b3JzLmlzQWN0aXZlRmVhdHVyZSwgb25GZWF0dXJlKTtcbiAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIGlzTWlkcG9pbnQsIG9uTWlkcG9pbnQpO1xuICAgICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGlzTWlkcG9pbnQsIG9uTWlkcG9pbnQpO1xuICAgICAgdGhpcy5vbignZHJhZycsICgpID0+IGNhbkRyYWdNb3ZlLCAoZSkgPT4ge1xuICAgICAgICBkcmFnTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgZS5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGxldCBldnQgPSBlO1xuXG4gICAgICAgIGlmICghY3R4LnNuYXBUb092ZXJyaWRlICYmIGV2dC5wb2ludCAmJiBjdHgub3B0aW9ucy5zbmFwVG8pIHtcbiAgICAgICAgICBldnQgPSBzbmFwVG8oZXZ0LCBjdHgsIGZlYXR1cmVJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWx0YSA9IHtcbiAgICAgICAgICBsbmc6IGV2dC5sbmdMYXQubG5nIC0gZHJhZ01vdmVMb2NhdGlvbi5sbmcsXG4gICAgICAgICAgbGF0OiBldnQubG5nTGF0LmxhdCAtIGRyYWdNb3ZlTG9jYXRpb24ubGF0XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZWxlY3RlZENvb3JkUGF0aHMubGVuZ3RoID4gMCkgZHJhZ1ZlcnRleChldnQsIGRlbHRhKTtcbiAgICAgICAgZWxzZSBkcmFnRmVhdHVyZShldnQsIGRlbHRhKTtcblxuICAgICAgICBkcmFnTW92ZUxvY2F0aW9uID0gZXZ0LmxuZ0xhdDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignY2xpY2snLCBDb21tb25TZWxlY3RvcnMudHJ1ZSwgc3RvcERyYWdnaW5nKTtcbiAgICAgIHRoaXMub24oJ21vdXNldXAnLCBDb21tb25TZWxlY3RvcnMudHJ1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAoZHJhZ01vdmluZykge1xuICAgICAgICAgIGZpcmVVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wRHJhZ2dpbmcoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbigndG91Y2hlbmQnLCBDb21tb25TZWxlY3RvcnMudHJ1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAoZHJhZ01vdmluZykge1xuICAgICAgICAgIGZpcmVVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wRHJhZ2dpbmcoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignY2xpY2snLCBub1RhcmdldCwgY2xpY2tOb1RhcmdldCk7XG4gICAgICB0aGlzLm9uKCd0YXAnLCBub1RhcmdldCwgY2xpY2tOb1RhcmdldCk7XG4gICAgICB0aGlzLm9uKCdjbGljaycsIGlzSW5hY3RpdmVGZWF0dXJlLCBjbGlja0luYWN0aXZlKTtcbiAgICAgIHRoaXMub24oJ3RhcCcsIGlzSW5hY3RpdmVGZWF0dXJlLCBjbGlja0luYWN0aXZlKTtcbiAgICAgIHRoaXMub24oJ2NsaWNrJywgQ29tbW9uU2VsZWN0b3JzLmlzQWN0aXZlRmVhdHVyZSwgY2xpY2tBY3RpdmVGZWF0dXJlKTtcbiAgICAgIHRoaXMub24oJ3RhcCcsIENvbW1vblNlbGVjdG9ycy5pc0FjdGl2ZUZlYXR1cmUsIGNsaWNrQWN0aXZlRmVhdHVyZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsaWNrTm9UYXJnZXQoKSB7XG4gICAgICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbGlja0luYWN0aXZlKCkge1xuICAgICAgICBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xpY2tBY3RpdmVGZWF0dXJlKCkge1xuICAgICAgICBzZWxlY3RlZENvb3JkUGF0aHMgPSBbXTtcbiAgICAgICAgY3R4LnN0b3JlLmNsZWFyU2VsZWN0ZWRDb29yZGluYXRlcygpO1xuICAgICAgICBmZWF0dXJlLmNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgZG91YmxlQ2xpY2tab29tLmVuYWJsZShjdHgpO1xuICAgICAgY3R4LnN0b3JlLmNsZWFyU2VsZWN0ZWRDb29yZGluYXRlcygpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnZW9qc29uLCBwdXNoKSB7XG4gICAgICBpZiAoZmVhdHVyZUlkID09PSBnZW9qc29uLnByb3BlcnRpZXMuaWQpIHtcbiAgICAgICAgZ2VvanNvbi5wcm9wZXJ0aWVzLmFjdGl2ZSA9IENvbnN0YW50cy5hY3RpdmVTdGF0ZXMuQUNUSVZFO1xuICAgICAgICBwdXNoKGdlb2pzb24pO1xuICAgICAgICBjcmVhdGVTdXBwbGVtZW50YXJ5UG9pbnRzKGdlb2pzb24sIHtcbiAgICAgICAgICBtYXA6IGN0eC5tYXAsXG4gICAgICAgICAgbWlkcG9pbnRzOiB0cnVlLFxuICAgICAgICAgIHNlbGVjdGVkUGF0aHM6IHNlbGVjdGVkQ29vcmRQYXRoc1xuICAgICAgICB9KS5mb3JFYWNoKHB1c2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VvanNvbi5wcm9wZXJ0aWVzLmFjdGl2ZSA9IENvbnN0YW50cy5hY3RpdmVTdGF0ZXMuSU5BQ1RJVkU7XG4gICAgICAgIHB1c2goZ2VvanNvbik7XG4gICAgICB9XG4gICAgICBmaXJlQWN0aW9uYWJsZSgpO1xuICAgIH0sXG4gICAgdHJhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZWN0ZWRDb29yZFBhdGhzLnNvcnQoKS5yZXZlcnNlKCkuZm9yRWFjaChpZCA9PiBmZWF0dXJlLnJlbW92ZUNvb3JkaW5hdGUoaWQpKTtcbiAgICAgIGN0eC5tYXAuZmlyZShDb25zdGFudHMuZXZlbnRzLlVQREFURSwge1xuICAgICAgICBhY3Rpb246IENvbnN0YW50cy51cGRhdGVBY3Rpb25zLkNIQU5HRV9DT09SRElOQVRFUyxcbiAgICAgICAgZmVhdHVyZXM6IGN0eC5zdG9yZS5nZXRTZWxlY3RlZCgpLm1hcChmID0+IGYudG9HZW9KU09OKCkpXG4gICAgICB9KTtcbiAgICAgIHNlbGVjdGVkQ29vcmRQYXRocyA9IFtdO1xuICAgICAgY3R4LnN0b3JlLmNsZWFyU2VsZWN0ZWRDb29yZGluYXRlcygpO1xuICAgICAgZmlyZUFjdGlvbmFibGUoKTtcbiAgICAgIGlmIChmZWF0dXJlLmlzVmFsaWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3R4LnN0b3JlLmRlbGV0ZShbZmVhdHVyZUlkXSk7XG4gICAgICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCwge30pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iLCJjb25zdCBDb21tb25TZWxlY3RvcnMgPSByZXF1aXJlKCcuLi9saWIvY29tbW9uX3NlbGVjdG9ycycpO1xuY29uc3QgTGluZVN0cmluZyA9IHJlcXVpcmUoJy4uL2ZlYXR1cmVfdHlwZXMvbGluZV9zdHJpbmcnKTtcbmNvbnN0IGlzRXZlbnRBdENvb3JkaW5hdGVzID0gcmVxdWlyZSgnLi4vbGliL2lzX2V2ZW50X2F0X2Nvb3JkaW5hdGVzJyk7XG5jb25zdCBkb3VibGVDbGlja1pvb20gPSByZXF1aXJlKCcuLi9saWIvZG91YmxlX2NsaWNrX3pvb20nKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgY3JlYXRlVmVydGV4ID0gcmVxdWlyZSgnLi4vbGliL2NyZWF0ZV92ZXJ0ZXgnKTtcbmNvbnN0IHNuYXBUbyA9IHJlcXVpcmUoJy4uL2xpYi9zbmFwX3RvJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGNvbnN0IGZlYXR1cmVJZCA9IG9wdHMuZmVhdHVyZUlkO1xuXG4gIGxldCBsaW5lLCBjdXJyZW50VmVydGV4UG9zaXRpb247XG4gIGxldCBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gIGlmIChmZWF0dXJlSWQpIHtcbiAgICBsaW5lID0gY3R4LnN0b3JlLmdldChmZWF0dXJlSWQpO1xuICAgIGlmICghbGluZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhIGZlYXR1cmUgd2l0aCB0aGUgcHJvdmlkZWQgZmVhdHVyZUlkJyk7XG4gICAgfVxuICAgIGxldCBmcm9tID0gb3B0cy5mcm9tO1xuICAgIGlmIChmcm9tICYmIGZyb20udHlwZSA9PT0gJ0ZlYXR1cmUnICYmIGZyb20uZ2VvbWV0cnkgJiYgZnJvbS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICBmcm9tID0gZnJvbS5nZW9tZXRyeTtcbiAgICB9XG4gICAgaWYgKGZyb20gJiYgZnJvbS50eXBlID09PSAnUG9pbnQnICYmIGZyb20uY29vcmRpbmF0ZXMgJiYgZnJvbS5jb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGZyb20gPSBmcm9tLmNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICBpZiAoIWZyb20gfHwgIUFycmF5LmlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSB0aGUgYGZyb21gIHByb3BlcnR5IHRvIGluZGljYXRlIHdoaWNoIHBvaW50IHRvIGNvbnRpbnVlIHRoZSBsaW5lIGZyb20nKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENvb3JkID0gbGluZS5jb29yZGluYXRlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsaW5lLmNvb3JkaW5hdGVzW2xhc3RDb29yZF1bMF0gPT09IGZyb21bMF0gJiYgbGluZS5jb29yZGluYXRlc1tsYXN0Q29vcmRdWzFdID09PSBmcm9tWzFdKSB7XG4gICAgICBjdXJyZW50VmVydGV4UG9zaXRpb24gPSBsYXN0Q29vcmQgKyAxO1xuICAgICAgLy8gYWRkIG9uZSBuZXcgY29vcmRpbmF0ZSB0byBjb250aW51ZSBmcm9tXG4gICAgICBsaW5lLmFkZENvb3JkaW5hdGUoY3VycmVudFZlcnRleFBvc2l0aW9uLCAuLi5saW5lLmNvb3JkaW5hdGVzW2xhc3RDb29yZF0pO1xuICAgIH0gZWxzZSBpZiAobGluZS5jb29yZGluYXRlc1swXVswXSA9PT0gZnJvbVswXSAmJiBsaW5lLmNvb3JkaW5hdGVzWzBdWzFdID09PSBmcm9tWzFdKSB7XG4gICAgICBkaXJlY3Rpb24gPSAnYmFja3dhcmRzJztcbiAgICAgIGN1cnJlbnRWZXJ0ZXhQb3NpdGlvbiA9IDA7XG4gICAgICAvLyBhZGQgb25lIG5ldyBjb29yZGluYXRlIHRvIGNvbnRpbnVlIGZyb21cbiAgICAgIGxpbmUuYWRkQ29vcmRpbmF0ZShjdXJyZW50VmVydGV4UG9zaXRpb24sIC4uLmxpbmUuY29vcmRpbmF0ZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bmcm9tYCBzaG91bGQgbWF0Y2ggdGhlIHBvaW50IGF0IGVpdGhlciB0aGUgc3RhcnQgb3IgdGhlIGVuZCBvZiB0aGUgcHJvdmlkZWQgTGluZVN0cmluZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5lID0gbmV3IExpbmVTdHJpbmcoY3R4LCB7XG4gICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuTElORV9TVFJJTkcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbXVxuICAgICAgfVxuICAgIH0pO1xuICAgIGN1cnJlbnRWZXJ0ZXhQb3NpdGlvbiA9IDA7XG4gICAgY3R4LnN0b3JlLmFkZChsaW5lKTtcbiAgfVxuXG4gIGlmIChjdHguX3Rlc3QpIGN0eC5fdGVzdC5saW5lID0gbGluZTtcbiAgbGV0IGhlYXJkTW91c2VNb3ZlID0gZmFsc2U7XG4gIGxldCBzbmFwQ2xpY2tQb2ludDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGN0eC5zdG9yZS5jbGVhclNlbGVjdGVkKCk7XG4gICAgICBkb3VibGVDbGlja1pvb20uZGlzYWJsZShjdHgpO1xuICAgICAgY3R4LnVpLnF1ZXVlTWFwQ2xhc3Nlcyh7IG1vdXNlOiBDb25zdGFudHMuY3Vyc29ycy5BREQgfSk7XG4gICAgICBjdHgudWkuc2V0QWN0aXZlQnV0dG9uKENvbnN0YW50cy50eXBlcy5MSU5FKTtcblxuICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgQ29tbW9uU2VsZWN0b3JzLnRydWUsIChlKSA9PiB7XG4gICAgICAgIGxldCBldnQgPSBlO1xuXG4gICAgICAgIGlmICghY3R4LnNuYXBUb092ZXJyaWRlICYmIGV2dC5wb2ludCAmJiBjdHgub3B0aW9ucy5zbmFwVG8pIHtcbiAgICAgICAgICBldnQgPSBzbmFwVG8oZXZ0LCBjdHgsIGxpbmUuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHNuYXBDbGlja1BvaW50ID0gZXZ0O1xuICAgICAgICBsaW5lLnVwZGF0ZUNvb3JkaW5hdGUoY3VycmVudFZlcnRleFBvc2l0aW9uLCBldnQubG5nTGF0LmxuZywgZXZ0LmxuZ0xhdC5sYXQpO1xuICAgICAgICBpZiAoQ29tbW9uU2VsZWN0b3JzLmlzVmVydGV4KGV2dCkpIHtcbiAgICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLlBPSU5URVIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhcmRNb3VzZU1vdmUgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub24oJ2NsaWNrJywgQ29tbW9uU2VsZWN0b3JzLnRydWUsIGNsaWNrQW55d2hlcmUpO1xuICAgICAgdGhpcy5vbigndGFwJywgQ29tbW9uU2VsZWN0b3JzLnRydWUsIGNsaWNrQW55d2hlcmUpO1xuICAgICAgdGhpcy5vbignY2xpY2snLCBDb21tb25TZWxlY3RvcnMuaXNWZXJ0ZXgsIGNsaWNrT25WZXJ0ZXgpO1xuICAgICAgdGhpcy5vbigndGFwJywgQ29tbW9uU2VsZWN0b3JzLmlzVmVydGV4LCBjbGlja09uVmVydGV4KTtcblxuICAgICAgZnVuY3Rpb24gY2xpY2tBbnl3aGVyZShlKSB7XG4gICAgICAgIGNvbnN0IGV2dCA9IHNuYXBDbGlja1BvaW50IHx8IGU7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4UG9zaXRpb24gPiAwICYmIGlzRXZlbnRBdENvb3JkaW5hdGVzKGV2dCwgbGluZS5jb29yZGluYXRlc1tjdXJyZW50VmVydGV4UG9zaXRpb24gLSAxXSkgfHxcbiAgICAgICAgICBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZHMnICYmIGlzRXZlbnRBdENvb3JkaW5hdGVzKGV2dCwgbGluZS5jb29yZGluYXRlc1tjdXJyZW50VmVydGV4UG9zaXRpb24gKyAxXSkpIHtcbiAgICAgICAgICByZXR1cm4gY3R4LmV2ZW50cy5jaGFuZ2VNb2RlKENvbnN0YW50cy5tb2Rlcy5TSU1QTEVfU0VMRUNULCB7IGZlYXR1cmVJZHM6IFtsaW5lLmlkXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLkFERCB9KTtcbiAgICAgICAgbGluZS51cGRhdGVDb29yZGluYXRlKGN1cnJlbnRWZXJ0ZXhQb3NpdGlvbiwgZXZ0LmxuZ0xhdC5sbmcsIGV2dC5sbmdMYXQubGF0KTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgY3VycmVudFZlcnRleFBvc2l0aW9uKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZS5hZGRDb29yZGluYXRlKDAsIGV2dC5sbmdMYXQubG5nLCBldnQubG5nTGF0LmxhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsaWNrT25WZXJ0ZXgoKSB7XG4gICAgICAgIHJldHVybiBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QsIHsgZmVhdHVyZUlkczogW2xpbmUuaWRdIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIENvbW1vblNlbGVjdG9ycy5pc0VzY2FwZUtleSwgKCkgPT4ge1xuICAgICAgICBjdHguc3RvcmUuZGVsZXRlKFtsaW5lLmlkXSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2tleXVwJywgQ29tbW9uU2VsZWN0b3JzLmlzRW50ZXJLZXksICgpID0+IHtcbiAgICAgICAgY3R4LmV2ZW50cy5jaGFuZ2VNb2RlKENvbnN0YW50cy5tb2Rlcy5TSU1QTEVfU0VMRUNULCB7IGZlYXR1cmVJZHM6IFtsaW5lLmlkXSB9KTtcbiAgICAgIH0pO1xuICAgICAgY3R4LmV2ZW50cy5hY3Rpb25hYmxlKHtcbiAgICAgICAgY29tYmluZUZlYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgdW5jb21iaW5lRmVhdHVyZXM6IGZhbHNlLFxuICAgICAgICB0cmFzaDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHN0b3AoKSB7XG4gICAgICBkb3VibGVDbGlja1pvb20uZW5hYmxlKGN0eCk7XG4gICAgICBjdHgudWkuc2V0QWN0aXZlQnV0dG9uKCk7XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBkZWxldGVkIHRoaXMgZmVhdHVyZVxuICAgICAgaWYgKGN0eC5zdG9yZS5nZXQobGluZS5pZCkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAvL3JlbW92ZSBsYXN0IGFkZGVkIGNvb3JkaW5hdGVcbiAgICAgIGxpbmUucmVtb3ZlQ29vcmRpbmF0ZShgJHtjdXJyZW50VmVydGV4UG9zaXRpb259YCk7XG4gICAgICBpZiAobGluZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgY3R4Lm1hcC5maXJlKENvbnN0YW50cy5ldmVudHMuQ1JFQVRFLCB7XG4gICAgICAgICAgZmVhdHVyZXM6IFtsaW5lLnRvR2VvSlNPTigpXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5zdG9yZS5kZWxldGUoW2xpbmUuaWRdLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgY3R4LmV2ZW50cy5jaGFuZ2VNb2RlKENvbnN0YW50cy5tb2Rlcy5TSU1QTEVfU0VMRUNULCB7fSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcihnZW9qc29uLCBjYWxsYmFjaykge1xuICAgICAgY29uc3QgaXNBY3RpdmVMaW5lID0gZ2VvanNvbi5wcm9wZXJ0aWVzLmlkID09PSBsaW5lLmlkO1xuICAgICAgZ2VvanNvbi5wcm9wZXJ0aWVzLmFjdGl2ZSA9IChpc0FjdGl2ZUxpbmUpID8gQ29uc3RhbnRzLmFjdGl2ZVN0YXRlcy5BQ1RJVkUgOiBDb25zdGFudHMuYWN0aXZlU3RhdGVzLklOQUNUSVZFO1xuICAgICAgaWYgKCFpc0FjdGl2ZUxpbmUpIHJldHVybiBjYWxsYmFjayhnZW9qc29uKTtcblxuICAgICAgLy8gT25seSByZW5kZXIgdGhlIGxpbmUgaWYgaXQgaGFzIGF0IGxlYXN0IG9uZSByZWFsIGNvb3JkaW5hdGVcbiAgICAgIGlmIChnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgIGdlb2pzb24ucHJvcGVydGllcy5tZXRhID0gQ29uc3RhbnRzLm1ldGEuRkVBVFVSRTtcblxuICAgICAgaWYgKGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgY2FsbGJhY2soY3JlYXRlVmVydGV4KFxuICAgICAgICAgIGxpbmUuaWQsXG4gICAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlc1tkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMiA6IDFdLFxuICAgICAgICAgIGAke2RpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAyIDogMX1gLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhnZW9qc29uKTtcbiAgICB9LFxuXG4gICAgdHJhc2goKSB7XG4gICAgICBpZiAoY3VycmVudFZlcnRleFBvc2l0aW9uID4gMSkge1xuICAgICAgICBsZXQgY3Vyc29yUG9zaXRpb24gPSBsaW5lLmdldENvb3JkaW5hdGUoYCR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWApO1xuXG4gICAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiA9PT0gdW5kZWZpbmVkICYmIGhlYXJkTW91c2VNb3ZlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy9hIG1vdXNlbW92ZSBldmVudCBoYXMgbm90IHJlY2VudGx5IGhhcHBlbmVkIHNvIG1pbWljIG9uZVxuICAgICAgICAgIGN1cnNvclBvc2l0aW9uID0gbGluZS5nZXRDb29yZGluYXRlKGAke2N1cnJlbnRWZXJ0ZXhQb3NpdGlvbiAtIDF9YCk7XG4gICAgICAgICAgbGluZS51cGRhdGVDb29yZGluYXRlKGAke2N1cnJlbnRWZXJ0ZXhQb3NpdGlvbn1gLCBjdXJzb3JQb3NpdGlvblswXSwgY3Vyc29yUG9zaXRpb25bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJzb3JQb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIGhlYXJkTW91c2VNb3ZlID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vc2hvdWxkIGJlIGEgdG91Y2ggd2l0aCBubyBtb3VzZW1vdmVcbiAgICAgICAgICBsaW5lLnJlbW92ZUNvb3JkaW5hdGUoYCR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWApO1xuICAgICAgICAgIGN1cnJlbnRWZXJ0ZXhQb3NpdGlvbi0tO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVtb3ZlIHRoZSBsYXN0IHBvaW50XG4gICAgICAgIGN1cnJlbnRWZXJ0ZXhQb3NpdGlvbi0tO1xuICAgICAgICBsaW5lLnJlbW92ZUNvb3JkaW5hdGUoYCR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnN0b3JlLmRlbGV0ZShbbGluZS5pZF0sIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iLCJjb25zdCBDb21tb25TZWxlY3RvcnMgPSByZXF1aXJlKCcuLi9saWIvY29tbW9uX3NlbGVjdG9ycycpO1xuY29uc3QgUG9pbnQgPSByZXF1aXJlKCcuLi9mZWF0dXJlX3R5cGVzL3BvaW50Jyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgpIHtcblxuICBjb25zdCBwb2ludCA9IG5ldyBQb2ludChjdHgsIHtcbiAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuUE9JTlQsXG4gICAgICBjb29yZGluYXRlczogW11cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjdHguX3Rlc3QpIGN0eC5fdGVzdC5wb2ludCA9IHBvaW50O1xuXG4gIGN0eC5zdG9yZS5hZGQocG9pbnQpO1xuXG4gIGZ1bmN0aW9uIHN0b3BEcmF3aW5nQW5kUmVtb3ZlKCkge1xuICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCk7XG4gICAgY3R4LnN0b3JlLmRlbGV0ZShbcG9pbnQuaWRdLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLk1PVkUgfSk7XG4gICAgcG9pbnQudXBkYXRlQ29vcmRpbmF0ZSgnJywgZS5sbmdMYXQubG5nLCBlLmxuZ0xhdC5sYXQpO1xuICAgIGN0eC5tYXAuZmlyZShDb25zdGFudHMuZXZlbnRzLkNSRUFURSwge1xuICAgICAgZmVhdHVyZXM6IFtwb2ludC50b0dlb0pTT04oKV1cbiAgICB9KTtcbiAgICBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QsIHsgZmVhdHVyZUlkczogW3BvaW50LmlkXSB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQoKSB7XG4gICAgICBjdHguc3RvcmUuY2xlYXJTZWxlY3RlZCgpO1xuICAgICAgY3R4LnVpLnF1ZXVlTWFwQ2xhc3Nlcyh7IG1vdXNlOiBDb25zdGFudHMuY3Vyc29ycy5BREQgfSk7XG4gICAgICBjdHgudWkuc2V0QWN0aXZlQnV0dG9uKENvbnN0YW50cy50eXBlcy5QT0lOVCk7XG4gICAgICB0aGlzLm9uKCdjbGljaycsIENvbW1vblNlbGVjdG9ycy50cnVlLCBoYW5kbGVDbGljayk7XG4gICAgICB0aGlzLm9uKCd0YXAnLCBDb21tb25TZWxlY3RvcnMudHJ1ZSwgaGFuZGxlQ2xpY2spO1xuICAgICAgdGhpcy5vbigna2V5dXAnLCBDb21tb25TZWxlY3RvcnMuaXNFc2NhcGVLZXksIHN0b3BEcmF3aW5nQW5kUmVtb3ZlKTtcbiAgICAgIHRoaXMub24oJ2tleXVwJywgQ29tbW9uU2VsZWN0b3JzLmlzRW50ZXJLZXksIHN0b3BEcmF3aW5nQW5kUmVtb3ZlKTtcbiAgICAgIGN0eC5ldmVudHMuYWN0aW9uYWJsZSh7XG4gICAgICAgIGNvbWJpbmVGZWF0dXJlczogZmFsc2UsXG4gICAgICAgIHVuY29tYmluZUZlYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgdHJhc2g6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzdG9wKCkge1xuICAgICAgY3R4LnVpLnNldEFjdGl2ZUJ1dHRvbigpO1xuICAgICAgaWYgKCFwb2ludC5nZXRDb29yZGluYXRlKCkubGVuZ3RoKSB7XG4gICAgICAgIGN0eC5zdG9yZS5kZWxldGUoW3BvaW50LmlkXSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcihnZW9qc29uLCBjYWxsYmFjaykge1xuICAgICAgY29uc3QgaXNBY3RpdmVQb2ludCA9IGdlb2pzb24ucHJvcGVydGllcy5pZCA9PT0gcG9pbnQuaWQ7XG4gICAgICBnZW9qc29uLnByb3BlcnRpZXMuYWN0aXZlID0gKGlzQWN0aXZlUG9pbnQpID8gQ29uc3RhbnRzLmFjdGl2ZVN0YXRlcy5BQ1RJVkUgOiBDb25zdGFudHMuYWN0aXZlU3RhdGVzLklOQUNUSVZFO1xuICAgICAgaWYgKCFpc0FjdGl2ZVBvaW50KSByZXR1cm4gY2FsbGJhY2soZ2VvanNvbik7XG4gICAgICAvLyBOZXZlciByZW5kZXIgdGhlIHBvaW50IHdlJ3JlIGRyYXdpbmdcbiAgICB9LFxuXG4gICAgdHJhc2goKSB7XG4gICAgICBzdG9wRHJhd2luZ0FuZFJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn07XG4iLCJjb25zdCBDb21tb25TZWxlY3RvcnMgPSByZXF1aXJlKCcuLi9saWIvY29tbW9uX3NlbGVjdG9ycycpO1xuY29uc3QgUG9seWdvbiA9IHJlcXVpcmUoJy4uL2ZlYXR1cmVfdHlwZXMvcG9seWdvbicpO1xuY29uc3QgZG91YmxlQ2xpY2tab29tID0gcmVxdWlyZSgnLi4vbGliL2RvdWJsZV9jbGlja196b29tJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbmNvbnN0IGlzRXZlbnRBdENvb3JkaW5hdGVzID0gcmVxdWlyZSgnLi4vbGliL2lzX2V2ZW50X2F0X2Nvb3JkaW5hdGVzJyk7XG5jb25zdCBjcmVhdGVWZXJ0ZXggPSByZXF1aXJlKCcuLi9saWIvY3JlYXRlX3ZlcnRleCcpO1xuY29uc3Qgc25hcFRvID0gcmVxdWlyZSgnLi4vbGliL3NuYXBfdG8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgpIHtcblxuICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24oY3R4LCB7XG4gICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5GRUFUVVJFLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLlBPTFlHT04sXG4gICAgICBjb29yZGluYXRlczogW1tdXVxuICAgIH1cbiAgfSk7XG4gIGxldCBjdXJyZW50VmVydGV4UG9zaXRpb24gPSAwO1xuICBsZXQgaGVhcmRNb3VzZU1vdmUgPSBmYWxzZTtcblxuICBpZiAoY3R4Ll90ZXN0KSBjdHguX3Rlc3QucG9seWdvbiA9IHBvbHlnb247XG5cbiAgY3R4LnN0b3JlLmFkZChwb2x5Z29uKTtcblxuICBsZXQgc25hcENsaWNrUG9pbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydCgpIHtcbiAgICAgIGN0eC5zdG9yZS5jbGVhclNlbGVjdGVkKCk7XG4gICAgICBkb3VibGVDbGlja1pvb20uZGlzYWJsZShjdHgpO1xuICAgICAgY3R4LnVpLnF1ZXVlTWFwQ2xhc3Nlcyh7IG1vdXNlOiBDb25zdGFudHMuY3Vyc29ycy5BREQgfSk7XG4gICAgICBjdHgudWkuc2V0QWN0aXZlQnV0dG9uKENvbnN0YW50cy50eXBlcy5QT0xZR09OKTtcbiAgICAgIHRoaXMub24oJ21vdXNlbW92ZScsIENvbW1vblNlbGVjdG9ycy50cnVlLCBlID0+IHtcbiAgICAgICAgbGV0IGV2dCA9IGU7XG5cbiAgICAgICAgaWYgKCFjdHguc25hcFRvT3ZlcnJpZGUgJiYgZXZ0LnBvaW50ICYmIGN0eC5vcHRpb25zLnNuYXBUbykge1xuICAgICAgICAgIGV2dCA9IHNuYXBUbyhldnQsIGN0eCwgcG9seWdvbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgc25hcENsaWNrUG9pbnQgPSBldnQ7XG4gICAgICAgIHBvbHlnb24udXBkYXRlQ29vcmRpbmF0ZShgMC4ke2N1cnJlbnRWZXJ0ZXhQb3NpdGlvbn1gLCBldnQubG5nTGF0LmxuZywgZXZ0LmxuZ0xhdC5sYXQpO1xuICAgICAgICBpZiAoQ29tbW9uU2VsZWN0b3JzLmlzVmVydGV4KGV2dCkpIHtcbiAgICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLlBPSU5URVIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhcmRNb3VzZU1vdmUgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdjbGljaycsIENvbW1vblNlbGVjdG9ycy50cnVlLCBjbGlja0FueXdoZXJlKTtcbiAgICAgIHRoaXMub24oJ2NsaWNrJywgQ29tbW9uU2VsZWN0b3JzLmlzVmVydGV4LCBjbGlja09uVmVydGV4KTtcbiAgICAgIHRoaXMub24oJ3RhcCcsIENvbW1vblNlbGVjdG9ycy50cnVlLCBjbGlja0FueXdoZXJlKTtcbiAgICAgIHRoaXMub24oJ3RhcCcsIENvbW1vblNlbGVjdG9ycy5pc1ZlcnRleCwgY2xpY2tPblZlcnRleCk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsaWNrQW55d2hlcmUoZSkge1xuICAgICAgICBjb25zdCBldnQgPSBzbmFwQ2xpY2tQb2ludCB8fCBlO1xuICAgICAgICBpZiAoY3VycmVudFZlcnRleFBvc2l0aW9uID4gMCAmJiBpc0V2ZW50QXRDb29yZGluYXRlcyhldnQsIHBvbHlnb24uY29vcmRpbmF0ZXNbMF1bY3VycmVudFZlcnRleFBvc2l0aW9uIC0gMV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCwgeyBmZWF0dXJlSWRzOiBbcG9seWdvbi5pZF0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnVpLnF1ZXVlTWFwQ2xhc3Nlcyh7IG1vdXNlOiBDb25zdGFudHMuY3Vyc29ycy5BREQgfSk7XG4gICAgICAgIHBvbHlnb24udXBkYXRlQ29vcmRpbmF0ZShgMC4ke2N1cnJlbnRWZXJ0ZXhQb3NpdGlvbn1gLCBldnQubG5nTGF0LmxuZywgZXZ0LmxuZ0xhdC5sYXQpO1xuICAgICAgICBjdXJyZW50VmVydGV4UG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsaWNrT25WZXJ0ZXgoKSB7XG4gICAgICAgIHJldHVybiBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QsIHsgZmVhdHVyZUlkczogW3BvbHlnb24uaWRdIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5vbigna2V5dXAnLCBDb21tb25TZWxlY3RvcnMuaXNFc2NhcGVLZXksICgpID0+IHtcbiAgICAgICAgY3R4LnN0b3JlLmRlbGV0ZShbcG9seWdvbi5pZF0sIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIENvbW1vblNlbGVjdG9ycy5pc0VudGVyS2V5LCAoKSA9PiB7XG4gICAgICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCwgeyBmZWF0dXJlSWRzOiBbcG9seWdvbi5pZF0gfSk7XG4gICAgICB9KTtcbiAgICAgIGN0eC5ldmVudHMuYWN0aW9uYWJsZSh7XG4gICAgICAgIGNvbWJpbmVGZWF0dXJlczogZmFsc2UsXG4gICAgICAgIHVuY29tYmluZUZlYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgdHJhc2g6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGN0eC51aS5xdWV1ZU1hcENsYXNzZXMoeyBtb3VzZTogQ29uc3RhbnRzLmN1cnNvcnMuTk9ORSB9KTtcbiAgICAgIGRvdWJsZUNsaWNrWm9vbS5lbmFibGUoY3R4KTtcbiAgICAgIGN0eC51aS5zZXRBY3RpdmVCdXR0b24oKTtcblxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGRlbGV0ZWQgdGhpcyBmZWF0dXJlXG4gICAgICBpZiAoY3R4LnN0b3JlLmdldChwb2x5Z29uLmlkKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIC8vcmVtb3ZlIGxhc3QgYWRkZWQgY29vcmRpbmF0ZVxuICAgICAgcG9seWdvbi5yZW1vdmVDb29yZGluYXRlKGAwLiR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWApO1xuICAgICAgaWYgKHBvbHlnb24uaXNWYWxpZCgpKSB7XG4gICAgICAgIGN0eC5tYXAuZmlyZShDb25zdGFudHMuZXZlbnRzLkNSRUFURSwge1xuICAgICAgICAgIGZlYXR1cmVzOiBbcG9seWdvbi50b0dlb0pTT04oKV1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguc3RvcmUuZGVsZXRlKFtwb2x5Z29uLmlkXSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuU0lNUExFX1NFTEVDVCwge30sIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXIoZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGlzQWN0aXZlUG9seWdvbiA9IGdlb2pzb24ucHJvcGVydGllcy5pZCA9PT0gcG9seWdvbi5pZDtcbiAgICAgIGdlb2pzb24ucHJvcGVydGllcy5hY3RpdmUgPSAoaXNBY3RpdmVQb2x5Z29uKSA/IENvbnN0YW50cy5hY3RpdmVTdGF0ZXMuQUNUSVZFIDogQ29uc3RhbnRzLmFjdGl2ZVN0YXRlcy5JTkFDVElWRTtcbiAgICAgIGlmICghaXNBY3RpdmVQb2x5Z29uKSByZXR1cm4gY2FsbGJhY2soZ2VvanNvbik7XG5cbiAgICAgIC8vIERvbid0IHJlbmRlciBhIHBvbHlnb24gdW50aWwgaXQgaGFzIHR3byBwb3NpdGlvbnNcbiAgICAgIC8vIChhbmQgYSAzcmQgd2hpY2ggaXMganVzdCB0aGUgZmlyc3QgcmVwZWF0ZWQpXG4gICAgICBpZiAoZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgY29uc3QgY29vcmRpbmF0ZUNvdW50ID0gZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5sZW5ndGg7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiB0d28gcG9zaXRpb25zIChwbHVzIHRoZSBjbG9zZXIpLFxuICAgICAgLy8gaXQncyBub3QgeWV0IGEgc2hhcGUgdG8gcmVuZGVyXG4gICAgICBpZiAoY29vcmRpbmF0ZUNvdW50IDwgMykgcmV0dXJuO1xuXG4gICAgICBnZW9qc29uLnByb3BlcnRpZXMubWV0YSA9IENvbnN0YW50cy5tZXRhLkZFQVRVUkU7XG5cbiAgICAgIGlmIChjb29yZGluYXRlQ291bnQgPiA0KSB7XG4gICAgICAgIC8vIEFkZCBhIHN0YXJ0IHBvc2l0aW9uIG1hcmtlciB0byB0aGUgbWFwLCBjbGlja2luZyBvbiB0aGlzIHdpbGwgZmluaXNoIHRoZSBmZWF0dXJlXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgc2hvd24gd2hlbiB3ZSdyZSBpbiBhIHZhbGlkIHNwb3RcbiAgICAgICAgY2FsbGJhY2soY3JlYXRlVmVydGV4KHBvbHlnb24uaWQsIGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF0sICcwLjAnLCBmYWxzZSkpO1xuICAgICAgICBjb25zdCBlbmRQb3MgPSBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLmxlbmd0aCAtIDM7XG4gICAgICAgIGNhbGxiYWNrKGNyZWF0ZVZlcnRleChwb2x5Z29uLmlkLCBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdW2VuZFBvc10sIGAwLiR7ZW5kUG9zfWAsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIHR3byBwb3NpdGlvbnMgKHBsdXMgdGhlIGNsb3NlciksXG4gICAgICAvLyByZW5kZXIgdGhlIFBvbHlnb25cbiAgICAgIGlmIChjb29yZGluYXRlQ291bnQgPiAzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhnZW9qc29uKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UndmUgb25seSBkcmF3biB0d28gcG9zaXRpb25zIChwbHVzIHRoZSBjbG9zZXIpLFxuICAgICAgLy8gbWFrZSBhIExpbmVTdHJpbmcgaW5zdGVhZCBvZiBhIFBvbHlnb25cbiAgICAgIGNvbnN0IGxpbmVDb29yZGluYXRlcyA9IFtcbiAgICAgICAgW2dlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF1bMF0sIGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF1bMV1dLCBbZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsxXVswXSwgZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsxXVsxXV1cbiAgICAgIF07XG4gICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkUsXG4gICAgICAgIHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllcyxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICBjb29yZGluYXRlczogbGluZUNvb3JkaW5hdGVzLFxuICAgICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuTElORV9TVFJJTkdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0cmFzaCgpIHtcbiAgICAgIGlmIChjdXJyZW50VmVydGV4UG9zaXRpb24gPiAxKSB7XG4gICAgICAgIGxldCBjdXJzb3JQb3NpdGlvbiA9IHBvbHlnb24uZ2V0Q29vcmRpbmF0ZShgMC4ke2N1cnJlbnRWZXJ0ZXhQb3NpdGlvbn1gKTtcblxuICAgICAgICBpZiAoY3Vyc29yUG9zaXRpb24gPT09IHVuZGVmaW5lZCAmJiBoZWFyZE1vdXNlTW92ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vYSBtb3VzZW1vdmUgZXZlbnQgaGFzIG5vdCByZWNlbnRseSBoYXBwZW5lZCBzbyBtaW1pYyBvbmVcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IHBvbHlnb24uZ2V0Q29vcmRpbmF0ZShgMC4ke2N1cnJlbnRWZXJ0ZXhQb3NpdGlvbiAtIDF9YCk7XG4gICAgICAgICAgcG9seWdvbi51cGRhdGVDb29yZGluYXRlKGAwLiR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWAsIGN1cnNvclBvc2l0aW9uWzBdLCBjdXJzb3JQb3NpdGlvblsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnNvclBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgaGVhcmRNb3VzZU1vdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy9zaG91bGQgYmUgYSB0b3VjaCB3aGljaCBoYXMgbm8gbW91c2Vtb3ZlXG4gICAgICAgICAgcG9seWdvbi5yZW1vdmVDb29yZGluYXRlKGAwLiR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWApO1xuICAgICAgICAgIGN1cnJlbnRWZXJ0ZXhQb3NpdGlvbi0tO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVtb3ZlIGxhc3QgYWRkZWQgY29vcmRpbmF0ZVxuICAgICAgICBjdXJyZW50VmVydGV4UG9zaXRpb24tLTtcbiAgICAgICAgcG9seWdvbi5yZW1vdmVDb29yZGluYXRlKGAwLiR7Y3VycmVudFZlcnRleFBvc2l0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnN0b3JlLmRlbGV0ZShbcG9seWdvbi5pZF0sIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLlNJTVBMRV9TRUxFQ1QpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iLCJjb25zdCBDb21tb25TZWxlY3RvcnMgPSByZXF1aXJlKCcuLi9saWIvY29tbW9uX3NlbGVjdG9ycycpO1xuY29uc3QgbW91c2VFdmVudFBvaW50ID0gcmVxdWlyZSgnLi4vbGliL21vdXNlX2V2ZW50X3BvaW50Jyk7XG5jb25zdCBmZWF0dXJlc0F0ID0gcmVxdWlyZSgnLi4vbGliL2ZlYXR1cmVzX2F0Jyk7XG5jb25zdCBjcmVhdGVTdXBwbGVtZW50YXJ5UG9pbnRzID0gcmVxdWlyZSgnLi4vbGliL2NyZWF0ZV9zdXBwbGVtZW50YXJ5X3BvaW50cycpO1xuY29uc3QgU3RyaW5nU2V0ID0gcmVxdWlyZSgnLi4vbGliL3N0cmluZ19zZXQnKTtcbmNvbnN0IGRvdWJsZUNsaWNrWm9vbSA9IHJlcXVpcmUoJy4uL2xpYi9kb3VibGVfY2xpY2tfem9vbScpO1xuY29uc3QgbW92ZUZlYXR1cmVzID0gcmVxdWlyZSgnLi4vbGliL21vdmVfZmVhdHVyZXMnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgTXVsdGlGZWF0dXJlID0gcmVxdWlyZSgnLi4vZmVhdHVyZV90eXBlcy9tdWx0aV9mZWF0dXJlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3R4LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGRyYWdNb3ZlTG9jYXRpb24gPSBudWxsO1xuICBsZXQgYm94U2VsZWN0U3RhcnRMb2NhdGlvbiA9IG51bGw7XG4gIGxldCBib3hTZWxlY3RFbGVtZW50O1xuICBsZXQgYm94U2VsZWN0aW5nID0gZmFsc2U7XG4gIGxldCBjYW5Cb3hTZWxlY3QgPSBmYWxzZTtcbiAgbGV0IGRyYWdNb3ZpbmcgPSBmYWxzZTtcbiAgbGV0IGNhbkRyYWdNb3ZlID0gZmFsc2U7XG5cbiAgY29uc3QgaW5pdGlhbGx5U2VsZWN0ZWRGZWF0dXJlSWRzID0gb3B0aW9ucy5mZWF0dXJlSWRzIHx8IFtdO1xuXG4gIGNvbnN0IGZpcmVVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBjdHgubWFwLmZpcmUoQ29uc3RhbnRzLmV2ZW50cy5VUERBVEUsIHtcbiAgICAgIGFjdGlvbjogQ29uc3RhbnRzLnVwZGF0ZUFjdGlvbnMuTU9WRSxcbiAgICAgIGZlYXR1cmVzOiBjdHguc3RvcmUuZ2V0U2VsZWN0ZWQoKS5tYXAoZiA9PiBmLnRvR2VvSlNPTigpKVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGZpcmVBY3Rpb25hYmxlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkRmVhdHVyZXMgPSBjdHguc3RvcmUuZ2V0U2VsZWN0ZWQoKTtcblxuICAgIGNvbnN0IG11bHRpRmVhdHVyZXMgPSBzZWxlY3RlZEZlYXR1cmVzLmZpbHRlcihcbiAgICAgIGZlYXR1cmUgPT4gZmVhdHVyZSBpbnN0YW5jZW9mIE11bHRpRmVhdHVyZVxuICAgICk7XG5cbiAgICBsZXQgY29tYmluZUZlYXR1cmVzID0gZmFsc2U7XG5cbiAgICBpZiAoc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb21iaW5lRmVhdHVyZXMgPSB0cnVlO1xuICAgICAgY29uc3QgZmVhdHVyZVR5cGUgPSBzZWxlY3RlZEZlYXR1cmVzWzBdLnR5cGUucmVwbGFjZSgnTXVsdGknLCAnJyk7XG4gICAgICBzZWxlY3RlZEZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICAgIGlmIChmZWF0dXJlLnR5cGUucmVwbGFjZSgnTXVsdGknLCAnJykgIT09IGZlYXR1cmVUeXBlKSB7XG4gICAgICAgICAgY29tYmluZUZlYXR1cmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHVuY29tYmluZUZlYXR1cmVzID0gbXVsdGlGZWF0dXJlcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHRyYXNoID0gc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGggPiAwO1xuXG4gICAgY3R4LmV2ZW50cy5hY3Rpb25hYmxlKHtcbiAgICAgIGNvbWJpbmVGZWF0dXJlcywgdW5jb21iaW5lRmVhdHVyZXMsIHRyYXNoXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0VW5pcXVlSWRzID0gZnVuY3Rpb24oYWxsRmVhdHVyZXMpIHtcbiAgICBpZiAoIWFsbEZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGlkcyA9IGFsbEZlYXR1cmVzLm1hcChzID0+IHMucHJvcGVydGllcy5pZClcbiAgICAgIC5maWx0ZXIoaWQgPT4gaWQgIT09IHVuZGVmaW5lZClcbiAgICAgIC5yZWR1Y2UoKG1lbW8sIGlkKSA9PiB7XG4gICAgICAgIG1lbW8uYWRkKGlkKTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCBuZXcgU3RyaW5nU2V0KCkpO1xuXG4gICAgcmV0dXJuIGlkcy52YWx1ZXMoKTtcbiAgfTtcblxuICBjb25zdCBzdG9wRXh0ZW5kZWRJbnRlcmFjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYm94U2VsZWN0RWxlbWVudCkge1xuICAgICAgaWYgKGJveFNlbGVjdEVsZW1lbnQucGFyZW50Tm9kZSkgYm94U2VsZWN0RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJveFNlbGVjdEVsZW1lbnQpO1xuICAgICAgYm94U2VsZWN0RWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgY3R4Lm1hcC5kcmFnUGFuLmVuYWJsZSgpO1xuXG4gICAgYm94U2VsZWN0aW5nID0gZmFsc2U7XG4gICAgY2FuQm94U2VsZWN0ID0gZmFsc2U7XG4gICAgZHJhZ01vdmluZyA9IGZhbHNlO1xuICAgIGNhbkRyYWdNb3ZlID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRvdWJsZUNsaWNrWm9vbS5lbmFibGUoY3R4KTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFNlbGVjdCBmZWF0dXJlcyB0aGF0IHNob3VsZCBzdGFydCBzZWxlY3RlZCxcbiAgICAgIC8vIHByb2JhYmx5IHBhc3NlZCBpbiBmcm9tIGEgYGRyYXdfKmAgbW9kZVxuICAgICAgaWYgKGN0eC5zdG9yZSkge1xuICAgICAgICBjdHguc3RvcmUuc2V0U2VsZWN0ZWQoaW5pdGlhbGx5U2VsZWN0ZWRGZWF0dXJlSWRzLmZpbHRlcihpZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5zdG9yZS5nZXQoaWQpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZmlyZUFjdGlvbmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQW55IG1vdXNldXAgc2hvdWxkIHN0b3AgYm94IHNlbGVjdGluZyBhbmQgZHJhZ01vdmluZ1xuICAgICAgdGhpcy5vbignbW91c2V1cCcsIENvbW1vblNlbGVjdG9ycy50cnVlLCBzdG9wRXh0ZW5kZWRJbnRlcmFjdGlvbnMpO1xuXG4gICAgICAvLyBPbiBtb3VzZW1vdmUgdGhhdCBpcyBub3QgYSBkcmFnLCBzdG9wIGV4dGVuZGVkIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBkcmFnIG9mZiB0aGUgY2FudmFzLCByZWxlYXNlIHRoZSBidXR0b24sXG4gICAgICAvLyB0aGVuIG1vdmUgdGhlIG1vdXNlIGJhY2sgb3ZlciB0aGUgY2FudmFzIC0tLSB3ZSBkb24ndCBhbGxvdyB0aGVcbiAgICAgIC8vIGludGVyYWN0aW9uIHRvIGNvbnRpbnVlIHRoZW4sIGJ1dCB3ZSBkbyBsZXQgaXQgY29udGludWUgaWYgeW91IGhlbGRcbiAgICAgIC8vIHRoZSBtb3VzZSBidXR0b24gdGhhdCB3aG9sZSB0aW1lXG4gICAgICB0aGlzLm9uKCdtb3VzZW1vdmUnLCBDb21tb25TZWxlY3RvcnMudHJ1ZSwgc3RvcEV4dGVuZGVkSW50ZXJhY3Rpb25zKTtcblxuICAgICAgLy8gQXMgc29vbiBhcyB5b3UgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHVwZGF0ZSB0aGUgZmVhdHVyZVxuICAgICAgdGhpcy5vbignbW91c2VvdXQnLCAoKSA9PiBkcmFnTW92aW5nLCBmaXJlVXBkYXRlKTtcblxuICAgICAgLy8gQ2xpY2sgKHdpdGggb3Igd2l0aG91dCBzaGlmdCkgb24gbm8gZmVhdHVyZVxuICAgICAgdGhpcy5vbignY2xpY2snLCBDb21tb25TZWxlY3RvcnMubm9UYXJnZXQsIGNsaWNrQW55d2hlcmUpO1xuICAgICAgdGhpcy5vbigndGFwJywgQ29tbW9uU2VsZWN0b3JzLm5vVGFyZ2V0LCBjbGlja0FueXdoZXJlKTtcblxuICAgICAgLy8gQ2xpY2sgKHdpdGggb3Igd2l0aG91dCBzaGlmdCkgb24gYSB2ZXJ0ZXhcbiAgICAgIHRoaXMub24oJ2NsaWNrJywgQ29tbW9uU2VsZWN0b3JzLmlzT2ZNZXRhVHlwZShDb25zdGFudHMubWV0YS5WRVJURVgpLCBjbGlja09uVmVydGV4KTtcbiAgICAgIHRoaXMub24oJ3RhcCcsIENvbW1vblNlbGVjdG9ycy5pc09mTWV0YVR5cGUoQ29uc3RhbnRzLm1ldGEuVkVSVEVYKSwgY2xpY2tPblZlcnRleCk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsaWNrQW55d2hlcmUoKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSByZS1yZW5kZXIgc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHdhc1NlbGVjdGVkID0gY3R4LnN0b3JlLmdldFNlbGVjdGVkSWRzKCk7XG4gICAgICAgIGlmICh3YXNTZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICBjdHguc3RvcmUuY2xlYXJTZWxlY3RlZCgpO1xuICAgICAgICAgIHdhc1NlbGVjdGVkLmZvckVhY2goaWQgPT4gdGhpcy5yZW5kZXIoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBkb3VibGVDbGlja1pvb20uZW5hYmxlKGN0eCk7XG4gICAgICAgIHN0b3BFeHRlbmRlZEludGVyYWN0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGlja09uVmVydGV4KGUpIHtcbiAgICAgICAgLy8gRW50ZXIgZGlyZWN0IHNlbGVjdCBtb2RlXG4gICAgICAgIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuRElSRUNUX1NFTEVDVCwge1xuICAgICAgICAgIGZlYXR1cmVJZDogZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMucGFyZW50LFxuICAgICAgICAgIGNvb3JkUGF0aDogZS5mZWF0dXJlVGFyZ2V0LnByb3BlcnRpZXMuY29vcmRfcGF0aCxcbiAgICAgICAgICBzdGFydFBvczogZS5sbmdMYXRcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC51aS5xdWV1ZU1hcENsYXNzZXMoeyBtb3VzZTogQ29uc3RhbnRzLmN1cnNvcnMuTU9WRSB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTW91c2Vkb3duIG9uIGEgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgQ29tbW9uU2VsZWN0b3JzLmlzQWN0aXZlRmVhdHVyZSwgc3RhcnRPbkFjdGl2ZUZlYXR1cmUpO1xuICAgICAgdGhpcy5vbigndG91Y2hzdGFydCcsIENvbW1vblNlbGVjdG9ycy5pc0FjdGl2ZUZlYXR1cmUsIHN0YXJ0T25BY3RpdmVGZWF0dXJlKTtcblxuICAgICAgZnVuY3Rpb24gc3RhcnRPbkFjdGl2ZUZlYXR1cmUoZSkge1xuICAgICAgICAvLyBTdG9wIGFueSBhbHJlYWR5LXVuZGVyd2F5IGV4dGVuZGVkIGludGVyYWN0aW9uc1xuICAgICAgICBzdG9wRXh0ZW5kZWRJbnRlcmFjdGlvbnMoKTtcblxuICAgICAgICAvLyBEaXNhYmxlIG1hcC5kcmFnUGFuIGltbWVkaWF0ZWx5IHNvIGl0IGNhbid0IHN0YXJ0XG4gICAgICAgIGN0eC5tYXAuZHJhZ1Bhbi5kaXNhYmxlKCk7XG5cbiAgICAgICAgLy8gUmUtcmVuZGVyIGl0IGFuZCBlbmFibGUgZHJhZyBtb3ZlXG4gICAgICAgIHRoaXMucmVuZGVyKGUuZmVhdHVyZVRhcmdldC5wcm9wZXJ0aWVzLmlkKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIHN0YXRlIGZvciBkcmFnIG1vdmluZ1xuICAgICAgICBjYW5EcmFnTW92ZSA9IHRydWU7XG4gICAgICAgIGRyYWdNb3ZlTG9jYXRpb24gPSBlLmxuZ0xhdDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xpY2sgKHdpdGggb3Igd2l0aG91dCBzaGlmdCkgb24gYW55IGZlYXR1cmVcbiAgICAgIHRoaXMub24oJ2NsaWNrJywgQ29tbW9uU2VsZWN0b3JzLmlzRmVhdHVyZSwgY2xpY2tPbkZlYXR1cmUpO1xuICAgICAgdGhpcy5vbigndGFwJywgQ29tbW9uU2VsZWN0b3JzLmlzRmVhdHVyZSwgY2xpY2tPbkZlYXR1cmUpO1xuXG5cbiAgICAgIGZ1bmN0aW9uIGNsaWNrT25GZWF0dXJlKGUpIHtcbiAgICAgICAgLy8gU3RvcCBldmVyeXRoaW5nXG4gICAgICAgIGRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKGN0eCk7XG4gICAgICAgIHN0b3BFeHRlbmRlZEludGVyYWN0aW9ucygpO1xuXG4gICAgICAgIGNvbnN0IGlzU2hpZnRDbGljayA9IENvbW1vblNlbGVjdG9ycy5pc1NoaWZ0RG93bihlKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSWRzID0gY3R4LnN0b3JlLmdldFNlbGVjdGVkSWRzKCk7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVJZCA9IGUuZmVhdHVyZVRhcmdldC5wcm9wZXJ0aWVzLmlkO1xuICAgICAgICBjb25zdCBpc0ZlYXR1cmVTZWxlY3RlZCA9IGN0eC5zdG9yZS5pc1NlbGVjdGVkKGZlYXR1cmVJZCk7XG5cbiAgICAgICAgLy8gQ2xpY2sgKHdpdGhvdXQgc2hpZnQpIG9uIGFueSBzZWxlY3RlZCBmZWF0dXJlIGJ1dCBhIHBvaW50XG4gICAgICAgIGlmICghaXNTaGlmdENsaWNrICYmIGlzRmVhdHVyZVNlbGVjdGVkICYmIGN0eC5zdG9yZS5nZXQoZmVhdHVyZUlkKS50eXBlICE9PSBDb25zdGFudHMuZ2VvanNvblR5cGVzLlBPSU5UKSB7XG4gICAgICAgICAgLy8gRW50ZXIgZGlyZWN0IHNlbGVjdCBtb2RlXG4gICAgICAgICAgcmV0dXJuIGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuRElSRUNUX1NFTEVDVCwge1xuICAgICAgICAgICAgZmVhdHVyZUlkOiBmZWF0dXJlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoaWZ0LWNsaWNrIG9uIGEgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICBpZiAoaXNGZWF0dXJlU2VsZWN0ZWQgJiYgaXNTaGlmdENsaWNrKSB7XG4gICAgICAgICAgLy8gRGVzZWxlY3QgaXRcbiAgICAgICAgICBjdHguc3RvcmUuZGVzZWxlY3QoZmVhdHVyZUlkKTtcbiAgICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLlBPSU5URVIgfSk7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkRmVhdHVyZUlkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRvdWJsZUNsaWNrWm9vbS5lbmFibGUoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIC8vIFNoaWZ0LWNsaWNrIG9uIGFuIHVuc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0ZlYXR1cmVTZWxlY3RlZCAmJiBpc1NoaWZ0Q2xpY2spIHtcbiAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIHNlbGVjdGlvblxuICAgICAgICAgIGN0eC5zdG9yZS5zZWxlY3QoZmVhdHVyZUlkKTtcbiAgICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLk1PVkUgfSk7XG4gICAgICAgIC8vIENsaWNrICh3aXRob3V0IHNoaWZ0KSBvbiBhbiB1bnNlbGVjdGVkIGZlYXR1cmVcbiAgICAgICAgfSBlbHNlIGlmICghaXNGZWF0dXJlU2VsZWN0ZWQgJiYgIWlzU2hpZnRDbGljaykge1xuICAgICAgICAgIC8vIE1ha2UgaXQgdGhlIG9ubHkgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZUlkcy5mb3JFYWNoKHRoaXMucmVuZGVyKTtcbiAgICAgICAgICBjdHguc3RvcmUuc2V0U2VsZWN0ZWQoZmVhdHVyZUlkKTtcbiAgICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLk1PVkUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBtYXR0ZXIgd2hhdCwgcmUtcmVuZGVyIHRoZSBjbGlja2VkIGZlYXR1cmVcbiAgICAgICAgdGhpcy5yZW5kZXIoZmVhdHVyZUlkKTtcbiAgICAgIH1cblxuICAgICAgLy8gRHJhZ2dpbmcgd2hlbiBkcmFnIG1vdmUgaXMgZW5hYmxlZFxuICAgICAgdGhpcy5vbignZHJhZycsICgpID0+IGNhbkRyYWdNb3ZlLCAoZSkgPT4ge1xuICAgICAgICBkcmFnTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgZS5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGNvbnN0IGRlbHRhID0ge1xuICAgICAgICAgIGxuZzogZS5sbmdMYXQubG5nIC0gZHJhZ01vdmVMb2NhdGlvbi5sbmcsXG4gICAgICAgICAgbGF0OiBlLmxuZ0xhdC5sYXQgLSBkcmFnTW92ZUxvY2F0aW9uLmxhdFxuICAgICAgICB9O1xuXG4gICAgICAgIG1vdmVGZWF0dXJlcyhjdHguc3RvcmUuZ2V0U2VsZWN0ZWQoKSwgZGVsdGEpO1xuXG4gICAgICAgIGRyYWdNb3ZlTG9jYXRpb24gPSBlLmxuZ0xhdDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb3VzZXVwLCBhbHdheXNcbiAgICAgIHRoaXMub24oJ21vdXNldXAnLCBDb21tb25TZWxlY3RvcnMudHJ1ZSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBFbmQgYW55IGV4dGVuZGVkIGludGVyYWN0aW9uc1xuICAgICAgICBpZiAoZHJhZ01vdmluZykge1xuICAgICAgICAgIGZpcmVVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3hTZWxlY3RpbmcpIHtcbiAgICAgICAgICBjb25zdCBiYm94ID0gW1xuICAgICAgICAgICAgYm94U2VsZWN0U3RhcnRMb2NhdGlvbixcbiAgICAgICAgICAgIG1vdXNlRXZlbnRQb2ludChlLm9yaWdpbmFsRXZlbnQsIGN0eC5jb250YWluZXIpXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCBmZWF0dXJlc0luQm94ID0gZmVhdHVyZXNBdC5jbGljayhudWxsLCBiYm94LCBjdHgpO1xuICAgICAgICAgIGNvbnN0IGlkc1RvU2VsZWN0ID0gZ2V0VW5pcXVlSWRzKGZlYXR1cmVzSW5Cb3gpXG4gICAgICAgICAgICAuZmlsdGVyKGlkID0+ICFjdHguc3RvcmUuaXNTZWxlY3RlZChpZCkpO1xuXG4gICAgICAgICAgaWYgKGlkc1RvU2VsZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY3R4LnN0b3JlLnNlbGVjdChpZHNUb1NlbGVjdCk7XG4gICAgICAgICAgICBpZHNUb1NlbGVjdC5mb3JFYWNoKHRoaXMucmVuZGVyKTtcbiAgICAgICAgICAgIGN0eC51aS5xdWV1ZU1hcENsYXNzZXMoeyBtb3VzZTogQ29uc3RhbnRzLmN1cnNvcnMuTU9WRSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV4dGVuZGVkSW50ZXJhY3Rpb25zKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGN0eC5vcHRpb25zLmJveFNlbGVjdCkge1xuICAgICAgICAvLyBTaGlmdC1tb3VzZWRvd24gYW55d2hlcmVcbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgQ29tbW9uU2VsZWN0b3JzLmlzU2hpZnRNb3VzZWRvd24sIChlKSA9PiB7XG4gICAgICAgICAgc3RvcEV4dGVuZGVkSW50ZXJhY3Rpb25zKCk7XG4gICAgICAgICAgY3R4Lm1hcC5kcmFnUGFuLmRpc2FibGUoKTtcbiAgICAgICAgICAvLyBFbmFibGUgYm94IHNlbGVjdFxuICAgICAgICAgIGJveFNlbGVjdFN0YXJ0TG9jYXRpb24gPSBtb3VzZUV2ZW50UG9pbnQoZS5vcmlnaW5hbEV2ZW50LCBjdHguY29udGFpbmVyKTtcbiAgICAgICAgICBjYW5Cb3hTZWxlY3QgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEcmFnIHdoZW4gYm94IHNlbGVjdCBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMub24oJ2RyYWcnLCAoKSA9PiBjYW5Cb3hTZWxlY3QsIChlKSA9PiB7XG4gICAgICAgICAgYm94U2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBjdHgudWkucXVldWVNYXBDbGFzc2VzKHsgbW91c2U6IENvbnN0YW50cy5jdXJzb3JzLkFERCB9KTtcblxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYm94IG5vZGUgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgIGlmICghYm94U2VsZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgYm94U2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYm94U2VsZWN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENvbnN0YW50cy5jbGFzc2VzLkJPWF9TRUxFQ1QpO1xuICAgICAgICAgICAgY3R4LmNvbnRhaW5lci5hcHBlbmRDaGlsZChib3hTZWxlY3RFbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGp1c3QgdGhlIGJveCBub2RlJ3Mgd2lkdGggYW5kIHh5IHBvc2l0aW9uXG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IG1vdXNlRXZlbnRQb2ludChlLm9yaWdpbmFsRXZlbnQsIGN0eC5jb250YWluZXIpO1xuICAgICAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbihib3hTZWxlY3RTdGFydExvY2F0aW9uLngsIGN1cnJlbnQueCk7XG4gICAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KGJveFNlbGVjdFN0YXJ0TG9jYXRpb24ueCwgY3VycmVudC54KTtcbiAgICAgICAgICBjb25zdCBtaW5ZID0gTWF0aC5taW4oYm94U2VsZWN0U3RhcnRMb2NhdGlvbi55LCBjdXJyZW50LnkpO1xuICAgICAgICAgIGNvbnN0IG1heFkgPSBNYXRoLm1heChib3hTZWxlY3RTdGFydExvY2F0aW9uLnksIGN1cnJlbnQueSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNsYXRlVmFsdWUgPSBgdHJhbnNsYXRlKCR7bWluWH1weCwgJHttaW5ZfXB4KWA7XG4gICAgICAgICAgYm94U2VsZWN0RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGVWYWx1ZTtcbiAgICAgICAgICBib3hTZWxlY3RFbGVtZW50LnN0eWxlLldlYmtpdFRyYW5zZm9ybSA9IHRyYW5zbGF0ZVZhbHVlO1xuICAgICAgICAgIGJveFNlbGVjdEVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHttYXhYIC0gbWluWH1weGA7XG4gICAgICAgICAgYm94U2VsZWN0RWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHttYXhZIC0gbWluWX1weGA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnZW9qc29uLCBwdXNoKSB7XG4gICAgICBnZW9qc29uLnByb3BlcnRpZXMuYWN0aXZlID0gKGN0eC5zdG9yZS5pc1NlbGVjdGVkKGdlb2pzb24ucHJvcGVydGllcy5pZCkpID9cbiAgICAgICAgQ29uc3RhbnRzLmFjdGl2ZVN0YXRlcy5BQ1RJVkUgOiBDb25zdGFudHMuYWN0aXZlU3RhdGVzLklOQUNUSVZFO1xuICAgICAgcHVzaChnZW9qc29uKTtcbiAgICAgIGZpcmVBY3Rpb25hYmxlKCk7XG4gICAgICBpZiAoZ2VvanNvbi5wcm9wZXJ0aWVzLmFjdGl2ZSAhPT0gQ29uc3RhbnRzLmFjdGl2ZVN0YXRlcy5BQ1RJVkUgfHxcbiAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS50eXBlID09PSBDb25zdGFudHMuZ2VvanNvblR5cGVzLlBPSU5UKSByZXR1cm47XG4gICAgICBjcmVhdGVTdXBwbGVtZW50YXJ5UG9pbnRzKGdlb2pzb24pLmZvckVhY2gocHVzaCk7XG4gICAgfSxcbiAgICB0cmFzaDogZnVuY3Rpb24oKSB7XG4gICAgICBjdHguc3RvcmUuZGVsZXRlKGN0eC5zdG9yZS5nZXRTZWxlY3RlZElkcygpKTtcbiAgICAgIGZpcmVBY3Rpb25hYmxlKCk7XG4gICAgfSxcbiAgICBjb21iaW5lRmVhdHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlcyA9IGN0eC5zdG9yZS5nZXRTZWxlY3RlZCgpO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGggPT09IDAgfHwgc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGggPCAyKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW10sIGZlYXR1cmVzQ29tYmluZWQgPSBbXTtcbiAgICAgIGNvbnN0IGZlYXR1cmVUeXBlID0gc2VsZWN0ZWRGZWF0dXJlc1swXS50eXBlLnJlcGxhY2UoJ011bHRpJywgJycpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IHNlbGVjdGVkRmVhdHVyZXNbaV07XG5cbiAgICAgICAgaWYgKGZlYXR1cmUudHlwZS5yZXBsYWNlKCdNdWx0aScsICcnKSAhPT0gZmVhdHVyZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlYXR1cmUudHlwZS5pbmNsdWRlcygnTXVsdGknKSkge1xuICAgICAgICAgIGZlYXR1cmUuZ2V0Q29vcmRpbmF0ZXMoKS5mb3JFYWNoKChzdWJjb29yZHMpID0+IHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goc3ViY29vcmRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKGZlYXR1cmUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZWF0dXJlc0NvbWJpbmVkLnB1c2goZmVhdHVyZS50b0dlb0pTT04oKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmZWF0dXJlc0NvbWJpbmVkLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICBjb25zdCBtdWx0aUZlYXR1cmUgPSBuZXcgTXVsdGlGZWF0dXJlKGN0eCwge1xuICAgICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuRkVBVFVSRSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlc0NvbWJpbmVkWzBdLnByb3BlcnRpZXMsXG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IGBNdWx0aSR7ZmVhdHVyZVR5cGV9YCxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3R4LnN0b3JlLmFkZChtdWx0aUZlYXR1cmUpO1xuICAgICAgICBjdHguc3RvcmUuZGVsZXRlKGN0eC5zdG9yZS5nZXRTZWxlY3RlZElkcygpLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgY3R4LnN0b3JlLnNldFNlbGVjdGVkKFttdWx0aUZlYXR1cmUuaWRdKTtcblxuICAgICAgICBjdHgubWFwLmZpcmUoQ29uc3RhbnRzLmV2ZW50cy5DT01CSU5FX0ZFQVRVUkVTLCB7XG4gICAgICAgICAgY3JlYXRlZEZlYXR1cmVzOiBbbXVsdGlGZWF0dXJlLnRvR2VvSlNPTigpXSxcbiAgICAgICAgICBkZWxldGVkRmVhdHVyZXM6IGZlYXR1cmVzQ29tYmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmaXJlQWN0aW9uYWJsZSgpO1xuICAgIH0sXG4gICAgdW5jb21iaW5lRmVhdHVyZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlcyA9IGN0eC5zdG9yZS5nZXRTZWxlY3RlZCgpO1xuICAgICAgaWYgKHNlbGVjdGVkRmVhdHVyZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGNyZWF0ZWRGZWF0dXJlcyA9IFtdO1xuICAgICAgY29uc3QgZmVhdHVyZXNVbmNvbWJpbmVkID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gc2VsZWN0ZWRGZWF0dXJlc1tpXTtcblxuICAgICAgICBpZiAoZmVhdHVyZSBpbnN0YW5jZW9mIE11bHRpRmVhdHVyZSkge1xuICAgICAgICAgIGZlYXR1cmUuZ2V0RmVhdHVyZXMoKS5mb3JFYWNoKChzdWJGZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICBjdHguc3RvcmUuYWRkKHN1YkZlYXR1cmUpO1xuICAgICAgICAgICAgc3ViRmVhdHVyZS5wcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY3JlYXRlZEZlYXR1cmVzLnB1c2goc3ViRmVhdHVyZS50b0dlb0pTT04oKSk7XG4gICAgICAgICAgICBjdHguc3RvcmUuc2VsZWN0KFtzdWJGZWF0dXJlLmlkXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3R4LnN0b3JlLmRlbGV0ZShmZWF0dXJlLmlkLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgICBmZWF0dXJlc1VuY29tYmluZWQucHVzaChmZWF0dXJlLnRvR2VvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3JlYXRlZEZlYXR1cmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY3R4Lm1hcC5maXJlKENvbnN0YW50cy5ldmVudHMuVU5DT01CSU5FX0ZFQVRVUkVTLCB7XG4gICAgICAgICAgY3JlYXRlZEZlYXR1cmVzOiBjcmVhdGVkRmVhdHVyZXMsXG4gICAgICAgICAgZGVsZXRlZEZlYXR1cmVzOiBmZWF0dXJlc1VuY29tYmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmaXJlQWN0aW9uYWJsZSgpO1xuICAgIH1cbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGN0eCkge1xuICByZXR1cm4ge1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge30sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY3R4LmV2ZW50cy5hY3Rpb25hYmxlKHtcbiAgICAgICAgY29tYmluZUZlYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgdW5jb21iaW5lRmVhdHVyZXM6IGZhbHNlLFxuICAgICAgICB0cmFzaDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnZW9qc29uLCBwdXNoKSB7XG4gICAgICBwdXNoKGdlb2pzb24pO1xuICAgIH1cbiAgfTtcbn07XG4iLCJjb25zdCB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZGVmYXVsdE1vZGU6IENvbnN0YW50cy5tb2Rlcy5TSU1QTEVfU0VMRUNULFxuICBrZXliaW5kaW5nczogdHJ1ZSxcbiAgdG91Y2hFbmFibGVkOiB0cnVlLFxuICBjbGlja0J1ZmZlcjogMixcbiAgc25hcEJ1ZmZlcjogMTUsXG4gIHRvdWNoQnVmZmVyOiAyNSxcbiAgYm94U2VsZWN0OiB0cnVlLFxuICBzbmFwVG86IHRydWUsXG4gIGRpc3BsYXlDb250cm9sc0RlZmF1bHQ6IHRydWUsXG4gIHN0eWxlczogcmVxdWlyZSgnLi9saWIvdGhlbWUnKSxcbiAgY29udHJvbHM6IHt9LFxuICB1c2VyUHJvcGVydGllczogZmFsc2UsXG4gIHNuYXBTdHlsZXM6IFsnZ2wtZHJhdy1wb2x5Z29uLXN0cm9rZS1pbmFjdGl2ZS5jb2xkJywgJ2dsLWRyYXctbGluZS1pbmFjdGl2ZS5jb2xkJywgJ2dsLWRyYXctcG9pbnQtaW5hY3RpdmUuY29sZCddLFxuICBzbmFwT3ZlckNpcmNsZVN0eWxlOiB7XG4gICAgJ2lkJzogJ2dsLWRyYXctY2lyY2xlLXNuYXAnLFxuICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2NpcmNsZS1yYWRpdXMnOiAzLFxuICAgICAgJ2NpcmNsZS1jb2xvcic6ICcjRkYwJyxcbiAgICAgICdjaXJjbGUtc3Ryb2tlLXdpZHRoJyA6IDEsXG4gICAgICAnY2lyY2xlLXN0cm9rZS1jb2xvcicgOicjMDAwJ1xuICAgIH0sXG4gICAgJ2ZpbHRlcic6IFsnYWxsJywgW1wiPT1cIiwgXCJpZFwiLCBcIlwiXV0sXG4gICAgJ3NvdXJjZSc6ICdtYXBib3gtZ2wtZHJhdy1jb2xkJ1xuICB9LFxuICBzbmFwT3ZlckxpbmVTdHlsZToge1xuICAgICdpZCc6ICdnbC1kcmF3LWxpbmUtc25hcCcsXG4gICAgJ3R5cGUnOiAnbGluZScsXG4gICAgJ2xheW91dCc6IHtcbiAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAnbGluZS1qb2luJzogJ3JvdW5kJ1xuICAgIH0sXG4gICAgJ3BhaW50Jzoge1xuICAgICAgJ2xpbmUtY29sb3InOiAnIzAwRicsXG4gICAgICAnbGluZS13aWR0aCc6IDFcbiAgICB9LFxuICAgICdmaWx0ZXInOiBbJ2FsbCcsIFtcIj09XCIsIFwiaWRcIiwgXCJcIl1dLFxuICAgICdzb3VyY2UnOiAnbWFwYm94LWdsLWRyYXctY29sZCdcbiAgfVxufTtcblxuY29uc3Qgc2hvd0NvbnRyb2xzID0ge1xuICBwb2ludDogdHJ1ZSxcbiAgbGluZV9zdHJpbmc6IHRydWUsXG4gIHBvbHlnb246IHRydWUsXG4gIHRyYXNoOiB0cnVlLFxuICBjb21iaW5lX2ZlYXR1cmVzOiB0cnVlLFxuICB1bmNvbWJpbmVfZmVhdHVyZXM6IHRydWVcbn07XG5cbmNvbnN0IGhpZGVDb250cm9scyA9IHtcbiAgcG9pbnQ6IGZhbHNlLFxuICBsaW5lX3N0cmluZzogZmFsc2UsXG4gIHBvbHlnb246IGZhbHNlLFxuICB0cmFzaDogZmFsc2UsXG4gIGNvbWJpbmVfZmVhdHVyZXM6IGZhbHNlLFxuICB1bmNvbWJpbmVfZmVhdHVyZXM6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBhZGRTb3VyY2VzKHN0eWxlcywgc291cmNlQnVja2V0KSB7XG4gIHJldHVybiBzdHlsZXMubWFwKHN0eWxlID0+IHtcbiAgICBpZiAoc3R5bGUuc291cmNlKSByZXR1cm4gc3R5bGU7XG4gICAgcmV0dXJuIHh0ZW5kKHN0eWxlLCB7XG4gICAgICBpZDogYCR7c3R5bGUuaWR9LiR7c291cmNlQnVja2V0fWAsXG4gICAgICBzb3VyY2U6IChzb3VyY2VCdWNrZXQgPT09ICdob3QnKSA/IENvbnN0YW50cy5zb3VyY2VzLkhPVCA6IENvbnN0YW50cy5zb3VyY2VzLkNPTERcbiAgICB9KTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGxldCB3aXRoRGVmYXVsdHMgPSB4dGVuZChvcHRpb25zKTtcblxuICBpZiAoIW9wdGlvbnMuY29udHJvbHMpIHtcbiAgICB3aXRoRGVmYXVsdHMuY29udHJvbHMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmRpc3BsYXlDb250cm9sc0RlZmF1bHQgPT09IGZhbHNlKSB7XG4gICAgd2l0aERlZmF1bHRzLmNvbnRyb2xzID0geHRlbmQoaGlkZUNvbnRyb2xzLCBvcHRpb25zLmNvbnRyb2xzKTtcbiAgfSBlbHNlIHtcbiAgICB3aXRoRGVmYXVsdHMuY29udHJvbHMgPSB4dGVuZChzaG93Q29udHJvbHMsIG9wdGlvbnMuY29udHJvbHMpO1xuICB9XG5cbiAgd2l0aERlZmF1bHRzID0geHRlbmQoZGVmYXVsdE9wdGlvbnMsIHdpdGhEZWZhdWx0cyk7XG5cbiAgLy8gTGF5ZXJzIHdpdGggYSBzaGFyZWQgc291cmNlIHNob3VsZCBiZSBhZGphY2VudCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICB3aXRoRGVmYXVsdHMuc3R5bGVzID0gYWRkU291cmNlcyh3aXRoRGVmYXVsdHMuc3R5bGVzLCAnY29sZCcpLmNvbmNhdChhZGRTb3VyY2VzKHdpdGhEZWZhdWx0cy5zdHlsZXMsICdob3QnKSk7XG5cbiAgcmV0dXJuIHdpdGhEZWZhdWx0cztcbn07XG4iLCJjb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgY29uc3Qgc3RvcmUgPSB0aGlzO1xuICBjb25zdCBtYXBFeGlzdHMgPSBzdG9yZS5jdHgubWFwICYmIHN0b3JlLmN0eC5tYXAuZ2V0U291cmNlKENvbnN0YW50cy5zb3VyY2VzLkhPVCkgIT09IHVuZGVmaW5lZDtcbiAgaWYgKCFtYXBFeGlzdHMpIHJldHVybiBjbGVhbnVwKCk7XG5cbiAgY29uc3QgbW9kZSA9IHN0b3JlLmN0eC5ldmVudHMuY3VycmVudE1vZGVOYW1lKCk7XG5cbiAgc3RvcmUuY3R4LnVpLnF1ZXVlTWFwQ2xhc3Nlcyh7IG1vZGUgfSk7XG5cbiAgbGV0IG5ld0hvdElkcyA9IFtdO1xuICBsZXQgbmV3Q29sZElkcyA9IFtdO1xuXG4gIGlmIChzdG9yZS5pc0RpcnR5KSB7XG4gICAgbmV3Q29sZElkcyA9IHN0b3JlLmdldEFsbElkcygpO1xuICB9IGVsc2Uge1xuICAgIG5ld0hvdElkcyA9IHN0b3JlLmdldENoYW5nZWRJZHMoKS5maWx0ZXIoaWQgPT4gc3RvcmUuZ2V0KGlkKSAhPT0gdW5kZWZpbmVkKTtcbiAgICBuZXdDb2xkSWRzID0gc3RvcmUuc291cmNlcy5ob3QuZmlsdGVyKChnZW9qc29uKSA9PiB7XG4gICAgICByZXR1cm4gZ2VvanNvbi5wcm9wZXJ0aWVzLmlkICYmIG5ld0hvdElkcy5pbmRleE9mKGdlb2pzb24ucHJvcGVydGllcy5pZCkgPT09IC0xICYmIHN0b3JlLmdldChnZW9qc29uLnByb3BlcnRpZXMuaWQpICE9PSB1bmRlZmluZWQ7XG4gICAgfSkubWFwKGdlb2pzb24gPT4gZ2VvanNvbi5wcm9wZXJ0aWVzLmlkKTtcbiAgfVxuXG4gIHN0b3JlLnNvdXJjZXMuaG90ID0gW107XG4gIGNvbnN0IGxhc3RDb2xkQ291bnQgPSBzdG9yZS5zb3VyY2VzLmNvbGQubGVuZ3RoO1xuICBzdG9yZS5zb3VyY2VzLmNvbGQgPSBzdG9yZS5pc0RpcnR5ID8gW10gOiBzdG9yZS5zb3VyY2VzLmNvbGQuZmlsdGVyKChnZW9qc29uKSA9PiB7XG4gICAgY29uc3QgaWQgPSBnZW9qc29uLnByb3BlcnRpZXMuaWQgfHwgZ2VvanNvbi5wcm9wZXJ0aWVzLnBhcmVudDtcbiAgICByZXR1cm4gbmV3SG90SWRzLmluZGV4T2YoaWQpID09PSAtMTtcbiAgfSk7XG5cbiAgY29uc3QgY29sZENoYW5nZWQgPSBsYXN0Q29sZENvdW50ICE9PSBzdG9yZS5zb3VyY2VzLmNvbGQubGVuZ3RoIHx8IG5ld0NvbGRJZHMubGVuZ3RoID4gMDtcblxuICBuZXdIb3RJZHMuZm9yRWFjaChpZCA9PiByZW5kZXJGZWF0dXJlKGlkLCAnaG90JykpO1xuICBuZXdDb2xkSWRzLmZvckVhY2goaWQgPT4gcmVuZGVyRmVhdHVyZShpZCwgJ2NvbGQnKSk7XG5cbiAgZnVuY3Rpb24gcmVuZGVyRmVhdHVyZShpZCwgc291cmNlKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHN0b3JlLmdldChpZCk7XG4gICAgY29uc3QgZmVhdHVyZUludGVybmFsID0gZmVhdHVyZS5pbnRlcm5hbChtb2RlKTtcbiAgICBzdG9yZS5jdHguZXZlbnRzLmN1cnJlbnRNb2RlUmVuZGVyKGZlYXR1cmVJbnRlcm5hbCwgKGdlb2pzb24pID0+IHtcbiAgICAgIHN0b3JlLnNvdXJjZXNbc291cmNlXS5wdXNoKGdlb2pzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNvbGRDaGFuZ2VkKSB7XG4gICAgc3RvcmUuY3R4Lm1hcC5nZXRTb3VyY2UoQ29uc3RhbnRzLnNvdXJjZXMuQ09MRCkuc2V0RGF0YSh7XG4gICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkVfQ09MTEVDVElPTixcbiAgICAgIGZlYXR1cmVzOiBzdG9yZS5zb3VyY2VzLmNvbGRcbiAgICB9KTtcbiAgfVxuXG4gIHN0b3JlLmN0eC5tYXAuZ2V0U291cmNlKENvbnN0YW50cy5zb3VyY2VzLkhPVCkuc2V0RGF0YSh7XG4gICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5GRUFUVVJFX0NPTExFQ1RJT04sXG4gICAgZmVhdHVyZXM6IHN0b3JlLnNvdXJjZXMuaG90XG4gIH0pO1xuXG4gIGlmIChzdG9yZS5fZW1pdFNlbGVjdGlvbkNoYW5nZSkge1xuICAgIHN0b3JlLmN0eC5tYXAuZmlyZShDb25zdGFudHMuZXZlbnRzLlNFTEVDVElPTl9DSEFOR0UsIHtcbiAgICAgIGZlYXR1cmVzOiBzdG9yZS5nZXRTZWxlY3RlZCgpLm1hcChmZWF0dXJlID0+IGZlYXR1cmUudG9HZW9KU09OKCkpLFxuICAgICAgcG9pbnRzOiBzdG9yZS5nZXRTZWxlY3RlZENvb3JkaW5hdGVzKCkubWFwKGNvb3JkaW5hdGUgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuRkVBVFVSRSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogQ29uc3RhbnRzLmdlb2pzb25UeXBlcy5QT0lOVCxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlLmNvb3JkaW5hdGVzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBzdG9yZS5fZW1pdFNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0b3JlLl9kZWxldGVkRmVhdHVyZXNUb0VtaXQubGVuZ3RoKSB7XG4gICAgY29uc3QgZ2VvanNvblRvRW1pdCA9IHN0b3JlLl9kZWxldGVkRmVhdHVyZXNUb0VtaXQubWFwKGZlYXR1cmUgPT4gZmVhdHVyZS50b0dlb0pTT04oKSk7XG5cbiAgICBzdG9yZS5fZGVsZXRlZEZlYXR1cmVzVG9FbWl0ID0gW107XG5cbiAgICBzdG9yZS5jdHgubWFwLmZpcmUoQ29uc3RhbnRzLmV2ZW50cy5ERUxFVEUsIHtcbiAgICAgIGZlYXR1cmVzOiBnZW9qc29uVG9FbWl0XG4gICAgfSk7XG4gIH1cblxuICBzdG9yZS5jdHgubWFwLmZpcmUoQ29uc3RhbnRzLmV2ZW50cy5SRU5ERVIsIHt9KTtcbiAgY2xlYW51cCgpO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc3RvcmUuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIHN0b3JlLmNsZWFyQ2hhbmdlZElkcygpO1xuICB9XG59O1xuIiwiY29uc3QgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMnKTtcbmNvbnN0IFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpO1xuY29uc3QgdWkgPSByZXF1aXJlKCcuL3VpJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGN0eCkge1xuXG4gIGN0eC5ldmVudHMgPSBldmVudHMoY3R4KTtcblxuICBjdHgubWFwID0gbnVsbDtcbiAgY3R4LmNvbnRhaW5lciA9IG51bGw7XG4gIGN0eC5zdG9yZSA9IG51bGw7XG4gIGN0eC51aSA9IHVpKGN0eCk7XG4gIGN0eC5zbmFwVG9PdmVycmlkZSA9IGZhbHNlO1xuXG4gIGxldCBjb250cm9sQ29udGFpbmVyID0gbnVsbDtcblxuICBjb25zdCBzZXR1cCA9IHtcbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICBzZXR1cC5yZW1vdmVMYXllcnMoKTtcbiAgICAgIGN0eC51aS5yZW1vdmVCdXR0b25zKCk7XG4gICAgICBjdHguZXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBjdHgubWFwID0gbnVsbDtcbiAgICAgIGN0eC5jb250YWluZXIgPSBudWxsO1xuICAgICAgY3R4LnN0b3JlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRyb2xDb250YWluZXIgJiYgY29udHJvbENvbnRhaW5lci5wYXJlbnROb2RlKSBjb250cm9sQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udHJvbENvbnRhaW5lcik7XG4gICAgICBjb250cm9sQ29udGFpbmVyID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICBjdHgubWFwID0gbWFwO1xuICAgICAgY3R4LmNvbnRhaW5lciA9IG1hcC5nZXRDb250YWluZXIoKTtcbiAgICAgIGN0eC5zdG9yZSA9IG5ldyBTdG9yZShjdHgpO1xuXG4gICAgICBjb250cm9sQ29udGFpbmVyID0gY3R4LnVpLmFkZEJ1dHRvbnMoKTtcblxuICAgICAgaWYgKGN0eC5vcHRpb25zLmJveFNlbGVjdCkge1xuICAgICAgICBtYXAuYm94Wm9vbS5kaXNhYmxlKCk7XG4gICAgICAgIC8vIE5lZWQgdG8gdG9nZ2xlIGRyYWdQYW4gb24gYW5kIG9mZiBvciBlbHNlIGZpcnN0XG4gICAgICAgIC8vIGRyYWdQYW4gZGlzYWJsZSBhdHRlbXB0IGluIHNpbXBsZV9zZWxlY3QgZG9lc24ndCB3b3JrXG4gICAgICAgIG1hcC5kcmFnUGFuLmRpc2FibGUoKTtcbiAgICAgICAgbWFwLmRyYWdQYW4uZW5hYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbnRlcnZhbElkID0gbnVsbDtcblxuICAgICAgY29uc3QgY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgbWFwLm9mZignbG9hZCcsIGNvbm5lY3QpO1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICBzZXR1cC5hZGRMYXllcnMoKTtcbiAgICAgICAgY3R4LmV2ZW50cy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG1hcC5sb2FkZWQoKSkge1xuICAgICAgICBjb25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAub24oJ2xvYWQnLCBjb25uZWN0KTtcbiAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHsgaWYgKG1hcC5sb2FkZWQoKSkgY29ubmVjdCgpOyB9LCAxNik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250cm9sQ29udGFpbmVyO1xuICAgIH0sXG4gICAgYWRkTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGRyYXduIGZlYXR1cmVzIHN0eWxlXG4gICAgICBjdHgubWFwLmFkZFNvdXJjZShDb25zdGFudHMuc291cmNlcy5DT0xELCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0eXBlOiBDb25zdGFudHMuZ2VvanNvblR5cGVzLkZFQVRVUkVfQ09MTEVDVElPTixcbiAgICAgICAgICBmZWF0dXJlczogW11cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ2dlb2pzb24nXG4gICAgICB9KTtcblxuICAgICAgLy8gaG90IGZlYXR1cmVzIHN0eWxlXG4gICAgICBjdHgubWFwLmFkZFNvdXJjZShDb25zdGFudHMuc291cmNlcy5IT1QsIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHR5cGU6IENvbnN0YW50cy5nZW9qc29uVHlwZXMuRkVBVFVSRV9DT0xMRUNUSU9OLFxuICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAnZ2VvanNvbidcbiAgICAgIH0pO1xuXG4gICAgICBjdHgub3B0aW9ucy5zdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgIGN0eC5tYXAuYWRkTGF5ZXIoc3R5bGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGN0eC5zdG9yZS5yZW5kZXIoKTtcbiAgICB9LFxuICAgIHJlbW92ZUxheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICBjdHgub3B0aW9ucy5zdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgIGN0eC5tYXAucmVtb3ZlTGF5ZXIoc3R5bGUuaWQpO1xuICAgICAgfSk7XG4gICAgICAvL3JlbW92ZSBzbmFwIGxheWVyc1xuICAgICAgaWYgKGN0eC5tYXAuZ2V0TGF5ZXIoY3R4Lm9wdGlvbnMuc25hcE92ZXJDaXJjbGVTdHlsZS5pZCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHgubWFwLnJlbW92ZUxheWVyKGN0eC5vcHRpb25zLnNuYXBPdmVyQ2lyY2xlU3R5bGUuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKGN0eC5tYXAuZ2V0TGF5ZXIoY3R4Lm9wdGlvbnMuc25hcE92ZXJMaW5lU3R5bGUuaWQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4Lm1hcC5yZW1vdmVMYXllcihjdHgub3B0aW9ucy5zbmFwT3ZlckxpbmVTdHlsZS5pZCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5tYXAucmVtb3ZlU291cmNlKENvbnN0YW50cy5zb3VyY2VzLkNPTEQpO1xuICAgICAgY3R4Lm1hcC5yZW1vdmVTb3VyY2UoQ29uc3RhbnRzLnNvdXJjZXMuSE9UKTtcbiAgICB9XG4gIH07XG5cbiAgY3R4LnNldHVwID0gc2V0dXA7XG5cbiAgcmV0dXJuIHNldHVwO1xufTtcbiIsImNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnLi9saWIvdGhyb3R0bGUnKTtcbmNvbnN0IHRvRGVuc2VBcnJheSA9IHJlcXVpcmUoJy4vbGliL3RvX2RlbnNlX2FycmF5Jyk7XG5jb25zdCBTdHJpbmdTZXQgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdfc2V0Jyk7XG5jb25zdCByZW5kZXIgPSByZXF1aXJlKCcuL3JlbmRlcicpO1xuXG5jb25zdCBTdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3R4KSB7XG4gIHRoaXMuX2ZlYXR1cmVzID0ge307XG4gIHRoaXMuX2ZlYXR1cmVJZHMgPSBuZXcgU3RyaW5nU2V0KCk7XG4gIHRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgdGhpcy5fc2VsZWN0ZWRDb29yZGluYXRlcyA9IFtdO1xuICB0aGlzLl9jaGFuZ2VkRmVhdHVyZUlkcyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgdGhpcy5fZGVsZXRlZEZlYXR1cmVzVG9FbWl0ID0gW107XG4gIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2UgPSBmYWxzZTtcbiAgdGhpcy5jdHggPSBjdHg7XG4gIHRoaXMuc291cmNlcyA9IHtcbiAgICBob3Q6IFtdLFxuICAgIGNvbGQ6IFtdXG4gIH07XG4gIHRoaXMucmVuZGVyID0gdGhyb3R0bGUocmVuZGVyLCAxNiwgdGhpcyk7XG4gIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xufTtcblxuXG4vKipcbiAqIERlbGF5cyBhbGwgcmVuZGVyaW5nIHVudGlsIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBpbnZva2VkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVuZGVyQmF0Y2hcbiAqL1xuU3RvcmUucHJvdG90eXBlLmNyZWF0ZVJlbmRlckJhdGNoID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGhvbGRSZW5kZXIgPSB0aGlzLnJlbmRlcjtcbiAgbGV0IG51bVJlbmRlcnMgPSAwO1xuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIG51bVJlbmRlcnMrKztcbiAgfTtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHRoaXMucmVuZGVyID0gaG9sZFJlbmRlcjtcbiAgICBpZiAobnVtUmVuZGVycyA+IDApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdG9yZSdzIHN0YXRlIHRvIGRpcnR5LlxuICogQHJldHVybiB7U3RvcmV9IHRoaXNcbiAqL1xuU3RvcmUucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgZmVhdHVyZSdzIHN0YXRlIHRvIGNoYW5nZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUlkXG4gKiBAcmV0dXJuIHtTdG9yZX0gdGhpc1xuICovXG5TdG9yZS5wcm90b3R5cGUuZmVhdHVyZUNoYW5nZWQgPSBmdW5jdGlvbihmZWF0dXJlSWQpIHtcbiAgdGhpcy5fY2hhbmdlZEZlYXR1cmVJZHMuYWRkKGZlYXR1cmVJZCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpZHMgb2YgYWxsIGZlYXR1cmVzIGN1cnJlbnRseSBpbiBjaGFuZ2VkIHN0YXRlLlxuICogQHJldHVybiB7U3RvcmV9IHRoaXNcbiAqL1xuU3RvcmUucHJvdG90eXBlLmdldENoYW5nZWRJZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoYW5nZWRGZWF0dXJlSWRzLnZhbHVlcygpO1xufTtcblxuLyoqXG4gKiBTZXRzIGFsbCBmZWF0dXJlcyB0byB1bmNoYW5nZWQgc3RhdGUuXG4gKiBAcmV0dXJuIHtTdG9yZX0gdGhpc1xuICovXG5TdG9yZS5wcm90b3R5cGUuY2xlYXJDaGFuZ2VkSWRzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NoYW5nZWRGZWF0dXJlSWRzLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpZHMgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBzdG9yZS5cbiAqIEByZXR1cm4ge1N0b3JlfSB0aGlzXG4gKi9cblN0b3JlLnByb3RvdHlwZS5nZXRBbGxJZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVJZHMudmFsdWVzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBmZWF0dXJlIHRvIHRoZSBzdG9yZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlXG4gKlxuICogQHJldHVybiB7U3RvcmV9IHRoaXNcbiAqL1xuU3RvcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgdGhpcy5mZWF0dXJlQ2hhbmdlZChmZWF0dXJlLmlkKTtcbiAgdGhpcy5fZmVhdHVyZXNbZmVhdHVyZS5pZF0gPSBmZWF0dXJlO1xuICB0aGlzLl9mZWF0dXJlSWRzLmFkZChmZWF0dXJlLmlkKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBmZWF0dXJlIG9yIGFycmF5IG9mIGZlYXR1cmVzIGZyb20gdGhlIHN0b3JlLlxuICogQ2xlYW5zIHVwIGFmdGVyIHRoZSBkZWxldGlvbiBieSBkZXNlbGVjdGluZyB0aGUgZmVhdHVyZXMuXG4gKiBJZiBjaGFuZ2VzIHdlcmUgbWFkZSwgc2V0cyB0aGUgc3RhdGUgdG8gdGhlIGRpcnR5XG4gKiBhbmQgZmlyZXMgYW4gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZyB8IEFycmF5PHN0cmluZz59IGZlYXR1cmVJZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zaWxlbnRdIC0gSWYgYHRydWVgLCB0aGlzIGludm9jYXRpb24gd2lsbCBub3QgZmlyZSBhbiBldmVudC5cbiAqIEByZXR1cm4ge1N0b3JlfSB0aGlzXG4gKi9cblN0b3JlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihmZWF0dXJlSWRzLCBvcHRpb25zID0ge30pIHtcbiAgdG9EZW5zZUFycmF5KGZlYXR1cmVJZHMpLmZvckVhY2goaWQgPT4ge1xuICAgIGlmICghdGhpcy5fZmVhdHVyZUlkcy5oYXMoaWQpKSByZXR1cm47XG4gICAgdGhpcy5fZmVhdHVyZUlkcy5kZWxldGUoaWQpO1xuICAgIHRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcy5kZWxldGUoaWQpO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIGlmICh0aGlzLl9kZWxldGVkRmVhdHVyZXNUb0VtaXQuaW5kZXhPZih0aGlzLl9mZWF0dXJlc1tpZF0pID09PSAtMSkge1xuICAgICAgICB0aGlzLl9kZWxldGVkRmVhdHVyZXNUb0VtaXQucHVzaCh0aGlzLl9mZWF0dXJlc1tpZF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fZmVhdHVyZXNbaWRdO1xuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gIH0pO1xuICByZWZyZXNoU2VsZWN0ZWRDb29yZGluYXRlcy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZlYXR1cmUgaW4gdGhlIHN0b3JlIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKiBAcmV0dXJuIHtPYmplY3QgfCB1bmRlZmluZWR9IGZlYXR1cmVcbiAqL1xuU3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiB0aGlzLl9mZWF0dXJlc1tpZF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGZlYXR1cmVzIGluIHRoZSBzdG9yZS5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59XG4gKi9cblN0b3JlLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2ZlYXR1cmVzKS5tYXAoaWQgPT4gdGhpcy5fZmVhdHVyZXNbaWRdKTtcbn07XG5cbi8qKlxuICogQWRkcyBmZWF0dXJlcyB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZyB8IEFycmF5PHN0cmluZz59IGZlYXR1cmVJZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zaWxlbnRdIC0gSWYgYHRydWVgLCB0aGlzIGludm9jYXRpb24gd2lsbCBub3QgZmlyZSBhbiBldmVudC5cbiAqIEByZXR1cm4ge1N0b3JlfSB0aGlzXG4gKi9cblN0b3JlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihmZWF0dXJlSWRzLCBvcHRpb25zID0ge30pIHtcbiAgdG9EZW5zZUFycmF5KGZlYXR1cmVJZHMpLmZvckVhY2goaWQgPT4ge1xuICAgIGlmICh0aGlzLl9zZWxlY3RlZEZlYXR1cmVJZHMuaGFzKGlkKSkgcmV0dXJuO1xuICAgIHRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcy5hZGQoaWQpO1xuICAgIHRoaXMuX2NoYW5nZWRGZWF0dXJlSWRzLmFkZChpZCk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgZmVhdHVyZXMgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZyB8IEFycmF5PHN0cmluZz59IGZlYXR1cmVJZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zaWxlbnRdIC0gSWYgYHRydWVgLCB0aGlzIGludm9jYXRpb24gd2lsbCBub3QgZmlyZSBhbiBldmVudC5cbiAqIEByZXR1cm4ge1N0b3JlfSB0aGlzXG4gKi9cblN0b3JlLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKGZlYXR1cmVJZHMsIG9wdGlvbnMgPSB7fSkge1xuICB0b0RlbnNlQXJyYXkoZmVhdHVyZUlkcykuZm9yRWFjaChpZCA9PiB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3RlZEZlYXR1cmVJZHMuaGFzKGlkKSkgcmV0dXJuO1xuICAgIHRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcy5kZWxldGUoaWQpO1xuICAgIHRoaXMuX2NoYW5nZWRGZWF0dXJlSWRzLmFkZChpZCk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmVmcmVzaFNlbGVjdGVkQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2lsZW50XSAtIElmIGB0cnVlYCwgdGhpcyBpbnZvY2F0aW9uIHdpbGwgbm90IGZpcmUgYW4gZXZlbnQuXG4gKiBAcmV0dXJuIHtTdG9yZX0gdGhpc1xuICovXG5TdG9yZS5wcm90b3R5cGUuY2xlYXJTZWxlY3RlZCA9IGZ1bmN0aW9uKG9wdGlvbnMgPSB7fSkge1xuICB0aGlzLmRlc2VsZWN0KHRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcy52YWx1ZXMoKSwgeyBzaWxlbnQ6IG9wdGlvbnMuc2lsZW50IH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3RvcmUncyBzZWxlY3Rpb24sIGNsZWFyaW5nIGFueSBwcmlvciB2YWx1ZXMuXG4gKiBJZiBubyBmZWF0dXJlIGlkcyBhcmUgcGFzc2VkLCB0aGUgc3RvcmUgaXMganVzdCBjbGVhcmVkLlxuICogQHBhcmFtIHtzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgdW5kZWZpbmVkfSBmZWF0dXJlSWRzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2lsZW50XSAtIElmIGB0cnVlYCwgdGhpcyBpbnZvY2F0aW9uIHdpbGwgbm90IGZpcmUgYW4gZXZlbnQuXG4gKiBAcmV0dXJuIHtTdG9yZX0gdGhpc1xuICovXG5TdG9yZS5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbihmZWF0dXJlSWRzLCBvcHRpb25zID0ge30pIHtcbiAgZmVhdHVyZUlkcyA9IHRvRGVuc2VBcnJheShmZWF0dXJlSWRzKTtcblxuICAvLyBEZXNlbGVjdCBhbnkgZmVhdHVyZXMgbm90IGluIHRoZSBuZXcgc2VsZWN0aW9uXG4gIHRoaXMuZGVzZWxlY3QodGhpcy5fc2VsZWN0ZWRGZWF0dXJlSWRzLnZhbHVlcygpLmZpbHRlcihpZCA9PiB7XG4gICAgcmV0dXJuIGZlYXR1cmVJZHMuaW5kZXhPZihpZCkgPT09IC0xO1xuICB9KSwgeyBzaWxlbnQ6IG9wdGlvbnMuc2lsZW50IH0pO1xuXG4gIC8vIFNlbGVjdCBhbnkgZmVhdHVyZXMgaW4gdGhlIG5ldyBzZWxlY3Rpb24gdGhhdCB3ZXJlIG5vdCBhbHJlYWR5IHNlbGVjdGVkXG4gIHRoaXMuc2VsZWN0KGZlYXR1cmVJZHMuZmlsdGVyKGlkID0+IHtcbiAgICByZXR1cm4gIXRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcy5oYXMoaWQpO1xuICB9KSwgeyBzaWxlbnQ6IG9wdGlvbnMuc2lsZW50IH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdG9yZSdzIGNvb3JkaW5hdGVzIHNlbGVjdGlvbiwgY2xlYXJpbmcgYW55IHByaW9yIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8c3RyaW5nPj59IGNvb3JkaW5hdGVzXG4gKiBAcmV0dXJuIHtTdG9yZX0gdGhpc1xuICovXG5TdG9yZS5wcm90b3R5cGUuc2V0U2VsZWN0ZWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gIHRoaXMuX3NlbGVjdGVkQ29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcbiAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGN1cnJlbnQgY29vcmRpbmF0ZXMgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7U3RvcmV9IHRoaXNcbiAqL1xuU3RvcmUucHJvdG90eXBlLmNsZWFyU2VsZWN0ZWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zZWxlY3RlZENvb3JkaW5hdGVzID0gW107XG4gIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2UgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaWRzIG9mIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IFNlbGVjdGVkIGZlYXR1cmUgaWRzLlxuICovXG5TdG9yZS5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRJZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkRmVhdHVyZUlkcy52YWx1ZXMoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBTZWxlY3RlZCBmZWF0dXJlcy5cbiAqL1xuU3RvcmUucHJvdG90eXBlLmdldFNlbGVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zZWxlY3RlZEZlYXR1cmVJZHMudmFsdWVzKCkubWFwKGlkID0+IHRoaXMuZ2V0KGlkKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgc2VsZWN0ZWQgY29vcmRpbmF0ZXMgaW4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmZWF0dXJlLlxuICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gU2VsZWN0ZWQgY29vcmRpbmF0ZXMuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5nZXRTZWxlY3RlZENvb3JkaW5hdGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zZWxlY3RlZENvb3JkaW5hdGVzO1xufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciBhIGZlYXR1cmUgaXMgc2VsZWN0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUlkXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGZlYXR1cmUgaXMgc2VsZWN0ZWQsIGBmYWxzZWAgaWYgbm90LlxuICovXG5TdG9yZS5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uKGZlYXR1cmVJZCkge1xuICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRGZWF0dXJlSWRzLmhhcyhmZWF0dXJlSWQpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcHJvcGVydHkgb24gdGhlIGdpdmVuIGZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlSWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IHZhbHVlXG4qL1xuU3RvcmUucHJvdG90eXBlLnNldEZlYXR1cmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKGZlYXR1cmVJZCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHRoaXMuZ2V0KGZlYXR1cmVJZCkuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgdGhpcy5mZWF0dXJlQ2hhbmdlZChmZWF0dXJlSWQpO1xufTtcblxuZnVuY3Rpb24gcmVmcmVzaFNlbGVjdGVkQ29vcmRpbmF0ZXMob3B0aW9ucykge1xuICBjb25zdCBuZXdTZWxlY3RlZENvb3JkaW5hdGVzID0gdGhpcy5fc2VsZWN0ZWRDb29yZGluYXRlcy5maWx0ZXIocG9pbnQgPT4gdGhpcy5fc2VsZWN0ZWRGZWF0dXJlSWRzLmhhcyhwb2ludC5mZWF0dXJlX2lkKSk7XG4gIGlmICh0aGlzLl9zZWxlY3RlZENvb3JkaW5hdGVzLmxlbmd0aCAhPT0gbmV3U2VsZWN0ZWRDb29yZGluYXRlcy5sZW5ndGggJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZSA9IHRydWU7XG4gIH1cbiAgdGhpcy5fc2VsZWN0ZWRDb29yZGluYXRlcyA9IG5ld1NlbGVjdGVkQ29vcmRpbmF0ZXM7XG59XG4iLCJjb25zdCB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBjbGFzc1R5cGVzID0gWydtb2RlJywgJ2ZlYXR1cmUnLCAnbW91c2UnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgpIHtcblxuXG4gIGNvbnN0IGJ1dHRvbkVsZW1lbnRzID0ge307XG4gIGxldCBhY3RpdmVCdXR0b24gPSBudWxsO1xuXG4gIGxldCBjdXJyZW50TWFwQ2xhc3NlcyA9IHtcbiAgICBtb2RlOiBudWxsLCAvLyBlLmcuIG1vZGUtZGlyZWN0X3NlbGVjdFxuICAgIGZlYXR1cmU6IG51bGwsIC8vIGUuZy4gZmVhdHVyZS12ZXJ0ZXhcbiAgICBtb3VzZTogbnVsbCAvLyBlLmcuIG1vdXNlLW1vdmVcbiAgfTtcblxuICBsZXQgbmV4dE1hcENsYXNzZXMgPSB7XG4gICAgbW9kZTogbnVsbCxcbiAgICBmZWF0dXJlOiBudWxsLFxuICAgIG1vdXNlOiBudWxsXG4gIH07XG5cbiAgZnVuY3Rpb24gcXVldWVNYXBDbGFzc2VzKG9wdGlvbnMpIHtcbiAgICBuZXh0TWFwQ2xhc3NlcyA9IHh0ZW5kKG5leHRNYXBDbGFzc2VzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hcENsYXNzZXMoKSB7XG4gICAgaWYgKCFjdHguY29udGFpbmVyKSByZXR1cm47XG5cbiAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcblxuICAgIGNsYXNzVHlwZXMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgaWYgKG5leHRNYXBDbGFzc2VzW3R5cGVdID09PSBjdXJyZW50TWFwQ2xhc3Nlc1t0eXBlXSkgcmV0dXJuO1xuXG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChgJHt0eXBlfS0ke2N1cnJlbnRNYXBDbGFzc2VzW3R5cGVdfWApO1xuICAgICAgaWYgKG5leHRNYXBDbGFzc2VzW3R5cGVdICE9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGAke3R5cGV9LSR7bmV4dE1hcENsYXNzZXNbdHlwZV19YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgIGN0eC5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZS5hcHBseShjdHguY29udGFpbmVyLmNsYXNzTGlzdCwgY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICAgIGN0eC5jb250YWluZXIuY2xhc3NMaXN0LmFkZC5hcHBseShjdHguY29udGFpbmVyLmNsYXNzTGlzdCwgY2xhc3Nlc1RvQWRkKTtcbiAgICB9XG5cbiAgICBjdXJyZW50TWFwQ2xhc3NlcyA9IHh0ZW5kKGN1cnJlbnRNYXBDbGFzc2VzLCBuZXh0TWFwQ2xhc3Nlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb250cm9sQnV0dG9uKGlkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gYCR7Q29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT059ICR7b3B0aW9ucy5jbGFzc05hbWV9YDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsIG9wdGlvbnMudGl0bGUpO1xuICAgIG9wdGlvbnMuY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgY29uc3QgY2xpY2tlZEJ1dHRvbiA9IGUudGFyZ2V0O1xuICAgICAgaWYgKGNsaWNrZWRCdXR0b24gPT09IGFjdGl2ZUJ1dHRvbikge1xuICAgICAgICBkZWFjdGl2YXRlQnV0dG9ucygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldEFjdGl2ZUJ1dHRvbihpZCk7XG4gICAgICBvcHRpb25zLm9uQWN0aXZhdGUoKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIHJldHVybiBidXR0b247XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlQnV0dG9ucygpIHtcbiAgICBpZiAoIWFjdGl2ZUJ1dHRvbikgcmV0dXJuO1xuICAgIGFjdGl2ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENvbnN0YW50cy5jbGFzc2VzLkFDVElWRV9CVVRUT04pO1xuICAgIGFjdGl2ZUJ1dHRvbiA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBY3RpdmVCdXR0b24oaWQpIHtcbiAgICBkZWFjdGl2YXRlQnV0dG9ucygpO1xuXG4gICAgY29uc3QgYnV0dG9uID0gYnV0dG9uRWxlbWVudHNbaWRdO1xuICAgIGlmICghYnV0dG9uKSByZXR1cm47XG5cbiAgICBpZiAoYnV0dG9uICYmIGlkICE9PSAndHJhc2gnKSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChDb25zdGFudHMuY2xhc3Nlcy5BQ1RJVkVfQlVUVE9OKTtcbiAgICAgIGFjdGl2ZUJ1dHRvbiA9IGJ1dHRvbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRCdXR0b25zKCkge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gY3R4Lm9wdGlvbnMuY29udHJvbHM7XG4gICAgY29uc3QgY29udHJvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udHJvbEdyb3VwLmNsYXNzTmFtZSA9IGAke0NvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfR1JPVVB9ICR7Q29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CQVNFfWA7XG5cbiAgICBpZiAoIWNvbnRyb2xzKSByZXR1cm4gY29udHJvbEdyb3VwO1xuXG4gICAgaWYgKGNvbnRyb2xzW0NvbnN0YW50cy50eXBlcy5MSU5FXSkge1xuICAgICAgYnV0dG9uRWxlbWVudHNbQ29uc3RhbnRzLnR5cGVzLkxJTkVdID0gY3JlYXRlQ29udHJvbEJ1dHRvbihDb25zdGFudHMudHlwZXMuTElORSwge1xuICAgICAgICBjb250YWluZXI6IGNvbnRyb2xHcm91cCxcbiAgICAgICAgY2xhc3NOYW1lOiBDb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9MSU5FLFxuICAgICAgICB0aXRsZTogYExpbmVTdHJpbmcgdG9vbCAke2N0eC5vcHRpb25zLmtleWJpbmRpbmdzICYmICcobCknfWAsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IGN0eC5ldmVudHMuY2hhbmdlTW9kZShDb25zdGFudHMubW9kZXMuRFJBV19MSU5FX1NUUklORylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250cm9sc1tDb25zdGFudHMudHlwZXMuUE9MWUdPTl0pIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnRzW0NvbnN0YW50cy50eXBlcy5QT0xZR09OXSA9IGNyZWF0ZUNvbnRyb2xCdXR0b24oQ29uc3RhbnRzLnR5cGVzLlBPTFlHT04sIHtcbiAgICAgICAgY29udGFpbmVyOiBjb250cm9sR3JvdXAsXG4gICAgICAgIGNsYXNzTmFtZTogQ29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fUE9MWUdPTixcbiAgICAgICAgdGl0bGU6IGBQb2x5Z29uIHRvb2wgJHtjdHgub3B0aW9ucy5rZXliaW5kaW5ncyAmJiAnKHApJ31gLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLkRSQVdfUE9MWUdPTilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250cm9sc1tDb25zdGFudHMudHlwZXMuUE9JTlRdKSB7XG4gICAgICBidXR0b25FbGVtZW50c1tDb25zdGFudHMudHlwZXMuUE9JTlRdID0gY3JlYXRlQ29udHJvbEJ1dHRvbihDb25zdGFudHMudHlwZXMuUE9JTlQsIHtcbiAgICAgICAgY29udGFpbmVyOiBjb250cm9sR3JvdXAsXG4gICAgICAgIGNsYXNzTmFtZTogQ29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fUE9JTlQsXG4gICAgICAgIHRpdGxlOiBgTWFya2VyIHRvb2wgJHtjdHgub3B0aW9ucy5rZXliaW5kaW5ncyAmJiAnKG0pJ31gLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiBjdHguZXZlbnRzLmNoYW5nZU1vZGUoQ29uc3RhbnRzLm1vZGVzLkRSQVdfUE9JTlQpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udHJvbHMudHJhc2gpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnRzLnRyYXNoID0gY3JlYXRlQ29udHJvbEJ1dHRvbigndHJhc2gnLCB7XG4gICAgICAgIGNvbnRhaW5lcjogY29udHJvbEdyb3VwLFxuICAgICAgICBjbGFzc05hbWU6IENvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX1RSQVNILFxuICAgICAgICB0aXRsZTogJ0RlbGV0ZScsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICBjdHguZXZlbnRzLnRyYXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250cm9scy5jb21iaW5lX2ZlYXR1cmVzKSB7XG4gICAgICBidXR0b25FbGVtZW50cy5jb21iaW5lX2ZlYXR1cmVzID0gY3JlYXRlQ29udHJvbEJ1dHRvbignY29tYmluZUZlYXR1cmVzJywge1xuICAgICAgICBjb250YWluZXI6IGNvbnRyb2xHcm91cCxcbiAgICAgICAgY2xhc3NOYW1lOiBDb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9DT01CSU5FX0ZFQVRVUkVTLFxuICAgICAgICB0aXRsZTogJ0NvbWJpbmUnLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgICAgY3R4LmV2ZW50cy5jb21iaW5lRmVhdHVyZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xzLnVuY29tYmluZV9mZWF0dXJlcykge1xuICAgICAgYnV0dG9uRWxlbWVudHMudW5jb21iaW5lX2ZlYXR1cmVzID0gY3JlYXRlQ29udHJvbEJ1dHRvbigndW5jb21iaW5lRmVhdHVyZXMnLCB7XG4gICAgICAgIGNvbnRhaW5lcjogY29udHJvbEdyb3VwLFxuICAgICAgICBjbGFzc05hbWU6IENvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX1VOQ09NQklORV9GRUFUVVJFUyxcbiAgICAgICAgdGl0bGU6ICdVbmNvbWJpbmUnLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgICAgY3R4LmV2ZW50cy51bmNvbWJpbmVGZWF0dXJlcygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udHJvbEdyb3VwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQnV0dG9ucygpIHtcbiAgICBPYmplY3Qua2V5cyhidXR0b25FbGVtZW50cykuZm9yRWFjaChidXR0b25JZCA9PiB7XG4gICAgICBjb25zdCBidXR0b24gPSBidXR0b25FbGVtZW50c1tidXR0b25JZF07XG4gICAgICBpZiAoYnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgYnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBidXR0b25FbGVtZW50c1tidXR0b25JZF07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNldEFjdGl2ZUJ1dHRvbixcbiAgICBxdWV1ZU1hcENsYXNzZXMsXG4gICAgdXBkYXRlTWFwQ2xhc3NlcyxcbiAgICBhZGRCdXR0b25zLFxuICAgIHJlbW92ZUJ1dHRvbnNcbiAgfTtcbn07XG4iXX0=
